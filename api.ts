/* tslint:disable */
/* eslint-disable */
/**
 * Qovery API
 * - Qovery is the fastest way to deploy your full-stack apps on any Cloud provider. - ℹ️ The API is stable and still in development. 
 *
 * The version of the OpenAPI document: 1.0.3
 * Contact: support+api+documentation@qovery.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AccountInfoEditRequest
 */
export interface AccountInfoEditRequest {
    /**
     * 
     * @type {string}
     * @memberof AccountInfoEditRequest
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountInfoEditRequest
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountInfoEditRequest
     */
    'profile_picture_url'?: string;
}
/**
 * 
 * @export
 * @interface AccountInfoResponse
 */
export interface AccountInfoResponse {
    /**
     * 
     * @type {string}
     * @memberof AccountInfoResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountInfoResponse
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountInfoResponse
     */
    'nickname'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountInfoResponse
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountInfoResponse
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountInfoResponse
     */
    'profile_picture_url'?: string;
}
/**
 * 
 * @export
 * @interface AliasedSecret
 */
export interface AliasedSecret {
    /**
     * 
     * @type {string}
     * @memberof AliasedSecret
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AliasedSecret
     */
    'key'?: string;
    /**
     * 
     * @type {EnvironmentVariableScopeEnum}
     * @memberof AliasedSecret
     */
    'scope'?: EnvironmentVariableScopeEnum;
}
/**
 * 
 * @export
 * @interface ApplicationCurrentScaleResponse
 */
export interface ApplicationCurrentScaleResponse {
    /**
     * 
     * @type {number}
     * @memberof ApplicationCurrentScaleResponse
     */
    'min'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApplicationCurrentScaleResponse
     */
    'max'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApplicationCurrentScaleResponse
     */
    'running'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApplicationCurrentScaleResponse
     */
    'running_in_percent'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApplicationCurrentScaleResponse
     */
    'warning_threshold_in_percent'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApplicationCurrentScaleResponse
     */
    'alert_threshold_in_percent'?: number;
    /**
     * 
     * @type {ThresholdMetricStatusEnum}
     * @memberof ApplicationCurrentScaleResponse
     */
    'status'?: ThresholdMetricStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCurrentScaleResponse
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface ApplicationDependencyRequest
 */
export interface ApplicationDependencyRequest {
    /**
     * Set application ID
     * @type {string}
     * @memberof ApplicationDependencyRequest
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface ApplicationDeploymentRestriction
 */
export interface ApplicationDeploymentRestriction {
    /**
     * 
     * @type {DeploymentRestrictionModeEnum}
     * @memberof ApplicationDeploymentRestriction
     */
    'mode': DeploymentRestrictionModeEnum;
    /**
     * 
     * @type {DeploymentRestrictionTypeEnum}
     * @memberof ApplicationDeploymentRestriction
     */
    'type': DeploymentRestrictionTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ApplicationDeploymentRestriction
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface ApplicationDeploymentRuleEditRequest
 */
export interface ApplicationDeploymentRuleEditRequest {
    /**
     * 
     * @type {Array<ApplicationDeploymentRestriction>}
     * @memberof ApplicationDeploymentRuleEditRequest
     */
    'deployment_restrictions'?: Array<ApplicationDeploymentRestriction>;
}
/**
 * 
 * @export
 * @interface ApplicationDeploymentRuleResponse
 */
export interface ApplicationDeploymentRuleResponse {
    /**
     * 
     * @type {Array<ApplicationDeploymentRestriction>}
     * @memberof ApplicationDeploymentRuleResponse
     */
    'deployment_restrictions'?: Array<ApplicationDeploymentRestriction>;
    /**
     * 
     * @type {string}
     * @memberof ApplicationDeploymentRuleResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationDeploymentRuleResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationDeploymentRuleResponse
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface ApplicationEditRequest
 */
export interface ApplicationEditRequest {
    /**
     * 
     * @type {Array<ApplicationStorageResponseStorage>}
     * @memberof ApplicationEditRequest
     */
    'storage'?: Array<ApplicationStorageResponseStorage>;
    /**
     * 
     * @type {Array<ApplicationPortResponsePorts>}
     * @memberof ApplicationEditRequest
     */
    'ports'?: Array<ApplicationPortResponsePorts>;
    /**
     * name is case insensitive
     * @type {string}
     * @memberof ApplicationEditRequest
     */
    'name'?: string;
    /**
     * give a description to this application
     * @type {string}
     * @memberof ApplicationEditRequest
     */
    'description'?: string;
    /**
     * 
     * @type {ApplicationGitRepositoryRequest}
     * @memberof ApplicationEditRequest
     */
    'git_repository'?: ApplicationGitRepositoryRequest;
    /**
     * 
     * @type {BuildModeEnum}
     * @memberof ApplicationEditRequest
     */
    'build_mode'?: BuildModeEnum;
    /**
     * The path of the associated Dockerfile
     * @type {string}
     * @memberof ApplicationEditRequest
     */
    'dockerfile_path'?: string;
    /**
     * 
     * @type {BuildPackLanguageEnum}
     * @memberof ApplicationEditRequest
     */
    'buildpack_language'?: BuildPackLanguageEnum | null;
    /**
     * unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof ApplicationEditRequest
     */
    'cpu'?: number;
    /**
     * unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof ApplicationEditRequest
     */
    'memory'?: number;
    /**
     * Minimum number of instances running. This resource auto-scale based on the CPU and Memory consumption. Note: 0 means that there is no application running. 
     * @type {number}
     * @memberof ApplicationEditRequest
     */
    'min_running_instances'?: number;
    /**
     * Maximum number of instances running. This resource auto-scale based on the CPU and Memory consumption. Note: -1 means that there is no limit. 
     * @type {number}
     * @memberof ApplicationEditRequest
     */
    'max_running_instances'?: number;
    /**
     * 
     * @type {Healthcheck}
     * @memberof ApplicationEditRequest
     */
    'healthcheck'?: Healthcheck;
    /**
     * Specify if the environment preview option is activated or not for this application. If activated, a preview environment will be automatically cloned at each pull request. 
     * @type {boolean}
     * @memberof ApplicationEditRequest
     */
    'auto_preview'?: boolean;
    /**
     * Specify if the sticky session option (also called persistant session) is activated or not for this application. If activated, user will be redirected by the load balancer to the same instance each time he access to the application. 
     * @type {boolean}
     * @memberof ApplicationEditRequest
     */
    'sticky_session'?: boolean;
}
/**
 * 
 * @export
 * @interface ApplicationEditRequestAllOf
 */
export interface ApplicationEditRequestAllOf {
    /**
     * name is case insensitive
     * @type {string}
     * @memberof ApplicationEditRequestAllOf
     */
    'name'?: string;
    /**
     * give a description to this application
     * @type {string}
     * @memberof ApplicationEditRequestAllOf
     */
    'description'?: string;
    /**
     * 
     * @type {ApplicationGitRepositoryRequest}
     * @memberof ApplicationEditRequestAllOf
     */
    'git_repository'?: ApplicationGitRepositoryRequest;
    /**
     * 
     * @type {BuildModeEnum}
     * @memberof ApplicationEditRequestAllOf
     */
    'build_mode'?: BuildModeEnum;
    /**
     * The path of the associated Dockerfile
     * @type {string}
     * @memberof ApplicationEditRequestAllOf
     */
    'dockerfile_path'?: string;
    /**
     * 
     * @type {BuildPackLanguageEnum}
     * @memberof ApplicationEditRequestAllOf
     */
    'buildpack_language'?: BuildPackLanguageEnum | null;
    /**
     * unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof ApplicationEditRequestAllOf
     */
    'cpu'?: number;
    /**
     * unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof ApplicationEditRequestAllOf
     */
    'memory'?: number;
    /**
     * Minimum number of instances running. This resource auto-scale based on the CPU and Memory consumption. Note: 0 means that there is no application running. 
     * @type {number}
     * @memberof ApplicationEditRequestAllOf
     */
    'min_running_instances'?: number;
    /**
     * Maximum number of instances running. This resource auto-scale based on the CPU and Memory consumption. Note: -1 means that there is no limit. 
     * @type {number}
     * @memberof ApplicationEditRequestAllOf
     */
    'max_running_instances'?: number;
    /**
     * 
     * @type {Healthcheck}
     * @memberof ApplicationEditRequestAllOf
     */
    'healthcheck'?: Healthcheck;
    /**
     * Specify if the environment preview option is activated or not for this application. If activated, a preview environment will be automatically cloned at each pull request. 
     * @type {boolean}
     * @memberof ApplicationEditRequestAllOf
     */
    'auto_preview'?: boolean;
    /**
     * Specify if the sticky session option (also called persistant session) is activated or not for this application. If activated, user will be redirected by the load balancer to the same instance each time he access to the application. 
     * @type {boolean}
     * @memberof ApplicationEditRequestAllOf
     */
    'sticky_session'?: boolean;
}
/**
 * 
 * @export
 * @interface ApplicationGitRepositoryRequest
 */
export interface ApplicationGitRepositoryRequest {
    /**
     * application git repository URL
     * @type {string}
     * @memberof ApplicationGitRepositoryRequest
     */
    'url': string;
    /**
     * Name of the branch to use. This is optional If not specified, then the branch used is the `main` or `master` one 
     * @type {string}
     * @memberof ApplicationGitRepositoryRequest
     */
    'branch'?: string;
    /**
     * indicates the root path of the application.
     * @type {string}
     * @memberof ApplicationGitRepositoryRequest
     */
    'root_path'?: string;
}
/**
 * 
 * @export
 * @interface ApplicationGitRepositoryResponse
 */
export interface ApplicationGitRepositoryResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationGitRepositoryResponse
     */
    'has_access'?: boolean;
    /**
     * 
     * @type {GitProviderEnum}
     * @memberof ApplicationGitRepositoryResponse
     */
    'provider'?: GitProviderEnum;
    /**
     * 
     * @type {string}
     * @memberof ApplicationGitRepositoryResponse
     */
    'owner'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationGitRepositoryResponse
     */
    'url'?: string;
    /**
     * repository name
     * @type {string}
     * @memberof ApplicationGitRepositoryResponse
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationGitRepositoryResponse
     */
    'branch'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationGitRepositoryResponse
     */
    'root_path'?: string;
    /**
     * Git commit ID corresponding to the deployed version of the app
     * @type {string}
     * @memberof ApplicationGitRepositoryResponse
     */
    'deployed_commit_id'?: string;
    /**
     * Git commit date corresponding to the deployed version of the app
     * @type {string}
     * @memberof ApplicationGitRepositoryResponse
     */
    'deployed_commit_date'?: string;
    /**
     * Git commit user corresponding to the deployed version of the app
     * @type {string}
     * @memberof ApplicationGitRepositoryResponse
     */
    'deployed_commit_contributor'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationGitRepositoryResponse
     */
    'deployed_commit_tag'?: string;
}
/**
 * 
 * @export
 * @interface ApplicationNetworkRequest
 */
export interface ApplicationNetworkRequest {
    /**
     * Specify if the sticky session option (also called persistant session) is activated or not for this application. If activated, user will be redirected by the load balancer to the same instance each time he access to the application.  
     * @type {boolean}
     * @memberof ApplicationNetworkRequest
     */
    'sticky_session'?: boolean;
}
/**
 * 
 * @export
 * @interface ApplicationNetworkResponse
 */
export interface ApplicationNetworkResponse {
    /**
     * Specify if the sticky session option (also called persistant session) is activated or not for this application. If activated, user will be redirected by the load balancer to the same instance each time he access to the application.  
     * @type {boolean}
     * @memberof ApplicationNetworkResponse
     */
    'sticky_session'?: boolean;
}
/**
 * 
 * @export
 * @interface ApplicationPortRequest
 */
export interface ApplicationPortRequest {
    /**
     * 
     * @type {Array<ApplicationPortRequestPorts>}
     * @memberof ApplicationPortRequest
     */
    'ports'?: Array<ApplicationPortRequestPorts>;
}
/**
 * 
 * @export
 * @interface ApplicationPortRequestPorts
 */
export interface ApplicationPortRequestPorts {
    /**
     * 
     * @type {string}
     * @memberof ApplicationPortRequestPorts
     */
    'name'?: string | null;
    /**
     * The listening port of your application
     * @type {number}
     * @memberof ApplicationPortRequestPorts
     */
    'internal_port': number;
    /**
     * The exposed port for your application. This is optional. If not set a default port will be used.
     * @type {number}
     * @memberof ApplicationPortRequestPorts
     */
    'external_port'?: number;
    /**
     * Expose the port to the world
     * @type {boolean}
     * @memberof ApplicationPortRequestPorts
     */
    'publicly_accessible': boolean;
    /**
     * 
     * @type {PortProtocolEnum}
     * @memberof ApplicationPortRequestPorts
     */
    'protocol'?: PortProtocolEnum;
}
/**
 * 
 * @export
 * @interface ApplicationPortResponse
 */
export interface ApplicationPortResponse {
    /**
     * 
     * @type {Array<ApplicationPortResponsePorts>}
     * @memberof ApplicationPortResponse
     */
    'ports'?: Array<ApplicationPortResponsePorts>;
}
/**
 * 
 * @export
 * @interface ApplicationPortResponsePorts
 */
export interface ApplicationPortResponsePorts {
    /**
     * 
     * @type {string}
     * @memberof ApplicationPortResponsePorts
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationPortResponsePorts
     */
    'name'?: string | null;
    /**
     * The listening port of your application
     * @type {number}
     * @memberof ApplicationPortResponsePorts
     */
    'internal_port': number;
    /**
     * The exposed port for your application. This is optional. If not set a default port will be used.
     * @type {number}
     * @memberof ApplicationPortResponsePorts
     */
    'external_port'?: number;
    /**
     * Expose the port to the world
     * @type {boolean}
     * @memberof ApplicationPortResponsePorts
     */
    'publicly_accessible': boolean;
    /**
     * 
     * @type {PortProtocolEnum}
     * @memberof ApplicationPortResponsePorts
     */
    'protocol'?: PortProtocolEnum;
}
/**
 * 
 * @export
 * @interface ApplicationRequest
 */
export interface ApplicationRequest {
    /**
     * 
     * @type {Array<ApplicationStorageRequestStorage>}
     * @memberof ApplicationRequest
     */
    'storage'?: Array<ApplicationStorageRequestStorage>;
    /**
     * 
     * @type {Array<ApplicationPortRequestPorts>}
     * @memberof ApplicationRequest
     */
    'ports'?: Array<ApplicationPortRequestPorts>;
    /**
     * name is case insensitive
     * @type {string}
     * @memberof ApplicationRequest
     */
    'name': string;
    /**
     * give a description to this application
     * @type {string}
     * @memberof ApplicationRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {ApplicationGitRepositoryRequest}
     * @memberof ApplicationRequest
     */
    'git_repository': ApplicationGitRepositoryRequest;
    /**
     * 
     * @type {BuildModeEnum}
     * @memberof ApplicationRequest
     */
    'build_mode'?: BuildModeEnum;
    /**
     * The path of the associated Dockerfile. Only if you are using build_mode = DOCKER
     * @type {string}
     * @memberof ApplicationRequest
     */
    'dockerfile_path'?: string | null;
    /**
     * 
     * @type {BuildPackLanguageEnum}
     * @memberof ApplicationRequest
     */
    'buildpack_language'?: BuildPackLanguageEnum | null;
    /**
     * unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof ApplicationRequest
     */
    'cpu'?: number;
    /**
     * unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof ApplicationRequest
     */
    'memory'?: number;
    /**
     * Minimum number of instances running. This resource auto-scale based on the CPU and Memory consumption. Note: 0 means that there is no application running. 
     * @type {number}
     * @memberof ApplicationRequest
     */
    'min_running_instances'?: number;
    /**
     * Maximum number of instances running. This resource auto-scale based on the CPU and Memory consumption. Note: -1 means that there is no limit. 
     * @type {number}
     * @memberof ApplicationRequest
     */
    'max_running_instances'?: number;
    /**
     * 
     * @type {Healthcheck}
     * @memberof ApplicationRequest
     */
    'healthcheck'?: Healthcheck;
    /**
     * Specify if the environment preview option is activated or not for this application. If activated, a preview environment will be automatically cloned at each pull request. 
     * @type {boolean}
     * @memberof ApplicationRequest
     */
    'auto_preview'?: boolean;
}
/**
 * 
 * @export
 * @interface ApplicationRequestAllOf
 */
export interface ApplicationRequestAllOf {
    /**
     * name is case insensitive
     * @type {string}
     * @memberof ApplicationRequestAllOf
     */
    'name': string;
    /**
     * give a description to this application
     * @type {string}
     * @memberof ApplicationRequestAllOf
     */
    'description'?: string | null;
    /**
     * 
     * @type {ApplicationGitRepositoryRequest}
     * @memberof ApplicationRequestAllOf
     */
    'git_repository': ApplicationGitRepositoryRequest;
    /**
     * 
     * @type {BuildModeEnum}
     * @memberof ApplicationRequestAllOf
     */
    'build_mode'?: BuildModeEnum;
    /**
     * The path of the associated Dockerfile. Only if you are using build_mode = DOCKER
     * @type {string}
     * @memberof ApplicationRequestAllOf
     */
    'dockerfile_path'?: string | null;
    /**
     * 
     * @type {BuildPackLanguageEnum}
     * @memberof ApplicationRequestAllOf
     */
    'buildpack_language'?: BuildPackLanguageEnum | null;
    /**
     * unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof ApplicationRequestAllOf
     */
    'cpu'?: number;
    /**
     * unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof ApplicationRequestAllOf
     */
    'memory'?: number;
    /**
     * Minimum number of instances running. This resource auto-scale based on the CPU and Memory consumption. Note: 0 means that there is no application running. 
     * @type {number}
     * @memberof ApplicationRequestAllOf
     */
    'min_running_instances'?: number;
    /**
     * Maximum number of instances running. This resource auto-scale based on the CPU and Memory consumption. Note: -1 means that there is no limit. 
     * @type {number}
     * @memberof ApplicationRequestAllOf
     */
    'max_running_instances'?: number;
    /**
     * 
     * @type {Healthcheck}
     * @memberof ApplicationRequestAllOf
     */
    'healthcheck'?: Healthcheck;
    /**
     * Specify if the environment preview option is activated or not for this application. If activated, a preview environment will be automatically cloned at each pull request. 
     * @type {boolean}
     * @memberof ApplicationRequestAllOf
     */
    'auto_preview'?: boolean;
}
/**
 * 
 * @export
 * @interface ApplicationResponse
 */
export interface ApplicationResponse {
    /**
     * 
     * @type {string}
     * @memberof ApplicationResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {Array<ApplicationStorageResponseStorage>}
     * @memberof ApplicationResponse
     */
    'storage'?: Array<ApplicationStorageResponseStorage>;
    /**
     * 
     * @type {Array<ApplicationPortResponsePorts>}
     * @memberof ApplicationResponse
     */
    'ports'?: Array<ApplicationPortResponsePorts>;
    /**
     * 
     * @type {ReferenceObject}
     * @memberof ApplicationResponse
     */
    'environment'?: ReferenceObject;
    /**
     * 
     * @type {ApplicationGitRepositoryResponse}
     * @memberof ApplicationResponse
     */
    'git_repository'?: ApplicationGitRepositoryResponse;
    /**
     * Maximum cpu that can be allocated to the application based on organization cluster configuration. unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof ApplicationResponse
     */
    'maximum_cpu'?: number;
    /**
     * Maximum memory that can be allocated to the application based on organization cluster configuration. unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof ApplicationResponse
     */
    'maximum_memory'?: number;
    /**
     * name is case insensitive
     * @type {string}
     * @memberof ApplicationResponse
     */
    'name'?: string;
    /**
     * give a description to this application
     * @type {string}
     * @memberof ApplicationResponse
     */
    'description'?: string | null;
    /**
     * 
     * @type {BuildModeEnum}
     * @memberof ApplicationResponse
     */
    'build_mode'?: BuildModeEnum;
    /**
     * The path of the associated Dockerfile. Only if you are using build_mode = DOCKER
     * @type {string}
     * @memberof ApplicationResponse
     */
    'dockerfile_path'?: string | null;
    /**
     * 
     * @type {BuildPackLanguageEnum}
     * @memberof ApplicationResponse
     */
    'buildpack_language'?: BuildPackLanguageEnum | null;
    /**
     * unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof ApplicationResponse
     */
    'cpu'?: number;
    /**
     * unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof ApplicationResponse
     */
    'memory'?: number;
    /**
     * Minimum number of instances running. This resource auto-scale based on the CPU and Memory consumption. Note: 0 means that there is no application running. 
     * @type {number}
     * @memberof ApplicationResponse
     */
    'min_running_instances'?: number;
    /**
     * Maximum number of instances running. This resource auto-scale based on the CPU and Memory consumption. Note: -1 means that there is no limit. 
     * @type {number}
     * @memberof ApplicationResponse
     */
    'max_running_instances'?: number;
    /**
     * 
     * @type {Healthcheck}
     * @memberof ApplicationResponse
     */
    'healthcheck'?: Healthcheck;
    /**
     * Specify if the environment preview option is activated or not for this application. If activated, a preview environment will be automatically cloned at each pull request. 
     * @type {boolean}
     * @memberof ApplicationResponse
     */
    'auto_preview'?: boolean;
}
/**
 * 
 * @export
 * @interface ApplicationResponseAllOf
 */
export interface ApplicationResponseAllOf {
    /**
     * 
     * @type {ReferenceObject}
     * @memberof ApplicationResponseAllOf
     */
    'environment'?: ReferenceObject;
    /**
     * 
     * @type {ApplicationGitRepositoryResponse}
     * @memberof ApplicationResponseAllOf
     */
    'git_repository'?: ApplicationGitRepositoryResponse;
    /**
     * Maximum cpu that can be allocated to the application based on organization cluster configuration. unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof ApplicationResponseAllOf
     */
    'maximum_cpu'?: number;
    /**
     * Maximum memory that can be allocated to the application based on organization cluster configuration. unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof ApplicationResponseAllOf
     */
    'maximum_memory'?: number;
    /**
     * name is case insensitive
     * @type {string}
     * @memberof ApplicationResponseAllOf
     */
    'name'?: string;
    /**
     * give a description to this application
     * @type {string}
     * @memberof ApplicationResponseAllOf
     */
    'description'?: string | null;
    /**
     * 
     * @type {BuildModeEnum}
     * @memberof ApplicationResponseAllOf
     */
    'build_mode'?: BuildModeEnum;
    /**
     * The path of the associated Dockerfile. Only if you are using build_mode = DOCKER
     * @type {string}
     * @memberof ApplicationResponseAllOf
     */
    'dockerfile_path'?: string | null;
    /**
     * 
     * @type {BuildPackLanguageEnum}
     * @memberof ApplicationResponseAllOf
     */
    'buildpack_language'?: BuildPackLanguageEnum | null;
    /**
     * unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof ApplicationResponseAllOf
     */
    'cpu'?: number;
    /**
     * unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof ApplicationResponseAllOf
     */
    'memory'?: number;
    /**
     * Minimum number of instances running. This resource auto-scale based on the CPU and Memory consumption. Note: 0 means that there is no application running. 
     * @type {number}
     * @memberof ApplicationResponseAllOf
     */
    'min_running_instances'?: number;
    /**
     * Maximum number of instances running. This resource auto-scale based on the CPU and Memory consumption. Note: -1 means that there is no limit. 
     * @type {number}
     * @memberof ApplicationResponseAllOf
     */
    'max_running_instances'?: number;
    /**
     * 
     * @type {Healthcheck}
     * @memberof ApplicationResponseAllOf
     */
    'healthcheck'?: Healthcheck;
    /**
     * Specify if the environment preview option is activated or not for this application. If activated, a preview environment will be automatically cloned at each pull request. 
     * @type {boolean}
     * @memberof ApplicationResponseAllOf
     */
    'auto_preview'?: boolean;
}
/**
 * 
 * @export
 * @interface ApplicationResponseList
 */
export interface ApplicationResponseList {
    /**
     * 
     * @type {Array<ApplicationResponse>}
     * @memberof ApplicationResponseList
     */
    'results'?: Array<ApplicationResponse>;
}
/**
 * 
 * @export
 * @interface ApplicationStorageRequest
 */
export interface ApplicationStorageRequest {
    /**
     * 
     * @type {Array<ApplicationStorageRequestStorage>}
     * @memberof ApplicationStorageRequest
     */
    'storage'?: Array<ApplicationStorageRequestStorage>;
}
/**
 * 
 * @export
 * @interface ApplicationStorageRequestStorage
 */
export interface ApplicationStorageRequestStorage {
    /**
     * 
     * @type {string}
     * @memberof ApplicationStorageRequestStorage
     */
    'type': ApplicationStorageRequestStorageTypeEnum;
    /**
     * unit is GB
     * @type {number}
     * @memberof ApplicationStorageRequestStorage
     */
    'size': number;
    /**
     * 
     * @type {string}
     * @memberof ApplicationStorageRequestStorage
     */
    'mount_point': string;
}

/**
    * @export
    * @enum {string}
    */
export enum ApplicationStorageRequestStorageTypeEnum {
    FAST_SSD = 'FAST_SSD'
}

/**
 * 
 * @export
 * @interface ApplicationStorageResponse
 */
export interface ApplicationStorageResponse {
    /**
     * 
     * @type {Array<ApplicationStorageResponseStorage>}
     * @memberof ApplicationStorageResponse
     */
    'storage'?: Array<ApplicationStorageResponseStorage>;
}
/**
 * 
 * @export
 * @interface ApplicationStorageResponseStorage
 */
export interface ApplicationStorageResponseStorage {
    /**
     * 
     * @type {string}
     * @memberof ApplicationStorageResponseStorage
     */
    'id'?: string;
    /**
     * 
     * @type {StorageTypeEnum}
     * @memberof ApplicationStorageResponseStorage
     */
    'type': StorageTypeEnum;
    /**
     * unit is GB
     * @type {number}
     * @memberof ApplicationStorageResponseStorage
     */
    'size': number;
    /**
     * 
     * @type {string}
     * @memberof ApplicationStorageResponseStorage
     */
    'mount_point': string;
}
/**
 * 
 * @export
 * @interface AwsCredentialsRequest
 */
export interface AwsCredentialsRequest {
    /**
     * 
     * @type {string}
     * @memberof AwsCredentialsRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AwsCredentialsRequest
     */
    'access_key_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AwsCredentialsRequest
     */
    'secret_access_key'?: string;
}
/**
 * 
 * @export
 * @interface BackupPaginatedResponseList
 */
export interface BackupPaginatedResponseList {
    /**
     * 
     * @type {number}
     * @memberof BackupPaginatedResponseList
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof BackupPaginatedResponseList
     */
    'page_size': number;
    /**
     * 
     * @type {Array<BackupResponse>}
     * @memberof BackupPaginatedResponseList
     */
    'results'?: Array<BackupResponse>;
}
/**
 * 
 * @export
 * @interface BackupRequest
 */
export interface BackupRequest {
    /**
     * 
     * @type {string}
     * @memberof BackupRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BackupRequest
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface BackupResponse
 */
export interface BackupResponse {
    /**
     * 
     * @type {string}
     * @memberof BackupResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BackupResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof BackupResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof BackupResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BackupResponse
     */
    'message': string;
    /**
     * 
     * @type {Status}
     * @memberof BackupResponse
     */
    'status'?: Status;
}
/**
 * 
 * @export
 * @interface BackupResponseAllOf
 */
export interface BackupResponseAllOf {
    /**
     * 
     * @type {Status}
     * @memberof BackupResponseAllOf
     */
    'status'?: Status;
}
/**
 * 
 * @export
 * @interface BackupResponseList
 */
export interface BackupResponseList {
    /**
     * 
     * @type {Array<BackupResponse>}
     * @memberof BackupResponseList
     */
    'results'?: Array<BackupResponse>;
}
/**
 * 
 * @export
 * @interface BaseResponse
 */
export interface BaseResponse {
    /**
     * 
     * @type {string}
     * @memberof BaseResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BaseResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof BaseResponse
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface BillingEnd
 */
export interface BillingEnd {
    /**
     * 
     * @type {string}
     * @memberof BillingEnd
     */
    'billing_ended_on'?: string;
}
/**
 * 
 * @export
 * @interface BillingInfoRequest
 */
export interface BillingInfoRequest {
    /**
     * 
     * @type {string}
     * @memberof BillingInfoRequest
     */
    'first_name': string;
    /**
     * 
     * @type {string}
     * @memberof BillingInfoRequest
     */
    'last_name': string;
    /**
     * email used for billing, and to receive all invoices by email
     * @type {string}
     * @memberof BillingInfoRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof BillingInfoRequest
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof BillingInfoRequest
     */
    'city': string;
    /**
     * 
     * @type {string}
     * @memberof BillingInfoRequest
     */
    'zip': string;
    /**
     * only for US
     * @type {string}
     * @memberof BillingInfoRequest
     */
    'state'?: string;
    /**
     * ISO code of the country
     * @type {string}
     * @memberof BillingInfoRequest
     */
    'country_code': string;
    /**
     * name of the company to bill
     * @type {string}
     * @memberof BillingInfoRequest
     */
    'company'?: string;
    /**
     * 
     * @type {string}
     * @memberof BillingInfoRequest
     */
    'vat_number'?: string;
}
/**
 * 
 * @export
 * @interface BillingInfoResponse
 */
export interface BillingInfoResponse {
    /**
     * 
     * @type {string}
     * @memberof BillingInfoResponse
     */
    'first_name': string;
    /**
     * 
     * @type {string}
     * @memberof BillingInfoResponse
     */
    'last_name': string;
    /**
     * email used for billing, and to receive all invoices by email
     * @type {string}
     * @memberof BillingInfoResponse
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof BillingInfoResponse
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof BillingInfoResponse
     */
    'city': string;
    /**
     * 
     * @type {string}
     * @memberof BillingInfoResponse
     */
    'zip': string;
    /**
     * only for US
     * @type {string}
     * @memberof BillingInfoResponse
     */
    'state'?: string;
    /**
     * ISO code of the country
     * @type {string}
     * @memberof BillingInfoResponse
     */
    'country_code': string;
    /**
     * name of the company to bill
     * @type {string}
     * @memberof BillingInfoResponse
     */
    'company'?: string;
    /**
     * 
     * @type {string}
     * @memberof BillingInfoResponse
     */
    'vat_number'?: string;
}
/**
 * 
 * @export
 * @interface BillingPeriod
 */
export interface BillingPeriod {
    /**
     * 
     * @type {string}
     * @memberof BillingPeriod
     */
    'billing_started_on'?: string;
    /**
     * 
     * @type {string}
     * @memberof BillingPeriod
     */
    'billing_ended_on'?: string;
}
/**
 * 
 * @export
 * @interface BillingStart
 */
export interface BillingStart {
    /**
     * 
     * @type {string}
     * @memberof BillingStart
     */
    'billing_started_on'?: string;
}
/**
 * 
 * @export
 * @interface BillingStatus
 */
export interface BillingStatus {
    /**
     * 
     * @type {boolean}
     * @memberof BillingStatus
     */
    'is_valid'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof BillingStatus
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface BudgetResponse
 */
export interface BudgetResponse {
    /**
     * 
     * @type {number}
     * @memberof BudgetResponse
     */
    'total_in_cents'?: number;
    /**
     * 
     * @type {number}
     * @memberof BudgetResponse
     */
    'total'?: number;
    /**
     * 
     * @type {string}
     * @memberof BudgetResponse
     */
    'currency_code'?: string;
}
/**
 * 
 * @export
 * @interface BudgetThreshold
 */
export interface BudgetThreshold {
    /**
     * 
     * @type {number}
     * @memberof BudgetThreshold
     */
    'total_in_cents'?: number;
    /**
     * 
     * @type {number}
     * @memberof BudgetThreshold
     */
    'total'?: number;
    /**
     * 
     * @type {string}
     * @memberof BudgetThreshold
     */
    'currency_code'?: string;
}
/**
 * `DOCKER` requires `dockerfile_path` `BUILDPACKS` does not require any `dockerfile_path` 
 * @export
 * @enum {string}
 */

export enum BuildModeEnum {
    DOCKER = 'DOCKER',
    BUILDPACKS = 'BUILDPACKS'
}

/**
 * Development language of the application
 * @export
 * @enum {string}
 */

export enum BuildPackLanguageEnum {
    CLOJURE = 'CLOJURE',
    GO = 'GO',
    GRADLE = 'GRADLE',
    GRAILS = 'GRAILS',
    JAVA = 'JAVA',
    JVM = 'JVM',
    NODE_JS = 'NODE_JS',
    PHP = 'PHP',
    PLAY = 'PLAY',
    PYTHON = 'PYTHON',
    SCALA = 'SCALA'
}

/**
 * 
 * @export
 * @interface CloneRequest
 */
export interface CloneRequest {
    /**
     * name is case insensitive
     * @type {string}
     * @memberof CloneRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CloneRequest
     */
    'cluster_id'?: string;
    /**
     * 
     * @type {EnvironmentModeEnum}
     * @memberof CloneRequest
     */
    'mode'?: EnvironmentModeEnum;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum CloudProviderEnum {
    AWS = 'AWS',
    DIGITAL_OCEAN = 'DIGITAL_OCEAN',
    SCALEWAY = 'SCALEWAY'
}

/**
 * 
 * @export
 * @interface CloudProviderResponse
 */
export interface CloudProviderResponse {
    /**
     * 
     * @type {string}
     * @memberof CloudProviderResponse
     */
    'short_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CloudProviderResponse
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CloudProviderResponse
     */
    'logo_url'?: string;
    /**
     * 
     * @type {Array<ClusterRegionResponse>}
     * @memberof CloudProviderResponse
     */
    'regions'?: Array<ClusterRegionResponse>;
}
/**
 * 
 * @export
 * @interface CloudProviderResponseList
 */
export interface CloudProviderResponseList {
    /**
     * 
     * @type {Array<CloudProviderResponse>}
     * @memberof CloudProviderResponseList
     */
    'results'?: Array<CloudProviderResponse>;
}
/**
 * 
 * @export
 * @interface Cluster
 */
export interface Cluster {
    /**
     * name is case-insensitive
     * @type {string}
     * @memberof Cluster
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Cluster
     */
    'description'?: string;
    /**
     * 
     * @type {CloudProviderEnum}
     * @memberof Cluster
     */
    'cloud_provider': CloudProviderEnum;
    /**
     * 
     * @type {string}
     * @memberof Cluster
     */
    'region': string;
    /**
     * 
     * @type {boolean}
     * @memberof Cluster
     */
    'auto_update'?: boolean;
    /**
     * unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof Cluster
     */
    'cpu'?: number;
    /**
     * unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof Cluster
     */
    'memory'?: number;
    /**
     * 
     * @type {number}
     * @memberof Cluster
     */
    'min_running_nodes'?: number;
    /**
     * 
     * @type {number}
     * @memberof Cluster
     */
    'max_running_nodes'?: number;
}
/**
 * 
 * @export
 * @interface ClusterCloudProviderInfoRequest
 */
export interface ClusterCloudProviderInfoRequest {
    /**
     * 
     * @type {CloudProviderEnum}
     * @memberof ClusterCloudProviderInfoRequest
     */
    'cloud_provider'?: CloudProviderEnum;
    /**
     * 
     * @type {ClusterCloudProviderInfoRequestCredentials}
     * @memberof ClusterCloudProviderInfoRequest
     */
    'credentials'?: ClusterCloudProviderInfoRequestCredentials;
    /**
     * 
     * @type {string}
     * @memberof ClusterCloudProviderInfoRequest
     */
    'region'?: string;
}
/**
 * 
 * @export
 * @interface ClusterCloudProviderInfoRequestCredentials
 */
export interface ClusterCloudProviderInfoRequestCredentials {
    /**
     * 
     * @type {string}
     * @memberof ClusterCloudProviderInfoRequestCredentials
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterCloudProviderInfoRequestCredentials
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface ClusterCloudProviderInfoResponse
 */
export interface ClusterCloudProviderInfoResponse {
    /**
     * 
     * @type {CloudProviderEnum}
     * @memberof ClusterCloudProviderInfoResponse
     */
    'cloud_provider'?: CloudProviderEnum;
    /**
     * 
     * @type {ClusterCloudProviderInfoRequestCredentials}
     * @memberof ClusterCloudProviderInfoResponse
     */
    'credentials'?: ClusterCloudProviderInfoRequestCredentials;
    /**
     * 
     * @type {string}
     * @memberof ClusterCloudProviderInfoResponse
     */
    'region'?: string;
}
/**
 * 
 * @export
 * @interface ClusterCredentialsRequest
 */
export interface ClusterCredentialsRequest {
    /**
     * 
     * @type {string}
     * @memberof ClusterCredentialsRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ClusterCredentialsRequest
     */
    'access_key_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterCredentialsRequest
     */
    'secret_access_key'?: string;
}
/**
 * 
 * @export
 * @interface ClusterCredentialsResponse
 */
export interface ClusterCredentialsResponse {
    /**
     * 
     * @type {string}
     * @memberof ClusterCredentialsResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterCredentialsResponse
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface ClusterCredentialsResponseList
 */
export interface ClusterCredentialsResponseList {
    /**
     * 
     * @type {Array<ClusterCredentialsResponse>}
     * @memberof ClusterCredentialsResponseList
     */
    'results'?: Array<ClusterCredentialsResponse>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum ClusterDeploymentStatusEnum {
    READY = 'READY',
    QUEUED = 'QUEUED',
    STOP_QUEUED = 'STOP_QUEUED',
    DELETE_QUEUED = 'DELETE_QUEUED',
    BUILDING = 'BUILDING',
    BUILD_ERROR = 'BUILD_ERROR',
    BUILT = 'BUILT',
    DEPLOYING = 'DEPLOYING',
    DEPLOYMENT_ERROR = 'DEPLOYMENT_ERROR',
    DEPLOYED = 'DEPLOYED',
    STOPPING = 'STOPPING',
    STOP_ERROR = 'STOP_ERROR',
    STOPPED = 'STOPPED',
    DELETING = 'DELETING',
    DELETE_ERROR = 'DELETE_ERROR',
    DELETED = 'DELETED',
    RUNNING = 'RUNNING',
    RUNNING_ERROR = 'RUNNING_ERROR'
}

/**
 * 
 * @export
 * @interface ClusterFeatureRequest
 */
export interface ClusterFeatureRequest {
    /**
     * 
     * @type {Array<ClusterFeatureRequestFeatures>}
     * @memberof ClusterFeatureRequest
     */
    'features'?: Array<ClusterFeatureRequestFeatures>;
}
/**
 * 
 * @export
 * @interface ClusterFeatureRequestFeatures
 */
export interface ClusterFeatureRequestFeatures {
    /**
     * 
     * @type {string}
     * @memberof ClusterFeatureRequestFeatures
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterFeatureRequestFeatures
     */
    'value'?: string | null;
}
/**
 * 
 * @export
 * @interface ClusterFeatureResponse
 */
export interface ClusterFeatureResponse {
    /**
     * 
     * @type {string}
     * @memberof ClusterFeatureResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterFeatureResponse
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterFeatureResponse
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ClusterFeatureResponse
     */
    'cost_per_month_in_cents'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ClusterFeatureResponse
     */
    'cost_per_month'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ClusterFeatureResponse
     */
    'currency_code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ClusterFeatureResponse
     */
    'value_type'?: ClusterFeatureResponseValueTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ClusterFeatureResponse
     */
    'value'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ClusterFeatureResponse
     */
    'is_value_updatable'?: boolean;
    /**
     * 
     * @type {Array<string | boolean>}
     * @memberof ClusterFeatureResponse
     */
    'accepted_values'?: Array<string | boolean>;
}

/**
    * @export
    * @enum {string}
    */
export enum ClusterFeatureResponseValueTypeEnum {
    BOOLEAN = 'BOOLEAN'
}

/**
 * 
 * @export
 * @interface ClusterFeatureResponseList
 */
export interface ClusterFeatureResponseList {
    /**
     * 
     * @type {Array<ClusterFeatureResponse>}
     * @memberof ClusterFeatureResponseList
     */
    'results'?: Array<ClusterFeatureResponse>;
}
/**
 * 
 * @export
 * @interface ClusterReadinessStatus
 */
export interface ClusterReadinessStatus {
    /**
     * 
     * @type {boolean}
     * @memberof ClusterReadinessStatus
     */
    'is_ready'?: boolean;
}
/**
 * 
 * @export
 * @interface ClusterRegionResponse
 */
export interface ClusterRegionResponse {
    /**
     * 
     * @type {string}
     * @memberof ClusterRegionResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ClusterRegionResponse
     */
    'country_code': string;
    /**
     * 
     * @type {string}
     * @memberof ClusterRegionResponse
     */
    'country': string;
    /**
     * 
     * @type {string}
     * @memberof ClusterRegionResponse
     */
    'city': string;
}
/**
 * 
 * @export
 * @interface ClusterRegionResponseList
 */
export interface ClusterRegionResponseList {
    /**
     * 
     * @type {Array<ClusterRegionResponse>}
     * @memberof ClusterRegionResponseList
     */
    'results'?: Array<ClusterRegionResponse>;
}
/**
 * 
 * @export
 * @interface ClusterRequest
 */
export interface ClusterRequest {
    /**
     * name is case-insensitive
     * @type {string}
     * @memberof ClusterRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ClusterRequest
     */
    'description'?: string;
    /**
     * 
     * @type {CloudProviderEnum}
     * @memberof ClusterRequest
     */
    'cloud_provider': CloudProviderEnum;
    /**
     * 
     * @type {string}
     * @memberof ClusterRequest
     */
    'region': string;
    /**
     * 
     * @type {boolean}
     * @memberof ClusterRequest
     */
    'auto_update'?: boolean;
    /**
     * unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof ClusterRequest
     */
    'cpu'?: number;
    /**
     * unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof ClusterRequest
     */
    'memory'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterRequest
     */
    'min_running_nodes'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterRequest
     */
    'max_running_nodes'?: number;
    /**
     * 
     * @type {Array<ClusterFeatureRequestFeatures>}
     * @memberof ClusterRequest
     */
    'features'?: Array<ClusterFeatureRequestFeatures>;
}
/**
 * 
 * @export
 * @interface ClusterResponse
 */
export interface ClusterResponse {
    /**
     * 
     * @type {string}
     * @memberof ClusterResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ClusterResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ClusterResponse
     */
    'updated_at'?: string;
    /**
     * name is case-insensitive
     * @type {string}
     * @memberof ClusterResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ClusterResponse
     */
    'description'?: string | null;
    /**
     * 
     * @type {CloudProviderEnum}
     * @memberof ClusterResponse
     */
    'cloud_provider': CloudProviderEnum;
    /**
     * 
     * @type {string}
     * @memberof ClusterResponse
     */
    'region': string;
    /**
     * 
     * @type {boolean}
     * @memberof ClusterResponse
     */
    'auto_update'?: boolean;
    /**
     * unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof ClusterResponse
     */
    'cpu'?: number;
    /**
     * unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof ClusterResponse
     */
    'memory'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterResponse
     */
    'min_running_nodes'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterResponse
     */
    'max_running_nodes'?: number;
    /**
     * 
     * @type {string}
     * @memberof ClusterResponse
     */
    'title'?: string;
    /**
     * 
     * @type {number}
     * @memberof ClusterResponse
     */
    'cost_per_month_in_cents'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ClusterResponse
     */
    'cost_per_month'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ClusterResponse
     */
    'currency_code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ClusterResponse
     */
    'value_type'?: ClusterResponseValueTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ClusterResponse
     */
    'value'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ClusterResponse
     */
    'is_value_updatable'?: boolean;
    /**
     * 
     * @type {Array<string | boolean>}
     * @memberof ClusterResponse
     */
    'accepted_values'?: Array<string | boolean>;
    /**
     * This is an estimation of the cost this cluster will represent on your cloud proider bill, based on your current configuration
     * @type {number}
     * @memberof ClusterResponse
     */
    'estimated_cloud_provider_cost'?: number;
    /**
     * 
     * @type {ClusterStatusEnum}
     * @memberof ClusterResponse
     */
    'status'?: ClusterStatusEnum;
    /**
     * 
     * @type {boolean}
     * @memberof ClusterResponse
     */
    'has_access'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ClusterResponse
     */
    'version'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ClusterResponse
     */
    'is_default'?: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum ClusterResponseValueTypeEnum {
    BOOLEAN = 'BOOLEAN'
}

/**
 * 
 * @export
 * @interface ClusterResponseAllOf
 */
export interface ClusterResponseAllOf {
    /**
     * This is an estimation of the cost this cluster will represent on your cloud proider bill, based on your current configuration
     * @type {number}
     * @memberof ClusterResponseAllOf
     */
    'estimated_cloud_provider_cost'?: number;
    /**
     * 
     * @type {ClusterStatusEnum}
     * @memberof ClusterResponseAllOf
     */
    'status'?: ClusterStatusEnum;
    /**
     * 
     * @type {boolean}
     * @memberof ClusterResponseAllOf
     */
    'has_access'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ClusterResponseAllOf
     */
    'version'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ClusterResponseAllOf
     */
    'is_default'?: boolean;
}
/**
 * 
 * @export
 * @interface ClusterResponseList
 */
export interface ClusterResponseList {
    /**
     * 
     * @type {Array<ClusterResponse>}
     * @memberof ClusterResponseList
     */
    'results'?: Array<ClusterResponse>;
}
/**
 * 
 * @export
 * @interface ClusterRoutingTableRequest
 */
export interface ClusterRoutingTableRequest {
    /**
     * 
     * @type {Array<ClusterRoutingTableRequestRoutes>}
     * @memberof ClusterRoutingTableRequest
     */
    'routes': Array<ClusterRoutingTableRequestRoutes>;
}
/**
 * 
 * @export
 * @interface ClusterRoutingTableRequestRoutes
 */
export interface ClusterRoutingTableRequestRoutes {
    /**
     * 
     * @type {string}
     * @memberof ClusterRoutingTableRequestRoutes
     */
    'destination': string;
    /**
     * 
     * @type {string}
     * @memberof ClusterRoutingTableRequestRoutes
     */
    'target': string;
    /**
     * 
     * @type {string}
     * @memberof ClusterRoutingTableRequestRoutes
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface ClusterRoutingTableResponse
 */
export interface ClusterRoutingTableResponse {
    /**
     * 
     * @type {Array<ClusterRoutingTableResponseResults>}
     * @memberof ClusterRoutingTableResponse
     */
    'results'?: Array<ClusterRoutingTableResponseResults>;
}
/**
 * 
 * @export
 * @interface ClusterRoutingTableResponseResults
 */
export interface ClusterRoutingTableResponseResults {
    /**
     * 
     * @type {string}
     * @memberof ClusterRoutingTableResponseResults
     */
    'destination'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterRoutingTableResponseResults
     */
    'target'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterRoutingTableResponseResults
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum ClusterStatusEnum {
    READY = 'READY',
    QUEUED = 'QUEUED',
    STOP_QUEUED = 'STOP_QUEUED',
    DELETE_QUEUED = 'DELETE_QUEUED',
    BUILDING = 'BUILDING',
    BUILD_ERROR = 'BUILD_ERROR',
    BUILT = 'BUILT',
    DEPLOYING = 'DEPLOYING',
    DEPLOYMENT_ERROR = 'DEPLOYMENT_ERROR',
    DEPLOYED = 'DEPLOYED',
    STOPPING = 'STOPPING',
    STOP_ERROR = 'STOP_ERROR',
    STOPPED = 'STOPPED',
    DELETING = 'DELETING',
    DELETE_ERROR = 'DELETE_ERROR',
    DELETED = 'DELETED',
    RUNNING = 'RUNNING',
    RUNNING_ERROR = 'RUNNING_ERROR'
}

/**
 * 
 * @export
 * @interface ClusterStatusResponse
 */
export interface ClusterStatusResponse {
    /**
     * 
     * @type {string}
     * @memberof ClusterStatusResponse
     */
    'cluster_id'?: string;
    /**
     * 
     * @type {ClusterDeploymentStatusEnum}
     * @memberof ClusterStatusResponse
     */
    'status'?: ClusterDeploymentStatusEnum;
    /**
     * 
     * @type {boolean}
     * @memberof ClusterStatusResponse
     */
    'is_deployed'?: boolean;
}
/**
 * 
 * @export
 * @interface ClusterStatusResponseList
 */
export interface ClusterStatusResponseList {
    /**
     * 
     * @type {Array<ClusterStatusResponse>}
     * @memberof ClusterStatusResponseList
     */
    'results'?: Array<ClusterStatusResponse>;
}
/**
 * 
 * @export
 * @interface CommitPaginatedResponseList
 */
export interface CommitPaginatedResponseList {
    /**
     * 
     * @type {Array<CommitResponse>}
     * @memberof CommitPaginatedResponseList
     */
    'results'?: Array<CommitResponse>;
    /**
     * 
     * @type {number}
     * @memberof CommitPaginatedResponseList
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof CommitPaginatedResponseList
     */
    'page_size': number;
}
/**
 * 
 * @export
 * @interface CommitPaginatedResponseListAllOf
 */
export interface CommitPaginatedResponseListAllOf {
    /**
     * 
     * @type {Array<CommitResponse>}
     * @memberof CommitPaginatedResponseListAllOf
     */
    'results'?: Array<CommitResponse>;
}
/**
 * 
 * @export
 * @interface CommitResponse
 */
export interface CommitResponse {
    /**
     * 
     * @type {string}
     * @memberof CommitResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof CommitResponse
     */
    'git_commit_id': string;
    /**
     * 
     * @type {string}
     * @memberof CommitResponse
     */
    'tag': string;
    /**
     * 
     * @type {string}
     * @memberof CommitResponse
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof CommitResponse
     */
    'author_name': string;
    /**
     * 
     * @type {string}
     * @memberof CommitResponse
     */
    'author_avatar_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommitResponse
     */
    'commit_page_url'?: string;
}
/**
 * 
 * @export
 * @interface CommitResponseList
 */
export interface CommitResponseList {
    /**
     * 
     * @type {Array<CommitResponse>}
     * @memberof CommitResponseList
     */
    'results'?: Array<CommitResponse>;
}
/**
 * 
 * @export
 * @interface CommunityUsage
 */
export interface CommunityUsage {
    /**
     * 
     * @type {CommunityUsageResponse}
     * @memberof CommunityUsage
     */
    'community_usage'?: CommunityUsageResponse;
}
/**
 * 
 * @export
 * @interface CommunityUsageResponse
 */
export interface CommunityUsageResponse {
    /**
     * 
     * @type {Array<ProjectCurrentCostResponse>}
     * @memberof CommunityUsageResponse
     */
    'projects'?: Array<ProjectCurrentCostResponse>;
}
/**
 * 
 * @export
 * @interface Cost
 */
export interface Cost {
    /**
     * 
     * @type {number}
     * @memberof Cost
     */
    'total_in_cents': number;
    /**
     * 
     * @type {number}
     * @memberof Cost
     */
    'total': number;
    /**
     * 
     * @type {string}
     * @memberof Cost
     */
    'currency_code': string;
}
/**
 * 
 * @export
 * @interface CostRangeResponse
 */
export interface CostRangeResponse {
    /**
     * 
     * @type {number}
     * @memberof CostRangeResponse
     */
    'min_cost_in_cents'?: number;
    /**
     * 
     * @type {number}
     * @memberof CostRangeResponse
     */
    'min_cost'?: number;
    /**
     * 
     * @type {number}
     * @memberof CostRangeResponse
     */
    'max_cost_in_cents'?: number;
    /**
     * 
     * @type {number}
     * @memberof CostRangeResponse
     */
    'max_cost'?: number;
    /**
     * 
     * @type {string}
     * @memberof CostRangeResponse
     */
    'currency_code': string;
}
/**
 * 
 * @export
 * @interface CostResponse
 */
export interface CostResponse {
    /**
     * 
     * @type {number}
     * @memberof CostResponse
     */
    'total_in_cents': number;
    /**
     * 
     * @type {number}
     * @memberof CostResponse
     */
    'total': number;
    /**
     * 
     * @type {string}
     * @memberof CostResponse
     */
    'currency_code': string;
}
/**
 * 
 * @export
 * @interface CredentialsRequest
 */
export interface CredentialsRequest {
    /**
     * 
     * @type {string}
     * @memberof CredentialsRequest
     */
    'login': string;
    /**
     * 
     * @type {string}
     * @memberof CredentialsRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface CredentialsResponse
 */
export interface CredentialsResponse {
    /**
     * 
     * @type {string}
     * @memberof CredentialsResponse
     */
    'login': string;
    /**
     * 
     * @type {string}
     * @memberof CredentialsResponse
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface CreditCardRequest
 */
export interface CreditCardRequest {
    /**
     * 
     * @type {string}
     * @memberof CreditCardRequest
     */
    'number': string;
    /**
     * 
     * @type {string}
     * @memberof CreditCardRequest
     */
    'cvv': string;
    /**
     * 
     * @type {number}
     * @memberof CreditCardRequest
     */
    'expiry_month': number;
    /**
     * 
     * @type {number}
     * @memberof CreditCardRequest
     */
    'expiry_year': number;
}
/**
 * 
 * @export
 * @interface CreditCardResponse
 */
export interface CreditCardResponse {
    /**
     * 
     * @type {string}
     * @memberof CreditCardResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CreditCardResponse
     */
    'created_at': string;
    /**
     * 
     * @type {number}
     * @memberof CreditCardResponse
     */
    'expiry_month': number;
    /**
     * 
     * @type {number}
     * @memberof CreditCardResponse
     */
    'expiry_year': number;
    /**
     * 
     * @type {string}
     * @memberof CreditCardResponse
     */
    'last_digit': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreditCardResponse
     */
    'is_expired': boolean;
}
/**
 * 
 * @export
 * @interface CreditCardResponseList
 */
export interface CreditCardResponseList {
    /**
     * 
     * @type {Array<CreditCardResponse>}
     * @memberof CreditCardResponseList
     */
    'results'?: Array<CreditCardResponse>;
}
/**
 * 
 * @export
 * @interface CurrentCost
 */
export interface CurrentCost {
    /**
     * 
     * @type {PlanEnum}
     * @memberof CurrentCost
     */
    'plan'?: PlanEnum;
    /**
     * number of days remaining before the end of the trial period
     * @type {number}
     * @memberof CurrentCost
     */
    'remaining_trial_day'?: number;
    /**
     * 
     * @type {RemainingCredits}
     * @memberof CurrentCost
     */
    'remaining_credits'?: RemainingCredits;
    /**
     * 
     * @type {Cost}
     * @memberof CurrentCost
     */
    'cost'?: Cost;
}
/**
 * 
 * @export
 * @interface CustomDomainRequest
 */
export interface CustomDomainRequest {
    /**
     * your custom domain
     * @type {string}
     * @memberof CustomDomainRequest
     */
    'domain': string;
}
/**
 * 
 * @export
 * @interface CustomDomainResponse
 */
export interface CustomDomainResponse {
    /**
     * 
     * @type {string}
     * @memberof CustomDomainResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CustomDomainResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof CustomDomainResponse
     */
    'updated_at'?: string;
    /**
     * your custom domain
     * @type {string}
     * @memberof CustomDomainResponse
     */
    'domain': string;
    /**
     * URL provided by Qovery. You must create a CNAME on your DNS provider using that URL
     * @type {string}
     * @memberof CustomDomainResponse
     */
    'validation_domain'?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomDomainResponse
     */
    'status'?: CustomDomainResponseStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum CustomDomainResponseStatusEnum {
    DEPLOYING = 'deploying',
    CHECKING = 'checking',
    READY = 'ready',
    ERROR = 'error'
}

/**
 * 
 * @export
 * @interface CustomDomainResponseAllOf
 */
export interface CustomDomainResponseAllOf {
    /**
     * URL provided by Qovery. You must create a CNAME on your DNS provider using that URL
     * @type {string}
     * @memberof CustomDomainResponseAllOf
     */
    'validation_domain'?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomDomainResponseAllOf
     */
    'status'?: CustomDomainResponseAllOfStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum CustomDomainResponseAllOfStatusEnum {
    DEPLOYING = 'deploying',
    CHECKING = 'checking',
    READY = 'ready',
    ERROR = 'error'
}

/**
 * 
 * @export
 * @interface CustomDomainResponseList
 */
export interface CustomDomainResponseList {
    /**
     * 
     * @type {Array<CustomDomainResponse>}
     * @memberof CustomDomainResponseList
     */
    'results'?: Array<CustomDomainResponse>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum DatabaseAccessibilityEnum {
    PUBLIC = 'PUBLIC',
    PRIVATE = 'PRIVATE'
}

/**
 * 
 * @export
 * @interface DatabaseConfigurationResponse
 */
export interface DatabaseConfigurationResponse {
    /**
     * 
     * @type {DatabaseTypeEnum}
     * @memberof DatabaseConfigurationResponse
     */
    'database_type'?: DatabaseTypeEnum;
    /**
     * 
     * @type {Array<DatabaseVersionMode>}
     * @memberof DatabaseConfigurationResponse
     */
    'version'?: Array<DatabaseVersionMode>;
}
/**
 * 
 * @export
 * @interface DatabaseConfigurationResponseList
 */
export interface DatabaseConfigurationResponseList {
    /**
     * 
     * @type {Array<DatabaseConfigurationResponse>}
     * @memberof DatabaseConfigurationResponseList
     */
    'results'?: Array<DatabaseConfigurationResponse>;
}
/**
 * 
 * @export
 * @interface DatabaseCurrentMetricResponse
 */
export interface DatabaseCurrentMetricResponse {
    /**
     * 
     * @type {EnvironmentDatabasesCurrentMetricResponseCpu}
     * @memberof DatabaseCurrentMetricResponse
     */
    'cpu'?: EnvironmentDatabasesCurrentMetricResponseCpu;
    /**
     * 
     * @type {EnvironmentDatabasesCurrentMetricResponseMemory}
     * @memberof DatabaseCurrentMetricResponse
     */
    'memory'?: EnvironmentDatabasesCurrentMetricResponseMemory;
    /**
     * 
     * @type {EnvironmentDatabasesCurrentMetricResponseStorage}
     * @memberof DatabaseCurrentMetricResponse
     */
    'storage'?: EnvironmentDatabasesCurrentMetricResponseStorage;
}
/**
 * 
 * @export
 * @interface DatabaseEditRequest
 */
export interface DatabaseEditRequest {
    /**
     * name is case-insensitive
     * @type {string}
     * @memberof DatabaseEditRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DatabaseEditRequest
     */
    'version'?: string;
    /**
     * 
     * @type {DatabaseAccessibilityEnum}
     * @memberof DatabaseEditRequest
     */
    'accessibility'?: DatabaseAccessibilityEnum;
    /**
     * unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof DatabaseEditRequest
     */
    'cpu'?: number;
    /**
     * unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof DatabaseEditRequest
     */
    'memory'?: number;
    /**
     * unit is GB
     * @type {number}
     * @memberof DatabaseEditRequest
     */
    'storage'?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum DatabaseModeEnum {
    MANAGED = 'MANAGED',
    CONTAINER = 'CONTAINER'
}

/**
 * 
 * @export
 * @interface DatabaseRequest
 */
export interface DatabaseRequest {
    /**
     * name is case insensitive
     * @type {string}
     * @memberof DatabaseRequest
     */
    'name': string;
    /**
     * 
     * @type {DatabaseTypeEnum}
     * @memberof DatabaseRequest
     */
    'type': DatabaseTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof DatabaseRequest
     */
    'version': string;
    /**
     * 
     * @type {DatabaseModeEnum}
     * @memberof DatabaseRequest
     */
    'mode': DatabaseModeEnum;
    /**
     * 
     * @type {DatabaseAccessibilityEnum}
     * @memberof DatabaseRequest
     */
    'accessibility'?: DatabaseAccessibilityEnum;
    /**
     * unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof DatabaseRequest
     */
    'cpu'?: number;
    /**
     * unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof DatabaseRequest
     */
    'memory'?: number;
    /**
     * unit is MB
     * @type {number}
     * @memberof DatabaseRequest
     */
    'storage'?: number;
}
/**
 * 
 * @export
 * @interface DatabaseResponse
 */
export interface DatabaseResponse {
    /**
     * 
     * @type {string}
     * @memberof DatabaseResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DatabaseResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof DatabaseResponse
     */
    'updated_at'?: string;
    /**
     * name is case insensitive
     * @type {string}
     * @memberof DatabaseResponse
     */
    'name': string;
    /**
     * 
     * @type {DatabaseTypeEnum}
     * @memberof DatabaseResponse
     */
    'type': DatabaseTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof DatabaseResponse
     */
    'version': string;
    /**
     * 
     * @type {DatabaseModeEnum}
     * @memberof DatabaseResponse
     */
    'mode': DatabaseModeEnum;
    /**
     * 
     * @type {DatabaseAccessibilityEnum}
     * @memberof DatabaseResponse
     */
    'accessibility'?: DatabaseAccessibilityEnum;
    /**
     * unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof DatabaseResponse
     */
    'cpu'?: number;
    /**
     * unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof DatabaseResponse
     */
    'memory'?: number;
    /**
     * unit is MB
     * @type {number}
     * @memberof DatabaseResponse
     */
    'storage'?: number;
    /**
     * 
     * @type {ReferenceObject}
     * @memberof DatabaseResponse
     */
    'environment'?: ReferenceObject;
    /**
     * 
     * @type {string}
     * @memberof DatabaseResponse
     */
    'host'?: string;
    /**
     * 
     * @type {number}
     * @memberof DatabaseResponse
     */
    'port'?: number;
    /**
     * Maximum cpu that can be allocated to the database based on organization cluster configuration. unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof DatabaseResponse
     */
    'maximum_cpu'?: number;
    /**
     * Maximum memory that can be allocated to the database based on organization cluster configuration. unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof DatabaseResponse
     */
    'maximum_memory'?: number;
    /**
     * indicates if the database disk is encrypted or not
     * @type {boolean}
     * @memberof DatabaseResponse
     */
    'disk_encrypted'?: boolean;
}
/**
 * 
 * @export
 * @interface DatabaseResponseAllOf
 */
export interface DatabaseResponseAllOf {
    /**
     * 
     * @type {ReferenceObject}
     * @memberof DatabaseResponseAllOf
     */
    'environment'?: ReferenceObject;
    /**
     * 
     * @type {string}
     * @memberof DatabaseResponseAllOf
     */
    'host'?: string;
    /**
     * 
     * @type {number}
     * @memberof DatabaseResponseAllOf
     */
    'port'?: number;
    /**
     * Maximum cpu that can be allocated to the database based on organization cluster configuration. unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof DatabaseResponseAllOf
     */
    'maximum_cpu'?: number;
    /**
     * Maximum memory that can be allocated to the database based on organization cluster configuration. unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof DatabaseResponseAllOf
     */
    'maximum_memory'?: number;
    /**
     * indicates if the database disk is encrypted or not
     * @type {boolean}
     * @memberof DatabaseResponseAllOf
     */
    'disk_encrypted'?: boolean;
}
/**
 * 
 * @export
 * @interface DatabaseResponseList
 */
export interface DatabaseResponseList {
    /**
     * 
     * @type {Array<DatabaseResponse>}
     * @memberof DatabaseResponseList
     */
    'results'?: Array<DatabaseResponse>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum DatabaseTypeEnum {
    POSTGRESQL = 'POSTGRESQL',
    MYSQL = 'MYSQL',
    MONGODB = 'MONGODB',
    REDIS = 'REDIS'
}

/**
 * 
 * @export
 * @interface DatabaseVersionMode
 */
export interface DatabaseVersionMode {
    /**
     * 
     * @type {string}
     * @memberof DatabaseVersionMode
     */
    'name'?: string;
    /**
     * 
     * @type {DatabaseModeEnum}
     * @memberof DatabaseVersionMode
     */
    'supported_mode'?: DatabaseModeEnum;
}
/**
 * 
 * @export
 * @interface DeployRequest
 */
export interface DeployRequest {
    /**
     * Commit ID to deploy
     * @type {string}
     * @memberof DeployRequest
     */
    'git_commit_id': string;
}
/**
 * 
 * @export
 * @interface DeploymentHistoryApplicationResponse
 */
export interface DeploymentHistoryApplicationResponse {
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryApplicationResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryApplicationResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryApplicationResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryApplicationResponse
     */
    'name'?: string;
    /**
     * 
     * @type {CommitResponse}
     * @memberof DeploymentHistoryApplicationResponse
     */
    'commit'?: CommitResponse;
    /**
     * 
     * @type {GlobalDeploymentStatus}
     * @memberof DeploymentHistoryApplicationResponse
     */
    'status'?: GlobalDeploymentStatus;
}
/**
 * 
 * @export
 * @interface DeploymentHistoryApplicationResponseAllOf
 */
export interface DeploymentHistoryApplicationResponseAllOf {
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryApplicationResponseAllOf
     */
    'name'?: string;
    /**
     * 
     * @type {CommitResponse}
     * @memberof DeploymentHistoryApplicationResponseAllOf
     */
    'commit'?: CommitResponse;
    /**
     * 
     * @type {GlobalDeploymentStatus}
     * @memberof DeploymentHistoryApplicationResponseAllOf
     */
    'status'?: GlobalDeploymentStatus;
}
/**
 * 
 * @export
 * @interface DeploymentHistoryDatabaseResponse
 */
export interface DeploymentHistoryDatabaseResponse {
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryDatabaseResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryDatabaseResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryDatabaseResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryDatabaseResponse
     */
    'name'?: string;
    /**
     * 
     * @type {GlobalDeploymentStatus}
     * @memberof DeploymentHistoryDatabaseResponse
     */
    'status'?: GlobalDeploymentStatus;
}
/**
 * 
 * @export
 * @interface DeploymentHistoryDatabaseResponseAllOf
 */
export interface DeploymentHistoryDatabaseResponseAllOf {
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryDatabaseResponseAllOf
     */
    'name'?: string;
    /**
     * 
     * @type {GlobalDeploymentStatus}
     * @memberof DeploymentHistoryDatabaseResponseAllOf
     */
    'status'?: GlobalDeploymentStatus;
}
/**
 * 
 * @export
 * @interface DeploymentHistoryEnvironmentPaginatedResponseList
 */
export interface DeploymentHistoryEnvironmentPaginatedResponseList {
    /**
     * 
     * @type {number}
     * @memberof DeploymentHistoryEnvironmentPaginatedResponseList
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof DeploymentHistoryEnvironmentPaginatedResponseList
     */
    'page_size': number;
    /**
     * 
     * @type {Array<DeploymentHistoryEnvironmentResponse>}
     * @memberof DeploymentHistoryEnvironmentPaginatedResponseList
     */
    'results'?: Array<DeploymentHistoryEnvironmentResponse>;
}
/**
 * 
 * @export
 * @interface DeploymentHistoryEnvironmentPaginatedResponseListAllOf
 */
export interface DeploymentHistoryEnvironmentPaginatedResponseListAllOf {
    /**
     * 
     * @type {Array<DeploymentHistoryEnvironmentResponse>}
     * @memberof DeploymentHistoryEnvironmentPaginatedResponseListAllOf
     */
    'results'?: Array<DeploymentHistoryEnvironmentResponse>;
}
/**
 * 
 * @export
 * @interface DeploymentHistoryEnvironmentResponse
 */
export interface DeploymentHistoryEnvironmentResponse {
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryEnvironmentResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryEnvironmentResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryEnvironmentResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {GlobalDeploymentStatus}
     * @memberof DeploymentHistoryEnvironmentResponse
     */
    'status'?: GlobalDeploymentStatus;
    /**
     * 
     * @type {Array<DeploymentHistoryApplicationResponse>}
     * @memberof DeploymentHistoryEnvironmentResponse
     */
    'applications'?: Array<DeploymentHistoryApplicationResponse>;
    /**
     * 
     * @type {Array<DeploymentHistoryDatabaseResponse>}
     * @memberof DeploymentHistoryEnvironmentResponse
     */
    'databases'?: Array<DeploymentHistoryDatabaseResponse>;
}
/**
 * 
 * @export
 * @interface DeploymentHistoryEnvironmentResponseAllOf
 */
export interface DeploymentHistoryEnvironmentResponseAllOf {
    /**
     * 
     * @type {GlobalDeploymentStatus}
     * @memberof DeploymentHistoryEnvironmentResponseAllOf
     */
    'status'?: GlobalDeploymentStatus;
    /**
     * 
     * @type {Array<DeploymentHistoryApplicationResponse>}
     * @memberof DeploymentHistoryEnvironmentResponseAllOf
     */
    'applications'?: Array<DeploymentHistoryApplicationResponse>;
    /**
     * 
     * @type {Array<DeploymentHistoryDatabaseResponse>}
     * @memberof DeploymentHistoryEnvironmentResponseAllOf
     */
    'databases'?: Array<DeploymentHistoryDatabaseResponse>;
}
/**
 * 
 * @export
 * @interface DeploymentHistoryPaginatedResponseList
 */
export interface DeploymentHistoryPaginatedResponseList {
    /**
     * 
     * @type {number}
     * @memberof DeploymentHistoryPaginatedResponseList
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof DeploymentHistoryPaginatedResponseList
     */
    'page_size': number;
    /**
     * 
     * @type {Array<DeploymentHistoryResponse>}
     * @memberof DeploymentHistoryPaginatedResponseList
     */
    'results'?: Array<DeploymentHistoryResponse>;
}
/**
 * 
 * @export
 * @interface DeploymentHistoryPaginatedResponseListAllOf
 */
export interface DeploymentHistoryPaginatedResponseListAllOf {
    /**
     * 
     * @type {Array<DeploymentHistoryResponse>}
     * @memberof DeploymentHistoryPaginatedResponseListAllOf
     */
    'results'?: Array<DeploymentHistoryResponse>;
}
/**
 * 
 * @export
 * @interface DeploymentHistoryResponse
 */
export interface DeploymentHistoryResponse {
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {CommitResponse}
     * @memberof DeploymentHistoryResponse
     */
    'commit'?: CommitResponse;
    /**
     * 
     * @type {DeploymentHistoryStatusEnum}
     * @memberof DeploymentHistoryResponse
     */
    'status'?: DeploymentHistoryStatusEnum;
}
/**
 * 
 * @export
 * @interface DeploymentHistoryResponseAllOf
 */
export interface DeploymentHistoryResponseAllOf {
    /**
     * 
     * @type {CommitResponse}
     * @memberof DeploymentHistoryResponseAllOf
     */
    'commit'?: CommitResponse;
    /**
     * 
     * @type {DeploymentHistoryStatusEnum}
     * @memberof DeploymentHistoryResponseAllOf
     */
    'status'?: DeploymentHistoryStatusEnum;
}
/**
 * 
 * @export
 * @interface DeploymentHistoryResponseList
 */
export interface DeploymentHistoryResponseList {
    /**
     * 
     * @type {Array<DeploymentHistoryResponse>}
     * @memberof DeploymentHistoryResponseList
     */
    'results'?: Array<DeploymentHistoryResponse>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum DeploymentHistoryStatusEnum {
    SUCCESS = 'SUCCESS',
    FAILED = 'FAILED'
}

/**
 * Match mode will rebuild app only if specified items are updated. Exclude mode will not rebuild app if specified items are updated.
 * @export
 * @enum {string}
 */

export enum DeploymentRestrictionModeEnum {
    MATCH = 'MATCH',
    EXCLUDE = 'EXCLUDE'
}

/**
 * 
 * @export
 * @enum {string}
 */

export enum DeploymentRestrictionTypeEnum {
    FILE = 'FILE',
    PATH = 'PATH'
}

/**
 * 
 * @export
 * @interface DeploymentRuleRequest
 */
export interface DeploymentRuleRequest {
    /**
     * name is case insensitive
     * @type {string}
     * @memberof DeploymentRuleRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentRuleRequest
     */
    'description'?: string;
    /**
     * 
     * @type {EnvironmentModeEnum}
     * @memberof DeploymentRuleRequest
     */
    'mode': EnvironmentModeEnum;
    /**
     * 
     * @type {string}
     * @memberof DeploymentRuleRequest
     */
    'cluster': string;
    /**
     * 
     * @type {boolean}
     * @memberof DeploymentRuleRequest
     */
    'auto_deploy'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeploymentRuleRequest
     */
    'auto_stop': boolean;
    /**
     * specify value only if auto_stop = false
     * @type {string}
     * @memberof DeploymentRuleRequest
     */
    'timezone'?: string;
    /**
     * specify value only if auto_stop = false
     * @type {string}
     * @memberof DeploymentRuleRequest
     */
    'start_time'?: string | null;
    /**
     * specify value only if auto_stop = false
     * @type {string}
     * @memberof DeploymentRuleRequest
     */
    'stop_time'?: string | null;
    /**
     * specify value only if auto_stop = false
     * @type {Array<WeekdayEnum>}
     * @memberof DeploymentRuleRequest
     */
    'weekdays'?: Array<WeekdayEnum> | null;
}
/**
 * 
 * @export
 * @interface DoCredentialsRequest
 */
export interface DoCredentialsRequest {
    /**
     * 
     * @type {string}
     * @memberof DoCredentialsRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof DoCredentialsRequest
     */
    'token'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoCredentialsRequest
     */
    'spaces_access_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoCredentialsRequest
     */
    'spaces_secret_key'?: string;
}
/**
 * 
 * @export
 * @interface EnvironmentApplicationsCurrentScaleResponse
 */
export interface EnvironmentApplicationsCurrentScaleResponse {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentApplicationsCurrentScaleResponse
     */
    'application'?: string;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentApplicationsCurrentScaleResponse
     */
    'min'?: number;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentApplicationsCurrentScaleResponse
     */
    'max'?: number;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentApplicationsCurrentScaleResponse
     */
    'running'?: number;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentApplicationsCurrentScaleResponse
     */
    'running_in_percent'?: number;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentApplicationsCurrentScaleResponse
     */
    'warning_threshold_in_percent'?: number;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentApplicationsCurrentScaleResponse
     */
    'alert_threshold_in_percent'?: number;
    /**
     * 
     * @type {ThresholdMetricStatusEnum}
     * @memberof EnvironmentApplicationsCurrentScaleResponse
     */
    'status'?: ThresholdMetricStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentApplicationsCurrentScaleResponse
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface EnvironmentApplicationsCurrentScaleResponseList
 */
export interface EnvironmentApplicationsCurrentScaleResponseList {
    /**
     * 
     * @type {Array<EnvironmentApplicationsCurrentScaleResponse>}
     * @memberof EnvironmentApplicationsCurrentScaleResponseList
     */
    'results'?: Array<EnvironmentApplicationsCurrentScaleResponse>;
}
/**
 * 
 * @export
 * @interface EnvironmentApplicationsInstanceResponseList
 */
export interface EnvironmentApplicationsInstanceResponseList {
    /**
     * 
     * @type {Array<EnvironmentApplicationsInstanceResponseListResults>}
     * @memberof EnvironmentApplicationsInstanceResponseList
     */
    'results'?: Array<EnvironmentApplicationsInstanceResponseListResults>;
}
/**
 * 
 * @export
 * @interface EnvironmentApplicationsInstanceResponseListResults
 */
export interface EnvironmentApplicationsInstanceResponseListResults {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentApplicationsInstanceResponseListResults
     */
    'application': string;
    /**
     * 
     * @type {Array<InstanceResponse>}
     * @memberof EnvironmentApplicationsInstanceResponseListResults
     */
    'instances': Array<InstanceResponse>;
}
/**
 * 
 * @export
 * @interface EnvironmentApplicationsStorageResponse
 */
export interface EnvironmentApplicationsStorageResponse {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentApplicationsStorageResponse
     */
    'application': string;
    /**
     * 
     * @type {Array<StorageDiskResponse>}
     * @memberof EnvironmentApplicationsStorageResponse
     */
    'disks'?: Array<StorageDiskResponse>;
}
/**
 * 
 * @export
 * @interface EnvironmentApplicationsStorageResponseList
 */
export interface EnvironmentApplicationsStorageResponseList {
    /**
     * 
     * @type {Array<EnvironmentApplicationsStorageResponse>}
     * @memberof EnvironmentApplicationsStorageResponseList
     */
    'results'?: Array<EnvironmentApplicationsStorageResponse>;
}
/**
 * 
 * @export
 * @interface EnvironmentApplicationsSupportedLanguage
 */
export interface EnvironmentApplicationsSupportedLanguage {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentApplicationsSupportedLanguage
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface EnvironmentApplicationsSupportedLanguageList
 */
export interface EnvironmentApplicationsSupportedLanguageList {
    /**
     * 
     * @type {Array<EnvironmentApplicationsSupportedLanguage>}
     * @memberof EnvironmentApplicationsSupportedLanguageList
     */
    'results'?: Array<EnvironmentApplicationsSupportedLanguage>;
}
/**
 * 
 * @export
 * @interface EnvironmentDatabasesCurrentMetricResponse
 */
export interface EnvironmentDatabasesCurrentMetricResponse {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentDatabasesCurrentMetricResponse
     */
    'database'?: string;
    /**
     * 
     * @type {EnvironmentDatabasesCurrentMetricResponseCpu}
     * @memberof EnvironmentDatabasesCurrentMetricResponse
     */
    'cpu'?: EnvironmentDatabasesCurrentMetricResponseCpu;
    /**
     * 
     * @type {EnvironmentDatabasesCurrentMetricResponseMemory}
     * @memberof EnvironmentDatabasesCurrentMetricResponse
     */
    'memory'?: EnvironmentDatabasesCurrentMetricResponseMemory;
    /**
     * 
     * @type {EnvironmentDatabasesCurrentMetricResponseStorage}
     * @memberof EnvironmentDatabasesCurrentMetricResponse
     */
    'storage'?: EnvironmentDatabasesCurrentMetricResponseStorage;
}
/**
 * 
 * @export
 * @interface EnvironmentDatabasesCurrentMetricResponseCpu
 */
export interface EnvironmentDatabasesCurrentMetricResponseCpu {
    /**
     * 
     * @type {number}
     * @memberof EnvironmentDatabasesCurrentMetricResponseCpu
     */
    'requested_in_float'?: number;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentDatabasesCurrentMetricResponseCpu
     */
    'consumed_in_number'?: number;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentDatabasesCurrentMetricResponseCpu
     */
    'consumed_in_percent'?: number;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentDatabasesCurrentMetricResponseCpu
     */
    'warning_threshold_in_percent'?: number;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentDatabasesCurrentMetricResponseCpu
     */
    'alert_threshold_in_percent'?: number;
    /**
     * 
     * @type {ThresholdMetricStatusEnum}
     * @memberof EnvironmentDatabasesCurrentMetricResponseCpu
     */
    'status'?: ThresholdMetricStatusEnum;
}
/**
 * 
 * @export
 * @interface EnvironmentDatabasesCurrentMetricResponseList
 */
export interface EnvironmentDatabasesCurrentMetricResponseList {
    /**
     * 
     * @type {Array<EnvironmentDatabasesCurrentMetricResponse>}
     * @memberof EnvironmentDatabasesCurrentMetricResponseList
     */
    'results'?: Array<EnvironmentDatabasesCurrentMetricResponse>;
}
/**
 * 
 * @export
 * @interface EnvironmentDatabasesCurrentMetricResponseMemory
 */
export interface EnvironmentDatabasesCurrentMetricResponseMemory {
    /**
     * 
     * @type {number}
     * @memberof EnvironmentDatabasesCurrentMetricResponseMemory
     */
    'requested_in_mb'?: number;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentDatabasesCurrentMetricResponseMemory
     */
    'consumed_in_mb'?: number;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentDatabasesCurrentMetricResponseMemory
     */
    'consumed_in_percent'?: number;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentDatabasesCurrentMetricResponseMemory
     */
    'warning_threshold_in_percent'?: number;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentDatabasesCurrentMetricResponseMemory
     */
    'alert_threshold_in_percent'?: number;
    /**
     * 
     * @type {ThresholdMetricStatusEnum}
     * @memberof EnvironmentDatabasesCurrentMetricResponseMemory
     */
    'status'?: ThresholdMetricStatusEnum;
}
/**
 * 
 * @export
 * @interface EnvironmentDatabasesCurrentMetricResponseStorage
 */
export interface EnvironmentDatabasesCurrentMetricResponseStorage {
    /**
     * 
     * @type {number}
     * @memberof EnvironmentDatabasesCurrentMetricResponseStorage
     */
    'requested_in_gb'?: number;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentDatabasesCurrentMetricResponseStorage
     */
    'consumed_in_gb'?: number;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentDatabasesCurrentMetricResponseStorage
     */
    'consumed_in_percent'?: number;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentDatabasesCurrentMetricResponseStorage
     */
    'warning_threshold_in_percent'?: number;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentDatabasesCurrentMetricResponseStorage
     */
    'alert_threshold_in_percent'?: number;
    /**
     * 
     * @type {ThresholdMetricStatusEnum}
     * @memberof EnvironmentDatabasesCurrentMetricResponseStorage
     */
    'status'?: ThresholdMetricStatusEnum;
}
/**
 * 
 * @export
 * @interface EnvironmentDeploymentRuleEditRequest
 */
export interface EnvironmentDeploymentRuleEditRequest {
    /**
     * 
     * @type {boolean}
     * @memberof EnvironmentDeploymentRuleEditRequest
     */
    'auto_deploy'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EnvironmentDeploymentRuleEditRequest
     */
    'auto_delete'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EnvironmentDeploymentRuleEditRequest
     */
    'auto_stop'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentDeploymentRuleEditRequest
     */
    'timezone': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentDeploymentRuleEditRequest
     */
    'start_time': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentDeploymentRuleEditRequest
     */
    'stop_time': string;
    /**
     * 
     * @type {Array<WeekdayEnum>}
     * @memberof EnvironmentDeploymentRuleEditRequest
     */
    'weekdays': Array<WeekdayEnum>;
}
/**
 * 
 * @export
 * @interface EnvironmentDeploymentRuleResponse
 */
export interface EnvironmentDeploymentRuleResponse {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentDeploymentRuleResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentDeploymentRuleResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentDeploymentRuleResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EnvironmentDeploymentRuleResponse
     */
    'auto_deploy'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EnvironmentDeploymentRuleResponse
     */
    'auto_stop'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EnvironmentDeploymentRuleResponse
     */
    'auto_delete'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EnvironmentDeploymentRuleResponse
     */
    'auto_preview'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentDeploymentRuleResponse
     */
    'timezone': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentDeploymentRuleResponse
     */
    'start_time': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentDeploymentRuleResponse
     */
    'stop_time': string;
    /**
     * 
     * @type {Array<WeekdayEnum>}
     * @memberof EnvironmentDeploymentRuleResponse
     */
    'weekdays': Array<WeekdayEnum>;
}
/**
 * 
 * @export
 * @interface EnvironmentDeploymentRuleResponseAllOf
 */
export interface EnvironmentDeploymentRuleResponseAllOf {
    /**
     * 
     * @type {boolean}
     * @memberof EnvironmentDeploymentRuleResponseAllOf
     */
    'auto_deploy'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EnvironmentDeploymentRuleResponseAllOf
     */
    'auto_stop'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EnvironmentDeploymentRuleResponseAllOf
     */
    'auto_delete'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EnvironmentDeploymentRuleResponseAllOf
     */
    'auto_preview'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentDeploymentRuleResponseAllOf
     */
    'timezone': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentDeploymentRuleResponseAllOf
     */
    'start_time': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentDeploymentRuleResponseAllOf
     */
    'stop_time': string;
    /**
     * 
     * @type {Array<WeekdayEnum>}
     * @memberof EnvironmentDeploymentRuleResponseAllOf
     */
    'weekdays': Array<WeekdayEnum>;
}
/**
 * 
 * @export
 * @interface EnvironmentEditRequest
 */
export interface EnvironmentEditRequest {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentEditRequest
     */
    'name'?: string;
    /**
     * 
     * @type {EnvironmentModeEnum}
     * @memberof EnvironmentEditRequest
     */
    'mode'?: EnvironmentModeEnum;
}
/**
 * 
 * @export
 * @interface EnvironmentEnvironmentIdApplicationDeployApplications
 */
export interface EnvironmentEnvironmentIdApplicationDeployApplications {
    /**
     * id of the application to be deployed.
     * @type {string}
     * @memberof EnvironmentEnvironmentIdApplicationDeployApplications
     */
    'application_id': string;
    /**
     * Commit ID to deploy.
     * @type {string}
     * @memberof EnvironmentEnvironmentIdApplicationDeployApplications
     */
    'git_commit_id': string;
}
/**
 * 
 * @export
 * @interface EnvironmentLogPaginatedResponseList
 */
export interface EnvironmentLogPaginatedResponseList {
    /**
     * 
     * @type {number}
     * @memberof EnvironmentLogPaginatedResponseList
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentLogPaginatedResponseList
     */
    'page_size': number;
    /**
     * 
     * @type {Array<EnvironmentLogResponse>}
     * @memberof EnvironmentLogPaginatedResponseList
     */
    'results'?: Array<EnvironmentLogResponse>;
}
/**
 * 
 * @export
 * @interface EnvironmentLogPaginatedResponseListAllOf
 */
export interface EnvironmentLogPaginatedResponseListAllOf {
    /**
     * 
     * @type {Array<EnvironmentLogResponse>}
     * @memberof EnvironmentLogPaginatedResponseListAllOf
     */
    'results'?: Array<EnvironmentLogResponse>;
}
/**
 * 
 * @export
 * @interface EnvironmentLogResponse
 */
export interface EnvironmentLogResponse {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogResponse
     */
    'created_at': string;
    /**
     * 
     * @type {EnvironmentLogResponseScope}
     * @memberof EnvironmentLogResponse
     */
    'scope'?: EnvironmentLogResponseScope;
    /**
     * 
     * @type {GlobalDeploymentStatus}
     * @memberof EnvironmentLogResponse
     */
    'state'?: GlobalDeploymentStatus;
    /**
     * Log message
     * @type {string}
     * @memberof EnvironmentLogResponse
     */
    'message': string | null;
    /**
     * Only for errors. Helps Qovery team to investigate.
     * @type {string}
     * @memberof EnvironmentLogResponse
     */
    'execution_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogResponse
     */
    'hint'?: string;
}
/**
 * 
 * @export
 * @interface EnvironmentLogResponseList
 */
export interface EnvironmentLogResponseList {
    /**
     * 
     * @type {Array<EnvironmentLogResponse>}
     * @memberof EnvironmentLogResponseList
     */
    'results'?: Array<EnvironmentLogResponse>;
}
/**
 * 
 * @export
 * @interface EnvironmentLogResponseScope
 */
export interface EnvironmentLogResponseScope {
    /**
     * 
     * @type {EnvironmentLogTypeEnum}
     * @memberof EnvironmentLogResponseScope
     */
    'type'?: EnvironmentLogTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogResponseScope
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogResponseScope
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum EnvironmentLogTypeEnum {
    APPLICATION = 'APPLICATION',
    DATABASE = 'DATABASE',
    ENVIRONMENT = 'ENVIRONMENT'
}

/**
 * 
 * @export
 * @enum {string}
 */

export enum EnvironmentModeEnum {
    PRODUCTION = 'PRODUCTION',
    DEVELOPMENT = 'DEVELOPMENT',
    STAGING = 'STAGING',
    PREVIEW = 'PREVIEW'
}

/**
 * 
 * @export
 * @interface EnvironmentRequest
 */
export interface EnvironmentRequest {
    /**
     * name is case insensitive
     * @type {string}
     * @memberof EnvironmentRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentRequest
     */
    'cluster'?: string;
    /**
     * 
     * @type {EnvironmentModeEnum}
     * @memberof EnvironmentRequest
     */
    'mode'?: EnvironmentModeEnum;
}
/**
 * 
 * @export
 * @interface EnvironmentResponse
 */
export interface EnvironmentResponse {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentResponse
     */
    'updated_at'?: string;
    /**
     * name is case insensitive
     * @type {string}
     * @memberof EnvironmentResponse
     */
    'name': string;
    /**
     * 
     * @type {ReferenceObject}
     * @memberof EnvironmentResponse
     */
    'project'?: ReferenceObject;
    /**
     * uuid of the user that made the last update
     * @type {string}
     * @memberof EnvironmentResponse
     */
    'last_updated_by'?: string;
    /**
     * 
     * @type {EnvironmentResponseAllOfCloudProvider}
     * @memberof EnvironmentResponse
     */
    'cloud_provider': EnvironmentResponseAllOfCloudProvider;
    /**
     * 
     * @type {EnvironmentModeEnum}
     * @memberof EnvironmentResponse
     */
    'mode': EnvironmentModeEnum;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentResponse
     */
    'cluster_id': string;
}
/**
 * 
 * @export
 * @interface EnvironmentResponseAllOf
 */
export interface EnvironmentResponseAllOf {
    /**
     * name is case insensitive
     * @type {string}
     * @memberof EnvironmentResponseAllOf
     */
    'name': string;
    /**
     * 
     * @type {ReferenceObject}
     * @memberof EnvironmentResponseAllOf
     */
    'project'?: ReferenceObject;
    /**
     * uuid of the user that made the last update
     * @type {string}
     * @memberof EnvironmentResponseAllOf
     */
    'last_updated_by'?: string;
    /**
     * 
     * @type {EnvironmentResponseAllOfCloudProvider}
     * @memberof EnvironmentResponseAllOf
     */
    'cloud_provider': EnvironmentResponseAllOfCloudProvider;
    /**
     * 
     * @type {EnvironmentModeEnum}
     * @memberof EnvironmentResponseAllOf
     */
    'mode': EnvironmentModeEnum;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentResponseAllOf
     */
    'cluster_id': string;
}
/**
 * 
 * @export
 * @interface EnvironmentResponseAllOfCloudProvider
 */
export interface EnvironmentResponseAllOfCloudProvider {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentResponseAllOfCloudProvider
     */
    'provider'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentResponseAllOfCloudProvider
     */
    'cluster'?: string;
}
/**
 * 
 * @export
 * @interface EnvironmentResponseList
 */
export interface EnvironmentResponseList {
    /**
     * 
     * @type {Array<EnvironmentResponse>}
     * @memberof EnvironmentResponseList
     */
    'results'?: Array<EnvironmentResponse>;
}
/**
 * 
 * @export
 * @interface EnvironmentRestartRequest
 */
export interface EnvironmentRestartRequest {
    /**
     * 
     * @type {boolean}
     * @memberof EnvironmentRestartRequest
     */
    'restart_db'?: boolean;
}
/**
 * 
 * @export
 * @interface EnvironmentStatsResponse
 */
export interface EnvironmentStatsResponse {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentStatsResponse
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentStatsResponse
     */
    'service_total_number'?: number;
}
/**
 * 
 * @export
 * @interface EnvironmentStatsResponseList
 */
export interface EnvironmentStatsResponseList {
    /**
     * 
     * @type {Array<EnvironmentStatsResponse>}
     * @memberof EnvironmentStatsResponseList
     */
    'results'?: Array<EnvironmentStatsResponse>;
}
/**
 * 
 * @export
 * @interface EnvironmentTotalNumber
 */
export interface EnvironmentTotalNumber {
    /**
     * 
     * @type {number}
     * @memberof EnvironmentTotalNumber
     */
    'environment_total_number'?: number;
}
/**
 * 
 * @export
 * @interface EnvironmentVariableEditRequest
 */
export interface EnvironmentVariableEditRequest {
    /**
     * key is case sensitive
     * @type {string}
     * @memberof EnvironmentVariableEditRequest
     */
    'key': string;
    /**
     * value of the env variable.
     * @type {string}
     * @memberof EnvironmentVariableEditRequest
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface EnvironmentVariableRequest
 */
export interface EnvironmentVariableRequest {
    /**
     * key is case sensitive
     * @type {string}
     * @memberof EnvironmentVariableRequest
     */
    'key': string;
    /**
     * value of the env variable.
     * @type {string}
     * @memberof EnvironmentVariableRequest
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface EnvironmentVariableResponse
 */
export interface EnvironmentVariableResponse {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentVariableResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentVariableResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentVariableResponse
     */
    'updated_at'?: string;
    /**
     * key is case sensitive
     * @type {string}
     * @memberof EnvironmentVariableResponse
     */
    'key': string;
    /**
     * value of the env variable.
     * @type {string}
     * @memberof EnvironmentVariableResponse
     */
    'value': string;
    /**
     * 
     * @type {EnvironmentVariableResponseAllOfOverriddenVariable}
     * @memberof EnvironmentVariableResponse
     */
    'overridden_variable'?: EnvironmentVariableResponseAllOfOverriddenVariable;
    /**
     * 
     * @type {EnvironmentVariableResponseAllOfAliasedVariable}
     * @memberof EnvironmentVariableResponse
     */
    'aliased_variable'?: EnvironmentVariableResponseAllOfAliasedVariable;
    /**
     * 
     * @type {EnvironmentVariableScopeEnum}
     * @memberof EnvironmentVariableResponse
     */
    'scope': EnvironmentVariableScopeEnum;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentVariableResponse
     */
    'service_name'?: string;
}
/**
 * 
 * @export
 * @interface EnvironmentVariableResponseAllOf
 */
export interface EnvironmentVariableResponseAllOf {
    /**
     * 
     * @type {EnvironmentVariableResponseAllOfOverriddenVariable}
     * @memberof EnvironmentVariableResponseAllOf
     */
    'overridden_variable'?: EnvironmentVariableResponseAllOfOverriddenVariable;
    /**
     * 
     * @type {EnvironmentVariableResponseAllOfAliasedVariable}
     * @memberof EnvironmentVariableResponseAllOf
     */
    'aliased_variable'?: EnvironmentVariableResponseAllOfAliasedVariable;
    /**
     * 
     * @type {EnvironmentVariableScopeEnum}
     * @memberof EnvironmentVariableResponseAllOf
     */
    'scope': EnvironmentVariableScopeEnum;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentVariableResponseAllOf
     */
    'service_name'?: string;
}
/**
 * 
 * @export
 * @interface EnvironmentVariableResponseAllOfAliasedVariable
 */
export interface EnvironmentVariableResponseAllOfAliasedVariable {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentVariableResponseAllOfAliasedVariable
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentVariableResponseAllOfAliasedVariable
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentVariableResponseAllOfAliasedVariable
     */
    'value'?: string;
    /**
     * 
     * @type {EnvironmentVariableScopeEnum}
     * @memberof EnvironmentVariableResponseAllOfAliasedVariable
     */
    'scope'?: EnvironmentVariableScopeEnum;
}
/**
 * 
 * @export
 * @interface EnvironmentVariableResponseAllOfOverriddenVariable
 */
export interface EnvironmentVariableResponseAllOfOverriddenVariable {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentVariableResponseAllOfOverriddenVariable
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentVariableResponseAllOfOverriddenVariable
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentVariableResponseAllOfOverriddenVariable
     */
    'value'?: string;
    /**
     * 
     * @type {EnvironmentVariableScopeEnum}
     * @memberof EnvironmentVariableResponseAllOfOverriddenVariable
     */
    'scope'?: EnvironmentVariableScopeEnum;
}
/**
 * 
 * @export
 * @interface EnvironmentVariableResponseList
 */
export interface EnvironmentVariableResponseList {
    /**
     * 
     * @type {Array<EnvironmentVariableResponse>}
     * @memberof EnvironmentVariableResponseList
     */
    'results'?: Array<EnvironmentVariableResponse>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum EnvironmentVariableScopeEnum {
    BUILT_IN = 'BUILT_IN',
    ENVIRONMENT = 'ENVIRONMENT',
    PROJECT = 'PROJECT',
    APPLICATION = 'APPLICATION'
}

/**
 * 
 * @export
 * @interface EventPaginatedResponseList
 */
export interface EventPaginatedResponseList {
    /**
     * 
     * @type {number}
     * @memberof EventPaginatedResponseList
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof EventPaginatedResponseList
     */
    'page_size': number;
    /**
     * 
     * @type {Array<EventResponse>}
     * @memberof EventPaginatedResponseList
     */
    'results'?: Array<EventResponse>;
}
/**
 * 
 * @export
 * @interface EventPaginatedResponseListAllOf
 */
export interface EventPaginatedResponseListAllOf {
    /**
     * 
     * @type {Array<EventResponse>}
     * @memberof EventPaginatedResponseListAllOf
     */
    'results'?: Array<EventResponse>;
}
/**
 * 
 * @export
 * @interface EventResponse
 */
export interface EventResponse {
    /**
     * 
     * @type {string}
     * @memberof EventResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EventResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof EventResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {UserResponse}
     * @memberof EventResponse
     */
    'user'?: UserResponse;
    /**
     * 
     * @type {CommitResponse}
     * @memberof EventResponse
     */
    'commit'?: CommitResponse;
    /**
     * 
     * @type {Status}
     * @memberof EventResponse
     */
    'status'?: Status;
    /**
     * DRAFT - we have to specify here all the possible events
     * @type {string}
     * @memberof EventResponse
     */
    'type'?: string;
    /**
     * 
     * @type {ReferenceObject}
     * @memberof EventResponse
     */
    'log'?: ReferenceObject;
}
/**
 * 
 * @export
 * @interface EventResponseAllOf
 */
export interface EventResponseAllOf {
    /**
     * 
     * @type {UserResponse}
     * @memberof EventResponseAllOf
     */
    'user'?: UserResponse;
    /**
     * 
     * @type {CommitResponse}
     * @memberof EventResponseAllOf
     */
    'commit'?: CommitResponse;
    /**
     * 
     * @type {Status}
     * @memberof EventResponseAllOf
     */
    'status'?: Status;
    /**
     * DRAFT - we have to specify here all the possible events
     * @type {string}
     * @memberof EventResponseAllOf
     */
    'type'?: string;
    /**
     * 
     * @type {ReferenceObject}
     * @memberof EventResponseAllOf
     */
    'log'?: ReferenceObject;
}
/**
 * 
 * @export
 * @interface EventResponseList
 */
export interface EventResponseList {
    /**
     * 
     * @type {Array<EventResponse>}
     * @memberof EventResponseList
     */
    'results'?: Array<EventResponse>;
}
/**
 * 
 * @export
 * @interface GenericObjectCurrentCostResponse
 */
export interface GenericObjectCurrentCostResponse {
    /**
     * 
     * @type {string}
     * @memberof GenericObjectCurrentCostResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GenericObjectCurrentCostResponse
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof GenericObjectCurrentCostResponse
     */
    'consumed_time_in_seconds': number;
    /**
     * 
     * @type {CostResponse}
     * @memberof GenericObjectCurrentCostResponse
     */
    'cost': CostResponse;
}
/**
 * 
 * @export
 * @interface GitAuthProviderResponse
 */
export interface GitAuthProviderResponse {
    /**
     * 
     * @type {string}
     * @memberof GitAuthProviderResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GitAuthProviderResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GitAuthProviderResponse
     */
    'owner': string;
}
/**
 * 
 * @export
 * @interface GitAuthProviderResponseList
 */
export interface GitAuthProviderResponseList {
    /**
     * 
     * @type {Array<GitAuthProviderResponse>}
     * @memberof GitAuthProviderResponseList
     */
    'results'?: Array<GitAuthProviderResponse>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum GitProviderEnum {
    GITHUB = 'GITHUB',
    GITLAB = 'GITLAB'
}

/**
 * 
 * @export
 * @interface GitRepositoryBranchResponse
 */
export interface GitRepositoryBranchResponse {
    /**
     * 
     * @type {string}
     * @memberof GitRepositoryBranchResponse
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface GitRepositoryBranchResponseList
 */
export interface GitRepositoryBranchResponseList {
    /**
     * 
     * @type {Array<GitRepositoryBranchResponse>}
     * @memberof GitRepositoryBranchResponseList
     */
    'results'?: Array<GitRepositoryBranchResponse>;
}
/**
 * 
 * @export
 * @interface GitRepositoryResponse
 */
export interface GitRepositoryResponse {
    /**
     * 
     * @type {string}
     * @memberof GitRepositoryResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GitRepositoryResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GitRepositoryResponse
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof GitRepositoryResponse
     */
    'default_branch'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GitRepositoryResponse
     */
    'is_private'?: boolean;
}
/**
 * 
 * @export
 * @interface GitRepositoryResponseList
 */
export interface GitRepositoryResponseList {
    /**
     * 
     * @type {Array<GitRepositoryResponse>}
     * @memberof GitRepositoryResponseList
     */
    'results'?: Array<GitRepositoryResponse>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum GlobalDeploymentStatus {
    READY = 'READY',
    QUEUED = 'QUEUED',
    STOP_QUEUED = 'STOP_QUEUED',
    DELETE_QUEUED = 'DELETE_QUEUED',
    BUILDING = 'BUILDING',
    BUILD_ERROR = 'BUILD_ERROR',
    BUILT = 'BUILT',
    DEPLOYING = 'DEPLOYING',
    DEPLOYMENT_ERROR = 'DEPLOYMENT_ERROR',
    DEPLOYED = 'DEPLOYED',
    STOPPING = 'STOPPING',
    STOP_ERROR = 'STOP_ERROR',
    STOPPED = 'STOPPED',
    DELETING = 'DELETING',
    DELETE_ERROR = 'DELETE_ERROR',
    DELETED = 'DELETED',
    RUNNING = 'RUNNING',
    RUNNING_ERROR = 'RUNNING_ERROR'
}

/**
 * 
 * @export
 * @interface Healthcheck
 */
export interface Healthcheck {
    /**
     * 
     * @type {string}
     * @memberof Healthcheck
     */
    'protocol'?: HealthcheckProtocolEnum;
    /**
     * 
     * @type {string}
     * @memberof Healthcheck
     */
    'value'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum HealthcheckProtocolEnum {
    TCP = 'TCP',
    HTTP = 'HTTP',
    NONE = 'None'
}

/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * 
     * @type {Array<ProjectProjectIdDeploymentRuleOrderProjectDeploymentRuleIdsInOrder>}
     * @memberof InlineObject
     */
    'project_deployment_rule_ids_in_order'?: Array<ProjectProjectIdDeploymentRuleOrderProjectDeploymentRuleIdsInOrder>;
}
/**
 * 
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
    /**
     * 
     * @type {Array<EnvironmentEnvironmentIdApplicationDeployApplications>}
     * @memberof InlineObject1
     */
    'applications'?: Array<EnvironmentEnvironmentIdApplicationDeployApplications>;
}
/**
 * 
 * @export
 * @interface InstanceResponse
 */
export interface InstanceResponse {
    /**
     * 
     * @type {string}
     * @memberof InstanceResponse
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof InstanceResponse
     */
    'name'?: string;
    /**
     * 
     * @type {EnvironmentDatabasesCurrentMetricResponseCpu}
     * @memberof InstanceResponse
     */
    'cpu'?: EnvironmentDatabasesCurrentMetricResponseCpu;
    /**
     * 
     * @type {EnvironmentDatabasesCurrentMetricResponseMemory}
     * @memberof InstanceResponse
     */
    'memory'?: EnvironmentDatabasesCurrentMetricResponseMemory;
}
/**
 * 
 * @export
 * @interface InstanceResponseList
 */
export interface InstanceResponseList {
    /**
     * 
     * @type {Array<InstanceResponse>}
     * @memberof InstanceResponseList
     */
    'results'?: Array<InstanceResponse>;
}
/**
 * 
 * @export
 * @interface InviteMemberRequest
 */
export interface InviteMemberRequest {
    /**
     * 
     * @type {string}
     * @memberof InviteMemberRequest
     */
    'email': string;
    /**
     * 
     * @type {InviteMemberRoleEnum}
     * @memberof InviteMemberRequest
     */
    'role': InviteMemberRoleEnum;
}
/**
 * 
 * @export
 * @interface InviteMemberResponse
 */
export interface InviteMemberResponse {
    /**
     * 
     * @type {string}
     * @memberof InviteMemberResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof InviteMemberResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof InviteMemberResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof InviteMemberResponse
     */
    'email': string;
    /**
     * 
     * @type {InviteMemberRoleEnum}
     * @memberof InviteMemberResponse
     */
    'role': InviteMemberRoleEnum;
    /**
     * 
     * @type {string}
     * @memberof InviteMemberResponse
     */
    'invitation_link': string;
    /**
     * 
     * @type {InviteStatusEnum}
     * @memberof InviteMemberResponse
     */
    'invitation_status': InviteStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof InviteMemberResponse
     */
    'inviter': string;
    /**
     * 
     * @type {string}
     * @memberof InviteMemberResponse
     */
    'logo_url'?: string;
}
/**
 * 
 * @export
 * @interface InviteMemberResponseAllOf
 */
export interface InviteMemberResponseAllOf {
    /**
     * 
     * @type {string}
     * @memberof InviteMemberResponseAllOf
     */
    'email': string;
    /**
     * 
     * @type {InviteMemberRoleEnum}
     * @memberof InviteMemberResponseAllOf
     */
    'role': InviteMemberRoleEnum;
    /**
     * 
     * @type {string}
     * @memberof InviteMemberResponseAllOf
     */
    'invitation_link': string;
    /**
     * 
     * @type {InviteStatusEnum}
     * @memberof InviteMemberResponseAllOf
     */
    'invitation_status': InviteStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof InviteMemberResponseAllOf
     */
    'inviter': string;
    /**
     * 
     * @type {string}
     * @memberof InviteMemberResponseAllOf
     */
    'logo_url'?: string;
}
/**
 * 
 * @export
 * @interface InviteMemberResponseList
 */
export interface InviteMemberResponseList {
    /**
     * 
     * @type {Array<InviteMemberResponse>}
     * @memberof InviteMemberResponseList
     */
    'results'?: Array<InviteMemberResponse>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum InviteMemberRoleEnum {
    OWNER = 'OWNER',
    ADMIN = 'ADMIN',
    DEVELOPER = 'DEVELOPER',
    VIEWER = 'VIEWER'
}

/**
 * 
 * @export
 * @enum {string}
 */

export enum InviteStatusEnum {
    PENDING = 'PENDING',
    EXPIRED = 'EXPIRED'
}

/**
 * 
 * @export
 * @interface InvoiceResponse
 */
export interface InvoiceResponse {
    /**
     * 
     * @type {number}
     * @memberof InvoiceResponse
     */
    'total_in_cents': number;
    /**
     * 
     * @type {number}
     * @memberof InvoiceResponse
     */
    'total': number;
    /**
     * 
     * @type {string}
     * @memberof InvoiceResponse
     */
    'currency_code': string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceResponse
     */
    'created_at': string;
    /**
     * 
     * @type {InvoiceStatusEnum}
     * @memberof InvoiceResponse
     */
    'status': InvoiceStatusEnum;
}
/**
 * 
 * @export
 * @interface InvoiceResponseAllOf
 */
export interface InvoiceResponseAllOf {
    /**
     * 
     * @type {string}
     * @memberof InvoiceResponseAllOf
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceResponseAllOf
     */
    'created_at': string;
    /**
     * 
     * @type {InvoiceStatusEnum}
     * @memberof InvoiceResponseAllOf
     */
    'status': InvoiceStatusEnum;
}
/**
 * 
 * @export
 * @interface InvoiceResponseList
 */
export interface InvoiceResponseList {
    /**
     * 
     * @type {Array<InvoiceResponse>}
     * @memberof InvoiceResponseList
     */
    'results'?: Array<InvoiceResponse>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum InvoiceStatusEnum {
    PAID = 'PAID',
    POSTED = 'POSTED',
    PAYMENT_DUE = 'PAYMENT_DUE',
    NOT_PAID = 'NOT_PAID',
    VOIDED = 'VOIDED',
    PENDING = 'PENDING',
    UNKNOWN = 'UNKNOWN'
}

/**
 * 
 * @export
 * @interface Key
 */
export interface Key {
    /**
     * 
     * @type {string}
     * @memberof Key
     */
    'key': string;
}
/**
 * 
 * @export
 * @interface LinkResponse
 */
export interface LinkResponse {
    /**
     * 
     * @type {string}
     * @memberof LinkResponse
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface LinkResponseList
 */
export interface LinkResponseList {
    /**
     * 
     * @type {Array<LinkResponse>}
     * @memberof LinkResponseList
     */
    'results'?: Array<LinkResponse>;
}
/**
 * 
 * @export
 * @interface LogPaginatedResponseList
 */
export interface LogPaginatedResponseList {
    /**
     * 
     * @type {number}
     * @memberof LogPaginatedResponseList
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof LogPaginatedResponseList
     */
    'page_size': number;
    /**
     * 
     * @type {Array<LogResponse>}
     * @memberof LogPaginatedResponseList
     */
    'results'?: Array<LogResponse>;
}
/**
 * 
 * @export
 * @interface LogPaginatedResponseListAllOf
 */
export interface LogPaginatedResponseListAllOf {
    /**
     * 
     * @type {Array<LogResponse>}
     * @memberof LogPaginatedResponseListAllOf
     */
    'results'?: Array<LogResponse>;
}
/**
 * 
 * @export
 * @interface LogResponse
 */
export interface LogResponse {
    /**
     * 
     * @type {string}
     * @memberof LogResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof LogResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof LogResponse
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface LogResponseList
 */
export interface LogResponseList {
    /**
     * 
     * @type {Array<LogResponse>}
     * @memberof LogResponseList
     */
    'results'?: Array<LogResponse>;
}
/**
 * 
 * @export
 * @interface LogicalDatabaseRequest
 */
export interface LogicalDatabaseRequest {
    /**
     * name is case insensitive
     * @type {string}
     * @memberof LogicalDatabaseRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof LogicalDatabaseRequest
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface LogicalDatabaseResponse
 */
export interface LogicalDatabaseResponse {
    /**
     * 
     * @type {string}
     * @memberof LogicalDatabaseResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof LogicalDatabaseResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof LogicalDatabaseResponse
     */
    'updated_at'?: string;
    /**
     * name is case insensitive
     * @type {string}
     * @memberof LogicalDatabaseResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof LogicalDatabaseResponse
     */
    'description'?: string;
    /**
     * 
     * @type {ReferenceObject}
     * @memberof LogicalDatabaseResponse
     */
    'database'?: ReferenceObject;
}
/**
 * 
 * @export
 * @interface LogicalDatabaseResponseAllOf
 */
export interface LogicalDatabaseResponseAllOf {
    /**
     * 
     * @type {ReferenceObject}
     * @memberof LogicalDatabaseResponseAllOf
     */
    'database'?: ReferenceObject;
}
/**
 * 
 * @export
 * @interface LogicalDatabaseResponseList
 */
export interface LogicalDatabaseResponseList {
    /**
     * 
     * @type {Array<LogicalDatabaseResponse>}
     * @memberof LogicalDatabaseResponseList
     */
    'results'?: Array<LogicalDatabaseResponse>;
}
/**
 * 
 * @export
 * @interface MemberResponse
 */
export interface MemberResponse {
    /**
     * 
     * @type {string}
     * @memberof MemberResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MemberResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof MemberResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof MemberResponse
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof MemberResponse
     */
    'nickname'?: string;
    /**
     * 
     * @type {string}
     * @memberof MemberResponse
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof MemberResponse
     */
    'profile_picture_url'?: string;
    /**
     * last time the user was connected
     * @type {string}
     * @memberof MemberResponse
     */
    'last_activity_at'?: string;
    /**
     * 
     * @type {InviteMemberRoleEnum}
     * @memberof MemberResponse
     */
    'role'?: InviteMemberRoleEnum;
}
/**
 * 
 * @export
 * @interface MemberResponseAllOf
 */
export interface MemberResponseAllOf {
    /**
     * 
     * @type {string}
     * @memberof MemberResponseAllOf
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof MemberResponseAllOf
     */
    'nickname'?: string;
    /**
     * 
     * @type {string}
     * @memberof MemberResponseAllOf
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof MemberResponseAllOf
     */
    'profile_picture_url'?: string;
    /**
     * last time the user was connected
     * @type {string}
     * @memberof MemberResponseAllOf
     */
    'last_activity_at'?: string;
    /**
     * 
     * @type {InviteMemberRoleEnum}
     * @memberof MemberResponseAllOf
     */
    'role'?: InviteMemberRoleEnum;
}
/**
 * 
 * @export
 * @interface MemberResponseList
 */
export interface MemberResponseList {
    /**
     * 
     * @type {Array<MemberResponse>}
     * @memberof MemberResponseList
     */
    'results'?: Array<MemberResponse>;
}
/**
 * 
 * @export
 * @interface MetricCPUDatapointResponse
 */
export interface MetricCPUDatapointResponse {
    /**
     * 
     * @type {string}
     * @memberof MetricCPUDatapointResponse
     */
    'created_at': string;
    /**
     * 
     * @type {number}
     * @memberof MetricCPUDatapointResponse
     */
    'requested_in_number'?: number;
    /**
     * 
     * @type {number}
     * @memberof MetricCPUDatapointResponse
     */
    'consumed_in_number': number;
    /**
     * 
     * @type {number}
     * @memberof MetricCPUDatapointResponse
     */
    'consumed_in_percent': number;
}
/**
 * 
 * @export
 * @interface MetricCPUDatapointResponseList
 */
export interface MetricCPUDatapointResponseList {
    /**
     * 
     * @type {Array<MetricCPUDatapointResponse>}
     * @memberof MetricCPUDatapointResponseList
     */
    'results'?: Array<MetricCPUDatapointResponse>;
}
/**
 * 
 * @export
 * @interface MetricCPUResponse
 */
export interface MetricCPUResponse {
    /**
     * 
     * @type {string}
     * @memberof MetricCPUResponse
     */
    'instance_name': string;
    /**
     * 
     * @type {Array<MetricCPUDatapointResponse>}
     * @memberof MetricCPUResponse
     */
    'data': Array<MetricCPUDatapointResponse>;
}
/**
 * 
 * @export
 * @interface MetricCPUResponseList
 */
export interface MetricCPUResponseList {
    /**
     * 
     * @type {Array<MetricCPUResponse>}
     * @memberof MetricCPUResponseList
     */
    'results'?: Array<MetricCPUResponse>;
}
/**
 * 
 * @export
 * @interface MetricGenericDatapointResponse
 */
export interface MetricGenericDatapointResponse {
    /**
     * 
     * @type {string}
     * @memberof MetricGenericDatapointResponse
     */
    'created_at': string;
    /**
     * 
     * @type {number}
     * @memberof MetricGenericDatapointResponse
     */
    'value': number;
}
/**
 * 
 * @export
 * @interface MetricGenericResponse
 */
export interface MetricGenericResponse {
    /**
     * 
     * @type {string}
     * @memberof MetricGenericResponse
     */
    'instance_name': string;
    /**
     * 
     * @type {Array<MetricGenericDatapointResponse>}
     * @memberof MetricGenericResponse
     */
    'data': Array<MetricGenericDatapointResponse>;
}
/**
 * 
 * @export
 * @interface MetricGenericResponseList
 */
export interface MetricGenericResponseList {
    /**
     * 
     * @type {Array<MetricGenericResponse>}
     * @memberof MetricGenericResponseList
     */
    'results'?: Array<MetricGenericResponse>;
}
/**
 * 
 * @export
 * @interface MetricMemoryDatapointResponse
 */
export interface MetricMemoryDatapointResponse {
    /**
     * 
     * @type {string}
     * @memberof MetricMemoryDatapointResponse
     */
    'created_at': string;
    /**
     * 
     * @type {number}
     * @memberof MetricMemoryDatapointResponse
     */
    'requested_in_mb': number;
    /**
     * 
     * @type {number}
     * @memberof MetricMemoryDatapointResponse
     */
    'consumed_in_mb': number;
    /**
     * 
     * @type {number}
     * @memberof MetricMemoryDatapointResponse
     */
    'consumed_in_percent': number;
}
/**
 * 
 * @export
 * @interface MetricMemoryDatapointResponseList
 */
export interface MetricMemoryDatapointResponseList {
    /**
     * 
     * @type {Array<MetricMemoryDatapointResponse>}
     * @memberof MetricMemoryDatapointResponseList
     */
    'results'?: Array<MetricMemoryDatapointResponse>;
}
/**
 * 
 * @export
 * @interface MetricMemoryResponse
 */
export interface MetricMemoryResponse {
    /**
     * 
     * @type {string}
     * @memberof MetricMemoryResponse
     */
    'instance_name': string;
    /**
     * 
     * @type {Array<MetricMemoryDatapointResponse>}
     * @memberof MetricMemoryResponse
     */
    'data': Array<MetricMemoryDatapointResponse>;
}
/**
 * 
 * @export
 * @interface MetricMemoryResponseList
 */
export interface MetricMemoryResponseList {
    /**
     * 
     * @type {Array<MetricMemoryResponse>}
     * @memberof MetricMemoryResponseList
     */
    'results'?: Array<MetricMemoryResponse>;
}
/**
 * 
 * @export
 * @interface MetricRestartResponse
 */
export interface MetricRestartResponse {
    /**
     * 
     * @type {Array<MetricRestartResponseResults>}
     * @memberof MetricRestartResponse
     */
    'results'?: Array<MetricRestartResponseResults>;
}
/**
 * 
 * @export
 * @interface MetricRestartResponseResults
 */
export interface MetricRestartResponseResults {
    /**
     * 
     * @type {string}
     * @memberof MetricRestartResponseResults
     */
    'datetime': string;
    /**
     * 
     * @type {string}
     * @memberof MetricRestartResponseResults
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface MetricStorageDatapointResponse
 */
export interface MetricStorageDatapointResponse {
    /**
     * 
     * @type {string}
     * @memberof MetricStorageDatapointResponse
     */
    'created_at': string;
    /**
     * 
     * @type {number}
     * @memberof MetricStorageDatapointResponse
     */
    'requested_in_gb'?: number;
    /**
     * 
     * @type {number}
     * @memberof MetricStorageDatapointResponse
     */
    'consumed_in_gb'?: number;
    /**
     * 
     * @type {number}
     * @memberof MetricStorageDatapointResponse
     */
    'consumed_in_percent': number;
}
/**
 * 
 * @export
 * @interface MetricStorageDatapointResponseList
 */
export interface MetricStorageDatapointResponseList {
    /**
     * 
     * @type {Array<MetricStorageDatapointResponse>}
     * @memberof MetricStorageDatapointResponseList
     */
    'results'?: Array<MetricStorageDatapointResponse>;
}
/**
 * 
 * @export
 * @interface MetricStorageResponse
 */
export interface MetricStorageResponse {
    /**
     * 
     * @type {string}
     * @memberof MetricStorageResponse
     */
    'storage_id'?: string;
    /**
     * 
     * @type {Array<MetricStorageDatapointResponse>}
     * @memberof MetricStorageResponse
     */
    'data': Array<MetricStorageDatapointResponse>;
}
/**
 * 
 * @export
 * @interface MetricStorageResponseList
 */
export interface MetricStorageResponseList {
    /**
     * 
     * @type {Array<MetricStorageResponse>}
     * @memberof MetricStorageResponseList
     */
    'results'?: Array<MetricStorageResponse>;
}
/**
 * 
 * @export
 * @interface Name
 */
export interface Name {
    /**
     * 
     * @type {string}
     * @memberof Name
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface OrganizationApiTokenCreateRequest
 */
export interface OrganizationApiTokenCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiTokenCreateRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiTokenCreateRequest
     */
    'description'?: string;
    /**
     * 
     * @type {OrganizationApiTokenScope}
     * @memberof OrganizationApiTokenCreateRequest
     */
    'scope': OrganizationApiTokenScope;
}
/**
 * 
 * @export
 * @interface OrganizationApiTokenCreateResponse
 */
export interface OrganizationApiTokenCreateResponse {
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiTokenCreateResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiTokenCreateResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiTokenCreateResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiTokenCreateResponse
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiTokenCreateResponse
     */
    'description'?: string;
    /**
     * the generated token to send in \'Authorization\' header prefixed by \'Token \'
     * @type {string}
     * @memberof OrganizationApiTokenCreateResponse
     */
    'token'?: string;
    /**
     * 
     * @type {OrganizationApiTokenScope}
     * @memberof OrganizationApiTokenCreateResponse
     */
    'scope'?: OrganizationApiTokenScope;
}
/**
 * 
 * @export
 * @interface OrganizationApiTokenCreateResponseAllOf
 */
export interface OrganizationApiTokenCreateResponseAllOf {
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiTokenCreateResponseAllOf
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiTokenCreateResponseAllOf
     */
    'description'?: string;
    /**
     * the generated token to send in \'Authorization\' header prefixed by \'Token \'
     * @type {string}
     * @memberof OrganizationApiTokenCreateResponseAllOf
     */
    'token'?: string;
    /**
     * 
     * @type {OrganizationApiTokenScope}
     * @memberof OrganizationApiTokenCreateResponseAllOf
     */
    'scope'?: OrganizationApiTokenScope;
}
/**
 * 
 * @export
 * @interface OrganizationApiTokenResponse
 */
export interface OrganizationApiTokenResponse {
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiTokenResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiTokenResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiTokenResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiTokenResponse
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiTokenResponse
     */
    'description'?: string;
    /**
     * 
     * @type {OrganizationApiTokenScope}
     * @memberof OrganizationApiTokenResponse
     */
    'scope'?: OrganizationApiTokenScope;
}
/**
 * 
 * @export
 * @interface OrganizationApiTokenResponseAllOf
 */
export interface OrganizationApiTokenResponseAllOf {
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiTokenResponseAllOf
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiTokenResponseAllOf
     */
    'description'?: string;
    /**
     * 
     * @type {OrganizationApiTokenScope}
     * @memberof OrganizationApiTokenResponseAllOf
     */
    'scope'?: OrganizationApiTokenScope;
}
/**
 * 
 * @export
 * @interface OrganizationApiTokenResponseList
 */
export interface OrganizationApiTokenResponseList {
    /**
     * 
     * @type {Array<OrganizationApiTokenResponse>}
     * @memberof OrganizationApiTokenResponseList
     */
    'results'?: Array<OrganizationApiTokenResponse>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum OrganizationApiTokenScope {
    ADMIN = 'ADMIN'
}

/**
 * 
 * @export
 * @interface OrganizationCreditCodeRequest
 */
export interface OrganizationCreditCodeRequest {
    /**
     * 
     * @type {string}
     * @memberof OrganizationCreditCodeRequest
     */
    'code'?: string;
}
/**
 * 
 * @export
 * @interface OrganizationCurrentCostResponse
 */
export interface OrganizationCurrentCostResponse {
    /**
     * 
     * @type {PlanEnum}
     * @memberof OrganizationCurrentCostResponse
     */
    'plan'?: PlanEnum;
    /**
     * number of days remaining before the end of the trial period
     * @type {number}
     * @memberof OrganizationCurrentCostResponse
     */
    'remaining_trial_day'?: number;
    /**
     * 
     * @type {RemainingCredits}
     * @memberof OrganizationCurrentCostResponse
     */
    'remaining_credits'?: RemainingCredits;
    /**
     * 
     * @type {Cost}
     * @memberof OrganizationCurrentCostResponse
     */
    'cost'?: Cost;
    /**
     * 
     * @type {PaidUsageResponse}
     * @memberof OrganizationCurrentCostResponse
     */
    'paid_usage'?: PaidUsageResponse;
    /**
     * 
     * @type {CommunityUsageResponse}
     * @memberof OrganizationCurrentCostResponse
     */
    'community_usage'?: CommunityUsageResponse;
}
/**
 * 
 * @export
 * @interface OrganizationEditRequest
 */
export interface OrganizationEditRequest {
    /**
     * name is case insensitive
     * @type {string}
     * @memberof OrganizationEditRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationEditRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationEditRequest
     */
    'website_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationEditRequest
     */
    'repository'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationEditRequest
     */
    'logo_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationEditRequest
     */
    'icon_url'?: string | null;
}
/**
 * 
 * @export
 * @interface OrganizationRequest
 */
export interface OrganizationRequest {
    /**
     * name is case insensitive
     * @type {string}
     * @memberof OrganizationRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationRequest
     */
    'description'?: string;
    /**
     * 
     * @type {PlanEnum}
     * @memberof OrganizationRequest
     */
    'plan': PlanEnum;
    /**
     * 
     * @type {string}
     * @memberof OrganizationRequest
     */
    'website_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationRequest
     */
    'repository'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationRequest
     */
    'logo_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationRequest
     */
    'icon_url'?: string | null;
}
/**
 * 
 * @export
 * @interface OrganizationResponse
 */
export interface OrganizationResponse {
    /**
     * 
     * @type {string}
     * @memberof OrganizationResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationResponse
     */
    'updated_at'?: string;
    /**
     * name is case insensitive
     * @type {string}
     * @memberof OrganizationResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationResponse
     */
    'description'?: string;
    /**
     * 
     * @type {PlanEnum}
     * @memberof OrganizationResponse
     */
    'plan': PlanEnum;
    /**
     * 
     * @type {string}
     * @memberof OrganizationResponse
     */
    'website_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationResponse
     */
    'repository'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationResponse
     */
    'logo_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationResponse
     */
    'icon_url'?: string | null;
    /**
     * uuid of the user owning the organization
     * @type {string}
     * @memberof OrganizationResponse
     */
    'owner'?: string;
}
/**
 * 
 * @export
 * @interface OrganizationResponseAllOf
 */
export interface OrganizationResponseAllOf {
    /**
     * uuid of the user owning the organization
     * @type {string}
     * @memberof OrganizationResponseAllOf
     */
    'owner'?: string;
}
/**
 * 
 * @export
 * @interface OrganizationResponseList
 */
export interface OrganizationResponseList {
    /**
     * 
     * @type {Array<OrganizationResponse>}
     * @memberof OrganizationResponseList
     */
    'results'?: Array<OrganizationResponse>;
}
/**
 * 
 * @export
 * @interface OverriddenSecret
 */
export interface OverriddenSecret {
    /**
     * 
     * @type {string}
     * @memberof OverriddenSecret
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OverriddenSecret
     */
    'key'?: string;
    /**
     * 
     * @type {EnvironmentVariableScopeEnum}
     * @memberof OverriddenSecret
     */
    'scope'?: EnvironmentVariableScopeEnum;
}
/**
 * 
 * @export
 * @interface PaginationDataResponse
 */
export interface PaginationDataResponse {
    /**
     * 
     * @type {number}
     * @memberof PaginationDataResponse
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof PaginationDataResponse
     */
    'page_size': number;
}
/**
 * 
 * @export
 * @interface PaidUsage
 */
export interface PaidUsage {
    /**
     * 
     * @type {PaidUsageResponse}
     * @memberof PaidUsage
     */
    'paid_usage'?: PaidUsageResponse;
}
/**
 * 
 * @export
 * @interface PaidUsageResponse
 */
export interface PaidUsageResponse {
    /**
     * 
     * @type {number}
     * @memberof PaidUsageResponse
     */
    'max_deployments_per_month'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaidUsageResponse
     */
    'consumed_deployments'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaidUsageResponse
     */
    'monthly_plan_cost'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaidUsageResponse
     */
    'monthly_plan_cost_in_cents'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaidUsageResponse
     */
    'remaining_deployments'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PaidUsageResponse
     */
    'deployments_exceeded'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PaidUsageResponse
     */
    'renewal_at'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum PlanEnum {
    COMMUNITY = 'COMMUNITY',
    FREE = 'FREE',
    PROFESSIONAL = 'PROFESSIONAL',
    BUSINESS = 'BUSINESS'
}

/**
 * 
 * @export
 * @enum {string}
 */

export enum PortProtocolEnum {
    HTTPS = 'HTTPS',
    HTTP = 'HTTP',
    TCP = 'TCP',
    UDP = 'UDP'
}

/**
 * 
 * @export
 * @interface ProjectCurrentCostResponse
 */
export interface ProjectCurrentCostResponse {
    /**
     * 
     * @type {string}
     * @memberof ProjectCurrentCostResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectCurrentCostResponse
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof ProjectCurrentCostResponse
     */
    'consumed_time_in_seconds': number;
    /**
     * 
     * @type {CostResponse}
     * @memberof ProjectCurrentCostResponse
     */
    'cost': CostResponse;
    /**
     * 
     * @type {Array<GenericObjectCurrentCostResponse>}
     * @memberof ProjectCurrentCostResponse
     */
    'environments'?: Array<GenericObjectCurrentCostResponse>;
}
/**
 * 
 * @export
 * @interface ProjectCurrentCostResponseAllOf
 */
export interface ProjectCurrentCostResponseAllOf {
    /**
     * 
     * @type {Array<GenericObjectCurrentCostResponse>}
     * @memberof ProjectCurrentCostResponseAllOf
     */
    'environments'?: Array<GenericObjectCurrentCostResponse>;
}
/**
 * 
 * @export
 * @interface ProjectCurrentCostResponseList
 */
export interface ProjectCurrentCostResponseList {
    /**
     * 
     * @type {Array<ProjectCurrentCostResponse>}
     * @memberof ProjectCurrentCostResponseList
     */
    'projects'?: Array<ProjectCurrentCostResponse>;
}
/**
 * 
 * @export
 * @interface ProjectDeploymentRuleRequest
 */
export interface ProjectDeploymentRuleRequest {
    /**
     * name is case insensitive
     * @type {string}
     * @memberof ProjectDeploymentRuleRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectDeploymentRuleRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {EnvironmentModeEnum}
     * @memberof ProjectDeploymentRuleRequest
     */
    'mode': EnvironmentModeEnum;
    /**
     * 
     * @type {string}
     * @memberof ProjectDeploymentRuleRequest
     */
    'cluster_id': string;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectDeploymentRuleRequest
     */
    'auto_deploy'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectDeploymentRuleRequest
     */
    'auto_stop'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectDeploymentRuleRequest
     */
    'auto_delete'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ProjectDeploymentRuleRequest
     */
    'timezone': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectDeploymentRuleRequest
     */
    'start_time': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectDeploymentRuleRequest
     */
    'stop_time': string;
    /**
     * 
     * @type {Array<WeekdayEnum>}
     * @memberof ProjectDeploymentRuleRequest
     */
    'weekdays': Array<WeekdayEnum>;
    /**
     * wildcard pattern composed of \'?\' and/or \'*\' used to target new created environments
     * @type {string}
     * @memberof ProjectDeploymentRuleRequest
     */
    'wildcard': string;
}
/**
 * 
 * @export
 * @interface ProjectDeploymentRuleResponse
 */
export interface ProjectDeploymentRuleResponse {
    /**
     * 
     * @type {string}
     * @memberof ProjectDeploymentRuleResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectDeploymentRuleResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectDeploymentRuleResponse
     */
    'updated_at'?: string;
    /**
     * name is case insensitive
     * @type {string}
     * @memberof ProjectDeploymentRuleResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectDeploymentRuleResponse
     */
    'description'?: string | null;
    /**
     * 
     * @type {EnvironmentModeEnum}
     * @memberof ProjectDeploymentRuleResponse
     */
    'mode': EnvironmentModeEnum;
    /**
     * 
     * @type {string}
     * @memberof ProjectDeploymentRuleResponse
     */
    'cluster_id': string;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectDeploymentRuleResponse
     */
    'auto_deploy'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectDeploymentRuleResponse
     */
    'auto_stop'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectDeploymentRuleResponse
     */
    'auto_delete'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ProjectDeploymentRuleResponse
     */
    'timezone': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectDeploymentRuleResponse
     */
    'start_time': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectDeploymentRuleResponse
     */
    'stop_time': string;
    /**
     * 
     * @type {Array<WeekdayEnum>}
     * @memberof ProjectDeploymentRuleResponse
     */
    'weekdays': Array<WeekdayEnum>;
    /**
     * wildcard pattern composed of \'?\' and/or \'*\' used to target new created environments
     * @type {string}
     * @memberof ProjectDeploymentRuleResponse
     */
    'wildcard': string;
    /**
     * used to select the first deployment rule to match new created environments
     * @type {number}
     * @memberof ProjectDeploymentRuleResponse
     */
    'priority_index'?: number;
}
/**
 * 
 * @export
 * @interface ProjectDeploymentRuleResponseAllOf
 */
export interface ProjectDeploymentRuleResponseAllOf {
    /**
     * used to select the first deployment rule to match new created environments
     * @type {number}
     * @memberof ProjectDeploymentRuleResponseAllOf
     */
    'priority_index'?: number;
}
/**
 * 
 * @export
 * @interface ProjectDeploymentRuleResponseList
 */
export interface ProjectDeploymentRuleResponseList {
    /**
     * 
     * @type {Array<ProjectDeploymentRuleResponse>}
     * @memberof ProjectDeploymentRuleResponseList
     */
    'results'?: Array<ProjectDeploymentRuleResponse>;
}
/**
 * 
 * @export
 * @interface ProjectProjectIdDeploymentRuleOrderProjectDeploymentRuleIdsInOrder
 */
export interface ProjectProjectIdDeploymentRuleOrderProjectDeploymentRuleIdsInOrder {
    /**
     * project deployment rule id
     * @type {string}
     * @memberof ProjectProjectIdDeploymentRuleOrderProjectDeploymentRuleIdsInOrder
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface ProjectRequest
 */
export interface ProjectRequest {
    /**
     * name is case insensitive
     * @type {string}
     * @memberof ProjectRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectRequest
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface ProjectResponse
 */
export interface ProjectResponse {
    /**
     * 
     * @type {string}
     * @memberof ProjectResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectResponse
     */
    'description'?: string;
    /**
     * 
     * @type {ReferenceObject}
     * @memberof ProjectResponse
     */
    'organization'?: ReferenceObject;
}
/**
 * 
 * @export
 * @interface ProjectResponseAllOf
 */
export interface ProjectResponseAllOf {
    /**
     * 
     * @type {string}
     * @memberof ProjectResponseAllOf
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectResponseAllOf
     */
    'description'?: string;
    /**
     * 
     * @type {ReferenceObject}
     * @memberof ProjectResponseAllOf
     */
    'organization'?: ReferenceObject;
}
/**
 * 
 * @export
 * @interface ProjectResponseList
 */
export interface ProjectResponseList {
    /**
     * 
     * @type {Array<ProjectResponse>}
     * @memberof ProjectResponseList
     */
    'results'?: Array<ProjectResponse>;
}
/**
 * 
 * @export
 * @interface ProjectStatsResponse
 */
export interface ProjectStatsResponse {
    /**
     * 
     * @type {string}
     * @memberof ProjectStatsResponse
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof ProjectStatsResponse
     */
    'service_total_number'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProjectStatsResponse
     */
    'environment_total_number'?: number;
}
/**
 * 
 * @export
 * @interface ProjectStatsResponseList
 */
export interface ProjectStatsResponseList {
    /**
     * 
     * @type {Array<ProjectStatsResponse>}
     * @memberof ProjectStatsResponseList
     */
    'results'?: Array<ProjectStatsResponse>;
}
/**
 * 
 * @export
 * @interface ReferenceObject
 */
export interface ReferenceObject {
    /**
     * 
     * @type {string}
     * @memberof ReferenceObject
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface ReferenceObjectStatusResponse
 */
export interface ReferenceObjectStatusResponse {
    /**
     * 
     * @type {string}
     * @memberof ReferenceObjectStatusResponse
     */
    'id': string;
    /**
     * 
     * @type {GlobalDeploymentStatus}
     * @memberof ReferenceObjectStatusResponse
     */
    'state': GlobalDeploymentStatus;
    /**
     * message related to the state
     * @type {string}
     * @memberof ReferenceObjectStatusResponse
     */
    'message'?: string | null;
    /**
     * 
     * @type {ServiceDeploymentStatusEnum}
     * @memberof ReferenceObjectStatusResponse
     */
    'service_deployment_status'?: ServiceDeploymentStatusEnum | null;
}
/**
 * 
 * @export
 * @interface ReferenceObjectStatusResponseList
 */
export interface ReferenceObjectStatusResponseList {
    /**
     * 
     * @type {Array<ReferenceObjectStatusResponse>}
     * @memberof ReferenceObjectStatusResponseList
     */
    'results'?: Array<ReferenceObjectStatusResponse>;
}
/**
 * 
 * @export
 * @interface ReferralResponse
 */
export interface ReferralResponse {
    /**
     * 
     * @type {number}
     * @memberof ReferralResponse
     */
    'total_invited'?: number;
    /**
     * 
     * @type {string}
     * @memberof ReferralResponse
     */
    'invitation_link'?: string;
}
/**
 * 
 * @export
 * @interface RemainingCredits
 */
export interface RemainingCredits {
    /**
     * 
     * @type {number}
     * @memberof RemainingCredits
     */
    'total_in_cents': number;
    /**
     * 
     * @type {number}
     * @memberof RemainingCredits
     */
    'total': number;
    /**
     * 
     * @type {string}
     * @memberof RemainingCredits
     */
    'currency_code': string;
}
/**
 * 
 * @export
 * @interface RewardClaimResponse
 */
export interface RewardClaimResponse {
    /**
     * 
     * @type {string}
     * @memberof RewardClaimResponse
     */
    'type'?: RewardClaimResponseTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof RewardClaimResponse
     */
    'code'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum RewardClaimResponseTypeEnum {
    INVITATION = 'INVITATION'
}

/**
 * 
 * @export
 * @interface ScalewayCredentialsRequest
 */
export interface ScalewayCredentialsRequest {
    /**
     * 
     * @type {string}
     * @memberof ScalewayCredentialsRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ScalewayCredentialsRequest
     */
    'scaleway_access_key'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScalewayCredentialsRequest
     */
    'scaleway_secret_key'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScalewayCredentialsRequest
     */
    'scaleway_project_id'?: string;
}
/**
 * 
 * @export
 * @interface SecretEditRequest
 */
export interface SecretEditRequest {
    /**
     * 
     * @type {string}
     * @memberof SecretEditRequest
     */
    'value'?: string;
    /**
     * 
     * @type {string}
     * @memberof SecretEditRequest
     */
    'key'?: string;
}
/**
 * 
 * @export
 * @interface SecretRequest
 */
export interface SecretRequest {
    /**
     * key is case sensitive
     * @type {string}
     * @memberof SecretRequest
     */
    'key': string;
    /**
     * value of the secret. Clear value will never be returned
     * @type {string}
     * @memberof SecretRequest
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface SecretResponse
 */
export interface SecretResponse {
    /**
     * 
     * @type {string}
     * @memberof SecretResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SecretResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof SecretResponse
     */
    'updated_at'?: string;
    /**
     * key is case sensitive
     * @type {string}
     * @memberof SecretResponse
     */
    'key'?: string;
    /**
     * 
     * @type {OverriddenSecret}
     * @memberof SecretResponse
     */
    'overridden_secret'?: OverriddenSecret;
    /**
     * 
     * @type {AliasedSecret}
     * @memberof SecretResponse
     */
    'aliased_secret'?: AliasedSecret;
    /**
     * 
     * @type {EnvironmentVariableScopeEnum}
     * @memberof SecretResponse
     */
    'scope': EnvironmentVariableScopeEnum;
}
/**
 * 
 * @export
 * @interface SecretResponseAllOf
 */
export interface SecretResponseAllOf {
    /**
     * key is case sensitive
     * @type {string}
     * @memberof SecretResponseAllOf
     */
    'key'?: string;
    /**
     * 
     * @type {OverriddenSecret}
     * @memberof SecretResponseAllOf
     */
    'overridden_secret'?: OverriddenSecret;
    /**
     * 
     * @type {AliasedSecret}
     * @memberof SecretResponseAllOf
     */
    'aliased_secret'?: AliasedSecret;
    /**
     * 
     * @type {EnvironmentVariableScopeEnum}
     * @memberof SecretResponseAllOf
     */
    'scope': EnvironmentVariableScopeEnum;
}
/**
 * 
 * @export
 * @interface SecretResponseList
 */
export interface SecretResponseList {
    /**
     * 
     * @type {Array<SecretResponse>}
     * @memberof SecretResponseList
     */
    'results'?: Array<SecretResponse>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum ServiceDeploymentStatusEnum {
    NEVER_DEPLOYED = 'NEVER_DEPLOYED',
    UP_TO_DATE = 'UP_TO_DATE',
    OUT_OF_DATE = 'OUT_OF_DATE'
}

/**
 * 
 * @export
 * @interface ServiceResponse
 */
export interface ServiceResponse {
    /**
     * uuid of the associated service (application, database, job, gateway...)
     * @type {string}
     * @memberof ServiceResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {ServiceTypeEnum}
     * @memberof ServiceResponse
     */
    'type'?: ServiceTypeEnum;
    /**
     * name of the service
     * @type {string}
     * @memberof ServiceResponse
     */
    'name'?: string;
    /**
     * Git commit ID corresponding to the deployed version of the application
     * @type {string}
     * @memberof ServiceResponse
     */
    'deployed_commit_id'?: string;
    /**
     * uuid of the user that made the last update
     * @type {string}
     * @memberof ServiceResponse
     */
    'last_updated_by'?: string;
    /**
     * global overview of resources consumption of the service
     * @type {number}
     * @memberof ServiceResponse
     */
    'consumed_resources_in_percent'?: number;
    /**
     * describes the typology of service (container, postgresl, redis...)
     * @type {string}
     * @memberof ServiceResponse
     */
    'service_typology'?: string;
    /**
     * for databases this field exposes the database version
     * @type {string}
     * @memberof ServiceResponse
     */
    'service_version'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceResponse
     */
    'to_update'?: boolean;
}
/**
 * 
 * @export
 * @interface ServiceResponseAllOf
 */
export interface ServiceResponseAllOf {
    /**
     * 
     * @type {ServiceTypeEnum}
     * @memberof ServiceResponseAllOf
     */
    'type'?: ServiceTypeEnum;
    /**
     * name of the service
     * @type {string}
     * @memberof ServiceResponseAllOf
     */
    'name'?: string;
    /**
     * uuid of the associated service (application, database, job, gateway...)
     * @type {string}
     * @memberof ServiceResponseAllOf
     */
    'id': string;
    /**
     * Git commit ID corresponding to the deployed version of the application
     * @type {string}
     * @memberof ServiceResponseAllOf
     */
    'deployed_commit_id'?: string;
    /**
     * uuid of the user that made the last update
     * @type {string}
     * @memberof ServiceResponseAllOf
     */
    'last_updated_by'?: string;
    /**
     * global overview of resources consumption of the service
     * @type {number}
     * @memberof ServiceResponseAllOf
     */
    'consumed_resources_in_percent'?: number;
    /**
     * describes the typology of service (container, postgresl, redis...)
     * @type {string}
     * @memberof ServiceResponseAllOf
     */
    'service_typology'?: string;
    /**
     * for databases this field exposes the database version
     * @type {string}
     * @memberof ServiceResponseAllOf
     */
    'service_version'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceResponseAllOf
     */
    'to_update'?: boolean;
}
/**
 * 
 * @export
 * @interface ServiceResponseList
 */
export interface ServiceResponseList {
    /**
     * 
     * @type {Array<ServiceResponse>}
     * @memberof ServiceResponseList
     */
    'results'?: Array<ServiceResponse>;
}
/**
 * 
 * @export
 * @interface ServiceTotalNumber
 */
export interface ServiceTotalNumber {
    /**
     * 
     * @type {number}
     * @memberof ServiceTotalNumber
     */
    'service_total_number'?: number;
}
/**
 * type of the service (application, database, job, gateway...)
 * @export
 * @enum {string}
 */

export enum ServiceTypeEnum {
    APPLICATION = 'APPLICATION',
    DATABASE = 'DATABASE'
}

/**
 * 
 * @export
 * @interface Status
 */
export interface Status {
    /**
     * 
     * @type {string}
     * @memberof Status
     */
    'id'?: string;
    /**
     * 
     * @type {GlobalDeploymentStatus}
     * @memberof Status
     */
    'state': GlobalDeploymentStatus;
    /**
     * message related to the state
     * @type {string}
     * @memberof Status
     */
    'message'?: string | null;
    /**
     * 
     * @type {ServiceDeploymentStatusEnum}
     * @memberof Status
     */
    'service_deployment_status'?: ServiceDeploymentStatusEnum | null;
}
/**
 * 
 * @export
 * @interface StorageDiskResponse
 */
export interface StorageDiskResponse {
    /**
     * 
     * @type {string}
     * @memberof StorageDiskResponse
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof StorageDiskResponse
     */
    'storage_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof StorageDiskResponse
     */
    'requested_in_gb'?: number;
    /**
     * 
     * @type {number}
     * @memberof StorageDiskResponse
     */
    'consumed_in_gb'?: number;
    /**
     * 
     * @type {number}
     * @memberof StorageDiskResponse
     */
    'consumed_in_percent'?: number;
    /**
     * 
     * @type {number}
     * @memberof StorageDiskResponse
     */
    'warning_threshold_in_percent'?: number;
    /**
     * 
     * @type {number}
     * @memberof StorageDiskResponse
     */
    'alert_threshold_in_percent'?: number;
    /**
     * 
     * @type {ThresholdMetricStatusEnum}
     * @memberof StorageDiskResponse
     */
    'status'?: ThresholdMetricStatusEnum;
}
/**
 * 
 * @export
 * @interface StorageDiskResponseList
 */
export interface StorageDiskResponseList {
    /**
     * 
     * @type {Array<StorageDiskResponse>}
     * @memberof StorageDiskResponseList
     */
    'results'?: Array<StorageDiskResponse>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum StorageTypeEnum {
    AWS = 'AWS',
    DIGITAL_OCEAN = 'DIGITAL_OCEAN',
    SCALEWAY = 'SCALEWAY'
}

/**
 * 
 * @export
 * @interface TagRequest
 */
export interface TagRequest {
    /**
     * 
     * @type {string}
     * @memberof TagRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface TagResponse
 */
export interface TagResponse {
    /**
     * 
     * @type {string}
     * @memberof TagResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TagResponse
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface TagResponseList
 */
export interface TagResponseList {
    /**
     * 
     * @type {Array<TagResponse>}
     * @memberof TagResponseList
     */
    'results'?: Array<TagResponse>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum ThresholdMetricStatusEnum {
    OK = 'OK',
    WARNING = 'Warning',
    ALERT = 'Alert'
}

/**
 * 
 * @export
 * @interface TransferOwnershipRequest
 */
export interface TransferOwnershipRequest {
    /**
     * 
     * @type {string}
     * @memberof TransferOwnershipRequest
     */
    'user_id': string;
}
/**
 * 
 * @export
 * @interface UnexpectedError
 */
export interface UnexpectedError {
    /**
     * 
     * @type {string}
     * @memberof UnexpectedError
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface UserResponse
 */
export interface UserResponse {
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'profile_picture_url'?: string;
}
/**
 * 
 * @export
 * @interface UserResponseList
 */
export interface UserResponseList {
    /**
     * 
     * @type {Array<UserResponse>}
     * @memberof UserResponseList
     */
    'results'?: Array<UserResponse>;
}
/**
 * 
 * @export
 * @interface Value
 */
export interface Value {
    /**
     * 
     * @type {string}
     * @memberof Value
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface VariableImportRequest
 */
export interface VariableImportRequest {
    /**
     * 
     * @type {boolean}
     * @memberof VariableImportRequest
     */
    'overwrite': boolean;
    /**
     * 
     * @type {Array<VariableImportRequestVars>}
     * @memberof VariableImportRequest
     */
    'vars': Array<VariableImportRequestVars>;
}
/**
 * 
 * @export
 * @interface VariableImportRequestVars
 */
export interface VariableImportRequestVars {
    /**
     * 
     * @type {string}
     * @memberof VariableImportRequestVars
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof VariableImportRequestVars
     */
    'value': string;
    /**
     * 
     * @type {EnvironmentVariableScopeEnum}
     * @memberof VariableImportRequestVars
     */
    'scope': EnvironmentVariableScopeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof VariableImportRequestVars
     */
    'is_secret': boolean;
}
/**
 * 
 * @export
 * @interface VariableImportResponse
 */
export interface VariableImportResponse {
    /**
     * 
     * @type {number}
     * @memberof VariableImportResponse
     */
    'total_variables_to_import': number;
    /**
     * 
     * @type {Array<VariableImportResponseSuccessfulImportedVariables>}
     * @memberof VariableImportResponse
     */
    'successful_imported_variables': Array<VariableImportResponseSuccessfulImportedVariables>;
}
/**
 * 
 * @export
 * @interface VariableImportResponseSuccessfulImportedVariables
 */
export interface VariableImportResponseSuccessfulImportedVariables {
    /**
     * 
     * @type {string}
     * @memberof VariableImportResponseSuccessfulImportedVariables
     */
    'name': string;
    /**
     * Optional if the variable is secret
     * @type {string}
     * @memberof VariableImportResponseSuccessfulImportedVariables
     */
    'value'?: string;
    /**
     * 
     * @type {EnvironmentVariableScopeEnum}
     * @memberof VariableImportResponseSuccessfulImportedVariables
     */
    'scope': EnvironmentVariableScopeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof VariableImportResponseSuccessfulImportedVariables
     */
    'is_secret': boolean;
}
/**
 * 
 * @export
 * @interface VersionResponse
 */
export interface VersionResponse {
    /**
     * 
     * @type {string}
     * @memberof VersionResponse
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface VersionResponseList
 */
export interface VersionResponseList {
    /**
     * 
     * @type {Array<VersionResponse>}
     * @memberof VersionResponseList
     */
    'results'?: Array<VersionResponse>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum WeekdayEnum {
    MONDAY = 'MONDAY',
    TUESDAY = 'TUESDAY',
    WEDNESDAY = 'WEDNESDAY',
    THURSDAY = 'THURSDAY',
    FRIDAY = 'FRIDAY',
    SATURDAY = 'SATURDAY',
    SUNDAY = 'SUNDAY'
}


/**
 * AccountInfoApi - axios parameter creator
 * @export
 */
export const AccountInfoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Account information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountInformation: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountInfoApi - functional programming interface
 * @export
 */
export const AccountInfoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountInfoApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Account information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountInformation(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountInformation(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountInfoApi - factory interface
 * @export
 */
export const AccountInfoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountInfoApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Account information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountInformation(options?: any): AxiosPromise<AccountInfoResponse> {
            return localVarFp.getAccountInformation(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountInfoApi - object-oriented interface
 * @export
 * @class AccountInfoApi
 * @extends {BaseAPI}
 */
export class AccountInfoApi extends BaseAPI {
    /**
     * 
     * @summary Get Account information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountInfoApi
     */
    public getAccountInformation(options?: AxiosRequestConfig) {
        return AccountInfoApiFp(this.configuration).getAccountInformation(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ApplicationActionsApi - axios parameter creator
 * @export
 */
export const ApplicationActionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * You must provide a git commit id
         * @summary Deploy application
         * @param {string} applicationId Application ID
         * @param {DeployRequest} [deployRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployApplication: async (applicationId: string, deployRequest?: DeployRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('deployApplication', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/deploy`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deployRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restart application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartApplication: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('restartApplication', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/restart`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopApplication: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('stopApplication', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/stop`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationActionsApi - functional programming interface
 * @export
 */
export const ApplicationActionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationActionsApiAxiosParamCreator(configuration)
    return {
        /**
         * You must provide a git commit id
         * @summary Deploy application
         * @param {string} applicationId Application ID
         * @param {DeployRequest} [deployRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployApplication(applicationId: string, deployRequest?: DeployRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployApplication(applicationId, deployRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Restart application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restartApplication(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restartApplication(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Stop application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopApplication(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopApplication(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApplicationActionsApi - factory interface
 * @export
 */
export const ApplicationActionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationActionsApiFp(configuration)
    return {
        /**
         * You must provide a git commit id
         * @summary Deploy application
         * @param {string} applicationId Application ID
         * @param {DeployRequest} [deployRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployApplication(applicationId: string, deployRequest?: DeployRequest, options?: any): AxiosPromise<Status> {
            return localVarFp.deployApplication(applicationId, deployRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Restart application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartApplication(applicationId: string, options?: any): AxiosPromise<Status> {
            return localVarFp.restartApplication(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Stop application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopApplication(applicationId: string, options?: any): AxiosPromise<Status> {
            return localVarFp.stopApplication(applicationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationActionsApi - object-oriented interface
 * @export
 * @class ApplicationActionsApi
 * @extends {BaseAPI}
 */
export class ApplicationActionsApi extends BaseAPI {
    /**
     * You must provide a git commit id
     * @summary Deploy application
     * @param {string} applicationId Application ID
     * @param {DeployRequest} [deployRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationActionsApi
     */
    public deployApplication(applicationId: string, deployRequest?: DeployRequest, options?: AxiosRequestConfig) {
        return ApplicationActionsApiFp(this.configuration).deployApplication(applicationId, deployRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Restart application
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationActionsApi
     */
    public restartApplication(applicationId: string, options?: AxiosRequestConfig) {
        return ApplicationActionsApiFp(this.configuration).restartApplication(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Stop application
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationActionsApi
     */
    public stopApplication(applicationId: string, options?: AxiosRequestConfig) {
        return ApplicationActionsApiFp(this.configuration).stopApplication(applicationId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ApplicationConfigurationApi - axios parameter creator
 * @export
 */
export const ApplicationConfigurationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Edit the Network settings of the application.
         * @summary Edit Application Network
         * @param {string} applicationId Application ID
         * @param {ApplicationNetworkRequest} [applicationNetworkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editApplicationNetwork: async (applicationId: string, applicationNetworkRequest?: ApplicationNetworkRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('editApplicationNetwork', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/network`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(applicationNetworkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get status of the application network settings.
         * @summary Get Application Network information
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationNetwork: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getApplicationNetwork', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/network`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationConfigurationApi - functional programming interface
 * @export
 */
export const ApplicationConfigurationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationConfigurationApiAxiosParamCreator(configuration)
    return {
        /**
         * Edit the Network settings of the application.
         * @summary Edit Application Network
         * @param {string} applicationId Application ID
         * @param {ApplicationNetworkRequest} [applicationNetworkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editApplicationNetwork(applicationId: string, applicationNetworkRequest?: ApplicationNetworkRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationNetworkResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editApplicationNetwork(applicationId, applicationNetworkRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get status of the application network settings.
         * @summary Get Application Network information
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationNetwork(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationNetworkResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationNetwork(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApplicationConfigurationApi - factory interface
 * @export
 */
export const ApplicationConfigurationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationConfigurationApiFp(configuration)
    return {
        /**
         * Edit the Network settings of the application.
         * @summary Edit Application Network
         * @param {string} applicationId Application ID
         * @param {ApplicationNetworkRequest} [applicationNetworkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editApplicationNetwork(applicationId: string, applicationNetworkRequest?: ApplicationNetworkRequest, options?: any): AxiosPromise<ApplicationNetworkResponse> {
            return localVarFp.editApplicationNetwork(applicationId, applicationNetworkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get status of the application network settings.
         * @summary Get Application Network information
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationNetwork(applicationId: string, options?: any): AxiosPromise<ApplicationNetworkResponse> {
            return localVarFp.getApplicationNetwork(applicationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationConfigurationApi - object-oriented interface
 * @export
 * @class ApplicationConfigurationApi
 * @extends {BaseAPI}
 */
export class ApplicationConfigurationApi extends BaseAPI {
    /**
     * Edit the Network settings of the application.
     * @summary Edit Application Network
     * @param {string} applicationId Application ID
     * @param {ApplicationNetworkRequest} [applicationNetworkRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationConfigurationApi
     */
    public editApplicationNetwork(applicationId: string, applicationNetworkRequest?: ApplicationNetworkRequest, options?: AxiosRequestConfig) {
        return ApplicationConfigurationApiFp(this.configuration).editApplicationNetwork(applicationId, applicationNetworkRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get status of the application network settings.
     * @summary Get Application Network information
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationConfigurationApi
     */
    public getApplicationNetwork(applicationId: string, options?: AxiosRequestConfig) {
        return ApplicationConfigurationApiFp(this.configuration).getApplicationNetwork(applicationId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ApplicationDatabaseApi - axios parameter creator
 * @export
 */
export const ApplicationDatabaseApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Link a database to the application
         * @param {string} applicationId Application ID
         * @param {string} targetDatabaseId Target database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachDatabasetoApplication: async (applicationId: string, targetDatabaseId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('attachDatabasetoApplication', 'applicationId', applicationId)
            // verify required parameter 'targetDatabaseId' is not null or undefined
            assertParamExists('attachDatabasetoApplication', 'targetDatabaseId', targetDatabaseId)
            const localVarPath = `/application/{applicationId}/database/{targetDatabaseId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"targetDatabaseId"}}`, encodeURIComponent(String(targetDatabaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Link a logical database to the application
         * @param {string} applicationId Application ID
         * @param {string} targetLogicalDatabaseId Target database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachLogicalDatabasetoApplication: async (applicationId: string, targetLogicalDatabaseId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('attachLogicalDatabasetoApplication', 'applicationId', applicationId)
            // verify required parameter 'targetLogicalDatabaseId' is not null or undefined
            assertParamExists('attachLogicalDatabasetoApplication', 'targetLogicalDatabaseId', targetLogicalDatabaseId)
            const localVarPath = `/application/{applicationId}/logicalDatabase/{targetLogicalDatabaseId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"targetLogicalDatabaseId"}}`, encodeURIComponent(String(targetLogicalDatabaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List linked databases
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationDatabase: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('listApplicationDatabase', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/database`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List linked logical databases
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationLogicalDatabase: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('listApplicationLogicalDatabase', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/logicalDatabase`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove database link to this application.
         * @param {string} applicationId Application ID
         * @param {string} targetDatabaseId Target database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDatabaseFromApplication: async (applicationId: string, targetDatabaseId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('removeDatabaseFromApplication', 'applicationId', applicationId)
            // verify required parameter 'targetDatabaseId' is not null or undefined
            assertParamExists('removeDatabaseFromApplication', 'targetDatabaseId', targetDatabaseId)
            const localVarPath = `/application/{applicationId}/database/{targetDatabaseId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"targetDatabaseId"}}`, encodeURIComponent(String(targetDatabaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove logical database link to this application.
         * @param {string} applicationId Application ID
         * @param {string} targetLogicalDatabaseId Target database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeLogicalDatabaseFromApplication: async (applicationId: string, targetLogicalDatabaseId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('removeLogicalDatabaseFromApplication', 'applicationId', applicationId)
            // verify required parameter 'targetLogicalDatabaseId' is not null or undefined
            assertParamExists('removeLogicalDatabaseFromApplication', 'targetLogicalDatabaseId', targetLogicalDatabaseId)
            const localVarPath = `/application/{applicationId}/logicalDatabase/{targetLogicalDatabaseId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"targetLogicalDatabaseId"}}`, encodeURIComponent(String(targetLogicalDatabaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationDatabaseApi - functional programming interface
 * @export
 */
export const ApplicationDatabaseApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationDatabaseApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Link a database to the application
         * @param {string} applicationId Application ID
         * @param {string} targetDatabaseId Target database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async attachDatabasetoApplication(applicationId: string, targetDatabaseId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatabaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.attachDatabasetoApplication(applicationId, targetDatabaseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Link a logical database to the application
         * @param {string} applicationId Application ID
         * @param {string} targetLogicalDatabaseId Target database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async attachLogicalDatabasetoApplication(applicationId: string, targetLogicalDatabaseId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogicalDatabaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.attachLogicalDatabasetoApplication(applicationId, targetLogicalDatabaseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List linked databases
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplicationDatabase(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatabaseResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplicationDatabase(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List linked logical databases
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplicationLogicalDatabase(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogicalDatabaseResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplicationLogicalDatabase(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove database link to this application.
         * @param {string} applicationId Application ID
         * @param {string} targetDatabaseId Target database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeDatabaseFromApplication(applicationId: string, targetDatabaseId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeDatabaseFromApplication(applicationId, targetDatabaseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove logical database link to this application.
         * @param {string} applicationId Application ID
         * @param {string} targetLogicalDatabaseId Target database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeLogicalDatabaseFromApplication(applicationId: string, targetLogicalDatabaseId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeLogicalDatabaseFromApplication(applicationId, targetLogicalDatabaseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApplicationDatabaseApi - factory interface
 * @export
 */
export const ApplicationDatabaseApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationDatabaseApiFp(configuration)
    return {
        /**
         * 
         * @summary Link a database to the application
         * @param {string} applicationId Application ID
         * @param {string} targetDatabaseId Target database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachDatabasetoApplication(applicationId: string, targetDatabaseId: string, options?: any): AxiosPromise<DatabaseResponse> {
            return localVarFp.attachDatabasetoApplication(applicationId, targetDatabaseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Link a logical database to the application
         * @param {string} applicationId Application ID
         * @param {string} targetLogicalDatabaseId Target database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachLogicalDatabasetoApplication(applicationId: string, targetLogicalDatabaseId: string, options?: any): AxiosPromise<LogicalDatabaseResponse> {
            return localVarFp.attachLogicalDatabasetoApplication(applicationId, targetLogicalDatabaseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List linked databases
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationDatabase(applicationId: string, options?: any): AxiosPromise<DatabaseResponseList> {
            return localVarFp.listApplicationDatabase(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List linked logical databases
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationLogicalDatabase(applicationId: string, options?: any): AxiosPromise<LogicalDatabaseResponseList> {
            return localVarFp.listApplicationLogicalDatabase(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove database link to this application.
         * @param {string} applicationId Application ID
         * @param {string} targetDatabaseId Target database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDatabaseFromApplication(applicationId: string, targetDatabaseId: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeDatabaseFromApplication(applicationId, targetDatabaseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove logical database link to this application.
         * @param {string} applicationId Application ID
         * @param {string} targetLogicalDatabaseId Target database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeLogicalDatabaseFromApplication(applicationId: string, targetLogicalDatabaseId: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeLogicalDatabaseFromApplication(applicationId, targetLogicalDatabaseId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationDatabaseApi - object-oriented interface
 * @export
 * @class ApplicationDatabaseApi
 * @extends {BaseAPI}
 */
export class ApplicationDatabaseApi extends BaseAPI {
    /**
     * 
     * @summary Link a database to the application
     * @param {string} applicationId Application ID
     * @param {string} targetDatabaseId Target database ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDatabaseApi
     */
    public attachDatabasetoApplication(applicationId: string, targetDatabaseId: string, options?: AxiosRequestConfig) {
        return ApplicationDatabaseApiFp(this.configuration).attachDatabasetoApplication(applicationId, targetDatabaseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Link a logical database to the application
     * @param {string} applicationId Application ID
     * @param {string} targetLogicalDatabaseId Target database ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDatabaseApi
     */
    public attachLogicalDatabasetoApplication(applicationId: string, targetLogicalDatabaseId: string, options?: AxiosRequestConfig) {
        return ApplicationDatabaseApiFp(this.configuration).attachLogicalDatabasetoApplication(applicationId, targetLogicalDatabaseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List linked databases
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDatabaseApi
     */
    public listApplicationDatabase(applicationId: string, options?: AxiosRequestConfig) {
        return ApplicationDatabaseApiFp(this.configuration).listApplicationDatabase(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List linked logical databases
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDatabaseApi
     */
    public listApplicationLogicalDatabase(applicationId: string, options?: AxiosRequestConfig) {
        return ApplicationDatabaseApiFp(this.configuration).listApplicationLogicalDatabase(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove database link to this application.
     * @param {string} applicationId Application ID
     * @param {string} targetDatabaseId Target database ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDatabaseApi
     */
    public removeDatabaseFromApplication(applicationId: string, targetDatabaseId: string, options?: AxiosRequestConfig) {
        return ApplicationDatabaseApiFp(this.configuration).removeDatabaseFromApplication(applicationId, targetDatabaseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove logical database link to this application.
     * @param {string} applicationId Application ID
     * @param {string} targetLogicalDatabaseId Target database ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDatabaseApi
     */
    public removeLogicalDatabaseFromApplication(applicationId: string, targetLogicalDatabaseId: string, options?: AxiosRequestConfig) {
        return ApplicationDatabaseApiFp(this.configuration).removeLogicalDatabaseFromApplication(applicationId, targetLogicalDatabaseId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ApplicationDeploymentHistoryApi - axios parameter creator
 * @export
 */
export const ApplicationDeploymentHistoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter. You can also filter by status (FAILED or SUCCESS), and git_commit_id
         * @summary List application deploys
         * @param {string} applicationId Application ID
         * @param {string} [startId] Starting point after which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationDeploymentHistory: async (applicationId: string, startId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('listApplicationDeploymentHistory', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/deploymentHistory`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (startId !== undefined) {
                localVarQueryParameter['startId'] = startId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationDeploymentHistoryApi - functional programming interface
 * @export
 */
export const ApplicationDeploymentHistoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationDeploymentHistoryApiAxiosParamCreator(configuration)
    return {
        /**
         * By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter. You can also filter by status (FAILED or SUCCESS), and git_commit_id
         * @summary List application deploys
         * @param {string} applicationId Application ID
         * @param {string} [startId] Starting point after which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplicationDeploymentHistory(applicationId: string, startId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentHistoryPaginatedResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplicationDeploymentHistory(applicationId, startId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApplicationDeploymentHistoryApi - factory interface
 * @export
 */
export const ApplicationDeploymentHistoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationDeploymentHistoryApiFp(configuration)
    return {
        /**
         * By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter. You can also filter by status (FAILED or SUCCESS), and git_commit_id
         * @summary List application deploys
         * @param {string} applicationId Application ID
         * @param {string} [startId] Starting point after which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationDeploymentHistory(applicationId: string, startId?: string, options?: any): AxiosPromise<DeploymentHistoryPaginatedResponseList> {
            return localVarFp.listApplicationDeploymentHistory(applicationId, startId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationDeploymentHistoryApi - object-oriented interface
 * @export
 * @class ApplicationDeploymentHistoryApi
 * @extends {BaseAPI}
 */
export class ApplicationDeploymentHistoryApi extends BaseAPI {
    /**
     * By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter. You can also filter by status (FAILED or SUCCESS), and git_commit_id
     * @summary List application deploys
     * @param {string} applicationId Application ID
     * @param {string} [startId] Starting point after which to return results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentHistoryApi
     */
    public listApplicationDeploymentHistory(applicationId: string, startId?: string, options?: AxiosRequestConfig) {
        return ApplicationDeploymentHistoryApiFp(this.configuration).listApplicationDeploymentHistory(applicationId, startId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ApplicationDeploymentRuleApi - axios parameter creator
 * @export
 */
export const ApplicationDeploymentRuleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Edit an application deployment rule
         * @summary Edit an application deployment rule
         * @param {string} applicationId Application ID
         * @param {string} deploymentRuleId Deployment Rule ID
         * @param {ApplicationDeploymentRuleEditRequest} [applicationDeploymentRuleEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editApplicationDeploymentRule: async (applicationId: string, deploymentRuleId: string, applicationDeploymentRuleEditRequest?: ApplicationDeploymentRuleEditRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('editApplicationDeploymentRule', 'applicationId', applicationId)
            // verify required parameter 'deploymentRuleId' is not null or undefined
            assertParamExists('editApplicationDeploymentRule', 'deploymentRuleId', deploymentRuleId)
            const localVarPath = `/application/{applicationId}/deploymentRule/{deploymentRuleId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"deploymentRuleId"}}`, encodeURIComponent(String(deploymentRuleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(applicationDeploymentRuleEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get application deployment rule
         * @summary Get application deployment rule
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationDeploymentRule: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getApplicationDeploymentRule', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/deploymentRule`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationDeploymentRuleApi - functional programming interface
 * @export
 */
export const ApplicationDeploymentRuleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationDeploymentRuleApiAxiosParamCreator(configuration)
    return {
        /**
         * Edit an application deployment rule
         * @summary Edit an application deployment rule
         * @param {string} applicationId Application ID
         * @param {string} deploymentRuleId Deployment Rule ID
         * @param {ApplicationDeploymentRuleEditRequest} [applicationDeploymentRuleEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editApplicationDeploymentRule(applicationId: string, deploymentRuleId: string, applicationDeploymentRuleEditRequest?: ApplicationDeploymentRuleEditRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationDeploymentRuleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editApplicationDeploymentRule(applicationId, deploymentRuleId, applicationDeploymentRuleEditRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get application deployment rule
         * @summary Get application deployment rule
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationDeploymentRule(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationDeploymentRuleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationDeploymentRule(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApplicationDeploymentRuleApi - factory interface
 * @export
 */
export const ApplicationDeploymentRuleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationDeploymentRuleApiFp(configuration)
    return {
        /**
         * Edit an application deployment rule
         * @summary Edit an application deployment rule
         * @param {string} applicationId Application ID
         * @param {string} deploymentRuleId Deployment Rule ID
         * @param {ApplicationDeploymentRuleEditRequest} [applicationDeploymentRuleEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editApplicationDeploymentRule(applicationId: string, deploymentRuleId: string, applicationDeploymentRuleEditRequest?: ApplicationDeploymentRuleEditRequest, options?: any): AxiosPromise<ApplicationDeploymentRuleResponse> {
            return localVarFp.editApplicationDeploymentRule(applicationId, deploymentRuleId, applicationDeploymentRuleEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get application deployment rule
         * @summary Get application deployment rule
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationDeploymentRule(applicationId: string, options?: any): AxiosPromise<ApplicationDeploymentRuleResponse> {
            return localVarFp.getApplicationDeploymentRule(applicationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationDeploymentRuleApi - object-oriented interface
 * @export
 * @class ApplicationDeploymentRuleApi
 * @extends {BaseAPI}
 */
export class ApplicationDeploymentRuleApi extends BaseAPI {
    /**
     * Edit an application deployment rule
     * @summary Edit an application deployment rule
     * @param {string} applicationId Application ID
     * @param {string} deploymentRuleId Deployment Rule ID
     * @param {ApplicationDeploymentRuleEditRequest} [applicationDeploymentRuleEditRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentRuleApi
     */
    public editApplicationDeploymentRule(applicationId: string, deploymentRuleId: string, applicationDeploymentRuleEditRequest?: ApplicationDeploymentRuleEditRequest, options?: AxiosRequestConfig) {
        return ApplicationDeploymentRuleApiFp(this.configuration).editApplicationDeploymentRule(applicationId, deploymentRuleId, applicationDeploymentRuleEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get application deployment rule
     * @summary Get application deployment rule
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentRuleApi
     */
    public getApplicationDeploymentRule(applicationId: string, options?: AxiosRequestConfig) {
        return ApplicationDeploymentRuleApiFp(this.configuration).getApplicationDeploymentRule(applicationId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ApplicationEnvironmentVariableApi - axios parameter creator
 * @export
 */
export const ApplicationEnvironmentVariableApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * - Add an environment variable to the application. 
         * @summary Add an environment variable to the application
         * @param {string} applicationId Application ID
         * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationEnvironmentVariable: async (applicationId: string, environmentVariableRequest?: EnvironmentVariableRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('createApplicationEnvironmentVariable', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/environmentVariable`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentVariableRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to add an alias at application level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at application level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - Only 1 alias level is allowed. You can\'t create an alias on an alias 
         * @summary Create an environment variable alias at the application level
         * @param {string} applicationId Application ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationEnvironmentVariableAlias: async (applicationId: string, environmentVariableId: string, key?: Key, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('createApplicationEnvironmentVariableAlias', 'applicationId', applicationId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('createApplicationEnvironmentVariableAlias', 'environmentVariableId', environmentVariableId)
            const localVarPath = `/application/{applicationId}/environmentVariable/{environmentVariableId}/alias`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(key, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to override at application level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at application level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
         * @summary Create an environment variable override at the application level
         * @param {string} applicationId Application ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationEnvironmentVariableOverride: async (applicationId: string, environmentVariableId: string, value?: Value, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('createApplicationEnvironmentVariableOverride', 'applicationId', applicationId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('createApplicationEnvironmentVariableOverride', 'environmentVariableId', environmentVariableId)
            const localVarPath = `/application/{applicationId}/environmentVariable/{environmentVariableId}/override`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(value, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - To delete an environment variable from an application you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete an environment variable from an application
         * @param {string} applicationId Application ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationEnvironmentVariable: async (applicationId: string, environmentVariableId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('deleteApplicationEnvironmentVariable', 'applicationId', applicationId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('deleteApplicationEnvironmentVariable', 'environmentVariableId', environmentVariableId)
            const localVarPath = `/application/{applicationId}/environmentVariable/{environmentVariableId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit an environment variable belonging to the application
         * @param {string} applicationId Application ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editApplicationEnvironmentVariable: async (applicationId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('editApplicationEnvironmentVariable', 'applicationId', applicationId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('editApplicationEnvironmentVariable', 'environmentVariableId', environmentVariableId)
            // verify required parameter 'environmentVariableEditRequest' is not null or undefined
            assertParamExists('editApplicationEnvironmentVariable', 'environmentVariableEditRequest', environmentVariableEditRequest)
            const localVarPath = `/application/{applicationId}/environmentVariable/{environmentVariableId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentVariableEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Import environment variables in a defined scope, with a defined visibility.
         * @summary Import variables
         * @param {string} applicationId Application ID
         * @param {VariableImportRequest} [variableImportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importEnvironmentVariable: async (applicationId: string, variableImportRequest?: VariableImportRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('importEnvironmentVariable', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/environmentVariable/import`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(variableImportRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List environment variables
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationEnvironmentVariable: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('listApplicationEnvironmentVariable', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/environmentVariable`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationEnvironmentVariableApi - functional programming interface
 * @export
 */
export const ApplicationEnvironmentVariableApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationEnvironmentVariableApiAxiosParamCreator(configuration)
    return {
        /**
         * - Add an environment variable to the application. 
         * @summary Add an environment variable to the application
         * @param {string} applicationId Application ID
         * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplicationEnvironmentVariable(applicationId: string, environmentVariableRequest?: EnvironmentVariableRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariableResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplicationEnvironmentVariable(applicationId, environmentVariableRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - Allows you to add an alias at application level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at application level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - Only 1 alias level is allowed. You can\'t create an alias on an alias 
         * @summary Create an environment variable alias at the application level
         * @param {string} applicationId Application ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplicationEnvironmentVariableAlias(applicationId: string, environmentVariableId: string, key?: Key, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariableResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplicationEnvironmentVariableAlias(applicationId, environmentVariableId, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - Allows you to override at application level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at application level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
         * @summary Create an environment variable override at the application level
         * @param {string} applicationId Application ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplicationEnvironmentVariableOverride(applicationId: string, environmentVariableId: string, value?: Value, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariableResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplicationEnvironmentVariableOverride(applicationId, environmentVariableId, value, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - To delete an environment variable from an application you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete an environment variable from an application
         * @param {string} applicationId Application ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApplicationEnvironmentVariable(applicationId: string, environmentVariableId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApplicationEnvironmentVariable(applicationId, environmentVariableId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit an environment variable belonging to the application
         * @param {string} applicationId Application ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editApplicationEnvironmentVariable(applicationId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariableResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editApplicationEnvironmentVariable(applicationId, environmentVariableId, environmentVariableEditRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Import environment variables in a defined scope, with a defined visibility.
         * @summary Import variables
         * @param {string} applicationId Application ID
         * @param {VariableImportRequest} [variableImportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importEnvironmentVariable(applicationId: string, variableImportRequest?: VariableImportRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariableImportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importEnvironmentVariable(applicationId, variableImportRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List environment variables
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplicationEnvironmentVariable(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariableResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplicationEnvironmentVariable(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApplicationEnvironmentVariableApi - factory interface
 * @export
 */
export const ApplicationEnvironmentVariableApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationEnvironmentVariableApiFp(configuration)
    return {
        /**
         * - Add an environment variable to the application. 
         * @summary Add an environment variable to the application
         * @param {string} applicationId Application ID
         * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationEnvironmentVariable(applicationId: string, environmentVariableRequest?: EnvironmentVariableRequest, options?: any): AxiosPromise<EnvironmentVariableResponse> {
            return localVarFp.createApplicationEnvironmentVariable(applicationId, environmentVariableRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to add an alias at application level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at application level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - Only 1 alias level is allowed. You can\'t create an alias on an alias 
         * @summary Create an environment variable alias at the application level
         * @param {string} applicationId Application ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationEnvironmentVariableAlias(applicationId: string, environmentVariableId: string, key?: Key, options?: any): AxiosPromise<EnvironmentVariableResponse> {
            return localVarFp.createApplicationEnvironmentVariableAlias(applicationId, environmentVariableId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to override at application level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at application level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
         * @summary Create an environment variable override at the application level
         * @param {string} applicationId Application ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationEnvironmentVariableOverride(applicationId: string, environmentVariableId: string, value?: Value, options?: any): AxiosPromise<EnvironmentVariableResponse> {
            return localVarFp.createApplicationEnvironmentVariableOverride(applicationId, environmentVariableId, value, options).then((request) => request(axios, basePath));
        },
        /**
         * - To delete an environment variable from an application you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete an environment variable from an application
         * @param {string} applicationId Application ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationEnvironmentVariable(applicationId: string, environmentVariableId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteApplicationEnvironmentVariable(applicationId, environmentVariableId, options).then((request) => request(axios, basePath));
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit an environment variable belonging to the application
         * @param {string} applicationId Application ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editApplicationEnvironmentVariable(applicationId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options?: any): AxiosPromise<EnvironmentVariableResponse> {
            return localVarFp.editApplicationEnvironmentVariable(applicationId, environmentVariableId, environmentVariableEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Import environment variables in a defined scope, with a defined visibility.
         * @summary Import variables
         * @param {string} applicationId Application ID
         * @param {VariableImportRequest} [variableImportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importEnvironmentVariable(applicationId: string, variableImportRequest?: VariableImportRequest, options?: any): AxiosPromise<VariableImportResponse> {
            return localVarFp.importEnvironmentVariable(applicationId, variableImportRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List environment variables
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationEnvironmentVariable(applicationId: string, options?: any): AxiosPromise<EnvironmentVariableResponseList> {
            return localVarFp.listApplicationEnvironmentVariable(applicationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationEnvironmentVariableApi - object-oriented interface
 * @export
 * @class ApplicationEnvironmentVariableApi
 * @extends {BaseAPI}
 */
export class ApplicationEnvironmentVariableApi extends BaseAPI {
    /**
     * - Add an environment variable to the application. 
     * @summary Add an environment variable to the application
     * @param {string} applicationId Application ID
     * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationEnvironmentVariableApi
     */
    public createApplicationEnvironmentVariable(applicationId: string, environmentVariableRequest?: EnvironmentVariableRequest, options?: AxiosRequestConfig) {
        return ApplicationEnvironmentVariableApiFp(this.configuration).createApplicationEnvironmentVariable(applicationId, environmentVariableRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to add an alias at application level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at application level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - Only 1 alias level is allowed. You can\'t create an alias on an alias 
     * @summary Create an environment variable alias at the application level
     * @param {string} applicationId Application ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {Key} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationEnvironmentVariableApi
     */
    public createApplicationEnvironmentVariableAlias(applicationId: string, environmentVariableId: string, key?: Key, options?: AxiosRequestConfig) {
        return ApplicationEnvironmentVariableApiFp(this.configuration).createApplicationEnvironmentVariableAlias(applicationId, environmentVariableId, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to override at application level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at application level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
     * @summary Create an environment variable override at the application level
     * @param {string} applicationId Application ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {Value} [value] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationEnvironmentVariableApi
     */
    public createApplicationEnvironmentVariableOverride(applicationId: string, environmentVariableId: string, value?: Value, options?: AxiosRequestConfig) {
        return ApplicationEnvironmentVariableApiFp(this.configuration).createApplicationEnvironmentVariableOverride(applicationId, environmentVariableId, value, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - To delete an environment variable from an application you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
     * @summary Delete an environment variable from an application
     * @param {string} applicationId Application ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationEnvironmentVariableApi
     */
    public deleteApplicationEnvironmentVariable(applicationId: string, environmentVariableId: string, options?: AxiosRequestConfig) {
        return ApplicationEnvironmentVariableApiFp(this.configuration).deleteApplicationEnvironmentVariable(applicationId, environmentVariableId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
     * @summary Edit an environment variable belonging to the application
     * @param {string} applicationId Application ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationEnvironmentVariableApi
     */
    public editApplicationEnvironmentVariable(applicationId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options?: AxiosRequestConfig) {
        return ApplicationEnvironmentVariableApiFp(this.configuration).editApplicationEnvironmentVariable(applicationId, environmentVariableId, environmentVariableEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Import environment variables in a defined scope, with a defined visibility.
     * @summary Import variables
     * @param {string} applicationId Application ID
     * @param {VariableImportRequest} [variableImportRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationEnvironmentVariableApi
     */
    public importEnvironmentVariable(applicationId: string, variableImportRequest?: VariableImportRequest, options?: AxiosRequestConfig) {
        return ApplicationEnvironmentVariableApiFp(this.configuration).importEnvironmentVariable(applicationId, variableImportRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List environment variables
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationEnvironmentVariableApi
     */
    public listApplicationEnvironmentVariable(applicationId: string, options?: AxiosRequestConfig) {
        return ApplicationEnvironmentVariableApiFp(this.configuration).listApplicationEnvironmentVariable(applicationId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ApplicationEventApi - axios parameter creator
 * @export
 */
export const ApplicationEventApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter
         * @summary List application events
         * @param {string} applicationId Application ID
         * @param {string} [startId] Starting point after which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationEvent: async (applicationId: string, startId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('listApplicationEvent', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/event`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (startId !== undefined) {
                localVarQueryParameter['startId'] = startId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationEventApi - functional programming interface
 * @export
 */
export const ApplicationEventApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationEventApiAxiosParamCreator(configuration)
    return {
        /**
         * By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter
         * @summary List application events
         * @param {string} applicationId Application ID
         * @param {string} [startId] Starting point after which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplicationEvent(applicationId: string, startId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventPaginatedResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplicationEvent(applicationId, startId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApplicationEventApi - factory interface
 * @export
 */
export const ApplicationEventApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationEventApiFp(configuration)
    return {
        /**
         * By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter
         * @summary List application events
         * @param {string} applicationId Application ID
         * @param {string} [startId] Starting point after which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationEvent(applicationId: string, startId?: string, options?: any): AxiosPromise<EventPaginatedResponseList> {
            return localVarFp.listApplicationEvent(applicationId, startId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationEventApi - object-oriented interface
 * @export
 * @class ApplicationEventApi
 * @extends {BaseAPI}
 */
export class ApplicationEventApi extends BaseAPI {
    /**
     * By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter
     * @summary List application events
     * @param {string} applicationId Application ID
     * @param {string} [startId] Starting point after which to return results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationEventApi
     */
    public listApplicationEvent(applicationId: string, startId?: string, options?: AxiosRequestConfig) {
        return ApplicationEventApiFp(this.configuration).listApplicationEvent(applicationId, startId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ApplicationLogsApi - axios parameter creator
 * @export
 */
export const ApplicationLogsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This will list the last 1000 logs of the application
         * @summary List logs
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationLog: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('listApplicationLog', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/log`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationLogsApi - functional programming interface
 * @export
 */
export const ApplicationLogsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationLogsApiAxiosParamCreator(configuration)
    return {
        /**
         * This will list the last 1000 logs of the application
         * @summary List logs
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplicationLog(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplicationLog(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApplicationLogsApi - factory interface
 * @export
 */
export const ApplicationLogsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationLogsApiFp(configuration)
    return {
        /**
         * This will list the last 1000 logs of the application
         * @summary List logs
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationLog(applicationId: string, options?: any): AxiosPromise<LogResponseList> {
            return localVarFp.listApplicationLog(applicationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationLogsApi - object-oriented interface
 * @export
 * @class ApplicationLogsApi
 * @extends {BaseAPI}
 */
export class ApplicationLogsApi extends BaseAPI {
    /**
     * This will list the last 1000 logs of the application
     * @summary List logs
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationLogsApi
     */
    public listApplicationLog(applicationId: string, options?: AxiosRequestConfig) {
        return ApplicationLogsApiFp(this.configuration).listApplicationLog(applicationId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ApplicationMainCallsApi - axios parameter creator
 * @export
 */
export const ApplicationMainCallsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add application tag
         * @param {string} applicationId Application ID
         * @param {TagRequest} [tagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationTag: async (applicationId: string, tagRequest?: TagRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('createApplicationTag', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/tag`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To delete the application you must have the admin permission
         * @summary Delete application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplication: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('deleteApplication', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete application tag
         * @param {string} applicationId Application ID
         * @param {string} tagId Tag ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationTag: async (applicationId: string, tagId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('deleteApplicationTag', 'applicationId', applicationId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('deleteApplicationTag', 'tagId', tagId)
            const localVarPath = `/application/{applicationId}/tag/{tagId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - To edit the application you must have the admin permission. - For port edition, if you provide a port id, we will update the corresponding port. If you don\'t we will create a new one. If you remove a port from the payload, we will delete it. - For storage edition, if you provide a storage id, we will update the corresponding storage. If you don\'t we will create a new one. If you remove a storage from the payload, we will delete it. 
         * @summary Edit application
         * @param {string} applicationId Application ID
         * @param {ApplicationEditRequest} [applicationEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editApplication: async (applicationId: string, applicationEditRequest?: ApplicationEditRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('editApplication', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(applicationEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get application by ID
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplication: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getApplication', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get application status
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationStatus: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getApplicationStatus', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/status`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns list of the last 100 commits made on the repository linked to the application
         * @summary List last commits
         * @param {string} applicationId Application ID
         * @param {string} [startId] Starting point after which to return results
         * @param {string} [gitCommitId] Git Commit ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationCommit: async (applicationId: string, startId?: string, gitCommitId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('listApplicationCommit', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/commit`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (startId !== undefined) {
                localVarQueryParameter['startId'] = startId;
            }

            if (gitCommitId !== undefined) {
                localVarQueryParameter['gitCommitId'] = gitCommitId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List contributors
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationContributor: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('listApplicationContributor', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/contributor`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This will return all the custom domains and Qovery autogenerated domain for the given application
         * @summary List all URLs of the application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationLinks: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('listApplicationLinks', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/link`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List tags
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationTag: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('listApplicationTag', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/tag`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationMainCallsApi - functional programming interface
 * @export
 */
export const ApplicationMainCallsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationMainCallsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add application tag
         * @param {string} applicationId Application ID
         * @param {TagRequest} [tagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplicationTag(applicationId: string, tagRequest?: TagRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplicationTag(applicationId, tagRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * To delete the application you must have the admin permission
         * @summary Delete application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApplication(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApplication(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete application tag
         * @param {string} applicationId Application ID
         * @param {string} tagId Tag ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApplicationTag(applicationId: string, tagId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApplicationTag(applicationId, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - To edit the application you must have the admin permission. - For port edition, if you provide a port id, we will update the corresponding port. If you don\'t we will create a new one. If you remove a port from the payload, we will delete it. - For storage edition, if you provide a storage id, we will update the corresponding storage. If you don\'t we will create a new one. If you remove a storage from the payload, we will delete it. 
         * @summary Edit application
         * @param {string} applicationId Application ID
         * @param {ApplicationEditRequest} [applicationEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editApplication(applicationId: string, applicationEditRequest?: ApplicationEditRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editApplication(applicationId, applicationEditRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get application by ID
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplication(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplication(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get application status
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationStatus(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationStatus(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns list of the last 100 commits made on the repository linked to the application
         * @summary List last commits
         * @param {string} applicationId Application ID
         * @param {string} [startId] Starting point after which to return results
         * @param {string} [gitCommitId] Git Commit ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplicationCommit(applicationId: string, startId?: string, gitCommitId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommitResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplicationCommit(applicationId, startId, gitCommitId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List contributors
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplicationContributor(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplicationContributor(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This will return all the custom domains and Qovery autogenerated domain for the given application
         * @summary List all URLs of the application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplicationLinks(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplicationLinks(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List tags
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplicationTag(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplicationTag(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApplicationMainCallsApi - factory interface
 * @export
 */
export const ApplicationMainCallsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationMainCallsApiFp(configuration)
    return {
        /**
         * 
         * @summary Add application tag
         * @param {string} applicationId Application ID
         * @param {TagRequest} [tagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationTag(applicationId: string, tagRequest?: TagRequest, options?: any): AxiosPromise<TagResponseList> {
            return localVarFp.createApplicationTag(applicationId, tagRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * To delete the application you must have the admin permission
         * @summary Delete application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplication(applicationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteApplication(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete application tag
         * @param {string} applicationId Application ID
         * @param {string} tagId Tag ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationTag(applicationId: string, tagId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteApplicationTag(applicationId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * - To edit the application you must have the admin permission. - For port edition, if you provide a port id, we will update the corresponding port. If you don\'t we will create a new one. If you remove a port from the payload, we will delete it. - For storage edition, if you provide a storage id, we will update the corresponding storage. If you don\'t we will create a new one. If you remove a storage from the payload, we will delete it. 
         * @summary Edit application
         * @param {string} applicationId Application ID
         * @param {ApplicationEditRequest} [applicationEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editApplication(applicationId: string, applicationEditRequest?: ApplicationEditRequest, options?: any): AxiosPromise<ApplicationResponse> {
            return localVarFp.editApplication(applicationId, applicationEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get application by ID
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplication(applicationId: string, options?: any): AxiosPromise<ApplicationResponse> {
            return localVarFp.getApplication(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get application status
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationStatus(applicationId: string, options?: any): AxiosPromise<Status> {
            return localVarFp.getApplicationStatus(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns list of the last 100 commits made on the repository linked to the application
         * @summary List last commits
         * @param {string} applicationId Application ID
         * @param {string} [startId] Starting point after which to return results
         * @param {string} [gitCommitId] Git Commit ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationCommit(applicationId: string, startId?: string, gitCommitId?: string, options?: any): AxiosPromise<CommitResponseList> {
            return localVarFp.listApplicationCommit(applicationId, startId, gitCommitId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List contributors
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationContributor(applicationId: string, options?: any): AxiosPromise<UserResponseList> {
            return localVarFp.listApplicationContributor(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * This will return all the custom domains and Qovery autogenerated domain for the given application
         * @summary List all URLs of the application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationLinks(applicationId: string, options?: any): AxiosPromise<LinkResponseList> {
            return localVarFp.listApplicationLinks(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List tags
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationTag(applicationId: string, options?: any): AxiosPromise<TagResponseList> {
            return localVarFp.listApplicationTag(applicationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationMainCallsApi - object-oriented interface
 * @export
 * @class ApplicationMainCallsApi
 * @extends {BaseAPI}
 */
export class ApplicationMainCallsApi extends BaseAPI {
    /**
     * 
     * @summary Add application tag
     * @param {string} applicationId Application ID
     * @param {TagRequest} [tagRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationMainCallsApi
     */
    public createApplicationTag(applicationId: string, tagRequest?: TagRequest, options?: AxiosRequestConfig) {
        return ApplicationMainCallsApiFp(this.configuration).createApplicationTag(applicationId, tagRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To delete the application you must have the admin permission
     * @summary Delete application
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationMainCallsApi
     */
    public deleteApplication(applicationId: string, options?: AxiosRequestConfig) {
        return ApplicationMainCallsApiFp(this.configuration).deleteApplication(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete application tag
     * @param {string} applicationId Application ID
     * @param {string} tagId Tag ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationMainCallsApi
     */
    public deleteApplicationTag(applicationId: string, tagId: string, options?: AxiosRequestConfig) {
        return ApplicationMainCallsApiFp(this.configuration).deleteApplicationTag(applicationId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - To edit the application you must have the admin permission. - For port edition, if you provide a port id, we will update the corresponding port. If you don\'t we will create a new one. If you remove a port from the payload, we will delete it. - For storage edition, if you provide a storage id, we will update the corresponding storage. If you don\'t we will create a new one. If you remove a storage from the payload, we will delete it. 
     * @summary Edit application
     * @param {string} applicationId Application ID
     * @param {ApplicationEditRequest} [applicationEditRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationMainCallsApi
     */
    public editApplication(applicationId: string, applicationEditRequest?: ApplicationEditRequest, options?: AxiosRequestConfig) {
        return ApplicationMainCallsApiFp(this.configuration).editApplication(applicationId, applicationEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get application by ID
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationMainCallsApi
     */
    public getApplication(applicationId: string, options?: AxiosRequestConfig) {
        return ApplicationMainCallsApiFp(this.configuration).getApplication(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get application status
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationMainCallsApi
     */
    public getApplicationStatus(applicationId: string, options?: AxiosRequestConfig) {
        return ApplicationMainCallsApiFp(this.configuration).getApplicationStatus(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns list of the last 100 commits made on the repository linked to the application
     * @summary List last commits
     * @param {string} applicationId Application ID
     * @param {string} [startId] Starting point after which to return results
     * @param {string} [gitCommitId] Git Commit ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationMainCallsApi
     */
    public listApplicationCommit(applicationId: string, startId?: string, gitCommitId?: string, options?: AxiosRequestConfig) {
        return ApplicationMainCallsApiFp(this.configuration).listApplicationCommit(applicationId, startId, gitCommitId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List contributors
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationMainCallsApi
     */
    public listApplicationContributor(applicationId: string, options?: AxiosRequestConfig) {
        return ApplicationMainCallsApiFp(this.configuration).listApplicationContributor(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will return all the custom domains and Qovery autogenerated domain for the given application
     * @summary List all URLs of the application
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationMainCallsApi
     */
    public listApplicationLinks(applicationId: string, options?: AxiosRequestConfig) {
        return ApplicationMainCallsApiFp(this.configuration).listApplicationLinks(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List tags
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationMainCallsApi
     */
    public listApplicationTag(applicationId: string, options?: AxiosRequestConfig) {
        return ApplicationMainCallsApiFp(this.configuration).listApplicationTag(applicationId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ApplicationMetricsApi - axios parameter creator
 * @export
 */
export const ApplicationMetricsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List currently running instances of the application with their CPU and RAM metrics
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationCurrentInstance: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getApplicationCurrentInstance', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/instance`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns min, max, and running number of instances of the application
         * @summary Get current scaling of the application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationCurrentScale: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getApplicationCurrentScale', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/currentScale`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List current storage disk usage
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationCurrentStorageDisk: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getApplicationCurrentStorageDisk', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/currentStorage`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get CPU consumption metric over time for the application
         * @param {string} applicationId Application ID
         * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationMetricCpu: async (applicationId: string, lastSeconds: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getApplicationMetricCpu', 'applicationId', applicationId)
            // verify required parameter 'lastSeconds' is not null or undefined
            assertParamExists('getApplicationMetricCpu', 'lastSeconds', lastSeconds)
            const localVarPath = `/application/{applicationId}/metric/cpu`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (lastSeconds !== undefined) {
                localVarQueryParameter['lastSeconds'] = lastSeconds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The value returned corresponds to the 95th centile
         * @summary Get Health Check latency  metric over time for the application
         * @param {string} applicationId Application ID
         * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationMetricHealthCheck: async (applicationId: string, lastSeconds: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getApplicationMetricHealthCheck', 'applicationId', applicationId)
            // verify required parameter 'lastSeconds' is not null or undefined
            assertParamExists('getApplicationMetricHealthCheck', 'lastSeconds', lastSeconds)
            const localVarPath = `/application/{applicationId}/metric/healthCheck`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (lastSeconds !== undefined) {
                localVarQueryParameter['lastSeconds'] = lastSeconds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Memory consumption metric over time for the application
         * @param {string} applicationId Application ID
         * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationMetricMemory: async (applicationId: string, lastSeconds: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getApplicationMetricMemory', 'applicationId', applicationId)
            // verify required parameter 'lastSeconds' is not null or undefined
            assertParamExists('getApplicationMetricMemory', 'lastSeconds', lastSeconds)
            const localVarPath = `/application/{applicationId}/metric/memory`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (lastSeconds !== undefined) {
                localVarQueryParameter['lastSeconds'] = lastSeconds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get application restart message and timestamp.
         * @summary List application restarts
         * @param {string} applicationId Application ID
         * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationMetricRestart: async (applicationId: string, lastSeconds: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getApplicationMetricRestart', 'applicationId', applicationId)
            // verify required parameter 'lastSeconds' is not null or undefined
            assertParamExists('getApplicationMetricRestart', 'lastSeconds', lastSeconds)
            const localVarPath = `/application/{applicationId}/metric/restart`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (lastSeconds !== undefined) {
                localVarQueryParameter['lastSeconds'] = lastSeconds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Storage consumption metric over time for the application
         * @param {string} applicationId Application ID
         * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationMetricStorage: async (applicationId: string, lastSeconds: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getApplicationMetricStorage', 'applicationId', applicationId)
            // verify required parameter 'lastSeconds' is not null or undefined
            assertParamExists('getApplicationMetricStorage', 'lastSeconds', lastSeconds)
            const localVarPath = `/application/{applicationId}/metric/storage`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (lastSeconds !== undefined) {
                localVarQueryParameter['lastSeconds'] = lastSeconds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationMetricsApi - functional programming interface
 * @export
 */
export const ApplicationMetricsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationMetricsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List currently running instances of the application with their CPU and RAM metrics
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationCurrentInstance(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InstanceResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationCurrentInstance(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns min, max, and running number of instances of the application
         * @summary Get current scaling of the application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationCurrentScale(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationCurrentScaleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationCurrentScale(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List current storage disk usage
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationCurrentStorageDisk(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StorageDiskResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationCurrentStorageDisk(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get CPU consumption metric over time for the application
         * @param {string} applicationId Application ID
         * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationMetricCpu(applicationId: string, lastSeconds: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricCPUResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationMetricCpu(applicationId, lastSeconds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The value returned corresponds to the 95th centile
         * @summary Get Health Check latency  metric over time for the application
         * @param {string} applicationId Application ID
         * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationMetricHealthCheck(applicationId: string, lastSeconds: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricGenericResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationMetricHealthCheck(applicationId, lastSeconds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Memory consumption metric over time for the application
         * @param {string} applicationId Application ID
         * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationMetricMemory(applicationId: string, lastSeconds: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricMemoryResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationMetricMemory(applicationId, lastSeconds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get application restart message and timestamp.
         * @summary List application restarts
         * @param {string} applicationId Application ID
         * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationMetricRestart(applicationId: string, lastSeconds: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricRestartResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationMetricRestart(applicationId, lastSeconds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Storage consumption metric over time for the application
         * @param {string} applicationId Application ID
         * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationMetricStorage(applicationId: string, lastSeconds: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricStorageResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationMetricStorage(applicationId, lastSeconds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApplicationMetricsApi - factory interface
 * @export
 */
export const ApplicationMetricsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationMetricsApiFp(configuration)
    return {
        /**
         * 
         * @summary List currently running instances of the application with their CPU and RAM metrics
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationCurrentInstance(applicationId: string, options?: any): AxiosPromise<InstanceResponseList> {
            return localVarFp.getApplicationCurrentInstance(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns min, max, and running number of instances of the application
         * @summary Get current scaling of the application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationCurrentScale(applicationId: string, options?: any): AxiosPromise<ApplicationCurrentScaleResponse> {
            return localVarFp.getApplicationCurrentScale(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List current storage disk usage
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationCurrentStorageDisk(applicationId: string, options?: any): AxiosPromise<StorageDiskResponseList> {
            return localVarFp.getApplicationCurrentStorageDisk(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get CPU consumption metric over time for the application
         * @param {string} applicationId Application ID
         * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationMetricCpu(applicationId: string, lastSeconds: number, options?: any): AxiosPromise<MetricCPUResponseList> {
            return localVarFp.getApplicationMetricCpu(applicationId, lastSeconds, options).then((request) => request(axios, basePath));
        },
        /**
         * The value returned corresponds to the 95th centile
         * @summary Get Health Check latency  metric over time for the application
         * @param {string} applicationId Application ID
         * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationMetricHealthCheck(applicationId: string, lastSeconds: number, options?: any): AxiosPromise<MetricGenericResponseList> {
            return localVarFp.getApplicationMetricHealthCheck(applicationId, lastSeconds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Memory consumption metric over time for the application
         * @param {string} applicationId Application ID
         * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationMetricMemory(applicationId: string, lastSeconds: number, options?: any): AxiosPromise<MetricMemoryResponseList> {
            return localVarFp.getApplicationMetricMemory(applicationId, lastSeconds, options).then((request) => request(axios, basePath));
        },
        /**
         * Get application restart message and timestamp.
         * @summary List application restarts
         * @param {string} applicationId Application ID
         * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationMetricRestart(applicationId: string, lastSeconds: number, options?: any): AxiosPromise<MetricRestartResponse> {
            return localVarFp.getApplicationMetricRestart(applicationId, lastSeconds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Storage consumption metric over time for the application
         * @param {string} applicationId Application ID
         * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationMetricStorage(applicationId: string, lastSeconds: number, options?: any): AxiosPromise<MetricStorageResponseList> {
            return localVarFp.getApplicationMetricStorage(applicationId, lastSeconds, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationMetricsApi - object-oriented interface
 * @export
 * @class ApplicationMetricsApi
 * @extends {BaseAPI}
 */
export class ApplicationMetricsApi extends BaseAPI {
    /**
     * 
     * @summary List currently running instances of the application with their CPU and RAM metrics
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationMetricsApi
     */
    public getApplicationCurrentInstance(applicationId: string, options?: AxiosRequestConfig) {
        return ApplicationMetricsApiFp(this.configuration).getApplicationCurrentInstance(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns min, max, and running number of instances of the application
     * @summary Get current scaling of the application
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationMetricsApi
     */
    public getApplicationCurrentScale(applicationId: string, options?: AxiosRequestConfig) {
        return ApplicationMetricsApiFp(this.configuration).getApplicationCurrentScale(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List current storage disk usage
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationMetricsApi
     */
    public getApplicationCurrentStorageDisk(applicationId: string, options?: AxiosRequestConfig) {
        return ApplicationMetricsApiFp(this.configuration).getApplicationCurrentStorageDisk(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get CPU consumption metric over time for the application
     * @param {string} applicationId Application ID
     * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationMetricsApi
     */
    public getApplicationMetricCpu(applicationId: string, lastSeconds: number, options?: AxiosRequestConfig) {
        return ApplicationMetricsApiFp(this.configuration).getApplicationMetricCpu(applicationId, lastSeconds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The value returned corresponds to the 95th centile
     * @summary Get Health Check latency  metric over time for the application
     * @param {string} applicationId Application ID
     * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationMetricsApi
     */
    public getApplicationMetricHealthCheck(applicationId: string, lastSeconds: number, options?: AxiosRequestConfig) {
        return ApplicationMetricsApiFp(this.configuration).getApplicationMetricHealthCheck(applicationId, lastSeconds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Memory consumption metric over time for the application
     * @param {string} applicationId Application ID
     * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationMetricsApi
     */
    public getApplicationMetricMemory(applicationId: string, lastSeconds: number, options?: AxiosRequestConfig) {
        return ApplicationMetricsApiFp(this.configuration).getApplicationMetricMemory(applicationId, lastSeconds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get application restart message and timestamp.
     * @summary List application restarts
     * @param {string} applicationId Application ID
     * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationMetricsApi
     */
    public getApplicationMetricRestart(applicationId: string, lastSeconds: number, options?: AxiosRequestConfig) {
        return ApplicationMetricsApiFp(this.configuration).getApplicationMetricRestart(applicationId, lastSeconds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Storage consumption metric over time for the application
     * @param {string} applicationId Application ID
     * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationMetricsApi
     */
    public getApplicationMetricStorage(applicationId: string, lastSeconds: number, options?: AxiosRequestConfig) {
        return ApplicationMetricsApiFp(this.configuration).getApplicationMetricStorage(applicationId, lastSeconds, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ApplicationSecretApi - axios parameter creator
 * @export
 */
export const ApplicationSecretApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * - Add a secret to the application. 
         * @summary Add a secret to the application
         * @param {string} applicationId Application ID
         * @param {SecretRequest} [secretRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationSecret: async (applicationId: string, secretRequest?: SecretRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('createApplicationSecret', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/secret`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(secretRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to add an alias at application level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at application level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - Only 1 alias level is allowed. You can\'t create an alias on an alias 
         * @summary Create a secret alias at the application level
         * @param {string} applicationId Application ID
         * @param {string} secretId Secret ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationSecretAlias: async (applicationId: string, secretId: string, key?: Key, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('createApplicationSecretAlias', 'applicationId', applicationId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('createApplicationSecretAlias', 'secretId', secretId)
            const localVarPath = `/application/{applicationId}/secret/{secretId}/alias`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(key, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to override at application level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at application level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
         * @summary Create a secret override at the application level
         * @param {string} applicationId Application ID
         * @param {string} secretId Secret ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationSecretOverride: async (applicationId: string, secretId: string, value?: Value, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('createApplicationSecretOverride', 'applicationId', applicationId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('createApplicationSecretOverride', 'secretId', secretId)
            const localVarPath = `/application/{applicationId}/secret/{secretId}/override`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(value, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete a secret from an application
         * @param {string} applicationId Application ID
         * @param {string} secretId Secret ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationSecret: async (applicationId: string, secretId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('deleteApplicationSecret', 'applicationId', applicationId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('deleteApplicationSecret', 'secretId', secretId)
            const localVarPath = `/application/{applicationId}/secret/{secretId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit a secret belonging to the application
         * @param {string} applicationId Application ID
         * @param {string} secretId Secret ID
         * @param {SecretEditRequest} secretEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editApplicationSecret: async (applicationId: string, secretId: string, secretEditRequest: SecretEditRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('editApplicationSecret', 'applicationId', applicationId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('editApplicationSecret', 'secretId', secretId)
            // verify required parameter 'secretEditRequest' is not null or undefined
            assertParamExists('editApplicationSecret', 'secretEditRequest', secretEditRequest)
            const localVarPath = `/application/{applicationId}/secret/{secretId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(secretEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Secrets are like environment variables, but they are secured and can\'t be revealed.
         * @summary List application secrets
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationSecrets: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('listApplicationSecrets', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/secret`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationSecretApi - functional programming interface
 * @export
 */
export const ApplicationSecretApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationSecretApiAxiosParamCreator(configuration)
    return {
        /**
         * - Add a secret to the application. 
         * @summary Add a secret to the application
         * @param {string} applicationId Application ID
         * @param {SecretRequest} [secretRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplicationSecret(applicationId: string, secretRequest?: SecretRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecretResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplicationSecret(applicationId, secretRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - Allows you to add an alias at application level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at application level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - Only 1 alias level is allowed. You can\'t create an alias on an alias 
         * @summary Create a secret alias at the application level
         * @param {string} applicationId Application ID
         * @param {string} secretId Secret ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplicationSecretAlias(applicationId: string, secretId: string, key?: Key, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecretResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplicationSecretAlias(applicationId, secretId, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - Allows you to override at application level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at application level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
         * @summary Create a secret override at the application level
         * @param {string} applicationId Application ID
         * @param {string} secretId Secret ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplicationSecretOverride(applicationId: string, secretId: string, value?: Value, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecretResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplicationSecretOverride(applicationId, secretId, value, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete a secret from an application
         * @param {string} applicationId Application ID
         * @param {string} secretId Secret ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApplicationSecret(applicationId: string, secretId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApplicationSecret(applicationId, secretId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit a secret belonging to the application
         * @param {string} applicationId Application ID
         * @param {string} secretId Secret ID
         * @param {SecretEditRequest} secretEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editApplicationSecret(applicationId: string, secretId: string, secretEditRequest: SecretEditRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecretResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editApplicationSecret(applicationId, secretId, secretEditRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Secrets are like environment variables, but they are secured and can\'t be revealed.
         * @summary List application secrets
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplicationSecrets(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecretResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplicationSecrets(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApplicationSecretApi - factory interface
 * @export
 */
export const ApplicationSecretApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationSecretApiFp(configuration)
    return {
        /**
         * - Add a secret to the application. 
         * @summary Add a secret to the application
         * @param {string} applicationId Application ID
         * @param {SecretRequest} [secretRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationSecret(applicationId: string, secretRequest?: SecretRequest, options?: any): AxiosPromise<SecretResponse> {
            return localVarFp.createApplicationSecret(applicationId, secretRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to add an alias at application level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at application level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - Only 1 alias level is allowed. You can\'t create an alias on an alias 
         * @summary Create a secret alias at the application level
         * @param {string} applicationId Application ID
         * @param {string} secretId Secret ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationSecretAlias(applicationId: string, secretId: string, key?: Key, options?: any): AxiosPromise<SecretResponse> {
            return localVarFp.createApplicationSecretAlias(applicationId, secretId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to override at application level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at application level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
         * @summary Create a secret override at the application level
         * @param {string} applicationId Application ID
         * @param {string} secretId Secret ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationSecretOverride(applicationId: string, secretId: string, value?: Value, options?: any): AxiosPromise<SecretResponse> {
            return localVarFp.createApplicationSecretOverride(applicationId, secretId, value, options).then((request) => request(axios, basePath));
        },
        /**
         * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete a secret from an application
         * @param {string} applicationId Application ID
         * @param {string} secretId Secret ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationSecret(applicationId: string, secretId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteApplicationSecret(applicationId, secretId, options).then((request) => request(axios, basePath));
        },
        /**
         * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit a secret belonging to the application
         * @param {string} applicationId Application ID
         * @param {string} secretId Secret ID
         * @param {SecretEditRequest} secretEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editApplicationSecret(applicationId: string, secretId: string, secretEditRequest: SecretEditRequest, options?: any): AxiosPromise<SecretResponse> {
            return localVarFp.editApplicationSecret(applicationId, secretId, secretEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Secrets are like environment variables, but they are secured and can\'t be revealed.
         * @summary List application secrets
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationSecrets(applicationId: string, options?: any): AxiosPromise<SecretResponseList> {
            return localVarFp.listApplicationSecrets(applicationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationSecretApi - object-oriented interface
 * @export
 * @class ApplicationSecretApi
 * @extends {BaseAPI}
 */
export class ApplicationSecretApi extends BaseAPI {
    /**
     * - Add a secret to the application. 
     * @summary Add a secret to the application
     * @param {string} applicationId Application ID
     * @param {SecretRequest} [secretRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationSecretApi
     */
    public createApplicationSecret(applicationId: string, secretRequest?: SecretRequest, options?: AxiosRequestConfig) {
        return ApplicationSecretApiFp(this.configuration).createApplicationSecret(applicationId, secretRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to add an alias at application level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at application level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - Only 1 alias level is allowed. You can\'t create an alias on an alias 
     * @summary Create a secret alias at the application level
     * @param {string} applicationId Application ID
     * @param {string} secretId Secret ID
     * @param {Key} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationSecretApi
     */
    public createApplicationSecretAlias(applicationId: string, secretId: string, key?: Key, options?: AxiosRequestConfig) {
        return ApplicationSecretApiFp(this.configuration).createApplicationSecretAlias(applicationId, secretId, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to override at application level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at application level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
     * @summary Create a secret override at the application level
     * @param {string} applicationId Application ID
     * @param {string} secretId Secret ID
     * @param {Value} [value] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationSecretApi
     */
    public createApplicationSecretOverride(applicationId: string, secretId: string, value?: Value, options?: AxiosRequestConfig) {
        return ApplicationSecretApiFp(this.configuration).createApplicationSecretOverride(applicationId, secretId, value, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well 
     * @summary Delete a secret from an application
     * @param {string} applicationId Application ID
     * @param {string} secretId Secret ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationSecretApi
     */
    public deleteApplicationSecret(applicationId: string, secretId: string, options?: AxiosRequestConfig) {
        return ApplicationSecretApiFp(this.configuration).deleteApplicationSecret(applicationId, secretId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
     * @summary Edit a secret belonging to the application
     * @param {string} applicationId Application ID
     * @param {string} secretId Secret ID
     * @param {SecretEditRequest} secretEditRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationSecretApi
     */
    public editApplicationSecret(applicationId: string, secretId: string, secretEditRequest: SecretEditRequest, options?: AxiosRequestConfig) {
        return ApplicationSecretApiFp(this.configuration).editApplicationSecret(applicationId, secretId, secretEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Secrets are like environment variables, but they are secured and can\'t be revealed.
     * @summary List application secrets
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationSecretApi
     */
    public listApplicationSecrets(applicationId: string, options?: AxiosRequestConfig) {
        return ApplicationSecretApiFp(this.configuration).listApplicationSecrets(applicationId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ApplicationsApi - axios parameter creator
 * @export
 */
export const ApplicationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create an application
         * @param {string} environmentId Environment ID
         * @param {ApplicationRequest} [applicationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplication: async (environmentId: string, applicationRequest?: ApplicationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('createApplication', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/application`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(applicationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deploy to the last commit the applications you specified.
         * @summary Deploy applications
         * @param {string} environmentId Environment ID
         * @param {InlineObject1} [inlineObject1] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployAllApplications: async (environmentId: string, inlineObject1?: InlineObject1, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('deployAllApplications', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/application/deploy`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject1, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List running instances with CPU and RAM usage for each application
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentApplicationCurrentInstance: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('getEnvironmentApplicationCurrentInstance', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/application/instance`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns min, max, and running number of instances for each application
         * @summary List current scaling information for each application
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentApplicationCurrentScale: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('getEnvironmentApplicationCurrentScale', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/application/currentScale`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List current storage disk usage for each application
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentApplicationCurrentStorage: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('getEnvironmentApplicationCurrentStorage', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/application/currentStorage`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of applications with only their id and status.
         * @summary List all environment applications statuses
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentApplicationStatus: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('getEnvironmentApplicationStatus', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/application/status`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns list of languages supported by Buildpacks.
         * @summary List supported languages
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentApplicationSupportedLanguages: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('getEnvironmentApplicationSupportedLanguages', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/application/supportedLanguage`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List applications
         * @param {string} environmentId Environment ID
         * @param {boolean} [toUpdate] return (or not) results that must be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplication: async (environmentId: string, toUpdate?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('listApplication', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/application`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (toUpdate !== undefined) {
                localVarQueryParameter['toUpdate'] = toUpdate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationsApi - functional programming interface
 * @export
 */
export const ApplicationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create an application
         * @param {string} environmentId Environment ID
         * @param {ApplicationRequest} [applicationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplication(environmentId: string, applicationRequest?: ApplicationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplication(environmentId, applicationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deploy to the last commit the applications you specified.
         * @summary Deploy applications
         * @param {string} environmentId Environment ID
         * @param {InlineObject1} [inlineObject1] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployAllApplications(environmentId: string, inlineObject1?: InlineObject1, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployAllApplications(environmentId, inlineObject1, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List running instances with CPU and RAM usage for each application
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironmentApplicationCurrentInstance(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentApplicationsInstanceResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironmentApplicationCurrentInstance(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns min, max, and running number of instances for each application
         * @summary List current scaling information for each application
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironmentApplicationCurrentScale(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentApplicationsCurrentScaleResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironmentApplicationCurrentScale(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List current storage disk usage for each application
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironmentApplicationCurrentStorage(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentApplicationsStorageResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironmentApplicationCurrentStorage(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of applications with only their id and status.
         * @summary List all environment applications statuses
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironmentApplicationStatus(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReferenceObjectStatusResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironmentApplicationStatus(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns list of languages supported by Buildpacks.
         * @summary List supported languages
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironmentApplicationSupportedLanguages(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentApplicationsSupportedLanguageList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironmentApplicationSupportedLanguages(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List applications
         * @param {string} environmentId Environment ID
         * @param {boolean} [toUpdate] return (or not) results that must be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplication(environmentId: string, toUpdate?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplication(environmentId, toUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApplicationsApi - factory interface
 * @export
 */
export const ApplicationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create an application
         * @param {string} environmentId Environment ID
         * @param {ApplicationRequest} [applicationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplication(environmentId: string, applicationRequest?: ApplicationRequest, options?: any): AxiosPromise<ApplicationResponse> {
            return localVarFp.createApplication(environmentId, applicationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deploy to the last commit the applications you specified.
         * @summary Deploy applications
         * @param {string} environmentId Environment ID
         * @param {InlineObject1} [inlineObject1] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployAllApplications(environmentId: string, inlineObject1?: InlineObject1, options?: any): AxiosPromise<Status> {
            return localVarFp.deployAllApplications(environmentId, inlineObject1, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List running instances with CPU and RAM usage for each application
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentApplicationCurrentInstance(environmentId: string, options?: any): AxiosPromise<EnvironmentApplicationsInstanceResponseList> {
            return localVarFp.getEnvironmentApplicationCurrentInstance(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns min, max, and running number of instances for each application
         * @summary List current scaling information for each application
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentApplicationCurrentScale(environmentId: string, options?: any): AxiosPromise<EnvironmentApplicationsCurrentScaleResponseList> {
            return localVarFp.getEnvironmentApplicationCurrentScale(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List current storage disk usage for each application
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentApplicationCurrentStorage(environmentId: string, options?: any): AxiosPromise<EnvironmentApplicationsStorageResponseList> {
            return localVarFp.getEnvironmentApplicationCurrentStorage(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of applications with only their id and status.
         * @summary List all environment applications statuses
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentApplicationStatus(environmentId: string, options?: any): AxiosPromise<ReferenceObjectStatusResponseList> {
            return localVarFp.getEnvironmentApplicationStatus(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns list of languages supported by Buildpacks.
         * @summary List supported languages
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentApplicationSupportedLanguages(environmentId: string, options?: any): AxiosPromise<EnvironmentApplicationsSupportedLanguageList> {
            return localVarFp.getEnvironmentApplicationSupportedLanguages(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List applications
         * @param {string} environmentId Environment ID
         * @param {boolean} [toUpdate] return (or not) results that must be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplication(environmentId: string, toUpdate?: boolean, options?: any): AxiosPromise<ApplicationResponseList> {
            return localVarFp.listApplication(environmentId, toUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationsApi - object-oriented interface
 * @export
 * @class ApplicationsApi
 * @extends {BaseAPI}
 */
export class ApplicationsApi extends BaseAPI {
    /**
     * 
     * @summary Create an application
     * @param {string} environmentId Environment ID
     * @param {ApplicationRequest} [applicationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public createApplication(environmentId: string, applicationRequest?: ApplicationRequest, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).createApplication(environmentId, applicationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deploy to the last commit the applications you specified.
     * @summary Deploy applications
     * @param {string} environmentId Environment ID
     * @param {InlineObject1} [inlineObject1] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public deployAllApplications(environmentId: string, inlineObject1?: InlineObject1, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).deployAllApplications(environmentId, inlineObject1, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List running instances with CPU and RAM usage for each application
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public getEnvironmentApplicationCurrentInstance(environmentId: string, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).getEnvironmentApplicationCurrentInstance(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns min, max, and running number of instances for each application
     * @summary List current scaling information for each application
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public getEnvironmentApplicationCurrentScale(environmentId: string, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).getEnvironmentApplicationCurrentScale(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List current storage disk usage for each application
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public getEnvironmentApplicationCurrentStorage(environmentId: string, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).getEnvironmentApplicationCurrentStorage(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of applications with only their id and status.
     * @summary List all environment applications statuses
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public getEnvironmentApplicationStatus(environmentId: string, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).getEnvironmentApplicationStatus(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns list of languages supported by Buildpacks.
     * @summary List supported languages
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public getEnvironmentApplicationSupportedLanguages(environmentId: string, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).getEnvironmentApplicationSupportedLanguages(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List applications
     * @param {string} environmentId Environment ID
     * @param {boolean} [toUpdate] return (or not) results that must be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public listApplication(environmentId: string, toUpdate?: boolean, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).listApplication(environmentId, toUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BackupsApi - axios parameter creator
 * @export
 */
export const BackupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a backup to the Database 
         * @param {string} databaseId Database ID
         * @param {BackupRequest} [backupRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addBackupDatabase: async (databaseId: string, backupRequest?: BackupRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('addBackupDatabase', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}/backup`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(backupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter
         * @summary List database  backups
         * @param {string} databaseId Database ID
         * @param {string} [startId] Starting point after which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseBackup: async (databaseId: string, startId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('listDatabaseBackup', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}/backup`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (startId !== undefined) {
                localVarQueryParameter['startId'] = startId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove database  backup
         * @param {string} databaseId Database ID
         * @param {string} backupId Database Backup ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDatabaseBackup: async (databaseId: string, backupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('removeDatabaseBackup', 'databaseId', databaseId)
            // verify required parameter 'backupId' is not null or undefined
            assertParamExists('removeDatabaseBackup', 'backupId', backupId)
            const localVarPath = `/database/{databaseId}/backup/{backupId}`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)))
                .replace(`{${"backupId"}}`, encodeURIComponent(String(backupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BackupsApi - functional programming interface
 * @export
 */
export const BackupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BackupsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a backup to the Database 
         * @param {string} databaseId Database ID
         * @param {BackupRequest} [backupRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addBackupDatabase(databaseId: string, backupRequest?: BackupRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BackupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addBackupDatabase(databaseId, backupRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter
         * @summary List database  backups
         * @param {string} databaseId Database ID
         * @param {string} [startId] Starting point after which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDatabaseBackup(databaseId: string, startId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BackupPaginatedResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDatabaseBackup(databaseId, startId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove database  backup
         * @param {string} databaseId Database ID
         * @param {string} backupId Database Backup ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeDatabaseBackup(databaseId: string, backupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeDatabaseBackup(databaseId, backupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BackupsApi - factory interface
 * @export
 */
export const BackupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BackupsApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a backup to the Database 
         * @param {string} databaseId Database ID
         * @param {BackupRequest} [backupRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addBackupDatabase(databaseId: string, backupRequest?: BackupRequest, options?: any): AxiosPromise<BackupResponse> {
            return localVarFp.addBackupDatabase(databaseId, backupRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter
         * @summary List database  backups
         * @param {string} databaseId Database ID
         * @param {string} [startId] Starting point after which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseBackup(databaseId: string, startId?: string, options?: any): AxiosPromise<BackupPaginatedResponseList> {
            return localVarFp.listDatabaseBackup(databaseId, startId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove database  backup
         * @param {string} databaseId Database ID
         * @param {string} backupId Database Backup ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDatabaseBackup(databaseId: string, backupId: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeDatabaseBackup(databaseId, backupId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BackupsApi - object-oriented interface
 * @export
 * @class BackupsApi
 * @extends {BaseAPI}
 */
export class BackupsApi extends BaseAPI {
    /**
     * 
     * @summary Add a backup to the Database 
     * @param {string} databaseId Database ID
     * @param {BackupRequest} [backupRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackupsApi
     */
    public addBackupDatabase(databaseId: string, backupRequest?: BackupRequest, options?: AxiosRequestConfig) {
        return BackupsApiFp(this.configuration).addBackupDatabase(databaseId, backupRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter
     * @summary List database  backups
     * @param {string} databaseId Database ID
     * @param {string} [startId] Starting point after which to return results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackupsApi
     */
    public listDatabaseBackup(databaseId: string, startId?: string, options?: AxiosRequestConfig) {
        return BackupsApiFp(this.configuration).listDatabaseBackup(databaseId, startId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove database  backup
     * @param {string} databaseId Database ID
     * @param {string} backupId Database Backup ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackupsApi
     */
    public removeDatabaseBackup(databaseId: string, backupId: string, options?: AxiosRequestConfig) {
        return BackupsApiFp(this.configuration).removeDatabaseBackup(databaseId, backupId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BillingApi - axios parameter creator
 * @export
 */
export const BillingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add credit card
         * @param {string} organizationId Organization ID
         * @param {CreditCardRequest} [creditCardRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCreditCard: async (organizationId: string, creditCardRequest?: CreditCardRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('addCreditCard', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/creditCard`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(creditCardRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add credit code
         * @param {string} organizationId Organization ID
         * @param {OrganizationCreditCodeRequest} [organizationCreditCodeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCreditCode: async (organizationId: string, organizationCreditCodeRequest?: OrganizationCreditCodeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('addCreditCode', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/creditCode`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationCreditCodeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete credit card
         * @param {string} organizationId Organization ID
         * @param {string} creditCardId Credit Card ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCreditCard: async (organizationId: string, creditCardId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteCreditCard', 'organizationId', organizationId)
            // verify required parameter 'creditCardId' is not null or undefined
            assertParamExists('deleteCreditCard', 'creditCardId', creditCardId)
            const localVarPath = `/organization/{organizationId}/creditCard/{creditCardId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"creditCardId"}}`, encodeURIComponent(String(creditCardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit Organization Billing Info
         * @param {string} organizationId Organization ID
         * @param {BillingInfoRequest} [billingInfoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editOrganizationBillingInfo: async (organizationId: string, billingInfoRequest?: BillingInfoRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('editOrganizationBillingInfo', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/billingInfo`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(billingInfoRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get your cluster cost range. We are unable to give a precise cost of your infrastructure at the moment. But Qovery guarantees that the cost of your cluster will not exceed the max range. 
         * @summary Get cluster current cost
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterCurrentCost: async (organizationId: string, clusterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getClusterCurrentCost', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('getClusterCurrentCost', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}/currentCost`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get organization billing info
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationBillingInfo: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationBillingInfo', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/billingInfo`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns a \"is_valid\" boolean field reflecting the billing status of the organization: - If true, the organization billing is valid - For Startup organization, it returns false if there is at least 1 invoice unpaid since 1 week - For Community organization, it returns false if there is no credit left 
         * @summary Get organization billing status
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationBillingStatus: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationBillingStatus', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/billingStatus`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get organization current cost
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationCurrentCost: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationCurrentCost', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/currentCost`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get organization invoice
         * @param {string} organizationId Organization ID
         * @param {string} invoiceId Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationInvoice: async (organizationId: string, invoiceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationInvoice', 'organizationId', organizationId)
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('getOrganizationInvoice', 'invoiceId', invoiceId)
            const localVarPath = `/organization/{organizationId}/invoice/{invoiceId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This will return URL of the invoice PDF
         * @summary Get invoice link
         * @param {string} organizationId Organization ID
         * @param {string} invoiceId Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationInvoicePDF: async (organizationId: string, invoiceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationInvoicePDF', 'organizationId', organizationId)
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('getOrganizationInvoicePDF', 'invoiceId', invoiceId)
            const localVarPath = `/organization/{organizationId}/invoice/{invoiceId}/download`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List organization credit cards
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationCreditCards: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listOrganizationCreditCards', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/creditCard`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List organization invoices
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationInvoice: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listOrganizationInvoice', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/invoice`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download all invoices
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationDownloadAllInvoices: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('organizationDownloadAllInvoices', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/downloadInvoices`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BillingApi - functional programming interface
 * @export
 */
export const BillingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BillingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add credit card
         * @param {string} organizationId Organization ID
         * @param {CreditCardRequest} [creditCardRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addCreditCard(organizationId: string, creditCardRequest?: CreditCardRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditCardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addCreditCard(organizationId, creditCardRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add credit code
         * @param {string} organizationId Organization ID
         * @param {OrganizationCreditCodeRequest} [organizationCreditCodeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addCreditCode(organizationId: string, organizationCreditCodeRequest?: OrganizationCreditCodeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addCreditCode(organizationId, organizationCreditCodeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete credit card
         * @param {string} organizationId Organization ID
         * @param {string} creditCardId Credit Card ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCreditCard(organizationId: string, creditCardId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCreditCard(organizationId, creditCardId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit Organization Billing Info
         * @param {string} organizationId Organization ID
         * @param {BillingInfoRequest} [billingInfoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editOrganizationBillingInfo(organizationId: string, billingInfoRequest?: BillingInfoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BillingInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editOrganizationBillingInfo(organizationId, billingInfoRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get your cluster cost range. We are unable to give a precise cost of your infrastructure at the moment. But Qovery guarantees that the cost of your cluster will not exceed the max range. 
         * @summary Get cluster current cost
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClusterCurrentCost(organizationId: string, clusterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CostRangeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClusterCurrentCost(organizationId, clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get organization billing info
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationBillingInfo(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BillingInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationBillingInfo(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns a \"is_valid\" boolean field reflecting the billing status of the organization: - If true, the organization billing is valid - For Startup organization, it returns false if there is at least 1 invoice unpaid since 1 week - For Community organization, it returns false if there is no credit left 
         * @summary Get organization billing status
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationBillingStatus(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BillingStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationBillingStatus(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get organization current cost
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationCurrentCost(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationCurrentCostResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationCurrentCost(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get organization invoice
         * @param {string} organizationId Organization ID
         * @param {string} invoiceId Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationInvoice(organizationId: string, invoiceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationInvoice(organizationId, invoiceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This will return URL of the invoice PDF
         * @summary Get invoice link
         * @param {string} organizationId Organization ID
         * @param {string} invoiceId Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationInvoicePDF(organizationId: string, invoiceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationInvoicePDF(organizationId, invoiceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List organization credit cards
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizationCreditCards(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditCardResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationCreditCards(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List organization invoices
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizationInvoice(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationInvoice(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Download all invoices
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationDownloadAllInvoices(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationDownloadAllInvoices(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BillingApi - factory interface
 * @export
 */
export const BillingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BillingApiFp(configuration)
    return {
        /**
         * 
         * @summary Add credit card
         * @param {string} organizationId Organization ID
         * @param {CreditCardRequest} [creditCardRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCreditCard(organizationId: string, creditCardRequest?: CreditCardRequest, options?: any): AxiosPromise<CreditCardResponse> {
            return localVarFp.addCreditCard(organizationId, creditCardRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add credit code
         * @param {string} organizationId Organization ID
         * @param {OrganizationCreditCodeRequest} [organizationCreditCodeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCreditCode(organizationId: string, organizationCreditCodeRequest?: OrganizationCreditCodeRequest, options?: any): AxiosPromise<void> {
            return localVarFp.addCreditCode(organizationId, organizationCreditCodeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete credit card
         * @param {string} organizationId Organization ID
         * @param {string} creditCardId Credit Card ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCreditCard(organizationId: string, creditCardId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCreditCard(organizationId, creditCardId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit Organization Billing Info
         * @param {string} organizationId Organization ID
         * @param {BillingInfoRequest} [billingInfoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editOrganizationBillingInfo(organizationId: string, billingInfoRequest?: BillingInfoRequest, options?: any): AxiosPromise<BillingInfoResponse> {
            return localVarFp.editOrganizationBillingInfo(organizationId, billingInfoRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get your cluster cost range. We are unable to give a precise cost of your infrastructure at the moment. But Qovery guarantees that the cost of your cluster will not exceed the max range. 
         * @summary Get cluster current cost
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterCurrentCost(organizationId: string, clusterId: string, options?: any): AxiosPromise<CostRangeResponse> {
            return localVarFp.getClusterCurrentCost(organizationId, clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get organization billing info
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationBillingInfo(organizationId: string, options?: any): AxiosPromise<BillingInfoResponse> {
            return localVarFp.getOrganizationBillingInfo(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a \"is_valid\" boolean field reflecting the billing status of the organization: - If true, the organization billing is valid - For Startup organization, it returns false if there is at least 1 invoice unpaid since 1 week - For Community organization, it returns false if there is no credit left 
         * @summary Get organization billing status
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationBillingStatus(organizationId: string, options?: any): AxiosPromise<BillingStatus> {
            return localVarFp.getOrganizationBillingStatus(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get organization current cost
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationCurrentCost(organizationId: string, options?: any): AxiosPromise<OrganizationCurrentCostResponse> {
            return localVarFp.getOrganizationCurrentCost(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get organization invoice
         * @param {string} organizationId Organization ID
         * @param {string} invoiceId Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationInvoice(organizationId: string, invoiceId: string, options?: any): AxiosPromise<InvoiceResponse> {
            return localVarFp.getOrganizationInvoice(organizationId, invoiceId, options).then((request) => request(axios, basePath));
        },
        /**
         * This will return URL of the invoice PDF
         * @summary Get invoice link
         * @param {string} organizationId Organization ID
         * @param {string} invoiceId Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationInvoicePDF(organizationId: string, invoiceId: string, options?: any): AxiosPromise<LinkResponse> {
            return localVarFp.getOrganizationInvoicePDF(organizationId, invoiceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List organization credit cards
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationCreditCards(organizationId: string, options?: any): AxiosPromise<CreditCardResponseList> {
            return localVarFp.listOrganizationCreditCards(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List organization invoices
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationInvoice(organizationId: string, options?: any): AxiosPromise<InvoiceResponseList> {
            return localVarFp.listOrganizationInvoice(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download all invoices
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationDownloadAllInvoices(organizationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.organizationDownloadAllInvoices(organizationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BillingApi - object-oriented interface
 * @export
 * @class BillingApi
 * @extends {BaseAPI}
 */
export class BillingApi extends BaseAPI {
    /**
     * 
     * @summary Add credit card
     * @param {string} organizationId Organization ID
     * @param {CreditCardRequest} [creditCardRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public addCreditCard(organizationId: string, creditCardRequest?: CreditCardRequest, options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).addCreditCard(organizationId, creditCardRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add credit code
     * @param {string} organizationId Organization ID
     * @param {OrganizationCreditCodeRequest} [organizationCreditCodeRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public addCreditCode(organizationId: string, organizationCreditCodeRequest?: OrganizationCreditCodeRequest, options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).addCreditCode(organizationId, organizationCreditCodeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete credit card
     * @param {string} organizationId Organization ID
     * @param {string} creditCardId Credit Card ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public deleteCreditCard(organizationId: string, creditCardId: string, options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).deleteCreditCard(organizationId, creditCardId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit Organization Billing Info
     * @param {string} organizationId Organization ID
     * @param {BillingInfoRequest} [billingInfoRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public editOrganizationBillingInfo(organizationId: string, billingInfoRequest?: BillingInfoRequest, options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).editOrganizationBillingInfo(organizationId, billingInfoRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get your cluster cost range. We are unable to give a precise cost of your infrastructure at the moment. But Qovery guarantees that the cost of your cluster will not exceed the max range. 
     * @summary Get cluster current cost
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getClusterCurrentCost(organizationId: string, clusterId: string, options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).getClusterCurrentCost(organizationId, clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get organization billing info
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getOrganizationBillingInfo(organizationId: string, options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).getOrganizationBillingInfo(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns a \"is_valid\" boolean field reflecting the billing status of the organization: - If true, the organization billing is valid - For Startup organization, it returns false if there is at least 1 invoice unpaid since 1 week - For Community organization, it returns false if there is no credit left 
     * @summary Get organization billing status
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getOrganizationBillingStatus(organizationId: string, options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).getOrganizationBillingStatus(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get organization current cost
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getOrganizationCurrentCost(organizationId: string, options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).getOrganizationCurrentCost(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get organization invoice
     * @param {string} organizationId Organization ID
     * @param {string} invoiceId Invoice ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getOrganizationInvoice(organizationId: string, invoiceId: string, options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).getOrganizationInvoice(organizationId, invoiceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will return URL of the invoice PDF
     * @summary Get invoice link
     * @param {string} organizationId Organization ID
     * @param {string} invoiceId Invoice ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getOrganizationInvoicePDF(organizationId: string, invoiceId: string, options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).getOrganizationInvoicePDF(organizationId, invoiceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List organization credit cards
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public listOrganizationCreditCards(organizationId: string, options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).listOrganizationCreditCards(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List organization invoices
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public listOrganizationInvoice(organizationId: string, options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).listOrganizationInvoice(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download all invoices
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public organizationDownloadAllInvoices(organizationId: string, options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).organizationDownloadAllInvoices(organizationId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CloudProviderApi - axios parameter creator
 * @export
 */
export const CloudProviderApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List AWS features available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAWSFeatures: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/aws/clusterFeature`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List AWS regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAWSRegions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/aws/region`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Cloud providers available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCloudProvider: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cloudProvider`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List DO features available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDOFeatures: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/digitalOcean/clusterFeature`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List DO regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDORegions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/digitalOcean/region`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Scaleway features available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScalewayFeatures: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/scaleway/clusterFeature`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Scaleway regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScalewayRegions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/scaleway/region`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CloudProviderApi - functional programming interface
 * @export
 */
export const CloudProviderApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CloudProviderApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List AWS features available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAWSFeatures(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterFeatureResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAWSFeatures(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List AWS regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAWSRegions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterRegionResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAWSRegions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Cloud providers available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCloudProvider(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudProviderResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCloudProvider(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List DO features available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDOFeatures(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterFeatureResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDOFeatures(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List DO regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDORegions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterRegionResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDORegions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Scaleway features available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listScalewayFeatures(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterFeatureResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listScalewayFeatures(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Scaleway regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listScalewayRegions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterRegionResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listScalewayRegions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CloudProviderApi - factory interface
 * @export
 */
export const CloudProviderApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CloudProviderApiFp(configuration)
    return {
        /**
         * 
         * @summary List AWS features available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAWSFeatures(options?: any): AxiosPromise<ClusterFeatureResponseList> {
            return localVarFp.listAWSFeatures(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List AWS regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAWSRegions(options?: any): AxiosPromise<ClusterRegionResponseList> {
            return localVarFp.listAWSRegions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Cloud providers available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCloudProvider(options?: any): AxiosPromise<CloudProviderResponseList> {
            return localVarFp.listCloudProvider(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List DO features available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDOFeatures(options?: any): AxiosPromise<ClusterFeatureResponseList> {
            return localVarFp.listDOFeatures(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List DO regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDORegions(options?: any): AxiosPromise<ClusterRegionResponseList> {
            return localVarFp.listDORegions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Scaleway features available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScalewayFeatures(options?: any): AxiosPromise<ClusterFeatureResponseList> {
            return localVarFp.listScalewayFeatures(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Scaleway regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScalewayRegions(options?: any): AxiosPromise<ClusterRegionResponseList> {
            return localVarFp.listScalewayRegions(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CloudProviderApi - object-oriented interface
 * @export
 * @class CloudProviderApi
 * @extends {BaseAPI}
 */
export class CloudProviderApi extends BaseAPI {
    /**
     * 
     * @summary List AWS features available
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listAWSFeatures(options?: AxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listAWSFeatures(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List AWS regions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listAWSRegions(options?: AxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listAWSRegions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Cloud providers available
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listCloudProvider(options?: AxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listCloudProvider(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List DO features available
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listDOFeatures(options?: AxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listDOFeatures(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List DO regions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listDORegions(options?: AxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listDORegions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Scaleway features available
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listScalewayFeatures(options?: AxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listScalewayFeatures(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Scaleway regions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listScalewayRegions(options?: AxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listScalewayRegions(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CloudProviderCredentialsApi - axios parameter creator
 * @export
 */
export const CloudProviderCredentialsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create AWS credentials set
         * @param {string} organizationId Organization ID
         * @param {AwsCredentialsRequest} [awsCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAWSCredentials: async (organizationId: string, awsCredentialsRequest?: AwsCredentialsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createAWSCredentials', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/aws/credentials`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(awsCredentialsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Digital Ocean credentials set
         * @param {string} organizationId Organization ID
         * @param {DoCredentialsRequest} [doCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDOCredentials: async (organizationId: string, doCredentialsRequest?: DoCredentialsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createDOCredentials', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/digitalOcean/credentials`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(doCredentialsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Scaleway credentials set
         * @param {string} organizationId Organization ID
         * @param {ScalewayCredentialsRequest} [scalewayCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScalewayCredentials: async (organizationId: string, scalewayCredentialsRequest?: ScalewayCredentialsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createScalewayCredentials', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/scaleway/credentials`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scalewayCredentialsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a set of AWS credentials
         * @param {string} credentialsId Credentials ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAWSCredentials: async (credentialsId: string, organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'credentialsId' is not null or undefined
            assertParamExists('deleteAWSCredentials', 'credentialsId', credentialsId)
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteAWSCredentials', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/aws/credentials/{credentialsId}`
                .replace(`{${"credentialsId"}}`, encodeURIComponent(String(credentialsId)))
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a set of Digital Ocean credentials
         * @param {string} credentialsId Credentials ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDOCredentials: async (credentialsId: string, organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'credentialsId' is not null or undefined
            assertParamExists('deleteDOCredentials', 'credentialsId', credentialsId)
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteDOCredentials', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/digitalOcean/credentials/{credentialsId}`
                .replace(`{${"credentialsId"}}`, encodeURIComponent(String(credentialsId)))
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a set of Scaleway credentials
         * @param {string} credentialsId Credentials ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScalewayCredentials: async (credentialsId: string, organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'credentialsId' is not null or undefined
            assertParamExists('deleteScalewayCredentials', 'credentialsId', credentialsId)
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteScalewayCredentials', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/scaleway/credentials/{credentialsId}`
                .replace(`{${"credentialsId"}}`, encodeURIComponent(String(credentialsId)))
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a set of AWS credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {AwsCredentialsRequest} [awsCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editAWSCredentials: async (organizationId: string, credentialsId: string, awsCredentialsRequest?: AwsCredentialsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('editAWSCredentials', 'organizationId', organizationId)
            // verify required parameter 'credentialsId' is not null or undefined
            assertParamExists('editAWSCredentials', 'credentialsId', credentialsId)
            const localVarPath = `/organization/{organizationId}/aws/credentials/{credentialsId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"credentialsId"}}`, encodeURIComponent(String(credentialsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(awsCredentialsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a set of Digital Ocean credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {DoCredentialsRequest} [doCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editDOCredentials: async (organizationId: string, credentialsId: string, doCredentialsRequest?: DoCredentialsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('editDOCredentials', 'organizationId', organizationId)
            // verify required parameter 'credentialsId' is not null or undefined
            assertParamExists('editDOCredentials', 'credentialsId', credentialsId)
            const localVarPath = `/organization/{organizationId}/digitalOcean/credentials/{credentialsId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"credentialsId"}}`, encodeURIComponent(String(credentialsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(doCredentialsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a set of Scaleway credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {ScalewayCredentialsRequest} [scalewayCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editScalewayCredentials: async (organizationId: string, credentialsId: string, scalewayCredentialsRequest?: ScalewayCredentialsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('editScalewayCredentials', 'organizationId', organizationId)
            // verify required parameter 'credentialsId' is not null or undefined
            assertParamExists('editScalewayCredentials', 'credentialsId', credentialsId)
            const localVarPath = `/organization/{organizationId}/scaleway/credentials/{credentialsId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"credentialsId"}}`, encodeURIComponent(String(credentialsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scalewayCredentialsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List AWS credentials
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAWSCredentials: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listAWSCredentials', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/aws/credentials`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List DO credentials
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDOCredentials: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listDOCredentials', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/digitalOcean/credentials`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Scaleway credentials
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScalewayCredentials: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listScalewayCredentials', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/scaleway/credentials`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CloudProviderCredentialsApi - functional programming interface
 * @export
 */
export const CloudProviderCredentialsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CloudProviderCredentialsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create AWS credentials set
         * @param {string} organizationId Organization ID
         * @param {AwsCredentialsRequest} [awsCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAWSCredentials(organizationId: string, awsCredentialsRequest?: AwsCredentialsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentialsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAWSCredentials(organizationId, awsCredentialsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create Digital Ocean credentials set
         * @param {string} organizationId Organization ID
         * @param {DoCredentialsRequest} [doCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDOCredentials(organizationId: string, doCredentialsRequest?: DoCredentialsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentialsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDOCredentials(organizationId, doCredentialsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create Scaleway credentials set
         * @param {string} organizationId Organization ID
         * @param {ScalewayCredentialsRequest} [scalewayCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createScalewayCredentials(organizationId: string, scalewayCredentialsRequest?: ScalewayCredentialsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentialsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createScalewayCredentials(organizationId, scalewayCredentialsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a set of AWS credentials
         * @param {string} credentialsId Credentials ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAWSCredentials(credentialsId: string, organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAWSCredentials(credentialsId, organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a set of Digital Ocean credentials
         * @param {string} credentialsId Credentials ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDOCredentials(credentialsId: string, organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDOCredentials(credentialsId, organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a set of Scaleway credentials
         * @param {string} credentialsId Credentials ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteScalewayCredentials(credentialsId: string, organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteScalewayCredentials(credentialsId, organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit a set of AWS credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {AwsCredentialsRequest} [awsCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editAWSCredentials(organizationId: string, credentialsId: string, awsCredentialsRequest?: AwsCredentialsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentialsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editAWSCredentials(organizationId, credentialsId, awsCredentialsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit a set of Digital Ocean credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {DoCredentialsRequest} [doCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editDOCredentials(organizationId: string, credentialsId: string, doCredentialsRequest?: DoCredentialsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentialsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editDOCredentials(organizationId, credentialsId, doCredentialsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit a set of Scaleway credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {ScalewayCredentialsRequest} [scalewayCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editScalewayCredentials(organizationId: string, credentialsId: string, scalewayCredentialsRequest?: ScalewayCredentialsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentialsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editScalewayCredentials(organizationId, credentialsId, scalewayCredentialsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List AWS credentials
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAWSCredentials(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentialsResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAWSCredentials(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List DO credentials
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDOCredentials(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentialsResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDOCredentials(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Scaleway credentials
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listScalewayCredentials(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentialsResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listScalewayCredentials(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CloudProviderCredentialsApi - factory interface
 * @export
 */
export const CloudProviderCredentialsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CloudProviderCredentialsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create AWS credentials set
         * @param {string} organizationId Organization ID
         * @param {AwsCredentialsRequest} [awsCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAWSCredentials(organizationId: string, awsCredentialsRequest?: AwsCredentialsRequest, options?: any): AxiosPromise<ClusterCredentialsResponse> {
            return localVarFp.createAWSCredentials(organizationId, awsCredentialsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Digital Ocean credentials set
         * @param {string} organizationId Organization ID
         * @param {DoCredentialsRequest} [doCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDOCredentials(organizationId: string, doCredentialsRequest?: DoCredentialsRequest, options?: any): AxiosPromise<ClusterCredentialsResponse> {
            return localVarFp.createDOCredentials(organizationId, doCredentialsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Scaleway credentials set
         * @param {string} organizationId Organization ID
         * @param {ScalewayCredentialsRequest} [scalewayCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScalewayCredentials(organizationId: string, scalewayCredentialsRequest?: ScalewayCredentialsRequest, options?: any): AxiosPromise<ClusterCredentialsResponse> {
            return localVarFp.createScalewayCredentials(organizationId, scalewayCredentialsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a set of AWS credentials
         * @param {string} credentialsId Credentials ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAWSCredentials(credentialsId: string, organizationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAWSCredentials(credentialsId, organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a set of Digital Ocean credentials
         * @param {string} credentialsId Credentials ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDOCredentials(credentialsId: string, organizationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDOCredentials(credentialsId, organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a set of Scaleway credentials
         * @param {string} credentialsId Credentials ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScalewayCredentials(credentialsId: string, organizationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteScalewayCredentials(credentialsId, organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a set of AWS credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {AwsCredentialsRequest} [awsCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editAWSCredentials(organizationId: string, credentialsId: string, awsCredentialsRequest?: AwsCredentialsRequest, options?: any): AxiosPromise<ClusterCredentialsResponse> {
            return localVarFp.editAWSCredentials(organizationId, credentialsId, awsCredentialsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a set of Digital Ocean credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {DoCredentialsRequest} [doCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editDOCredentials(organizationId: string, credentialsId: string, doCredentialsRequest?: DoCredentialsRequest, options?: any): AxiosPromise<ClusterCredentialsResponse> {
            return localVarFp.editDOCredentials(organizationId, credentialsId, doCredentialsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a set of Scaleway credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {ScalewayCredentialsRequest} [scalewayCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editScalewayCredentials(organizationId: string, credentialsId: string, scalewayCredentialsRequest?: ScalewayCredentialsRequest, options?: any): AxiosPromise<ClusterCredentialsResponse> {
            return localVarFp.editScalewayCredentials(organizationId, credentialsId, scalewayCredentialsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List AWS credentials
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAWSCredentials(organizationId: string, options?: any): AxiosPromise<ClusterCredentialsResponseList> {
            return localVarFp.listAWSCredentials(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List DO credentials
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDOCredentials(organizationId: string, options?: any): AxiosPromise<ClusterCredentialsResponseList> {
            return localVarFp.listDOCredentials(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Scaleway credentials
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScalewayCredentials(organizationId: string, options?: any): AxiosPromise<ClusterCredentialsResponseList> {
            return localVarFp.listScalewayCredentials(organizationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CloudProviderCredentialsApi - object-oriented interface
 * @export
 * @class CloudProviderCredentialsApi
 * @extends {BaseAPI}
 */
export class CloudProviderCredentialsApi extends BaseAPI {
    /**
     * 
     * @summary Create AWS credentials set
     * @param {string} organizationId Organization ID
     * @param {AwsCredentialsRequest} [awsCredentialsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public createAWSCredentials(organizationId: string, awsCredentialsRequest?: AwsCredentialsRequest, options?: AxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).createAWSCredentials(organizationId, awsCredentialsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Digital Ocean credentials set
     * @param {string} organizationId Organization ID
     * @param {DoCredentialsRequest} [doCredentialsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public createDOCredentials(organizationId: string, doCredentialsRequest?: DoCredentialsRequest, options?: AxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).createDOCredentials(organizationId, doCredentialsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Scaleway credentials set
     * @param {string} organizationId Organization ID
     * @param {ScalewayCredentialsRequest} [scalewayCredentialsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public createScalewayCredentials(organizationId: string, scalewayCredentialsRequest?: ScalewayCredentialsRequest, options?: AxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).createScalewayCredentials(organizationId, scalewayCredentialsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a set of AWS credentials
     * @param {string} credentialsId Credentials ID
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public deleteAWSCredentials(credentialsId: string, organizationId: string, options?: AxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).deleteAWSCredentials(credentialsId, organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a set of Digital Ocean credentials
     * @param {string} credentialsId Credentials ID
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public deleteDOCredentials(credentialsId: string, organizationId: string, options?: AxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).deleteDOCredentials(credentialsId, organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a set of Scaleway credentials
     * @param {string} credentialsId Credentials ID
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public deleteScalewayCredentials(credentialsId: string, organizationId: string, options?: AxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).deleteScalewayCredentials(credentialsId, organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a set of AWS credentials
     * @param {string} organizationId Organization ID
     * @param {string} credentialsId Credentials ID
     * @param {AwsCredentialsRequest} [awsCredentialsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public editAWSCredentials(organizationId: string, credentialsId: string, awsCredentialsRequest?: AwsCredentialsRequest, options?: AxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).editAWSCredentials(organizationId, credentialsId, awsCredentialsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a set of Digital Ocean credentials
     * @param {string} organizationId Organization ID
     * @param {string} credentialsId Credentials ID
     * @param {DoCredentialsRequest} [doCredentialsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public editDOCredentials(organizationId: string, credentialsId: string, doCredentialsRequest?: DoCredentialsRequest, options?: AxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).editDOCredentials(organizationId, credentialsId, doCredentialsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a set of Scaleway credentials
     * @param {string} organizationId Organization ID
     * @param {string} credentialsId Credentials ID
     * @param {ScalewayCredentialsRequest} [scalewayCredentialsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public editScalewayCredentials(organizationId: string, credentialsId: string, scalewayCredentialsRequest?: ScalewayCredentialsRequest, options?: AxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).editScalewayCredentials(organizationId, credentialsId, scalewayCredentialsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List AWS credentials
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public listAWSCredentials(organizationId: string, options?: AxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).listAWSCredentials(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List DO credentials
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public listDOCredentials(organizationId: string, options?: AxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).listDOCredentials(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Scaleway credentials
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public listScalewayCredentials(organizationId: string, options?: AxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).listScalewayCredentials(organizationId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ClustersApi - axios parameter creator
 * @export
 */
export const ClustersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a cluster
         * @param {string} organizationId Organization ID
         * @param {ClusterRequest} [clusterRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCluster: async (organizationId: string, clusterRequest?: ClusterRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createCluster', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/cluster`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clusterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a cluster
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCluster: async (organizationId: string, clusterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteCluster', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('deleteCluster', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * allows to deploy a cluster
         * @summary Deploy a cluster
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployCluster: async (organizationId: string, clusterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deployCluster', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('deployCluster', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}/deploy`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a cluster
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {ClusterRequest} [clusterRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editCluster: async (organizationId: string, clusterId: string, clusterRequest?: ClusterRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('editCluster', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('editCluster', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clusterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit routing table by returning updated table.
         * @summary Edit routing table
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {ClusterRoutingTableRequest} [clusterRoutingTableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editRoutingTable: async (organizationId: string, clusterId: string, clusterRoutingTableRequest?: ClusterRoutingTableRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('editRoutingTable', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('editRoutingTable', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}/routingTable`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clusterRoutingTableRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Know if a cluster is ready to be deployed or not
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterReadinessStatus: async (organizationId: string, clusterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getClusterReadinessStatus', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('getClusterReadinessStatus', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}/isReady`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get cluster status
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterStatus: async (organizationId: string, clusterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getClusterStatus', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('getClusterStatus', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}/status`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get cluster cloud provider info and credentials
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationCloudProviderInfo: async (organizationId: string, clusterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationCloudProviderInfo', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('getOrganizationCloudProviderInfo', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}/cloudProviderInfo`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of clusters with only their id and status.
         * @summary List all clusters statuses
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationClusterStatus: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationClusterStatus', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/cluster/status`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve network routing table where each line corresponds to a route between a destination and a target.
         * @summary Get routing table
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutingTable: async (organizationId: string, clusterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getRoutingTable', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('getRoutingTable', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}/routingTable`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List organization clusters
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationCluster: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listOrganizationCluster', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/cluster`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Specify cluster cloud provider info and credentials
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {ClusterCloudProviderInfoRequest} [clusterCloudProviderInfoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifyClusterCloudProviderInfo: async (organizationId: string, clusterId: string, clusterCloudProviderInfoRequest?: ClusterCloudProviderInfoRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('specifyClusterCloudProviderInfo', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('specifyClusterCloudProviderInfo', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}/cloudProviderInfo`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clusterCloudProviderInfoRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cluster stop has been requester.
         * @summary Stop cluster
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopCluster: async (organizationId: string, clusterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('stopCluster', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('stopCluster', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}/stop`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * allows to update cluster version
         * @summary Update a cluster Version
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCluster: async (organizationId: string, clusterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateCluster', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('updateCluster', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}/update`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClustersApi - functional programming interface
 * @export
 */
export const ClustersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClustersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a cluster
         * @param {string} organizationId Organization ID
         * @param {ClusterRequest} [clusterRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCluster(organizationId: string, clusterRequest?: ClusterRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCluster(organizationId, clusterRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a cluster
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCluster(organizationId: string, clusterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCluster(organizationId, clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * allows to deploy a cluster
         * @summary Deploy a cluster
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployCluster(organizationId: string, clusterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployCluster(organizationId, clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit a cluster
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {ClusterRequest} [clusterRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editCluster(organizationId: string, clusterId: string, clusterRequest?: ClusterRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editCluster(organizationId, clusterId, clusterRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Edit routing table by returning updated table.
         * @summary Edit routing table
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {ClusterRoutingTableRequest} [clusterRoutingTableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editRoutingTable(organizationId: string, clusterId: string, clusterRoutingTableRequest?: ClusterRoutingTableRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterRoutingTableResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editRoutingTable(organizationId, clusterId, clusterRoutingTableRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Know if a cluster is ready to be deployed or not
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClusterReadinessStatus(organizationId: string, clusterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterReadinessStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClusterReadinessStatus(organizationId, clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get cluster status
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClusterStatus(organizationId: string, clusterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClusterStatus(organizationId, clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get cluster cloud provider info and credentials
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationCloudProviderInfo(organizationId: string, clusterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCloudProviderInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationCloudProviderInfo(organizationId, clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of clusters with only their id and status.
         * @summary List all clusters statuses
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationClusterStatus(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterStatusResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationClusterStatus(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve network routing table where each line corresponds to a route between a destination and a target.
         * @summary Get routing table
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoutingTable(organizationId: string, clusterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterRoutingTableResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoutingTable(organizationId, clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List organization clusters
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizationCluster(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationCluster(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Specify cluster cloud provider info and credentials
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {ClusterCloudProviderInfoRequest} [clusterCloudProviderInfoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async specifyClusterCloudProviderInfo(organizationId: string, clusterId: string, clusterCloudProviderInfoRequest?: ClusterCloudProviderInfoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCloudProviderInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.specifyClusterCloudProviderInfo(organizationId, clusterId, clusterCloudProviderInfoRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Cluster stop has been requester.
         * @summary Stop cluster
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopCluster(organizationId: string, clusterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopCluster(organizationId, clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * allows to update cluster version
         * @summary Update a cluster Version
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCluster(organizationId: string, clusterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCluster(organizationId, clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ClustersApi - factory interface
 * @export
 */
export const ClustersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClustersApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a cluster
         * @param {string} organizationId Organization ID
         * @param {ClusterRequest} [clusterRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCluster(organizationId: string, clusterRequest?: ClusterRequest, options?: any): AxiosPromise<ClusterResponse> {
            return localVarFp.createCluster(organizationId, clusterRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a cluster
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCluster(organizationId: string, clusterId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCluster(organizationId, clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * allows to deploy a cluster
         * @summary Deploy a cluster
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployCluster(organizationId: string, clusterId: string, options?: any): AxiosPromise<ClusterStatusResponse> {
            return localVarFp.deployCluster(organizationId, clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a cluster
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {ClusterRequest} [clusterRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editCluster(organizationId: string, clusterId: string, clusterRequest?: ClusterRequest, options?: any): AxiosPromise<ClusterResponse> {
            return localVarFp.editCluster(organizationId, clusterId, clusterRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit routing table by returning updated table.
         * @summary Edit routing table
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {ClusterRoutingTableRequest} [clusterRoutingTableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editRoutingTable(organizationId: string, clusterId: string, clusterRoutingTableRequest?: ClusterRoutingTableRequest, options?: any): AxiosPromise<ClusterRoutingTableResponse> {
            return localVarFp.editRoutingTable(organizationId, clusterId, clusterRoutingTableRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Know if a cluster is ready to be deployed or not
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterReadinessStatus(organizationId: string, clusterId: string, options?: any): AxiosPromise<ClusterReadinessStatus> {
            return localVarFp.getClusterReadinessStatus(organizationId, clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get cluster status
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterStatus(organizationId: string, clusterId: string, options?: any): AxiosPromise<ClusterStatusResponse> {
            return localVarFp.getClusterStatus(organizationId, clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get cluster cloud provider info and credentials
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationCloudProviderInfo(organizationId: string, clusterId: string, options?: any): AxiosPromise<ClusterCloudProviderInfoResponse> {
            return localVarFp.getOrganizationCloudProviderInfo(organizationId, clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of clusters with only their id and status.
         * @summary List all clusters statuses
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationClusterStatus(organizationId: string, options?: any): AxiosPromise<ClusterStatusResponseList> {
            return localVarFp.getOrganizationClusterStatus(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve network routing table where each line corresponds to a route between a destination and a target.
         * @summary Get routing table
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutingTable(organizationId: string, clusterId: string, options?: any): AxiosPromise<ClusterRoutingTableResponse> {
            return localVarFp.getRoutingTable(organizationId, clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List organization clusters
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationCluster(organizationId: string, options?: any): AxiosPromise<ClusterResponseList> {
            return localVarFp.listOrganizationCluster(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Specify cluster cloud provider info and credentials
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {ClusterCloudProviderInfoRequest} [clusterCloudProviderInfoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifyClusterCloudProviderInfo(organizationId: string, clusterId: string, clusterCloudProviderInfoRequest?: ClusterCloudProviderInfoRequest, options?: any): AxiosPromise<ClusterCloudProviderInfoResponse> {
            return localVarFp.specifyClusterCloudProviderInfo(organizationId, clusterId, clusterCloudProviderInfoRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Cluster stop has been requester.
         * @summary Stop cluster
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopCluster(organizationId: string, clusterId: string, options?: any): AxiosPromise<ClusterStatusResponse> {
            return localVarFp.stopCluster(organizationId, clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * allows to update cluster version
         * @summary Update a cluster Version
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCluster(organizationId: string, clusterId: string, options?: any): AxiosPromise<ClusterStatusResponse> {
            return localVarFp.updateCluster(organizationId, clusterId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClustersApi - object-oriented interface
 * @export
 * @class ClustersApi
 * @extends {BaseAPI}
 */
export class ClustersApi extends BaseAPI {
    /**
     * 
     * @summary Create a cluster
     * @param {string} organizationId Organization ID
     * @param {ClusterRequest} [clusterRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public createCluster(organizationId: string, clusterRequest?: ClusterRequest, options?: AxiosRequestConfig) {
        return ClustersApiFp(this.configuration).createCluster(organizationId, clusterRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a cluster
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public deleteCluster(organizationId: string, clusterId: string, options?: AxiosRequestConfig) {
        return ClustersApiFp(this.configuration).deleteCluster(organizationId, clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * allows to deploy a cluster
     * @summary Deploy a cluster
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public deployCluster(organizationId: string, clusterId: string, options?: AxiosRequestConfig) {
        return ClustersApiFp(this.configuration).deployCluster(organizationId, clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a cluster
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {ClusterRequest} [clusterRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public editCluster(organizationId: string, clusterId: string, clusterRequest?: ClusterRequest, options?: AxiosRequestConfig) {
        return ClustersApiFp(this.configuration).editCluster(organizationId, clusterId, clusterRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit routing table by returning updated table.
     * @summary Edit routing table
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {ClusterRoutingTableRequest} [clusterRoutingTableRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public editRoutingTable(organizationId: string, clusterId: string, clusterRoutingTableRequest?: ClusterRoutingTableRequest, options?: AxiosRequestConfig) {
        return ClustersApiFp(this.configuration).editRoutingTable(organizationId, clusterId, clusterRoutingTableRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Know if a cluster is ready to be deployed or not
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public getClusterReadinessStatus(organizationId: string, clusterId: string, options?: AxiosRequestConfig) {
        return ClustersApiFp(this.configuration).getClusterReadinessStatus(organizationId, clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get cluster status
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public getClusterStatus(organizationId: string, clusterId: string, options?: AxiosRequestConfig) {
        return ClustersApiFp(this.configuration).getClusterStatus(organizationId, clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get cluster cloud provider info and credentials
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public getOrganizationCloudProviderInfo(organizationId: string, clusterId: string, options?: AxiosRequestConfig) {
        return ClustersApiFp(this.configuration).getOrganizationCloudProviderInfo(organizationId, clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of clusters with only their id and status.
     * @summary List all clusters statuses
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public getOrganizationClusterStatus(organizationId: string, options?: AxiosRequestConfig) {
        return ClustersApiFp(this.configuration).getOrganizationClusterStatus(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve network routing table where each line corresponds to a route between a destination and a target.
     * @summary Get routing table
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public getRoutingTable(organizationId: string, clusterId: string, options?: AxiosRequestConfig) {
        return ClustersApiFp(this.configuration).getRoutingTable(organizationId, clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List organization clusters
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public listOrganizationCluster(organizationId: string, options?: AxiosRequestConfig) {
        return ClustersApiFp(this.configuration).listOrganizationCluster(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Specify cluster cloud provider info and credentials
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {ClusterCloudProviderInfoRequest} [clusterCloudProviderInfoRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public specifyClusterCloudProviderInfo(organizationId: string, clusterId: string, clusterCloudProviderInfoRequest?: ClusterCloudProviderInfoRequest, options?: AxiosRequestConfig) {
        return ClustersApiFp(this.configuration).specifyClusterCloudProviderInfo(organizationId, clusterId, clusterCloudProviderInfoRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cluster stop has been requester.
     * @summary Stop cluster
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public stopCluster(organizationId: string, clusterId: string, options?: AxiosRequestConfig) {
        return ClustersApiFp(this.configuration).stopCluster(organizationId, clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * allows to update cluster version
     * @summary Update a cluster Version
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public updateCluster(organizationId: string, clusterId: string, options?: AxiosRequestConfig) {
        return ClustersApiFp(this.configuration).updateCluster(organizationId, clusterId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CustomDomainApi - axios parameter creator
 * @export
 */
export const CustomDomainApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a custom domain to this application in order not to use qovery autogenerated domain
         * @summary Add custom domain to the application.
         * @param {string} applicationId Application ID
         * @param {CustomDomainRequest} [customDomainRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationCustomDomain: async (applicationId: string, customDomainRequest?: CustomDomainRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('createApplicationCustomDomain', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/customDomain`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customDomainRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To delete an CustomDomain you must have the project user permission
         * @summary Delete a Custom Domain
         * @param {string} applicationId Application ID
         * @param {string} customDomainId Custom Domain ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomDomain: async (applicationId: string, customDomainId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('deleteCustomDomain', 'applicationId', applicationId)
            // verify required parameter 'customDomainId' is not null or undefined
            assertParamExists('deleteCustomDomain', 'customDomainId', customDomainId)
            const localVarPath = `/application/{applicationId}/customDomain/{customDomainId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"customDomainId"}}`, encodeURIComponent(String(customDomainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To edit a Custom Domain  you must have the project user permission
         * @summary Edit a Custom Domain
         * @param {string} applicationId Application ID
         * @param {string} customDomainId Custom Domain ID
         * @param {CustomDomainRequest} [customDomainRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editCustomDomain: async (applicationId: string, customDomainId: string, customDomainRequest?: CustomDomainRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('editCustomDomain', 'applicationId', applicationId)
            // verify required parameter 'customDomainId' is not null or undefined
            assertParamExists('editCustomDomain', 'customDomainId', customDomainId)
            const localVarPath = `/application/{applicationId}/customDomain/{customDomainId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"customDomainId"}}`, encodeURIComponent(String(customDomainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customDomainRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Custom Domain status
         * @param {string} applicationId Application ID
         * @param {string} customDomainId Custom Domain ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomDomainStatus: async (applicationId: string, customDomainId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getCustomDomainStatus', 'applicationId', applicationId)
            // verify required parameter 'customDomainId' is not null or undefined
            assertParamExists('getCustomDomainStatus', 'customDomainId', customDomainId)
            const localVarPath = `/application/{applicationId}/customDomain/{customDomainId}/status`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"customDomainId"}}`, encodeURIComponent(String(customDomainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List application custom domains
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationCustomDomain: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('listApplicationCustomDomain', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/customDomain`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomDomainApi - functional programming interface
 * @export
 */
export const CustomDomainApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomDomainApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a custom domain to this application in order not to use qovery autogenerated domain
         * @summary Add custom domain to the application.
         * @param {string} applicationId Application ID
         * @param {CustomDomainRequest} [customDomainRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplicationCustomDomain(applicationId: string, customDomainRequest?: CustomDomainRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomDomainResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplicationCustomDomain(applicationId, customDomainRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * To delete an CustomDomain you must have the project user permission
         * @summary Delete a Custom Domain
         * @param {string} applicationId Application ID
         * @param {string} customDomainId Custom Domain ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCustomDomain(applicationId: string, customDomainId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCustomDomain(applicationId, customDomainId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * To edit a Custom Domain  you must have the project user permission
         * @summary Edit a Custom Domain
         * @param {string} applicationId Application ID
         * @param {string} customDomainId Custom Domain ID
         * @param {CustomDomainRequest} [customDomainRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editCustomDomain(applicationId: string, customDomainId: string, customDomainRequest?: CustomDomainRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomDomainResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editCustomDomain(applicationId, customDomainId, customDomainRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Custom Domain status
         * @param {string} applicationId Application ID
         * @param {string} customDomainId Custom Domain ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomDomainStatus(applicationId: string, customDomainId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomDomainResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomDomainStatus(applicationId, customDomainId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List application custom domains
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplicationCustomDomain(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomDomainResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplicationCustomDomain(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CustomDomainApi - factory interface
 * @export
 */
export const CustomDomainApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomDomainApiFp(configuration)
    return {
        /**
         * Add a custom domain to this application in order not to use qovery autogenerated domain
         * @summary Add custom domain to the application.
         * @param {string} applicationId Application ID
         * @param {CustomDomainRequest} [customDomainRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationCustomDomain(applicationId: string, customDomainRequest?: CustomDomainRequest, options?: any): AxiosPromise<CustomDomainResponse> {
            return localVarFp.createApplicationCustomDomain(applicationId, customDomainRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * To delete an CustomDomain you must have the project user permission
         * @summary Delete a Custom Domain
         * @param {string} applicationId Application ID
         * @param {string} customDomainId Custom Domain ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomDomain(applicationId: string, customDomainId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCustomDomain(applicationId, customDomainId, options).then((request) => request(axios, basePath));
        },
        /**
         * To edit a Custom Domain  you must have the project user permission
         * @summary Edit a Custom Domain
         * @param {string} applicationId Application ID
         * @param {string} customDomainId Custom Domain ID
         * @param {CustomDomainRequest} [customDomainRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editCustomDomain(applicationId: string, customDomainId: string, customDomainRequest?: CustomDomainRequest, options?: any): AxiosPromise<CustomDomainResponse> {
            return localVarFp.editCustomDomain(applicationId, customDomainId, customDomainRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Custom Domain status
         * @param {string} applicationId Application ID
         * @param {string} customDomainId Custom Domain ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomDomainStatus(applicationId: string, customDomainId: string, options?: any): AxiosPromise<CustomDomainResponse> {
            return localVarFp.getCustomDomainStatus(applicationId, customDomainId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List application custom domains
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationCustomDomain(applicationId: string, options?: any): AxiosPromise<CustomDomainResponseList> {
            return localVarFp.listApplicationCustomDomain(applicationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CustomDomainApi - object-oriented interface
 * @export
 * @class CustomDomainApi
 * @extends {BaseAPI}
 */
export class CustomDomainApi extends BaseAPI {
    /**
     * Add a custom domain to this application in order not to use qovery autogenerated domain
     * @summary Add custom domain to the application.
     * @param {string} applicationId Application ID
     * @param {CustomDomainRequest} [customDomainRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomDomainApi
     */
    public createApplicationCustomDomain(applicationId: string, customDomainRequest?: CustomDomainRequest, options?: AxiosRequestConfig) {
        return CustomDomainApiFp(this.configuration).createApplicationCustomDomain(applicationId, customDomainRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To delete an CustomDomain you must have the project user permission
     * @summary Delete a Custom Domain
     * @param {string} applicationId Application ID
     * @param {string} customDomainId Custom Domain ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomDomainApi
     */
    public deleteCustomDomain(applicationId: string, customDomainId: string, options?: AxiosRequestConfig) {
        return CustomDomainApiFp(this.configuration).deleteCustomDomain(applicationId, customDomainId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To edit a Custom Domain  you must have the project user permission
     * @summary Edit a Custom Domain
     * @param {string} applicationId Application ID
     * @param {string} customDomainId Custom Domain ID
     * @param {CustomDomainRequest} [customDomainRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomDomainApi
     */
    public editCustomDomain(applicationId: string, customDomainId: string, customDomainRequest?: CustomDomainRequest, options?: AxiosRequestConfig) {
        return CustomDomainApiFp(this.configuration).editCustomDomain(applicationId, customDomainId, customDomainRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Custom Domain status
     * @param {string} applicationId Application ID
     * @param {string} customDomainId Custom Domain ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomDomainApi
     */
    public getCustomDomainStatus(applicationId: string, customDomainId: string, options?: AxiosRequestConfig) {
        return CustomDomainApiFp(this.configuration).getCustomDomainStatus(applicationId, customDomainId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List application custom domains
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomDomainApi
     */
    public listApplicationCustomDomain(applicationId: string, options?: AxiosRequestConfig) {
        return CustomDomainApiFp(this.configuration).listApplicationCustomDomain(applicationId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DatabaseActionsApi - axios parameter creator
 * @export
 */
export const DatabaseActionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deploy database 
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployDatabase: async (databaseId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('deployDatabase', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}/deploy`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retart database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartDatabase: async (databaseId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('restartDatabase', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}/restart`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopDatabase: async (databaseId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('stopDatabase', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}/stop`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatabaseActionsApi - functional programming interface
 * @export
 */
export const DatabaseActionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DatabaseActionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Deploy database 
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployDatabase(databaseId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployDatabase(databaseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retart database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restartDatabase(databaseId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restartDatabase(databaseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Stop database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopDatabase(databaseId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopDatabase(databaseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DatabaseActionsApi - factory interface
 * @export
 */
export const DatabaseActionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DatabaseActionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Deploy database 
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployDatabase(databaseId: string, options?: any): AxiosPromise<Status> {
            return localVarFp.deployDatabase(databaseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retart database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartDatabase(databaseId: string, options?: any): AxiosPromise<Status> {
            return localVarFp.restartDatabase(databaseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Stop database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopDatabase(databaseId: string, options?: any): AxiosPromise<Status> {
            return localVarFp.stopDatabase(databaseId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DatabaseActionsApi - object-oriented interface
 * @export
 * @class DatabaseActionsApi
 * @extends {BaseAPI}
 */
export class DatabaseActionsApi extends BaseAPI {
    /**
     * 
     * @summary Deploy database 
     * @param {string} databaseId Database ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseActionsApi
     */
    public deployDatabase(databaseId: string, options?: AxiosRequestConfig) {
        return DatabaseActionsApiFp(this.configuration).deployDatabase(databaseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retart database
     * @param {string} databaseId Database ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseActionsApi
     */
    public restartDatabase(databaseId: string, options?: AxiosRequestConfig) {
        return DatabaseActionsApiFp(this.configuration).restartDatabase(databaseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Stop database
     * @param {string} databaseId Database ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseActionsApi
     */
    public stopDatabase(databaseId: string, options?: AxiosRequestConfig) {
        return DatabaseActionsApiFp(this.configuration).stopDatabase(databaseId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DatabaseApplicationApi - axios parameter creator
 * @export
 */
export const DatabaseApplicationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List applications using the database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseApplication: async (databaseId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('listDatabaseApplication', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}/application`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove an application from this database 
         * @param {string} databaseId Database ID
         * @param {string} targetApplicationId Target application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeApplicationFromDatabase: async (databaseId: string, targetApplicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('removeApplicationFromDatabase', 'databaseId', databaseId)
            // verify required parameter 'targetApplicationId' is not null or undefined
            assertParamExists('removeApplicationFromDatabase', 'targetApplicationId', targetApplicationId)
            const localVarPath = `/database/{databaseId}/application/{targetApplicationId}`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)))
                .replace(`{${"targetApplicationId"}}`, encodeURIComponent(String(targetApplicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatabaseApplicationApi - functional programming interface
 * @export
 */
export const DatabaseApplicationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DatabaseApplicationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List applications using the database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDatabaseApplication(databaseId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDatabaseApplication(databaseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove an application from this database 
         * @param {string} databaseId Database ID
         * @param {string} targetApplicationId Target application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeApplicationFromDatabase(databaseId: string, targetApplicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeApplicationFromDatabase(databaseId, targetApplicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DatabaseApplicationApi - factory interface
 * @export
 */
export const DatabaseApplicationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DatabaseApplicationApiFp(configuration)
    return {
        /**
         * 
         * @summary List applications using the database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseApplication(databaseId: string, options?: any): AxiosPromise<ApplicationResponseList> {
            return localVarFp.listDatabaseApplication(databaseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove an application from this database 
         * @param {string} databaseId Database ID
         * @param {string} targetApplicationId Target application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeApplicationFromDatabase(databaseId: string, targetApplicationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeApplicationFromDatabase(databaseId, targetApplicationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DatabaseApplicationApi - object-oriented interface
 * @export
 * @class DatabaseApplicationApi
 * @extends {BaseAPI}
 */
export class DatabaseApplicationApi extends BaseAPI {
    /**
     * 
     * @summary List applications using the database
     * @param {string} databaseId Database ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseApplicationApi
     */
    public listDatabaseApplication(databaseId: string, options?: AxiosRequestConfig) {
        return DatabaseApplicationApiFp(this.configuration).listDatabaseApplication(databaseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove an application from this database 
     * @param {string} databaseId Database ID
     * @param {string} targetApplicationId Target application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseApplicationApi
     */
    public removeApplicationFromDatabase(databaseId: string, targetApplicationId: string, options?: AxiosRequestConfig) {
        return DatabaseApplicationApiFp(this.configuration).removeApplicationFromDatabase(databaseId, targetApplicationId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DatabaseEventApi - axios parameter creator
 * @export
 */
export const DatabaseEventApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter
         * @summary List database  events
         * @param {string} databaseId Database ID
         * @param {string} [startId] Starting point after which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseEvent: async (databaseId: string, startId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('listDatabaseEvent', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}/event`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (startId !== undefined) {
                localVarQueryParameter['startId'] = startId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatabaseEventApi - functional programming interface
 * @export
 */
export const DatabaseEventApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DatabaseEventApiAxiosParamCreator(configuration)
    return {
        /**
         * By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter
         * @summary List database  events
         * @param {string} databaseId Database ID
         * @param {string} [startId] Starting point after which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDatabaseEvent(databaseId: string, startId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventPaginatedResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDatabaseEvent(databaseId, startId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DatabaseEventApi - factory interface
 * @export
 */
export const DatabaseEventApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DatabaseEventApiFp(configuration)
    return {
        /**
         * By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter
         * @summary List database  events
         * @param {string} databaseId Database ID
         * @param {string} [startId] Starting point after which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseEvent(databaseId: string, startId?: string, options?: any): AxiosPromise<EventPaginatedResponseList> {
            return localVarFp.listDatabaseEvent(databaseId, startId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DatabaseEventApi - object-oriented interface
 * @export
 * @class DatabaseEventApi
 * @extends {BaseAPI}
 */
export class DatabaseEventApi extends BaseAPI {
    /**
     * By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter
     * @summary List database  events
     * @param {string} databaseId Database ID
     * @param {string} [startId] Starting point after which to return results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseEventApi
     */
    public listDatabaseEvent(databaseId: string, startId?: string, options?: AxiosRequestConfig) {
        return DatabaseEventApiFp(this.configuration).listDatabaseEvent(databaseId, startId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DatabaseMainCallsApi - axios parameter creator
 * @export
 */
export const DatabaseMainCallsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * To delete a database you must have the admin permission
         * @summary Delete a database 
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDatabase: async (databaseId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('deleteDatabase', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To edit a database  you must have the admin permission
         * @summary Edit a database 
         * @param {string} databaseId Database ID
         * @param {DatabaseEditRequest} [databaseEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editDatabase: async (databaseId: string, databaseEditRequest?: DatabaseEditRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('editDatabase', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(databaseEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit database  master credentials
         * @param {string} databaseId Database ID
         * @param {CredentialsRequest} [credentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editDatabaseCredentials: async (databaseId: string, credentialsRequest?: CredentialsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('editDatabaseCredentials', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}/masterCredentials`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(credentialsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get database by ID
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabase: async (databaseId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('getDatabase', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get master credentials of the database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseMasterCredentials: async (databaseId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('getDatabaseMasterCredentials', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}/masterCredentials`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get database status
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseStatus: async (databaseId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('getDatabaseStatus', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}/status`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List eligible versions for the database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseVersion: async (databaseId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('listDatabaseVersion', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}/version`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatabaseMainCallsApi - functional programming interface
 * @export
 */
export const DatabaseMainCallsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DatabaseMainCallsApiAxiosParamCreator(configuration)
    return {
        /**
         * To delete a database you must have the admin permission
         * @summary Delete a database 
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDatabase(databaseId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDatabase(databaseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * To edit a database  you must have the admin permission
         * @summary Edit a database 
         * @param {string} databaseId Database ID
         * @param {DatabaseEditRequest} [databaseEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editDatabase(databaseId: string, databaseEditRequest?: DatabaseEditRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatabaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editDatabase(databaseId, databaseEditRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit database  master credentials
         * @param {string} databaseId Database ID
         * @param {CredentialsRequest} [credentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editDatabaseCredentials(databaseId: string, credentialsRequest?: CredentialsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CredentialsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editDatabaseCredentials(databaseId, credentialsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get database by ID
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDatabase(databaseId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatabaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDatabase(databaseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get master credentials of the database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDatabaseMasterCredentials(databaseId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CredentialsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDatabaseMasterCredentials(databaseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get database status
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDatabaseStatus(databaseId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDatabaseStatus(databaseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List eligible versions for the database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDatabaseVersion(databaseId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VersionResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDatabaseVersion(databaseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DatabaseMainCallsApi - factory interface
 * @export
 */
export const DatabaseMainCallsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DatabaseMainCallsApiFp(configuration)
    return {
        /**
         * To delete a database you must have the admin permission
         * @summary Delete a database 
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDatabase(databaseId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDatabase(databaseId, options).then((request) => request(axios, basePath));
        },
        /**
         * To edit a database  you must have the admin permission
         * @summary Edit a database 
         * @param {string} databaseId Database ID
         * @param {DatabaseEditRequest} [databaseEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editDatabase(databaseId: string, databaseEditRequest?: DatabaseEditRequest, options?: any): AxiosPromise<DatabaseResponse> {
            return localVarFp.editDatabase(databaseId, databaseEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit database  master credentials
         * @param {string} databaseId Database ID
         * @param {CredentialsRequest} [credentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editDatabaseCredentials(databaseId: string, credentialsRequest?: CredentialsRequest, options?: any): AxiosPromise<CredentialsResponse> {
            return localVarFp.editDatabaseCredentials(databaseId, credentialsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get database by ID
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabase(databaseId: string, options?: any): AxiosPromise<DatabaseResponse> {
            return localVarFp.getDatabase(databaseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get master credentials of the database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseMasterCredentials(databaseId: string, options?: any): AxiosPromise<CredentialsResponse> {
            return localVarFp.getDatabaseMasterCredentials(databaseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get database status
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseStatus(databaseId: string, options?: any): AxiosPromise<Status> {
            return localVarFp.getDatabaseStatus(databaseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List eligible versions for the database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseVersion(databaseId: string, options?: any): AxiosPromise<VersionResponseList> {
            return localVarFp.listDatabaseVersion(databaseId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DatabaseMainCallsApi - object-oriented interface
 * @export
 * @class DatabaseMainCallsApi
 * @extends {BaseAPI}
 */
export class DatabaseMainCallsApi extends BaseAPI {
    /**
     * To delete a database you must have the admin permission
     * @summary Delete a database 
     * @param {string} databaseId Database ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseMainCallsApi
     */
    public deleteDatabase(databaseId: string, options?: AxiosRequestConfig) {
        return DatabaseMainCallsApiFp(this.configuration).deleteDatabase(databaseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To edit a database  you must have the admin permission
     * @summary Edit a database 
     * @param {string} databaseId Database ID
     * @param {DatabaseEditRequest} [databaseEditRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseMainCallsApi
     */
    public editDatabase(databaseId: string, databaseEditRequest?: DatabaseEditRequest, options?: AxiosRequestConfig) {
        return DatabaseMainCallsApiFp(this.configuration).editDatabase(databaseId, databaseEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit database  master credentials
     * @param {string} databaseId Database ID
     * @param {CredentialsRequest} [credentialsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseMainCallsApi
     */
    public editDatabaseCredentials(databaseId: string, credentialsRequest?: CredentialsRequest, options?: AxiosRequestConfig) {
        return DatabaseMainCallsApiFp(this.configuration).editDatabaseCredentials(databaseId, credentialsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get database by ID
     * @param {string} databaseId Database ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseMainCallsApi
     */
    public getDatabase(databaseId: string, options?: AxiosRequestConfig) {
        return DatabaseMainCallsApiFp(this.configuration).getDatabase(databaseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get master credentials of the database
     * @param {string} databaseId Database ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseMainCallsApi
     */
    public getDatabaseMasterCredentials(databaseId: string, options?: AxiosRequestConfig) {
        return DatabaseMainCallsApiFp(this.configuration).getDatabaseMasterCredentials(databaseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get database status
     * @param {string} databaseId Database ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseMainCallsApi
     */
    public getDatabaseStatus(databaseId: string, options?: AxiosRequestConfig) {
        return DatabaseMainCallsApiFp(this.configuration).getDatabaseStatus(databaseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List eligible versions for the database
     * @param {string} databaseId Database ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseMainCallsApi
     */
    public listDatabaseVersion(databaseId: string, options?: AxiosRequestConfig) {
        return DatabaseMainCallsApiFp(this.configuration).listDatabaseVersion(databaseId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DatabaseMetricsApi - axios parameter creator
 * @export
 */
export const DatabaseMetricsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get current metric consumption of the database 
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseCurrentMetric: async (databaseId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('getDatabaseCurrentMetric', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}/currentMetric`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get CPU consumption metric over time for the database
         * @param {string} databaseId Database ID
         * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseMetricCpu: async (databaseId: string, lastSeconds: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('getDatabaseMetricCpu', 'databaseId', databaseId)
            // verify required parameter 'lastSeconds' is not null or undefined
            assertParamExists('getDatabaseMetricCpu', 'lastSeconds', lastSeconds)
            const localVarPath = `/database/{databaseId}/metric/cpu`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (lastSeconds !== undefined) {
                localVarQueryParameter['lastSeconds'] = lastSeconds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The value returned corresponds to the 95th centile
         * @summary Get Health Check latency  metric over time for the database
         * @param {string} databaseId Database ID
         * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseMetricHealthCheck: async (databaseId: string, lastSeconds: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('getDatabaseMetricHealthCheck', 'databaseId', databaseId)
            // verify required parameter 'lastSeconds' is not null or undefined
            assertParamExists('getDatabaseMetricHealthCheck', 'lastSeconds', lastSeconds)
            const localVarPath = `/database/{databaseId}/metric/healthCheck`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (lastSeconds !== undefined) {
                localVarQueryParameter['lastSeconds'] = lastSeconds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Memory consumption metric over time for the database
         * @param {string} databaseId Database ID
         * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseMetricMemory: async (databaseId: string, lastSeconds: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('getDatabaseMetricMemory', 'databaseId', databaseId)
            // verify required parameter 'lastSeconds' is not null or undefined
            assertParamExists('getDatabaseMetricMemory', 'lastSeconds', lastSeconds)
            const localVarPath = `/database/{databaseId}/metric/memory`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (lastSeconds !== undefined) {
                localVarQueryParameter['lastSeconds'] = lastSeconds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get database restart message and timestamp.
         * @summary List database restarts
         * @param {string} databaseId Database ID
         * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseMetricRestart: async (databaseId: string, lastSeconds: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('getDatabaseMetricRestart', 'databaseId', databaseId)
            // verify required parameter 'lastSeconds' is not null or undefined
            assertParamExists('getDatabaseMetricRestart', 'lastSeconds', lastSeconds)
            const localVarPath = `/database/{databaseId}/metric/restart`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (lastSeconds !== undefined) {
                localVarQueryParameter['lastSeconds'] = lastSeconds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Storage consumption metric over time for the database
         * @param {string} databaseId Database ID
         * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseMetricStorage: async (databaseId: string, lastSeconds: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('getDatabaseMetricStorage', 'databaseId', databaseId)
            // verify required parameter 'lastSeconds' is not null or undefined
            assertParamExists('getDatabaseMetricStorage', 'lastSeconds', lastSeconds)
            const localVarPath = `/database/{databaseId}/metric/storage`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (lastSeconds !== undefined) {
                localVarQueryParameter['lastSeconds'] = lastSeconds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatabaseMetricsApi - functional programming interface
 * @export
 */
export const DatabaseMetricsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DatabaseMetricsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get current metric consumption of the database 
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDatabaseCurrentMetric(databaseId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatabaseCurrentMetricResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDatabaseCurrentMetric(databaseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get CPU consumption metric over time for the database
         * @param {string} databaseId Database ID
         * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDatabaseMetricCpu(databaseId: string, lastSeconds: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricCPUDatapointResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDatabaseMetricCpu(databaseId, lastSeconds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The value returned corresponds to the 95th centile
         * @summary Get Health Check latency  metric over time for the database
         * @param {string} databaseId Database ID
         * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDatabaseMetricHealthCheck(databaseId: string, lastSeconds: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricGenericResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDatabaseMetricHealthCheck(databaseId, lastSeconds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Memory consumption metric over time for the database
         * @param {string} databaseId Database ID
         * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDatabaseMetricMemory(databaseId: string, lastSeconds: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricMemoryDatapointResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDatabaseMetricMemory(databaseId, lastSeconds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get database restart message and timestamp.
         * @summary List database restarts
         * @param {string} databaseId Database ID
         * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDatabaseMetricRestart(databaseId: string, lastSeconds: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricRestartResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDatabaseMetricRestart(databaseId, lastSeconds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Storage consumption metric over time for the database
         * @param {string} databaseId Database ID
         * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDatabaseMetricStorage(databaseId: string, lastSeconds: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricStorageDatapointResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDatabaseMetricStorage(databaseId, lastSeconds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DatabaseMetricsApi - factory interface
 * @export
 */
export const DatabaseMetricsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DatabaseMetricsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get current metric consumption of the database 
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseCurrentMetric(databaseId: string, options?: any): AxiosPromise<DatabaseCurrentMetricResponse> {
            return localVarFp.getDatabaseCurrentMetric(databaseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get CPU consumption metric over time for the database
         * @param {string} databaseId Database ID
         * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseMetricCpu(databaseId: string, lastSeconds: number, options?: any): AxiosPromise<MetricCPUDatapointResponseList> {
            return localVarFp.getDatabaseMetricCpu(databaseId, lastSeconds, options).then((request) => request(axios, basePath));
        },
        /**
         * The value returned corresponds to the 95th centile
         * @summary Get Health Check latency  metric over time for the database
         * @param {string} databaseId Database ID
         * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseMetricHealthCheck(databaseId: string, lastSeconds: number, options?: any): AxiosPromise<MetricGenericResponseList> {
            return localVarFp.getDatabaseMetricHealthCheck(databaseId, lastSeconds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Memory consumption metric over time for the database
         * @param {string} databaseId Database ID
         * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseMetricMemory(databaseId: string, lastSeconds: number, options?: any): AxiosPromise<MetricMemoryDatapointResponseList> {
            return localVarFp.getDatabaseMetricMemory(databaseId, lastSeconds, options).then((request) => request(axios, basePath));
        },
        /**
         * Get database restart message and timestamp.
         * @summary List database restarts
         * @param {string} databaseId Database ID
         * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseMetricRestart(databaseId: string, lastSeconds: number, options?: any): AxiosPromise<MetricRestartResponse> {
            return localVarFp.getDatabaseMetricRestart(databaseId, lastSeconds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Storage consumption metric over time for the database
         * @param {string} databaseId Database ID
         * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseMetricStorage(databaseId: string, lastSeconds: number, options?: any): AxiosPromise<MetricStorageDatapointResponseList> {
            return localVarFp.getDatabaseMetricStorage(databaseId, lastSeconds, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DatabaseMetricsApi - object-oriented interface
 * @export
 * @class DatabaseMetricsApi
 * @extends {BaseAPI}
 */
export class DatabaseMetricsApi extends BaseAPI {
    /**
     * 
     * @summary Get current metric consumption of the database 
     * @param {string} databaseId Database ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseMetricsApi
     */
    public getDatabaseCurrentMetric(databaseId: string, options?: AxiosRequestConfig) {
        return DatabaseMetricsApiFp(this.configuration).getDatabaseCurrentMetric(databaseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get CPU consumption metric over time for the database
     * @param {string} databaseId Database ID
     * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseMetricsApi
     */
    public getDatabaseMetricCpu(databaseId: string, lastSeconds: number, options?: AxiosRequestConfig) {
        return DatabaseMetricsApiFp(this.configuration).getDatabaseMetricCpu(databaseId, lastSeconds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The value returned corresponds to the 95th centile
     * @summary Get Health Check latency  metric over time for the database
     * @param {string} databaseId Database ID
     * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseMetricsApi
     */
    public getDatabaseMetricHealthCheck(databaseId: string, lastSeconds: number, options?: AxiosRequestConfig) {
        return DatabaseMetricsApiFp(this.configuration).getDatabaseMetricHealthCheck(databaseId, lastSeconds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Memory consumption metric over time for the database
     * @param {string} databaseId Database ID
     * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseMetricsApi
     */
    public getDatabaseMetricMemory(databaseId: string, lastSeconds: number, options?: AxiosRequestConfig) {
        return DatabaseMetricsApiFp(this.configuration).getDatabaseMetricMemory(databaseId, lastSeconds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get database restart message and timestamp.
     * @summary List database restarts
     * @param {string} databaseId Database ID
     * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseMetricsApi
     */
    public getDatabaseMetricRestart(databaseId: string, lastSeconds: number, options?: AxiosRequestConfig) {
        return DatabaseMetricsApiFp(this.configuration).getDatabaseMetricRestart(databaseId, lastSeconds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Storage consumption metric over time for the database
     * @param {string} databaseId Database ID
     * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseMetricsApi
     */
    public getDatabaseMetricStorage(databaseId: string, lastSeconds: number, options?: AxiosRequestConfig) {
        return DatabaseMetricsApiFp(this.configuration).getDatabaseMetricStorage(databaseId, lastSeconds, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DatabasesApi - axios parameter creator
 * @export
 */
export const DatabasesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a database
         * @param {string} environmentId Environment ID
         * @param {DatabaseRequest} [databaseRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatabase: async (environmentId: string, databaseRequest?: DatabaseRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('createDatabase', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/database`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(databaseRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of databases with only their id and status.
         * @summary List all environment databases statuses
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentDatabaseStatus: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('getEnvironmentDatabaseStatus', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/database/status`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List environment databases
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabase: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('listDatabase', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/database`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List eligible database types, versions and modes for the environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentDatabaseConfig: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('listEnvironmentDatabaseConfig', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/databaseConfiguration`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List current metric consumption for each database
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentDatabaseCurrentMetric: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('listEnvironmentDatabaseCurrentMetric', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/database/currentMetric`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatabasesApi - functional programming interface
 * @export
 */
export const DatabasesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DatabasesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a database
         * @param {string} environmentId Environment ID
         * @param {DatabaseRequest} [databaseRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDatabase(environmentId: string, databaseRequest?: DatabaseRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatabaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDatabase(environmentId, databaseRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of databases with only their id and status.
         * @summary List all environment databases statuses
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironmentDatabaseStatus(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReferenceObjectStatusResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironmentDatabaseStatus(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List environment databases
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDatabase(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatabaseResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDatabase(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List eligible database types, versions and modes for the environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEnvironmentDatabaseConfig(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatabaseConfigurationResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEnvironmentDatabaseConfig(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List current metric consumption for each database
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEnvironmentDatabaseCurrentMetric(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentDatabasesCurrentMetricResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEnvironmentDatabaseCurrentMetric(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DatabasesApi - factory interface
 * @export
 */
export const DatabasesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DatabasesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a database
         * @param {string} environmentId Environment ID
         * @param {DatabaseRequest} [databaseRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatabase(environmentId: string, databaseRequest?: DatabaseRequest, options?: any): AxiosPromise<DatabaseResponse> {
            return localVarFp.createDatabase(environmentId, databaseRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of databases with only their id and status.
         * @summary List all environment databases statuses
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentDatabaseStatus(environmentId: string, options?: any): AxiosPromise<ReferenceObjectStatusResponseList> {
            return localVarFp.getEnvironmentDatabaseStatus(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List environment databases
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabase(environmentId: string, options?: any): AxiosPromise<DatabaseResponseList> {
            return localVarFp.listDatabase(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List eligible database types, versions and modes for the environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentDatabaseConfig(environmentId: string, options?: any): AxiosPromise<DatabaseConfigurationResponseList> {
            return localVarFp.listEnvironmentDatabaseConfig(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List current metric consumption for each database
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentDatabaseCurrentMetric(environmentId: string, options?: any): AxiosPromise<EnvironmentDatabasesCurrentMetricResponseList> {
            return localVarFp.listEnvironmentDatabaseCurrentMetric(environmentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DatabasesApi - object-oriented interface
 * @export
 * @class DatabasesApi
 * @extends {BaseAPI}
 */
export class DatabasesApi extends BaseAPI {
    /**
     * 
     * @summary Create a database
     * @param {string} environmentId Environment ID
     * @param {DatabaseRequest} [databaseRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabasesApi
     */
    public createDatabase(environmentId: string, databaseRequest?: DatabaseRequest, options?: AxiosRequestConfig) {
        return DatabasesApiFp(this.configuration).createDatabase(environmentId, databaseRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of databases with only their id and status.
     * @summary List all environment databases statuses
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabasesApi
     */
    public getEnvironmentDatabaseStatus(environmentId: string, options?: AxiosRequestConfig) {
        return DatabasesApiFp(this.configuration).getEnvironmentDatabaseStatus(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List environment databases
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabasesApi
     */
    public listDatabase(environmentId: string, options?: AxiosRequestConfig) {
        return DatabasesApiFp(this.configuration).listDatabase(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List eligible database types, versions and modes for the environment
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabasesApi
     */
    public listEnvironmentDatabaseConfig(environmentId: string, options?: AxiosRequestConfig) {
        return DatabasesApiFp(this.configuration).listEnvironmentDatabaseConfig(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List current metric consumption for each database
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabasesApi
     */
    public listEnvironmentDatabaseCurrentMetric(environmentId: string, options?: AxiosRequestConfig) {
        return DatabasesApiFp(this.configuration).listEnvironmentDatabaseCurrentMetric(environmentId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DependencyApi - axios parameter creator
 * @export
 */
export const DependencyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add application dependency to this application to prevent this application starting before the linked dependencies
         * @summary Add application dependency to this application.
         * @param {string} applicationId Application ID
         * @param {string} targetApplicationId Target application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationDependency: async (applicationId: string, targetApplicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('createApplicationDependency', 'applicationId', applicationId)
            // verify required parameter 'targetApplicationId' is not null or undefined
            assertParamExists('createApplicationDependency', 'targetApplicationId', targetApplicationId)
            const localVarPath = `/application/{applicationId}/dependency/{targetApplicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"targetApplicationId"}}`, encodeURIComponent(String(targetApplicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List application dependencies
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationDependency: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('listApplicationDependency', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/dependency`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove application dependency to this application.
         * @param {string} applicationId Application ID
         * @param {string} targetApplicationId Target application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeApplicationDependency: async (applicationId: string, targetApplicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('removeApplicationDependency', 'applicationId', applicationId)
            // verify required parameter 'targetApplicationId' is not null or undefined
            assertParamExists('removeApplicationDependency', 'targetApplicationId', targetApplicationId)
            const localVarPath = `/application/{applicationId}/dependency/{targetApplicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"targetApplicationId"}}`, encodeURIComponent(String(targetApplicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DependencyApi - functional programming interface
 * @export
 */
export const DependencyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DependencyApiAxiosParamCreator(configuration)
    return {
        /**
         * Add application dependency to this application to prevent this application starting before the linked dependencies
         * @summary Add application dependency to this application.
         * @param {string} applicationId Application ID
         * @param {string} targetApplicationId Target application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplicationDependency(applicationId: string, targetApplicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplicationDependency(applicationId, targetApplicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List application dependencies
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplicationDependency(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplicationDependency(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove application dependency to this application.
         * @param {string} applicationId Application ID
         * @param {string} targetApplicationId Target application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeApplicationDependency(applicationId: string, targetApplicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeApplicationDependency(applicationId, targetApplicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DependencyApi - factory interface
 * @export
 */
export const DependencyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DependencyApiFp(configuration)
    return {
        /**
         * Add application dependency to this application to prevent this application starting before the linked dependencies
         * @summary Add application dependency to this application.
         * @param {string} applicationId Application ID
         * @param {string} targetApplicationId Target application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationDependency(applicationId: string, targetApplicationId: string, options?: any): AxiosPromise<ApplicationResponse> {
            return localVarFp.createApplicationDependency(applicationId, targetApplicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List application dependencies
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationDependency(applicationId: string, options?: any): AxiosPromise<ApplicationResponseList> {
            return localVarFp.listApplicationDependency(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove application dependency to this application.
         * @param {string} applicationId Application ID
         * @param {string} targetApplicationId Target application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeApplicationDependency(applicationId: string, targetApplicationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeApplicationDependency(applicationId, targetApplicationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DependencyApi - object-oriented interface
 * @export
 * @class DependencyApi
 * @extends {BaseAPI}
 */
export class DependencyApi extends BaseAPI {
    /**
     * Add application dependency to this application to prevent this application starting before the linked dependencies
     * @summary Add application dependency to this application.
     * @param {string} applicationId Application ID
     * @param {string} targetApplicationId Target application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DependencyApi
     */
    public createApplicationDependency(applicationId: string, targetApplicationId: string, options?: AxiosRequestConfig) {
        return DependencyApiFp(this.configuration).createApplicationDependency(applicationId, targetApplicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List application dependencies
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DependencyApi
     */
    public listApplicationDependency(applicationId: string, options?: AxiosRequestConfig) {
        return DependencyApiFp(this.configuration).listApplicationDependency(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove application dependency to this application.
     * @param {string} applicationId Application ID
     * @param {string} targetApplicationId Target application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DependencyApi
     */
    public removeApplicationDependency(applicationId: string, targetApplicationId: string, options?: AxiosRequestConfig) {
        return DependencyApiFp(this.configuration).removeApplicationDependency(applicationId, targetApplicationId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EnvironmentActionsApi - axios parameter creator
 * @export
 */
export const EnvironmentActionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancel the current deployment of your environment.
         * @summary Cancel environment deployment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelEnvironmentDeployment: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('cancelEnvironmentDeployment', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/cancelDeployment`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You must provide a name. This will create a new environment, with the same configuration, and same applications and databases. Database data is not cloned.
         * @summary Clone environment
         * @param {string} environmentId Environment ID
         * @param {CloneRequest} [cloneRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneEnvironment: async (environmentId: string, cloneRequest?: CloneRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('cloneEnvironment', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/clone`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloneRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This will deploy all the services of this environment to their latest version.
         * @summary Deploy environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployEnvironment: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('deployEnvironment', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/deploy`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restart environment
         * @param {string} environmentId Environment ID
         * @param {EnvironmentRestartRequest} [environmentRestartRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartEnvironment: async (environmentId: string, environmentRestartRequest?: EnvironmentRestartRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('restartEnvironment', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/restart`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentRestartRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopEnvironment: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('stopEnvironment', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/stop`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentActionsApi - functional programming interface
 * @export
 */
export const EnvironmentActionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnvironmentActionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Cancel the current deployment of your environment.
         * @summary Cancel environment deployment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelEnvironmentDeployment(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelEnvironmentDeployment(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * You must provide a name. This will create a new environment, with the same configuration, and same applications and databases. Database data is not cloned.
         * @summary Clone environment
         * @param {string} environmentId Environment ID
         * @param {CloneRequest} [cloneRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloneEnvironment(environmentId: string, cloneRequest?: CloneRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cloneEnvironment(environmentId, cloneRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This will deploy all the services of this environment to their latest version.
         * @summary Deploy environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployEnvironment(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployEnvironment(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Restart environment
         * @param {string} environmentId Environment ID
         * @param {EnvironmentRestartRequest} [environmentRestartRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restartEnvironment(environmentId: string, environmentRestartRequest?: EnvironmentRestartRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restartEnvironment(environmentId, environmentRestartRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Stop environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopEnvironment(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopEnvironment(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EnvironmentActionsApi - factory interface
 * @export
 */
export const EnvironmentActionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnvironmentActionsApiFp(configuration)
    return {
        /**
         * Cancel the current deployment of your environment.
         * @summary Cancel environment deployment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelEnvironmentDeployment(environmentId: string, options?: any): AxiosPromise<Status> {
            return localVarFp.cancelEnvironmentDeployment(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * You must provide a name. This will create a new environment, with the same configuration, and same applications and databases. Database data is not cloned.
         * @summary Clone environment
         * @param {string} environmentId Environment ID
         * @param {CloneRequest} [cloneRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneEnvironment(environmentId: string, cloneRequest?: CloneRequest, options?: any): AxiosPromise<EnvironmentResponse> {
            return localVarFp.cloneEnvironment(environmentId, cloneRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This will deploy all the services of this environment to their latest version.
         * @summary Deploy environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployEnvironment(environmentId: string, options?: any): AxiosPromise<Status> {
            return localVarFp.deployEnvironment(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Restart environment
         * @param {string} environmentId Environment ID
         * @param {EnvironmentRestartRequest} [environmentRestartRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartEnvironment(environmentId: string, environmentRestartRequest?: EnvironmentRestartRequest, options?: any): AxiosPromise<Status> {
            return localVarFp.restartEnvironment(environmentId, environmentRestartRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Stop environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopEnvironment(environmentId: string, options?: any): AxiosPromise<Status> {
            return localVarFp.stopEnvironment(environmentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnvironmentActionsApi - object-oriented interface
 * @export
 * @class EnvironmentActionsApi
 * @extends {BaseAPI}
 */
export class EnvironmentActionsApi extends BaseAPI {
    /**
     * Cancel the current deployment of your environment.
     * @summary Cancel environment deployment
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentActionsApi
     */
    public cancelEnvironmentDeployment(environmentId: string, options?: AxiosRequestConfig) {
        return EnvironmentActionsApiFp(this.configuration).cancelEnvironmentDeployment(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You must provide a name. This will create a new environment, with the same configuration, and same applications and databases. Database data is not cloned.
     * @summary Clone environment
     * @param {string} environmentId Environment ID
     * @param {CloneRequest} [cloneRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentActionsApi
     */
    public cloneEnvironment(environmentId: string, cloneRequest?: CloneRequest, options?: AxiosRequestConfig) {
        return EnvironmentActionsApiFp(this.configuration).cloneEnvironment(environmentId, cloneRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will deploy all the services of this environment to their latest version.
     * @summary Deploy environment
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentActionsApi
     */
    public deployEnvironment(environmentId: string, options?: AxiosRequestConfig) {
        return EnvironmentActionsApiFp(this.configuration).deployEnvironment(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Restart environment
     * @param {string} environmentId Environment ID
     * @param {EnvironmentRestartRequest} [environmentRestartRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentActionsApi
     */
    public restartEnvironment(environmentId: string, environmentRestartRequest?: EnvironmentRestartRequest, options?: AxiosRequestConfig) {
        return EnvironmentActionsApiFp(this.configuration).restartEnvironment(environmentId, environmentRestartRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Stop environment
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentActionsApi
     */
    public stopEnvironment(environmentId: string, options?: AxiosRequestConfig) {
        return EnvironmentActionsApiFp(this.configuration).stopEnvironment(environmentId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EnvironmentDeploymentHistoryApi - axios parameter creator
 * @export
 */
export const EnvironmentDeploymentHistoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List previous and current environment deployments with the status deployment and the related services. By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter
         * @summary List environment deployments
         * @param {string} environmentId Environment ID
         * @param {string} [startId] Starting point after which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentDeploymentHistory: async (environmentId: string, startId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('listEnvironmentDeploymentHistory', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/deploymentHistory`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (startId !== undefined) {
                localVarQueryParameter['startId'] = startId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentDeploymentHistoryApi - functional programming interface
 * @export
 */
export const EnvironmentDeploymentHistoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnvironmentDeploymentHistoryApiAxiosParamCreator(configuration)
    return {
        /**
         * List previous and current environment deployments with the status deployment and the related services. By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter
         * @summary List environment deployments
         * @param {string} environmentId Environment ID
         * @param {string} [startId] Starting point after which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEnvironmentDeploymentHistory(environmentId: string, startId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentHistoryEnvironmentPaginatedResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEnvironmentDeploymentHistory(environmentId, startId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EnvironmentDeploymentHistoryApi - factory interface
 * @export
 */
export const EnvironmentDeploymentHistoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnvironmentDeploymentHistoryApiFp(configuration)
    return {
        /**
         * List previous and current environment deployments with the status deployment and the related services. By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter
         * @summary List environment deployments
         * @param {string} environmentId Environment ID
         * @param {string} [startId] Starting point after which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentDeploymentHistory(environmentId: string, startId?: string, options?: any): AxiosPromise<DeploymentHistoryEnvironmentPaginatedResponseList> {
            return localVarFp.listEnvironmentDeploymentHistory(environmentId, startId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnvironmentDeploymentHistoryApi - object-oriented interface
 * @export
 * @class EnvironmentDeploymentHistoryApi
 * @extends {BaseAPI}
 */
export class EnvironmentDeploymentHistoryApi extends BaseAPI {
    /**
     * List previous and current environment deployments with the status deployment and the related services. By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter
     * @summary List environment deployments
     * @param {string} environmentId Environment ID
     * @param {string} [startId] Starting point after which to return results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentDeploymentHistoryApi
     */
    public listEnvironmentDeploymentHistory(environmentId: string, startId?: string, options?: AxiosRequestConfig) {
        return EnvironmentDeploymentHistoryApiFp(this.configuration).listEnvironmentDeploymentHistory(environmentId, startId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EnvironmentDeploymentRuleApi - axios parameter creator
 * @export
 */
export const EnvironmentDeploymentRuleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Edit an environment deployment rule
         * @param {string} environmentId Environment ID
         * @param {string} deploymentRuleId Deployment Rule ID
         * @param {EnvironmentDeploymentRuleEditRequest} [environmentDeploymentRuleEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editEnvironmentDeploymentRule: async (environmentId: string, deploymentRuleId: string, environmentDeploymentRuleEditRequest?: EnvironmentDeploymentRuleEditRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('editEnvironmentDeploymentRule', 'environmentId', environmentId)
            // verify required parameter 'deploymentRuleId' is not null or undefined
            assertParamExists('editEnvironmentDeploymentRule', 'deploymentRuleId', deploymentRuleId)
            const localVarPath = `/environment/{environmentId}/deploymentRule/{deploymentRuleId}`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)))
                .replace(`{${"deploymentRuleId"}}`, encodeURIComponent(String(deploymentRuleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentDeploymentRuleEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get environment deployment rule
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentDeploymentRule: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('getEnvironmentDeploymentRule', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/deploymentRule`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentDeploymentRuleApi - functional programming interface
 * @export
 */
export const EnvironmentDeploymentRuleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnvironmentDeploymentRuleApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Edit an environment deployment rule
         * @param {string} environmentId Environment ID
         * @param {string} deploymentRuleId Deployment Rule ID
         * @param {EnvironmentDeploymentRuleEditRequest} [environmentDeploymentRuleEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editEnvironmentDeploymentRule(environmentId: string, deploymentRuleId: string, environmentDeploymentRuleEditRequest?: EnvironmentDeploymentRuleEditRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentDeploymentRuleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editEnvironmentDeploymentRule(environmentId, deploymentRuleId, environmentDeploymentRuleEditRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get environment deployment rule
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironmentDeploymentRule(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentDeploymentRuleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironmentDeploymentRule(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EnvironmentDeploymentRuleApi - factory interface
 * @export
 */
export const EnvironmentDeploymentRuleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnvironmentDeploymentRuleApiFp(configuration)
    return {
        /**
         * 
         * @summary Edit an environment deployment rule
         * @param {string} environmentId Environment ID
         * @param {string} deploymentRuleId Deployment Rule ID
         * @param {EnvironmentDeploymentRuleEditRequest} [environmentDeploymentRuleEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editEnvironmentDeploymentRule(environmentId: string, deploymentRuleId: string, environmentDeploymentRuleEditRequest?: EnvironmentDeploymentRuleEditRequest, options?: any): AxiosPromise<EnvironmentDeploymentRuleResponse> {
            return localVarFp.editEnvironmentDeploymentRule(environmentId, deploymentRuleId, environmentDeploymentRuleEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get environment deployment rule
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentDeploymentRule(environmentId: string, options?: any): AxiosPromise<EnvironmentDeploymentRuleResponse> {
            return localVarFp.getEnvironmentDeploymentRule(environmentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnvironmentDeploymentRuleApi - object-oriented interface
 * @export
 * @class EnvironmentDeploymentRuleApi
 * @extends {BaseAPI}
 */
export class EnvironmentDeploymentRuleApi extends BaseAPI {
    /**
     * 
     * @summary Edit an environment deployment rule
     * @param {string} environmentId Environment ID
     * @param {string} deploymentRuleId Deployment Rule ID
     * @param {EnvironmentDeploymentRuleEditRequest} [environmentDeploymentRuleEditRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentDeploymentRuleApi
     */
    public editEnvironmentDeploymentRule(environmentId: string, deploymentRuleId: string, environmentDeploymentRuleEditRequest?: EnvironmentDeploymentRuleEditRequest, options?: AxiosRequestConfig) {
        return EnvironmentDeploymentRuleApiFp(this.configuration).editEnvironmentDeploymentRule(environmentId, deploymentRuleId, environmentDeploymentRuleEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get environment deployment rule
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentDeploymentRuleApi
     */
    public getEnvironmentDeploymentRule(environmentId: string, options?: AxiosRequestConfig) {
        return EnvironmentDeploymentRuleApiFp(this.configuration).getEnvironmentDeploymentRule(environmentId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EnvironmentLogsApi - axios parameter creator
 * @export
 */
export const EnvironmentLogsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This returns the last 1000 environment deployment logs.
         * @summary List environment deployment logs
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentLog: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('listEnvironmentLog', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/log`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentLogsApi - functional programming interface
 * @export
 */
export const EnvironmentLogsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnvironmentLogsApiAxiosParamCreator(configuration)
    return {
        /**
         * This returns the last 1000 environment deployment logs.
         * @summary List environment deployment logs
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEnvironmentLog(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentLogResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEnvironmentLog(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EnvironmentLogsApi - factory interface
 * @export
 */
export const EnvironmentLogsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnvironmentLogsApiFp(configuration)
    return {
        /**
         * This returns the last 1000 environment deployment logs.
         * @summary List environment deployment logs
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentLog(environmentId: string, options?: any): AxiosPromise<EnvironmentLogResponseList> {
            return localVarFp.listEnvironmentLog(environmentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnvironmentLogsApi - object-oriented interface
 * @export
 * @class EnvironmentLogsApi
 * @extends {BaseAPI}
 */
export class EnvironmentLogsApi extends BaseAPI {
    /**
     * This returns the last 1000 environment deployment logs.
     * @summary List environment deployment logs
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentLogsApi
     */
    public listEnvironmentLog(environmentId: string, options?: AxiosRequestConfig) {
        return EnvironmentLogsApiFp(this.configuration).listEnvironmentLog(environmentId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EnvironmentMainCallsApi - axios parameter creator
 * @export
 */
export const EnvironmentMainCallsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * To delete an environment you must have the admin permission
         * @summary Delete an environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEnvironment: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('deleteEnvironment', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To edit an environment you must have the admin permission
         * @summary Edit an environment
         * @param {string} environmentId Environment ID
         * @param {EnvironmentEditRequest} [environmentEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editEnvironment: async (environmentId: string, environmentEditRequest?: EnvironmentEditRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('editEnvironment', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get environment by ID
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironment: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('getEnvironment', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get environment status
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentStatus: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('getEnvironmentStatus', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/status`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This will return all the custom domains and Qovery autogenerated domain for all the applications within this environment
         * @summary List all URLs of the environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentLinks: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('listEnvironmentLinks', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/link`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentMainCallsApi - functional programming interface
 * @export
 */
export const EnvironmentMainCallsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnvironmentMainCallsApiAxiosParamCreator(configuration)
    return {
        /**
         * To delete an environment you must have the admin permission
         * @summary Delete an environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEnvironment(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEnvironment(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * To edit an environment you must have the admin permission
         * @summary Edit an environment
         * @param {string} environmentId Environment ID
         * @param {EnvironmentEditRequest} [environmentEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editEnvironment(environmentId: string, environmentEditRequest?: EnvironmentEditRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editEnvironment(environmentId, environmentEditRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get environment by ID
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironment(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironment(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get environment status
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironmentStatus(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironmentStatus(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This will return all the custom domains and Qovery autogenerated domain for all the applications within this environment
         * @summary List all URLs of the environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEnvironmentLinks(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEnvironmentLinks(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EnvironmentMainCallsApi - factory interface
 * @export
 */
export const EnvironmentMainCallsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnvironmentMainCallsApiFp(configuration)
    return {
        /**
         * To delete an environment you must have the admin permission
         * @summary Delete an environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEnvironment(environmentId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteEnvironment(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * To edit an environment you must have the admin permission
         * @summary Edit an environment
         * @param {string} environmentId Environment ID
         * @param {EnvironmentEditRequest} [environmentEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editEnvironment(environmentId: string, environmentEditRequest?: EnvironmentEditRequest, options?: any): AxiosPromise<EnvironmentResponse> {
            return localVarFp.editEnvironment(environmentId, environmentEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get environment by ID
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironment(environmentId: string, options?: any): AxiosPromise<EnvironmentResponse> {
            return localVarFp.getEnvironment(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get environment status
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentStatus(environmentId: string, options?: any): AxiosPromise<Status> {
            return localVarFp.getEnvironmentStatus(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * This will return all the custom domains and Qovery autogenerated domain for all the applications within this environment
         * @summary List all URLs of the environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentLinks(environmentId: string, options?: any): AxiosPromise<LinkResponseList> {
            return localVarFp.listEnvironmentLinks(environmentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnvironmentMainCallsApi - object-oriented interface
 * @export
 * @class EnvironmentMainCallsApi
 * @extends {BaseAPI}
 */
export class EnvironmentMainCallsApi extends BaseAPI {
    /**
     * To delete an environment you must have the admin permission
     * @summary Delete an environment
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentMainCallsApi
     */
    public deleteEnvironment(environmentId: string, options?: AxiosRequestConfig) {
        return EnvironmentMainCallsApiFp(this.configuration).deleteEnvironment(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To edit an environment you must have the admin permission
     * @summary Edit an environment
     * @param {string} environmentId Environment ID
     * @param {EnvironmentEditRequest} [environmentEditRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentMainCallsApi
     */
    public editEnvironment(environmentId: string, environmentEditRequest?: EnvironmentEditRequest, options?: AxiosRequestConfig) {
        return EnvironmentMainCallsApiFp(this.configuration).editEnvironment(environmentId, environmentEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get environment by ID
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentMainCallsApi
     */
    public getEnvironment(environmentId: string, options?: AxiosRequestConfig) {
        return EnvironmentMainCallsApiFp(this.configuration).getEnvironment(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get environment status
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentMainCallsApi
     */
    public getEnvironmentStatus(environmentId: string, options?: AxiosRequestConfig) {
        return EnvironmentMainCallsApiFp(this.configuration).getEnvironmentStatus(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will return all the custom domains and Qovery autogenerated domain for all the applications within this environment
     * @summary List all URLs of the environment
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentMainCallsApi
     */
    public listEnvironmentLinks(environmentId: string, options?: AxiosRequestConfig) {
        return EnvironmentMainCallsApiFp(this.configuration).listEnvironmentLinks(environmentId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EnvironmentSecretApi - axios parameter creator
 * @export
 */
export const EnvironmentSecretApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * - Add a secret to the environment.   - If the secret key already exists, then it will be replaced by the new one.   - If the secret value points toward an existing secret key, it will be considered as an alias. 
         * @summary Add a secret to the environment
         * @param {string} environmentId Environment ID
         * @param {SecretRequest} [secretRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironmentSecret: async (environmentId: string, secretRequest?: SecretRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('createEnvironmentSecret', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/secret`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(secretRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to add an alias at environment level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at environment level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - Only 1 alias level is allowed. You can\'t create an alias on an alias 
         * @summary Create a secret alias at the environment level
         * @param {string} environmentId Environment ID
         * @param {string} secretId Secret ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironmentSecretAlias: async (environmentId: string, secretId: string, key?: Key, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('createEnvironmentSecretAlias', 'environmentId', environmentId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('createEnvironmentSecretAlias', 'secretId', secretId)
            const localVarPath = `/environment/{environmentId}/secret/{secretId}/alias`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(key, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to override at environment level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at environment level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
         * @summary Create a secret override at the environment level
         * @param {string} environmentId Environment ID
         * @param {string} secretId Secret ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironmentSecretOverride: async (environmentId: string, secretId: string, value?: Value, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('createEnvironmentSecretOverride', 'environmentId', environmentId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('createEnvironmentSecretOverride', 'secretId', secretId)
            const localVarPath = `/environment/{environmentId}/secret/{secretId}/override`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(value, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well  operationId: deleteEnvironmentSecret 
         * @summary Delete a secret from the environment
         * @param {string} environmentId Environment ID
         * @param {string} secretId Secret ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEnvironmentSecret: async (environmentId: string, secretId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('deleteEnvironmentSecret', 'environmentId', environmentId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('deleteEnvironmentSecret', 'secretId', secretId)
            const localVarPath = `/environment/{environmentId}/secret/{secretId}`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit a secret belonging to the environment
         * @param {string} environmentId Environment ID
         * @param {string} secretId Secret ID
         * @param {SecretEditRequest} secretEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editEnvironmentSecret: async (environmentId: string, secretId: string, secretEditRequest: SecretEditRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('editEnvironmentSecret', 'environmentId', environmentId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('editEnvironmentSecret', 'secretId', secretId)
            // verify required parameter 'secretEditRequest' is not null or undefined
            assertParamExists('editEnvironmentSecret', 'secretEditRequest', secretEditRequest)
            const localVarPath = `/environment/{environmentId}/secret/{secretId}`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(secretEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List environment secrets
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentSecrets: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('listEnvironmentSecrets', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/secret`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentSecretApi - functional programming interface
 * @export
 */
export const EnvironmentSecretApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnvironmentSecretApiAxiosParamCreator(configuration)
    return {
        /**
         * - Add a secret to the environment.   - If the secret key already exists, then it will be replaced by the new one.   - If the secret value points toward an existing secret key, it will be considered as an alias. 
         * @summary Add a secret to the environment
         * @param {string} environmentId Environment ID
         * @param {SecretRequest} [secretRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEnvironmentSecret(environmentId: string, secretRequest?: SecretRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecretResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEnvironmentSecret(environmentId, secretRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - Allows you to add an alias at environment level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at environment level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - Only 1 alias level is allowed. You can\'t create an alias on an alias 
         * @summary Create a secret alias at the environment level
         * @param {string} environmentId Environment ID
         * @param {string} secretId Secret ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEnvironmentSecretAlias(environmentId: string, secretId: string, key?: Key, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecretResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEnvironmentSecretAlias(environmentId, secretId, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - Allows you to override at environment level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at environment level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
         * @summary Create a secret override at the environment level
         * @param {string} environmentId Environment ID
         * @param {string} secretId Secret ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEnvironmentSecretOverride(environmentId: string, secretId: string, value?: Value, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecretResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEnvironmentSecretOverride(environmentId, secretId, value, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well  operationId: deleteEnvironmentSecret 
         * @summary Delete a secret from the environment
         * @param {string} environmentId Environment ID
         * @param {string} secretId Secret ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEnvironmentSecret(environmentId: string, secretId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEnvironmentSecret(environmentId, secretId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit a secret belonging to the environment
         * @param {string} environmentId Environment ID
         * @param {string} secretId Secret ID
         * @param {SecretEditRequest} secretEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editEnvironmentSecret(environmentId: string, secretId: string, secretEditRequest: SecretEditRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecretResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editEnvironmentSecret(environmentId, secretId, secretEditRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List environment secrets
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEnvironmentSecrets(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecretResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEnvironmentSecrets(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EnvironmentSecretApi - factory interface
 * @export
 */
export const EnvironmentSecretApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnvironmentSecretApiFp(configuration)
    return {
        /**
         * - Add a secret to the environment.   - If the secret key already exists, then it will be replaced by the new one.   - If the secret value points toward an existing secret key, it will be considered as an alias. 
         * @summary Add a secret to the environment
         * @param {string} environmentId Environment ID
         * @param {SecretRequest} [secretRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironmentSecret(environmentId: string, secretRequest?: SecretRequest, options?: any): AxiosPromise<SecretResponse> {
            return localVarFp.createEnvironmentSecret(environmentId, secretRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to add an alias at environment level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at environment level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - Only 1 alias level is allowed. You can\'t create an alias on an alias 
         * @summary Create a secret alias at the environment level
         * @param {string} environmentId Environment ID
         * @param {string} secretId Secret ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironmentSecretAlias(environmentId: string, secretId: string, key?: Key, options?: any): AxiosPromise<SecretResponse> {
            return localVarFp.createEnvironmentSecretAlias(environmentId, secretId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to override at environment level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at environment level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
         * @summary Create a secret override at the environment level
         * @param {string} environmentId Environment ID
         * @param {string} secretId Secret ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironmentSecretOverride(environmentId: string, secretId: string, value?: Value, options?: any): AxiosPromise<SecretResponse> {
            return localVarFp.createEnvironmentSecretOverride(environmentId, secretId, value, options).then((request) => request(axios, basePath));
        },
        /**
         * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well  operationId: deleteEnvironmentSecret 
         * @summary Delete a secret from the environment
         * @param {string} environmentId Environment ID
         * @param {string} secretId Secret ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEnvironmentSecret(environmentId: string, secretId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteEnvironmentSecret(environmentId, secretId, options).then((request) => request(axios, basePath));
        },
        /**
         * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit a secret belonging to the environment
         * @param {string} environmentId Environment ID
         * @param {string} secretId Secret ID
         * @param {SecretEditRequest} secretEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editEnvironmentSecret(environmentId: string, secretId: string, secretEditRequest: SecretEditRequest, options?: any): AxiosPromise<SecretResponse> {
            return localVarFp.editEnvironmentSecret(environmentId, secretId, secretEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List environment secrets
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentSecrets(environmentId: string, options?: any): AxiosPromise<SecretResponseList> {
            return localVarFp.listEnvironmentSecrets(environmentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnvironmentSecretApi - object-oriented interface
 * @export
 * @class EnvironmentSecretApi
 * @extends {BaseAPI}
 */
export class EnvironmentSecretApi extends BaseAPI {
    /**
     * - Add a secret to the environment.   - If the secret key already exists, then it will be replaced by the new one.   - If the secret value points toward an existing secret key, it will be considered as an alias. 
     * @summary Add a secret to the environment
     * @param {string} environmentId Environment ID
     * @param {SecretRequest} [secretRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentSecretApi
     */
    public createEnvironmentSecret(environmentId: string, secretRequest?: SecretRequest, options?: AxiosRequestConfig) {
        return EnvironmentSecretApiFp(this.configuration).createEnvironmentSecret(environmentId, secretRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to add an alias at environment level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at environment level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - Only 1 alias level is allowed. You can\'t create an alias on an alias 
     * @summary Create a secret alias at the environment level
     * @param {string} environmentId Environment ID
     * @param {string} secretId Secret ID
     * @param {Key} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentSecretApi
     */
    public createEnvironmentSecretAlias(environmentId: string, secretId: string, key?: Key, options?: AxiosRequestConfig) {
        return EnvironmentSecretApiFp(this.configuration).createEnvironmentSecretAlias(environmentId, secretId, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to override at environment level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at environment level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
     * @summary Create a secret override at the environment level
     * @param {string} environmentId Environment ID
     * @param {string} secretId Secret ID
     * @param {Value} [value] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentSecretApi
     */
    public createEnvironmentSecretOverride(environmentId: string, secretId: string, value?: Value, options?: AxiosRequestConfig) {
        return EnvironmentSecretApiFp(this.configuration).createEnvironmentSecretOverride(environmentId, secretId, value, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well  operationId: deleteEnvironmentSecret 
     * @summary Delete a secret from the environment
     * @param {string} environmentId Environment ID
     * @param {string} secretId Secret ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentSecretApi
     */
    public deleteEnvironmentSecret(environmentId: string, secretId: string, options?: AxiosRequestConfig) {
        return EnvironmentSecretApiFp(this.configuration).deleteEnvironmentSecret(environmentId, secretId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
     * @summary Edit a secret belonging to the environment
     * @param {string} environmentId Environment ID
     * @param {string} secretId Secret ID
     * @param {SecretEditRequest} secretEditRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentSecretApi
     */
    public editEnvironmentSecret(environmentId: string, secretId: string, secretEditRequest: SecretEditRequest, options?: AxiosRequestConfig) {
        return EnvironmentSecretApiFp(this.configuration).editEnvironmentSecret(environmentId, secretId, secretEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List environment secrets
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentSecretApi
     */
    public listEnvironmentSecrets(environmentId: string, options?: AxiosRequestConfig) {
        return EnvironmentSecretApiFp(this.configuration).listEnvironmentSecrets(environmentId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EnvironmentVariableApi - axios parameter creator
 * @export
 */
export const EnvironmentVariableApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * - Add an environment variable to the environment.   - If the environment variable key already exists, then it will be replaced by the new one.   - If the environment variable value points toward an existing environment variable key, it will be considered as an alias. 
         * @summary Add an environment variable to the environment
         * @param {string} environmentId Environment ID
         * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironmentEnvironmentVariable: async (environmentId: string, environmentVariableRequest?: EnvironmentVariableRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('createEnvironmentEnvironmentVariable', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/environmentVariable`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentVariableRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to add an alias at environment level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at environment level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - Only 1 alias level is allowed. You can\'t create an alias on an alias 
         * @summary Create an environment variable alias at the environment level
         * @param {string} environmentId Environment ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironmentEnvironmentVariableAlias: async (environmentId: string, environmentVariableId: string, key?: Key, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('createEnvironmentEnvironmentVariableAlias', 'environmentId', environmentId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('createEnvironmentEnvironmentVariableAlias', 'environmentVariableId', environmentVariableId)
            const localVarPath = `/environment/{environmentId}/environmentVariable/{environmentVariableId}/alias`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(key, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to override at environment level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at environment level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
         * @summary Create an environment variable override at the environment level
         * @param {string} environmentId Environment ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironmentEnvironmentVariableOverride: async (environmentId: string, environmentVariableId: string, value?: Value, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('createEnvironmentEnvironmentVariableOverride', 'environmentId', environmentId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('createEnvironmentEnvironmentVariableOverride', 'environmentVariableId', environmentVariableId)
            const localVarPath = `/environment/{environmentId}/environmentVariable/{environmentVariableId}/override`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(value, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - To delete an environment variable you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete an environment variable from an environment
         * @param {string} environmentId Environment ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEnvironmentEnvironmentVariable: async (environmentId: string, environmentVariableId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('deleteEnvironmentEnvironmentVariable', 'environmentId', environmentId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('deleteEnvironmentEnvironmentVariable', 'environmentVariableId', environmentVariableId)
            const localVarPath = `/environment/{environmentId}/environmentVariable/{environmentVariableId}`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit an environment variable belonging to the environment
         * @param {string} environmentId Environment ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editEnvironmentEnvironmentVariable: async (environmentId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('editEnvironmentEnvironmentVariable', 'environmentId', environmentId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('editEnvironmentEnvironmentVariable', 'environmentVariableId', environmentVariableId)
            // verify required parameter 'environmentVariableEditRequest' is not null or undefined
            assertParamExists('editEnvironmentEnvironmentVariable', 'environmentVariableEditRequest', environmentVariableEditRequest)
            const localVarPath = `/environment/{environmentId}/environmentVariable/{environmentVariableId}`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentVariableEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List environment variables
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentEnvironmentVariable: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('listEnvironmentEnvironmentVariable', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/environmentVariable`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentVariableApi - functional programming interface
 * @export
 */
export const EnvironmentVariableApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnvironmentVariableApiAxiosParamCreator(configuration)
    return {
        /**
         * - Add an environment variable to the environment.   - If the environment variable key already exists, then it will be replaced by the new one.   - If the environment variable value points toward an existing environment variable key, it will be considered as an alias. 
         * @summary Add an environment variable to the environment
         * @param {string} environmentId Environment ID
         * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEnvironmentEnvironmentVariable(environmentId: string, environmentVariableRequest?: EnvironmentVariableRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariableResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEnvironmentEnvironmentVariable(environmentId, environmentVariableRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - Allows you to add an alias at environment level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at environment level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - Only 1 alias level is allowed. You can\'t create an alias on an alias 
         * @summary Create an environment variable alias at the environment level
         * @param {string} environmentId Environment ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEnvironmentEnvironmentVariableAlias(environmentId: string, environmentVariableId: string, key?: Key, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariableResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEnvironmentEnvironmentVariableAlias(environmentId, environmentVariableId, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - Allows you to override at environment level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at environment level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
         * @summary Create an environment variable override at the environment level
         * @param {string} environmentId Environment ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEnvironmentEnvironmentVariableOverride(environmentId: string, environmentVariableId: string, value?: Value, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariableResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEnvironmentEnvironmentVariableOverride(environmentId, environmentVariableId, value, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - To delete an environment variable you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete an environment variable from an environment
         * @param {string} environmentId Environment ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEnvironmentEnvironmentVariable(environmentId: string, environmentVariableId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEnvironmentEnvironmentVariable(environmentId, environmentVariableId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit an environment variable belonging to the environment
         * @param {string} environmentId Environment ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editEnvironmentEnvironmentVariable(environmentId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariableResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editEnvironmentEnvironmentVariable(environmentId, environmentVariableId, environmentVariableEditRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List environment variables
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEnvironmentEnvironmentVariable(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariableResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEnvironmentEnvironmentVariable(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EnvironmentVariableApi - factory interface
 * @export
 */
export const EnvironmentVariableApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnvironmentVariableApiFp(configuration)
    return {
        /**
         * - Add an environment variable to the environment.   - If the environment variable key already exists, then it will be replaced by the new one.   - If the environment variable value points toward an existing environment variable key, it will be considered as an alias. 
         * @summary Add an environment variable to the environment
         * @param {string} environmentId Environment ID
         * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironmentEnvironmentVariable(environmentId: string, environmentVariableRequest?: EnvironmentVariableRequest, options?: any): AxiosPromise<EnvironmentVariableResponse> {
            return localVarFp.createEnvironmentEnvironmentVariable(environmentId, environmentVariableRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to add an alias at environment level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at environment level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - Only 1 alias level is allowed. You can\'t create an alias on an alias 
         * @summary Create an environment variable alias at the environment level
         * @param {string} environmentId Environment ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironmentEnvironmentVariableAlias(environmentId: string, environmentVariableId: string, key?: Key, options?: any): AxiosPromise<EnvironmentVariableResponse> {
            return localVarFp.createEnvironmentEnvironmentVariableAlias(environmentId, environmentVariableId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to override at environment level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at environment level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
         * @summary Create an environment variable override at the environment level
         * @param {string} environmentId Environment ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironmentEnvironmentVariableOverride(environmentId: string, environmentVariableId: string, value?: Value, options?: any): AxiosPromise<EnvironmentVariableResponse> {
            return localVarFp.createEnvironmentEnvironmentVariableOverride(environmentId, environmentVariableId, value, options).then((request) => request(axios, basePath));
        },
        /**
         * - To delete an environment variable you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete an environment variable from an environment
         * @param {string} environmentId Environment ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEnvironmentEnvironmentVariable(environmentId: string, environmentVariableId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteEnvironmentEnvironmentVariable(environmentId, environmentVariableId, options).then((request) => request(axios, basePath));
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit an environment variable belonging to the environment
         * @param {string} environmentId Environment ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editEnvironmentEnvironmentVariable(environmentId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options?: any): AxiosPromise<EnvironmentVariableResponse> {
            return localVarFp.editEnvironmentEnvironmentVariable(environmentId, environmentVariableId, environmentVariableEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List environment variables
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentEnvironmentVariable(environmentId: string, options?: any): AxiosPromise<EnvironmentVariableResponseList> {
            return localVarFp.listEnvironmentEnvironmentVariable(environmentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnvironmentVariableApi - object-oriented interface
 * @export
 * @class EnvironmentVariableApi
 * @extends {BaseAPI}
 */
export class EnvironmentVariableApi extends BaseAPI {
    /**
     * - Add an environment variable to the environment.   - If the environment variable key already exists, then it will be replaced by the new one.   - If the environment variable value points toward an existing environment variable key, it will be considered as an alias. 
     * @summary Add an environment variable to the environment
     * @param {string} environmentId Environment ID
     * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentVariableApi
     */
    public createEnvironmentEnvironmentVariable(environmentId: string, environmentVariableRequest?: EnvironmentVariableRequest, options?: AxiosRequestConfig) {
        return EnvironmentVariableApiFp(this.configuration).createEnvironmentEnvironmentVariable(environmentId, environmentVariableRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to add an alias at environment level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at environment level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - Only 1 alias level is allowed. You can\'t create an alias on an alias 
     * @summary Create an environment variable alias at the environment level
     * @param {string} environmentId Environment ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {Key} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentVariableApi
     */
    public createEnvironmentEnvironmentVariableAlias(environmentId: string, environmentVariableId: string, key?: Key, options?: AxiosRequestConfig) {
        return EnvironmentVariableApiFp(this.configuration).createEnvironmentEnvironmentVariableAlias(environmentId, environmentVariableId, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to override at environment level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at environment level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
     * @summary Create an environment variable override at the environment level
     * @param {string} environmentId Environment ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {Value} [value] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentVariableApi
     */
    public createEnvironmentEnvironmentVariableOverride(environmentId: string, environmentVariableId: string, value?: Value, options?: AxiosRequestConfig) {
        return EnvironmentVariableApiFp(this.configuration).createEnvironmentEnvironmentVariableOverride(environmentId, environmentVariableId, value, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - To delete an environment variable you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
     * @summary Delete an environment variable from an environment
     * @param {string} environmentId Environment ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentVariableApi
     */
    public deleteEnvironmentEnvironmentVariable(environmentId: string, environmentVariableId: string, options?: AxiosRequestConfig) {
        return EnvironmentVariableApiFp(this.configuration).deleteEnvironmentEnvironmentVariable(environmentId, environmentVariableId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
     * @summary Edit an environment variable belonging to the environment
     * @param {string} environmentId Environment ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentVariableApi
     */
    public editEnvironmentEnvironmentVariable(environmentId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options?: AxiosRequestConfig) {
        return EnvironmentVariableApiFp(this.configuration).editEnvironmentEnvironmentVariable(environmentId, environmentVariableId, environmentVariableEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List environment variables
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentVariableApi
     */
    public listEnvironmentEnvironmentVariable(environmentId: string, options?: AxiosRequestConfig) {
        return EnvironmentVariableApiFp(this.configuration).listEnvironmentEnvironmentVariable(environmentId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EnvironmentsApi - axios parameter creator
 * @export
 */
export const EnvironmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create an environment
         * @param {string} projectId Project ID
         * @param {EnvironmentRequest} [environmentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironment: async (projectId: string, environmentRequest?: EnvironmentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createEnvironment', 'projectId', projectId)
            const localVarPath = `/project/{projectId}/environment`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of environment ids, and for each its total numberof services
         * @summary List total number of services for each environment of the project
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectEnvironmentServiceNumber: async (projectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getProjectEnvironmentServiceNumber', 'projectId', projectId)
            const localVarPath = `/project/{projectId}/environment/stats`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of environments with only their id and status.
         * @summary List environments statuses
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectEnvironmentStatus: async (projectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getProjectEnvironmentStatus', 'projectId', projectId)
            const localVarPath = `/project/{projectId}/environment/status`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List environments
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironment: async (projectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('listEnvironment', 'projectId', projectId)
            const localVarPath = `/project/{projectId}/environment`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentsApi - functional programming interface
 * @export
 */
export const EnvironmentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnvironmentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create an environment
         * @param {string} projectId Project ID
         * @param {EnvironmentRequest} [environmentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEnvironment(projectId: string, environmentRequest?: EnvironmentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEnvironment(projectId, environmentRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of environment ids, and for each its total numberof services
         * @summary List total number of services for each environment of the project
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjectEnvironmentServiceNumber(projectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentStatsResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectEnvironmentServiceNumber(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of environments with only their id and status.
         * @summary List environments statuses
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjectEnvironmentStatus(projectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectEnvironmentStatus(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List environments
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEnvironment(projectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEnvironment(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EnvironmentsApi - factory interface
 * @export
 */
export const EnvironmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnvironmentsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create an environment
         * @param {string} projectId Project ID
         * @param {EnvironmentRequest} [environmentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironment(projectId: string, environmentRequest?: EnvironmentRequest, options?: any): AxiosPromise<EnvironmentResponse> {
            return localVarFp.createEnvironment(projectId, environmentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of environment ids, and for each its total numberof services
         * @summary List total number of services for each environment of the project
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectEnvironmentServiceNumber(projectId: string, options?: any): AxiosPromise<EnvironmentStatsResponseList> {
            return localVarFp.getProjectEnvironmentServiceNumber(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of environments with only their id and status.
         * @summary List environments statuses
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectEnvironmentStatus(projectId: string, options?: any): AxiosPromise<Status> {
            return localVarFp.getProjectEnvironmentStatus(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List environments
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironment(projectId: string, options?: any): AxiosPromise<EnvironmentResponseList> {
            return localVarFp.listEnvironment(projectId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnvironmentsApi - object-oriented interface
 * @export
 * @class EnvironmentsApi
 * @extends {BaseAPI}
 */
export class EnvironmentsApi extends BaseAPI {
    /**
     * 
     * @summary Create an environment
     * @param {string} projectId Project ID
     * @param {EnvironmentRequest} [environmentRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public createEnvironment(projectId: string, environmentRequest?: EnvironmentRequest, options?: AxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).createEnvironment(projectId, environmentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of environment ids, and for each its total numberof services
     * @summary List total number of services for each environment of the project
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public getProjectEnvironmentServiceNumber(projectId: string, options?: AxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).getProjectEnvironmentServiceNumber(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of environments with only their id and status.
     * @summary List environments statuses
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public getProjectEnvironmentStatus(projectId: string, options?: AxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).getProjectEnvironmentStatus(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List environments
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public listEnvironment(projectId: string, options?: AxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).listEnvironment(projectId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GitRepositoriesApi - axios parameter creator
 * @export
 */
export const GitRepositoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get bitbucket repositories of the connected user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBitbucketRepositories: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/bitbucket/repository`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get bitbucket branches of the specified repository
         * @param {string} [name] The name of the repository where to retrieve the branches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBitbucketRepositoryBranches: async (name?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/bitbucket/repository/branch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get git provider accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGitProviderAccount: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/gitAuthProvider`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get github repositories of the connected user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGithubRepositories: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/github/repository`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get github branches of the specified repository
         * @param {string} [name] The name of the repository where to retrieve the branches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGithubRepositoryBranches: async (name?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/github/repository/branch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get gitlab repositories of the connected user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGitlabRepositories: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/gitlab/repository`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get gitlab branches of the specified repository
         * @param {string} [name] The name of the repository to retrieve the branches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGitlabRepositoryBranches: async (name?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/gitlab/repository/branch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GitRepositoriesApi - functional programming interface
 * @export
 */
export const GitRepositoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GitRepositoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get bitbucket repositories of the connected user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBitbucketRepositories(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitRepositoryResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBitbucketRepositories(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get bitbucket branches of the specified repository
         * @param {string} [name] The name of the repository where to retrieve the branches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBitbucketRepositoryBranches(name?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitRepositoryBranchResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBitbucketRepositoryBranches(name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get git provider accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGitProviderAccount(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitAuthProviderResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGitProviderAccount(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get github repositories of the connected user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGithubRepositories(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitRepositoryResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGithubRepositories(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get github branches of the specified repository
         * @param {string} [name] The name of the repository where to retrieve the branches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGithubRepositoryBranches(name?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitRepositoryBranchResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGithubRepositoryBranches(name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get gitlab repositories of the connected user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGitlabRepositories(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitRepositoryResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGitlabRepositories(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get gitlab branches of the specified repository
         * @param {string} [name] The name of the repository to retrieve the branches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGitlabRepositoryBranches(name?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitRepositoryBranchResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGitlabRepositoryBranches(name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GitRepositoriesApi - factory interface
 * @export
 */
export const GitRepositoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GitRepositoriesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get bitbucket repositories of the connected user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBitbucketRepositories(options?: any): AxiosPromise<GitRepositoryResponseList> {
            return localVarFp.getBitbucketRepositories(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get bitbucket branches of the specified repository
         * @param {string} [name] The name of the repository where to retrieve the branches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBitbucketRepositoryBranches(name?: string, options?: any): AxiosPromise<GitRepositoryBranchResponseList> {
            return localVarFp.getBitbucketRepositoryBranches(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get git provider accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGitProviderAccount(options?: any): AxiosPromise<GitAuthProviderResponseList> {
            return localVarFp.getGitProviderAccount(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get github repositories of the connected user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGithubRepositories(options?: any): AxiosPromise<GitRepositoryResponseList> {
            return localVarFp.getGithubRepositories(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get github branches of the specified repository
         * @param {string} [name] The name of the repository where to retrieve the branches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGithubRepositoryBranches(name?: string, options?: any): AxiosPromise<GitRepositoryBranchResponseList> {
            return localVarFp.getGithubRepositoryBranches(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get gitlab repositories of the connected user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGitlabRepositories(options?: any): AxiosPromise<GitRepositoryResponseList> {
            return localVarFp.getGitlabRepositories(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get gitlab branches of the specified repository
         * @param {string} [name] The name of the repository to retrieve the branches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGitlabRepositoryBranches(name?: string, options?: any): AxiosPromise<GitRepositoryBranchResponseList> {
            return localVarFp.getGitlabRepositoryBranches(name, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GitRepositoriesApi - object-oriented interface
 * @export
 * @class GitRepositoriesApi
 * @extends {BaseAPI}
 */
export class GitRepositoriesApi extends BaseAPI {
    /**
     * 
     * @summary Get bitbucket repositories of the connected user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GitRepositoriesApi
     */
    public getBitbucketRepositories(options?: AxiosRequestConfig) {
        return GitRepositoriesApiFp(this.configuration).getBitbucketRepositories(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get bitbucket branches of the specified repository
     * @param {string} [name] The name of the repository where to retrieve the branches
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GitRepositoriesApi
     */
    public getBitbucketRepositoryBranches(name?: string, options?: AxiosRequestConfig) {
        return GitRepositoriesApiFp(this.configuration).getBitbucketRepositoryBranches(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get git provider accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GitRepositoriesApi
     */
    public getGitProviderAccount(options?: AxiosRequestConfig) {
        return GitRepositoriesApiFp(this.configuration).getGitProviderAccount(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get github repositories of the connected user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GitRepositoriesApi
     */
    public getGithubRepositories(options?: AxiosRequestConfig) {
        return GitRepositoriesApiFp(this.configuration).getGithubRepositories(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get github branches of the specified repository
     * @param {string} [name] The name of the repository where to retrieve the branches
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GitRepositoriesApi
     */
    public getGithubRepositoryBranches(name?: string, options?: AxiosRequestConfig) {
        return GitRepositoriesApiFp(this.configuration).getGithubRepositoryBranches(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get gitlab repositories of the connected user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GitRepositoriesApi
     */
    public getGitlabRepositories(options?: AxiosRequestConfig) {
        return GitRepositoriesApiFp(this.configuration).getGitlabRepositories(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get gitlab branches of the specified repository
     * @param {string} [name] The name of the repository to retrieve the branches
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GitRepositoriesApi
     */
    public getGitlabRepositoryBranches(name?: string, options?: AxiosRequestConfig) {
        return GitRepositoriesApiFp(this.configuration).getGitlabRepositoryBranches(name, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LogicalDatabaseApi - axios parameter creator
 * @export
 */
export const LogicalDatabaseApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * If you don\'t specify credentials, Qovery will autogenerate them.
         * @summary Create a logical database on the database
         * @param {string} databaseId Database ID
         * @param {LogicalDatabaseRequest} [logicalDatabaseRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLogicalDatabaseOnDatabase: async (databaseId: string, logicalDatabaseRequest?: LogicalDatabaseRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('createLogicalDatabaseOnDatabase', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}/logicalDatabase`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(logicalDatabaseRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To delete a logical database you must have the project user permission
         * @summary Delete a Logical database
         * @param {string} logicalDatabaseId Logical Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLogicalDatabase: async (logicalDatabaseId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'logicalDatabaseId' is not null or undefined
            assertParamExists('deleteLogicalDatabase', 'logicalDatabaseId', logicalDatabaseId)
            const localVarPath = `/logicalDatabase/{logicalDatabaseId}`
                .replace(`{${"logicalDatabaseId"}}`, encodeURIComponent(String(logicalDatabaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a logical database
         * @param {string} logicalDatabaseId Logical Database ID
         * @param {LogicalDatabaseRequest} [logicalDatabaseRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editLogicalDatabase: async (logicalDatabaseId: string, logicalDatabaseRequest?: LogicalDatabaseRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'logicalDatabaseId' is not null or undefined
            assertParamExists('editLogicalDatabase', 'logicalDatabaseId', logicalDatabaseId)
            const localVarPath = `/logicalDatabase/{logicalDatabaseId}`
                .replace(`{${"logicalDatabaseId"}}`, encodeURIComponent(String(logicalDatabaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(logicalDatabaseRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit logical database credentials
         * @param {string} logicalDatabaseId Logical Database ID
         * @param {CredentialsRequest} [credentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editLogicalDatabaseCredentials: async (logicalDatabaseId: string, credentialsRequest?: CredentialsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'logicalDatabaseId' is not null or undefined
            assertParamExists('editLogicalDatabaseCredentials', 'logicalDatabaseId', logicalDatabaseId)
            const localVarPath = `/logicalDatabase/{logicalDatabaseId}/credentials`
                .replace(`{${"logicalDatabaseId"}}`, encodeURIComponent(String(logicalDatabaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(credentialsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A logical database exists inside a database. The database is a service that exists within an environment, that you can deploy, and that has allocated resources. A database can have several logical databases
         * @summary Get logical database by ID
         * @param {string} logicalDatabaseId Logical Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogicalDatabase: async (logicalDatabaseId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'logicalDatabaseId' is not null or undefined
            assertParamExists('getLogicalDatabase', 'logicalDatabaseId', logicalDatabaseId)
            const localVarPath = `/logicalDatabase/{logicalDatabaseId}`
                .replace(`{${"logicalDatabaseId"}}`, encodeURIComponent(String(logicalDatabaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get  credentials of the logical database
         * @param {string} logicalDatabaseId Logical Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogicalDatabaseCredentials: async (logicalDatabaseId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'logicalDatabaseId' is not null or undefined
            assertParamExists('getLogicalDatabaseCredentials', 'logicalDatabaseId', logicalDatabaseId)
            const localVarPath = `/logicalDatabase/{logicalDatabaseId}/credentials`
                .replace(`{${"logicalDatabaseId"}}`, encodeURIComponent(String(logicalDatabaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List linked applications
         * @param {string} logicalDatabaseId Logical Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLogicalDatabaseApplication: async (logicalDatabaseId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'logicalDatabaseId' is not null or undefined
            assertParamExists('listLogicalDatabaseApplication', 'logicalDatabaseId', logicalDatabaseId)
            const localVarPath = `/logicalDatabase/{logicalDatabaseId}/application`
                .replace(`{${"logicalDatabaseId"}}`, encodeURIComponent(String(logicalDatabaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A logical database exists inside a database. The database is a service that exists within an environment, that you can deploy, and that has allocated resources. A database can have several logical databases
         * @summary List logical databases of a database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLogicalDatabaseDatabase: async (databaseId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('listLogicalDatabaseDatabase', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}/logicalDatabase`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LogicalDatabaseApi - functional programming interface
 * @export
 */
export const LogicalDatabaseApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LogicalDatabaseApiAxiosParamCreator(configuration)
    return {
        /**
         * If you don\'t specify credentials, Qovery will autogenerate them.
         * @summary Create a logical database on the database
         * @param {string} databaseId Database ID
         * @param {LogicalDatabaseRequest} [logicalDatabaseRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createLogicalDatabaseOnDatabase(databaseId: string, logicalDatabaseRequest?: LogicalDatabaseRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogicalDatabaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createLogicalDatabaseOnDatabase(databaseId, logicalDatabaseRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * To delete a logical database you must have the project user permission
         * @summary Delete a Logical database
         * @param {string} logicalDatabaseId Logical Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLogicalDatabase(logicalDatabaseId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteLogicalDatabase(logicalDatabaseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit a logical database
         * @param {string} logicalDatabaseId Logical Database ID
         * @param {LogicalDatabaseRequest} [logicalDatabaseRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editLogicalDatabase(logicalDatabaseId: string, logicalDatabaseRequest?: LogicalDatabaseRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogicalDatabaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editLogicalDatabase(logicalDatabaseId, logicalDatabaseRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit logical database credentials
         * @param {string} logicalDatabaseId Logical Database ID
         * @param {CredentialsRequest} [credentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editLogicalDatabaseCredentials(logicalDatabaseId: string, credentialsRequest?: CredentialsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CredentialsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editLogicalDatabaseCredentials(logicalDatabaseId, credentialsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A logical database exists inside a database. The database is a service that exists within an environment, that you can deploy, and that has allocated resources. A database can have several logical databases
         * @summary Get logical database by ID
         * @param {string} logicalDatabaseId Logical Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLogicalDatabase(logicalDatabaseId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogicalDatabaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLogicalDatabase(logicalDatabaseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get  credentials of the logical database
         * @param {string} logicalDatabaseId Logical Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLogicalDatabaseCredentials(logicalDatabaseId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CredentialsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLogicalDatabaseCredentials(logicalDatabaseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List linked applications
         * @param {string} logicalDatabaseId Logical Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLogicalDatabaseApplication(logicalDatabaseId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listLogicalDatabaseApplication(logicalDatabaseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A logical database exists inside a database. The database is a service that exists within an environment, that you can deploy, and that has allocated resources. A database can have several logical databases
         * @summary List logical databases of a database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLogicalDatabaseDatabase(databaseId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogicalDatabaseResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listLogicalDatabaseDatabase(databaseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LogicalDatabaseApi - factory interface
 * @export
 */
export const LogicalDatabaseApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LogicalDatabaseApiFp(configuration)
    return {
        /**
         * If you don\'t specify credentials, Qovery will autogenerate them.
         * @summary Create a logical database on the database
         * @param {string} databaseId Database ID
         * @param {LogicalDatabaseRequest} [logicalDatabaseRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLogicalDatabaseOnDatabase(databaseId: string, logicalDatabaseRequest?: LogicalDatabaseRequest, options?: any): AxiosPromise<LogicalDatabaseResponse> {
            return localVarFp.createLogicalDatabaseOnDatabase(databaseId, logicalDatabaseRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * To delete a logical database you must have the project user permission
         * @summary Delete a Logical database
         * @param {string} logicalDatabaseId Logical Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLogicalDatabase(logicalDatabaseId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteLogicalDatabase(logicalDatabaseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a logical database
         * @param {string} logicalDatabaseId Logical Database ID
         * @param {LogicalDatabaseRequest} [logicalDatabaseRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editLogicalDatabase(logicalDatabaseId: string, logicalDatabaseRequest?: LogicalDatabaseRequest, options?: any): AxiosPromise<LogicalDatabaseResponse> {
            return localVarFp.editLogicalDatabase(logicalDatabaseId, logicalDatabaseRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit logical database credentials
         * @param {string} logicalDatabaseId Logical Database ID
         * @param {CredentialsRequest} [credentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editLogicalDatabaseCredentials(logicalDatabaseId: string, credentialsRequest?: CredentialsRequest, options?: any): AxiosPromise<CredentialsResponse> {
            return localVarFp.editLogicalDatabaseCredentials(logicalDatabaseId, credentialsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * A logical database exists inside a database. The database is a service that exists within an environment, that you can deploy, and that has allocated resources. A database can have several logical databases
         * @summary Get logical database by ID
         * @param {string} logicalDatabaseId Logical Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogicalDatabase(logicalDatabaseId: string, options?: any): AxiosPromise<LogicalDatabaseResponse> {
            return localVarFp.getLogicalDatabase(logicalDatabaseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get  credentials of the logical database
         * @param {string} logicalDatabaseId Logical Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogicalDatabaseCredentials(logicalDatabaseId: string, options?: any): AxiosPromise<CredentialsResponse> {
            return localVarFp.getLogicalDatabaseCredentials(logicalDatabaseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List linked applications
         * @param {string} logicalDatabaseId Logical Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLogicalDatabaseApplication(logicalDatabaseId: string, options?: any): AxiosPromise<ApplicationResponseList> {
            return localVarFp.listLogicalDatabaseApplication(logicalDatabaseId, options).then((request) => request(axios, basePath));
        },
        /**
         * A logical database exists inside a database. The database is a service that exists within an environment, that you can deploy, and that has allocated resources. A database can have several logical databases
         * @summary List logical databases of a database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLogicalDatabaseDatabase(databaseId: string, options?: any): AxiosPromise<LogicalDatabaseResponseList> {
            return localVarFp.listLogicalDatabaseDatabase(databaseId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LogicalDatabaseApi - object-oriented interface
 * @export
 * @class LogicalDatabaseApi
 * @extends {BaseAPI}
 */
export class LogicalDatabaseApi extends BaseAPI {
    /**
     * If you don\'t specify credentials, Qovery will autogenerate them.
     * @summary Create a logical database on the database
     * @param {string} databaseId Database ID
     * @param {LogicalDatabaseRequest} [logicalDatabaseRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogicalDatabaseApi
     */
    public createLogicalDatabaseOnDatabase(databaseId: string, logicalDatabaseRequest?: LogicalDatabaseRequest, options?: AxiosRequestConfig) {
        return LogicalDatabaseApiFp(this.configuration).createLogicalDatabaseOnDatabase(databaseId, logicalDatabaseRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To delete a logical database you must have the project user permission
     * @summary Delete a Logical database
     * @param {string} logicalDatabaseId Logical Database ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogicalDatabaseApi
     */
    public deleteLogicalDatabase(logicalDatabaseId: string, options?: AxiosRequestConfig) {
        return LogicalDatabaseApiFp(this.configuration).deleteLogicalDatabase(logicalDatabaseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a logical database
     * @param {string} logicalDatabaseId Logical Database ID
     * @param {LogicalDatabaseRequest} [logicalDatabaseRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogicalDatabaseApi
     */
    public editLogicalDatabase(logicalDatabaseId: string, logicalDatabaseRequest?: LogicalDatabaseRequest, options?: AxiosRequestConfig) {
        return LogicalDatabaseApiFp(this.configuration).editLogicalDatabase(logicalDatabaseId, logicalDatabaseRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit logical database credentials
     * @param {string} logicalDatabaseId Logical Database ID
     * @param {CredentialsRequest} [credentialsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogicalDatabaseApi
     */
    public editLogicalDatabaseCredentials(logicalDatabaseId: string, credentialsRequest?: CredentialsRequest, options?: AxiosRequestConfig) {
        return LogicalDatabaseApiFp(this.configuration).editLogicalDatabaseCredentials(logicalDatabaseId, credentialsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A logical database exists inside a database. The database is a service that exists within an environment, that you can deploy, and that has allocated resources. A database can have several logical databases
     * @summary Get logical database by ID
     * @param {string} logicalDatabaseId Logical Database ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogicalDatabaseApi
     */
    public getLogicalDatabase(logicalDatabaseId: string, options?: AxiosRequestConfig) {
        return LogicalDatabaseApiFp(this.configuration).getLogicalDatabase(logicalDatabaseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get  credentials of the logical database
     * @param {string} logicalDatabaseId Logical Database ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogicalDatabaseApi
     */
    public getLogicalDatabaseCredentials(logicalDatabaseId: string, options?: AxiosRequestConfig) {
        return LogicalDatabaseApiFp(this.configuration).getLogicalDatabaseCredentials(logicalDatabaseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List linked applications
     * @param {string} logicalDatabaseId Logical Database ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogicalDatabaseApi
     */
    public listLogicalDatabaseApplication(logicalDatabaseId: string, options?: AxiosRequestConfig) {
        return LogicalDatabaseApiFp(this.configuration).listLogicalDatabaseApplication(logicalDatabaseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A logical database exists inside a database. The database is a service that exists within an environment, that you can deploy, and that has allocated resources. A database can have several logical databases
     * @summary List logical databases of a database
     * @param {string} databaseId Database ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogicalDatabaseApi
     */
    public listLogicalDatabaseDatabase(databaseId: string, options?: AxiosRequestConfig) {
        return LogicalDatabaseApiFp(this.configuration).listLogicalDatabaseDatabase(databaseId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MembersApi - axios parameter creator
 * @export
 */
export const MembersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove an invited member
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInviteMember: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteInviteMember', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/inviteMember/{inviteId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a member
         * @param {string} organizationId Organization ID
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMember: async (organizationId: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteMember', 'organizationId', organizationId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteMember', 'userId', userId)
            const localVarPath = `/organization/{organizationId}/member/{userId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get invited members
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationInvitedMembers: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationInvitedMembers', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/inviteMember`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get organization members
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationMembers: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationMembers', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/member`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Accept Invite in the organization
         * @param {string} organizationId Organization ID
         * @param {string} inviteId Invite ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAcceptInviteMember: async (organizationId: string, inviteId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('postAcceptInviteMember', 'organizationId', organizationId)
            // verify required parameter 'inviteId' is not null or undefined
            assertParamExists('postAcceptInviteMember', 'inviteId', inviteId)
            const localVarPath = `/organization/{organizationId}/inviteMember/{inviteId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"inviteId"}}`, encodeURIComponent(String(inviteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invite someone in the organization
         * @param {string} organizationId Organization ID
         * @param {InviteMemberRequest} [inviteMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postInviteMember: async (organizationId: string, inviteMemberRequest?: InviteMemberRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('postInviteMember', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/inviteMember`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inviteMemberRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Transfer organization ownership to another user
         * @param {string} organizationId Organization ID
         * @param {TransferOwnershipRequest} [transferOwnershipRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrganizationTransferOwnership: async (organizationId: string, transferOwnershipRequest?: TransferOwnershipRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('postOrganizationTransferOwnership', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/transferOwnership`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transferOwnershipRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MembersApi - functional programming interface
 * @export
 */
export const MembersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MembersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove an invited member
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteInviteMember(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteInviteMember(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove a member
         * @param {string} organizationId Organization ID
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMember(organizationId: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMember(organizationId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get invited members
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationInvitedMembers(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InviteMemberResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationInvitedMembers(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get organization members
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationMembers(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemberResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationMembers(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Accept Invite in the organization
         * @param {string} organizationId Organization ID
         * @param {string} inviteId Invite ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAcceptInviteMember(organizationId: string, inviteId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InviteMemberResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postAcceptInviteMember(organizationId, inviteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Invite someone in the organization
         * @param {string} organizationId Organization ID
         * @param {InviteMemberRequest} [inviteMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postInviteMember(organizationId: string, inviteMemberRequest?: InviteMemberRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InviteMemberResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postInviteMember(organizationId, inviteMemberRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Transfer organization ownership to another user
         * @param {string} organizationId Organization ID
         * @param {TransferOwnershipRequest} [transferOwnershipRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postOrganizationTransferOwnership(organizationId: string, transferOwnershipRequest?: TransferOwnershipRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postOrganizationTransferOwnership(organizationId, transferOwnershipRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MembersApi - factory interface
 * @export
 */
export const MembersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MembersApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove an invited member
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInviteMember(organizationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteInviteMember(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a member
         * @param {string} organizationId Organization ID
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMember(organizationId: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteMember(organizationId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get invited members
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationInvitedMembers(organizationId: string, options?: any): AxiosPromise<InviteMemberResponseList> {
            return localVarFp.getOrganizationInvitedMembers(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get organization members
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationMembers(organizationId: string, options?: any): AxiosPromise<MemberResponseList> {
            return localVarFp.getOrganizationMembers(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Accept Invite in the organization
         * @param {string} organizationId Organization ID
         * @param {string} inviteId Invite ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAcceptInviteMember(organizationId: string, inviteId: string, options?: any): AxiosPromise<InviteMemberResponse> {
            return localVarFp.postAcceptInviteMember(organizationId, inviteId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invite someone in the organization
         * @param {string} organizationId Organization ID
         * @param {InviteMemberRequest} [inviteMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postInviteMember(organizationId: string, inviteMemberRequest?: InviteMemberRequest, options?: any): AxiosPromise<InviteMemberResponse> {
            return localVarFp.postInviteMember(organizationId, inviteMemberRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Transfer organization ownership to another user
         * @param {string} organizationId Organization ID
         * @param {TransferOwnershipRequest} [transferOwnershipRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrganizationTransferOwnership(organizationId: string, transferOwnershipRequest?: TransferOwnershipRequest, options?: any): AxiosPromise<void> {
            return localVarFp.postOrganizationTransferOwnership(organizationId, transferOwnershipRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MembersApi - object-oriented interface
 * @export
 * @class MembersApi
 * @extends {BaseAPI}
 */
export class MembersApi extends BaseAPI {
    /**
     * 
     * @summary Remove an invited member
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public deleteInviteMember(organizationId: string, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).deleteInviteMember(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a member
     * @param {string} organizationId Organization ID
     * @param {string} userId User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public deleteMember(organizationId: string, userId: string, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).deleteMember(organizationId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get invited members
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public getOrganizationInvitedMembers(organizationId: string, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).getOrganizationInvitedMembers(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get organization members
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public getOrganizationMembers(organizationId: string, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).getOrganizationMembers(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Accept Invite in the organization
     * @param {string} organizationId Organization ID
     * @param {string} inviteId Invite ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public postAcceptInviteMember(organizationId: string, inviteId: string, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).postAcceptInviteMember(organizationId, inviteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invite someone in the organization
     * @param {string} organizationId Organization ID
     * @param {InviteMemberRequest} [inviteMemberRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public postInviteMember(organizationId: string, inviteMemberRequest?: InviteMemberRequest, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).postInviteMember(organizationId, inviteMemberRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Transfer organization ownership to another user
     * @param {string} organizationId Organization ID
     * @param {TransferOwnershipRequest} [transferOwnershipRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public postOrganizationTransferOwnership(organizationId: string, transferOwnershipRequest?: TransferOwnershipRequest, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).postOrganizationTransferOwnership(organizationId, transferOwnershipRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrganizationApiTokenApi - axios parameter creator
 * @export
 */
export const OrganizationApiTokenApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an organization api token
         * @summary Create an organization api token
         * @param {string} organizationId Organization ID
         * @param {OrganizationApiTokenCreateRequest} [organizationApiTokenCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationApiToken: async (organizationId: string, organizationApiTokenCreateRequest?: OrganizationApiTokenCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createOrganizationApiToken', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/apiToken`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationApiTokenCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete organization api token
         * @summary Delete organization api token
         * @param {string} organizationId Organization ID
         * @param {string} apiTokenId Organization Api Token ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationApiToken: async (organizationId: string, apiTokenId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteOrganizationApiToken', 'organizationId', organizationId)
            // verify required parameter 'apiTokenId' is not null or undefined
            assertParamExists('deleteOrganizationApiToken', 'apiTokenId', apiTokenId)
            const localVarPath = `/organization/{organizationId}/apiToken/{apiTokenId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"apiTokenId"}}`, encodeURIComponent(String(apiTokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List organization api tokens
         * @summary List organization api tokens
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationApiTokens: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listOrganizationApiTokens', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/apiToken`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationApiTokenApi - functional programming interface
 * @export
 */
export const OrganizationApiTokenApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationApiTokenApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an organization api token
         * @summary Create an organization api token
         * @param {string} organizationId Organization ID
         * @param {OrganizationApiTokenCreateRequest} [organizationApiTokenCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrganizationApiToken(organizationId: string, organizationApiTokenCreateRequest?: OrganizationApiTokenCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationApiTokenCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrganizationApiToken(organizationId, organizationApiTokenCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete organization api token
         * @summary Delete organization api token
         * @param {string} organizationId Organization ID
         * @param {string} apiTokenId Organization Api Token ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrganizationApiToken(organizationId: string, apiTokenId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrganizationApiToken(organizationId, apiTokenId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List organization api tokens
         * @summary List organization api tokens
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizationApiTokens(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationApiTokenResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationApiTokens(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrganizationApiTokenApi - factory interface
 * @export
 */
export const OrganizationApiTokenApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationApiTokenApiFp(configuration)
    return {
        /**
         * Create an organization api token
         * @summary Create an organization api token
         * @param {string} organizationId Organization ID
         * @param {OrganizationApiTokenCreateRequest} [organizationApiTokenCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationApiToken(organizationId: string, organizationApiTokenCreateRequest?: OrganizationApiTokenCreateRequest, options?: any): AxiosPromise<OrganizationApiTokenCreateResponse> {
            return localVarFp.createOrganizationApiToken(organizationId, organizationApiTokenCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete organization api token
         * @summary Delete organization api token
         * @param {string} organizationId Organization ID
         * @param {string} apiTokenId Organization Api Token ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationApiToken(organizationId: string, apiTokenId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteOrganizationApiToken(organizationId, apiTokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * List organization api tokens
         * @summary List organization api tokens
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationApiTokens(organizationId: string, options?: any): AxiosPromise<OrganizationApiTokenResponseList> {
            return localVarFp.listOrganizationApiTokens(organizationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationApiTokenApi - object-oriented interface
 * @export
 * @class OrganizationApiTokenApi
 * @extends {BaseAPI}
 */
export class OrganizationApiTokenApi extends BaseAPI {
    /**
     * Create an organization api token
     * @summary Create an organization api token
     * @param {string} organizationId Organization ID
     * @param {OrganizationApiTokenCreateRequest} [organizationApiTokenCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiTokenApi
     */
    public createOrganizationApiToken(organizationId: string, organizationApiTokenCreateRequest?: OrganizationApiTokenCreateRequest, options?: AxiosRequestConfig) {
        return OrganizationApiTokenApiFp(this.configuration).createOrganizationApiToken(organizationId, organizationApiTokenCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete organization api token
     * @summary Delete organization api token
     * @param {string} organizationId Organization ID
     * @param {string} apiTokenId Organization Api Token ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiTokenApi
     */
    public deleteOrganizationApiToken(organizationId: string, apiTokenId: string, options?: AxiosRequestConfig) {
        return OrganizationApiTokenApiFp(this.configuration).deleteOrganizationApiToken(organizationId, apiTokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List organization api tokens
     * @summary List organization api tokens
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiTokenApi
     */
    public listOrganizationApiTokens(organizationId: string, options?: AxiosRequestConfig) {
        return OrganizationApiTokenApiFp(this.configuration).listOrganizationApiTokens(organizationId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrganizationMainCallsApi - axios parameter creator
 * @export
 */
export const OrganizationMainCallsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create an organization
         * @param {OrganizationRequest} [organizationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganization: async (organizationRequest?: OrganizationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/organization`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To delete an organization you must have the admin permission
         * @summary Delete an organization
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganization: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteOrganization', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To edit an organization you must have the admin permission
         * @summary Edit an organization
         * @param {string} organizationId Organization ID
         * @param {OrganizationEditRequest} [organizationEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editOrganization: async (organizationId: string, organizationEditRequest?: OrganizationEditRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('editOrganization', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get organization by ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganization', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List user organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganization: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/organization`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationMainCallsApi - functional programming interface
 * @export
 */
export const OrganizationMainCallsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationMainCallsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create an organization
         * @param {OrganizationRequest} [organizationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrganization(organizationRequest?: OrganizationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrganization(organizationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * To delete an organization you must have the admin permission
         * @summary Delete an organization
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrganization(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrganization(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * To edit an organization you must have the admin permission
         * @summary Edit an organization
         * @param {string} organizationId Organization ID
         * @param {OrganizationEditRequest} [organizationEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editOrganization(organizationId: string, organizationEditRequest?: OrganizationEditRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editOrganization(organizationId, organizationEditRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get organization by ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganization(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganization(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List user organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganization(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganization(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrganizationMainCallsApi - factory interface
 * @export
 */
export const OrganizationMainCallsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationMainCallsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create an organization
         * @param {OrganizationRequest} [organizationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganization(organizationRequest?: OrganizationRequest, options?: any): AxiosPromise<OrganizationResponse> {
            return localVarFp.createOrganization(organizationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * To delete an organization you must have the admin permission
         * @summary Delete an organization
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganization(organizationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteOrganization(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * To edit an organization you must have the admin permission
         * @summary Edit an organization
         * @param {string} organizationId Organization ID
         * @param {OrganizationEditRequest} [organizationEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editOrganization(organizationId: string, organizationEditRequest?: OrganizationEditRequest, options?: any): AxiosPromise<OrganizationResponse> {
            return localVarFp.editOrganization(organizationId, organizationEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get organization by ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization(organizationId: string, options?: any): AxiosPromise<OrganizationResponse> {
            return localVarFp.getOrganization(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List user organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganization(options?: any): AxiosPromise<OrganizationResponseList> {
            return localVarFp.listOrganization(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationMainCallsApi - object-oriented interface
 * @export
 * @class OrganizationMainCallsApi
 * @extends {BaseAPI}
 */
export class OrganizationMainCallsApi extends BaseAPI {
    /**
     * 
     * @summary Create an organization
     * @param {OrganizationRequest} [organizationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationMainCallsApi
     */
    public createOrganization(organizationRequest?: OrganizationRequest, options?: AxiosRequestConfig) {
        return OrganizationMainCallsApiFp(this.configuration).createOrganization(organizationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To delete an organization you must have the admin permission
     * @summary Delete an organization
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationMainCallsApi
     */
    public deleteOrganization(organizationId: string, options?: AxiosRequestConfig) {
        return OrganizationMainCallsApiFp(this.configuration).deleteOrganization(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To edit an organization you must have the admin permission
     * @summary Edit an organization
     * @param {string} organizationId Organization ID
     * @param {OrganizationEditRequest} [organizationEditRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationMainCallsApi
     */
    public editOrganization(organizationId: string, organizationEditRequest?: OrganizationEditRequest, options?: AxiosRequestConfig) {
        return OrganizationMainCallsApiFp(this.configuration).editOrganization(organizationId, organizationEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get organization by ID
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationMainCallsApi
     */
    public getOrganization(organizationId: string, options?: AxiosRequestConfig) {
        return OrganizationMainCallsApiFp(this.configuration).getOrganization(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List user organizations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationMainCallsApi
     */
    public listOrganization(options?: AxiosRequestConfig) {
        return OrganizationMainCallsApiFp(this.configuration).listOrganization(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProjectDeploymentRuleApi - axios parameter creator
 * @export
 */
export const ProjectDeploymentRuleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a deployment rule
         * @summary Create a deployment rule
         * @param {string} projectId Project ID
         * @param {ProjectDeploymentRuleRequest} [projectDeploymentRuleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeploymentRule: async (projectId: string, projectDeploymentRuleRequest?: ProjectDeploymentRuleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createDeploymentRule', 'projectId', projectId)
            const localVarPath = `/project/{projectId}/deploymentRule`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectDeploymentRuleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a project deployment rule
         * @summary Delete a project deployment rule
         * @param {string} projectId Project ID
         * @param {string} deploymentRuleId Deployment Rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectDeploymentRule: async (projectId: string, deploymentRuleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteProjectDeploymentRule', 'projectId', projectId)
            // verify required parameter 'deploymentRuleId' is not null or undefined
            assertParamExists('deleteProjectDeploymentRule', 'deploymentRuleId', deploymentRuleId)
            const localVarPath = `/project/{projectId}/deploymentRule/{deploymentRuleId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"deploymentRuleId"}}`, encodeURIComponent(String(deploymentRuleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit a project deployment rule
         * @summary Edit a project deployment rule
         * @param {string} projectId Project ID
         * @param {string} deploymentRuleId Deployment Rule ID
         * @param {ProjectDeploymentRuleRequest} [projectDeploymentRuleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editProjectDeployemtnRule: async (projectId: string, deploymentRuleId: string, projectDeploymentRuleRequest?: ProjectDeploymentRuleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('editProjectDeployemtnRule', 'projectId', projectId)
            // verify required parameter 'deploymentRuleId' is not null or undefined
            assertParamExists('editProjectDeployemtnRule', 'deploymentRuleId', deploymentRuleId)
            const localVarPath = `/project/{projectId}/deploymentRule/{deploymentRuleId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"deploymentRuleId"}}`, encodeURIComponent(String(deploymentRuleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectDeploymentRuleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a project deployment rule
         * @summary Get a project deployment rule
         * @param {string} projectId Project ID
         * @param {string} deploymentRuleId Deployment Rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectDeploymentRule: async (projectId: string, deploymentRuleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getProjectDeploymentRule', 'projectId', projectId)
            // verify required parameter 'deploymentRuleId' is not null or undefined
            assertParamExists('getProjectDeploymentRule', 'deploymentRuleId', deploymentRuleId)
            const localVarPath = `/project/{projectId}/deploymentRule/{deploymentRuleId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"deploymentRuleId"}}`, encodeURIComponent(String(deploymentRuleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List project deployment rules
         * @summary List project deployment rules
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectDeploymentRules: async (projectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('listProjectDeploymentRules', 'projectId', projectId)
            const localVarPath = `/project/{projectId}/deploymentRule`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update deployment rules priority order
         * @summary Update deployment rules priority order
         * @param {string} projectId Project ID
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeploymentRulesPriorityOrder: async (projectId: string, inlineObject?: InlineObject, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateDeploymentRulesPriorityOrder', 'projectId', projectId)
            const localVarPath = `/project/{projectId}/deploymentRule/order`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectDeploymentRuleApi - functional programming interface
 * @export
 */
export const ProjectDeploymentRuleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectDeploymentRuleApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a deployment rule
         * @summary Create a deployment rule
         * @param {string} projectId Project ID
         * @param {ProjectDeploymentRuleRequest} [projectDeploymentRuleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDeploymentRule(projectId: string, projectDeploymentRuleRequest?: ProjectDeploymentRuleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectDeploymentRuleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDeploymentRule(projectId, projectDeploymentRuleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a project deployment rule
         * @summary Delete a project deployment rule
         * @param {string} projectId Project ID
         * @param {string} deploymentRuleId Deployment Rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProjectDeploymentRule(projectId: string, deploymentRuleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProjectDeploymentRule(projectId, deploymentRuleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Edit a project deployment rule
         * @summary Edit a project deployment rule
         * @param {string} projectId Project ID
         * @param {string} deploymentRuleId Deployment Rule ID
         * @param {ProjectDeploymentRuleRequest} [projectDeploymentRuleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editProjectDeployemtnRule(projectId: string, deploymentRuleId: string, projectDeploymentRuleRequest?: ProjectDeploymentRuleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectDeploymentRuleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editProjectDeployemtnRule(projectId, deploymentRuleId, projectDeploymentRuleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a project deployment rule
         * @summary Get a project deployment rule
         * @param {string} projectId Project ID
         * @param {string} deploymentRuleId Deployment Rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjectDeploymentRule(projectId: string, deploymentRuleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectDeploymentRuleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectDeploymentRule(projectId, deploymentRuleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List project deployment rules
         * @summary List project deployment rules
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProjectDeploymentRules(projectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectDeploymentRuleResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProjectDeploymentRules(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update deployment rules priority order
         * @summary Update deployment rules priority order
         * @param {string} projectId Project ID
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDeploymentRulesPriorityOrder(projectId: string, inlineObject?: InlineObject, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDeploymentRulesPriorityOrder(projectId, inlineObject, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectDeploymentRuleApi - factory interface
 * @export
 */
export const ProjectDeploymentRuleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectDeploymentRuleApiFp(configuration)
    return {
        /**
         * Create a deployment rule
         * @summary Create a deployment rule
         * @param {string} projectId Project ID
         * @param {ProjectDeploymentRuleRequest} [projectDeploymentRuleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeploymentRule(projectId: string, projectDeploymentRuleRequest?: ProjectDeploymentRuleRequest, options?: any): AxiosPromise<ProjectDeploymentRuleResponse> {
            return localVarFp.createDeploymentRule(projectId, projectDeploymentRuleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a project deployment rule
         * @summary Delete a project deployment rule
         * @param {string} projectId Project ID
         * @param {string} deploymentRuleId Deployment Rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectDeploymentRule(projectId: string, deploymentRuleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteProjectDeploymentRule(projectId, deploymentRuleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit a project deployment rule
         * @summary Edit a project deployment rule
         * @param {string} projectId Project ID
         * @param {string} deploymentRuleId Deployment Rule ID
         * @param {ProjectDeploymentRuleRequest} [projectDeploymentRuleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editProjectDeployemtnRule(projectId: string, deploymentRuleId: string, projectDeploymentRuleRequest?: ProjectDeploymentRuleRequest, options?: any): AxiosPromise<ProjectDeploymentRuleResponse> {
            return localVarFp.editProjectDeployemtnRule(projectId, deploymentRuleId, projectDeploymentRuleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a project deployment rule
         * @summary Get a project deployment rule
         * @param {string} projectId Project ID
         * @param {string} deploymentRuleId Deployment Rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectDeploymentRule(projectId: string, deploymentRuleId: string, options?: any): AxiosPromise<ProjectDeploymentRuleResponse> {
            return localVarFp.getProjectDeploymentRule(projectId, deploymentRuleId, options).then((request) => request(axios, basePath));
        },
        /**
         * List project deployment rules
         * @summary List project deployment rules
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectDeploymentRules(projectId: string, options?: any): AxiosPromise<ProjectDeploymentRuleResponseList> {
            return localVarFp.listProjectDeploymentRules(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update deployment rules priority order
         * @summary Update deployment rules priority order
         * @param {string} projectId Project ID
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeploymentRulesPriorityOrder(projectId: string, inlineObject?: InlineObject, options?: any): AxiosPromise<void> {
            return localVarFp.updateDeploymentRulesPriorityOrder(projectId, inlineObject, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectDeploymentRuleApi - object-oriented interface
 * @export
 * @class ProjectDeploymentRuleApi
 * @extends {BaseAPI}
 */
export class ProjectDeploymentRuleApi extends BaseAPI {
    /**
     * Create a deployment rule
     * @summary Create a deployment rule
     * @param {string} projectId Project ID
     * @param {ProjectDeploymentRuleRequest} [projectDeploymentRuleRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDeploymentRuleApi
     */
    public createDeploymentRule(projectId: string, projectDeploymentRuleRequest?: ProjectDeploymentRuleRequest, options?: AxiosRequestConfig) {
        return ProjectDeploymentRuleApiFp(this.configuration).createDeploymentRule(projectId, projectDeploymentRuleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a project deployment rule
     * @summary Delete a project deployment rule
     * @param {string} projectId Project ID
     * @param {string} deploymentRuleId Deployment Rule ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDeploymentRuleApi
     */
    public deleteProjectDeploymentRule(projectId: string, deploymentRuleId: string, options?: AxiosRequestConfig) {
        return ProjectDeploymentRuleApiFp(this.configuration).deleteProjectDeploymentRule(projectId, deploymentRuleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit a project deployment rule
     * @summary Edit a project deployment rule
     * @param {string} projectId Project ID
     * @param {string} deploymentRuleId Deployment Rule ID
     * @param {ProjectDeploymentRuleRequest} [projectDeploymentRuleRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDeploymentRuleApi
     */
    public editProjectDeployemtnRule(projectId: string, deploymentRuleId: string, projectDeploymentRuleRequest?: ProjectDeploymentRuleRequest, options?: AxiosRequestConfig) {
        return ProjectDeploymentRuleApiFp(this.configuration).editProjectDeployemtnRule(projectId, deploymentRuleId, projectDeploymentRuleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a project deployment rule
     * @summary Get a project deployment rule
     * @param {string} projectId Project ID
     * @param {string} deploymentRuleId Deployment Rule ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDeploymentRuleApi
     */
    public getProjectDeploymentRule(projectId: string, deploymentRuleId: string, options?: AxiosRequestConfig) {
        return ProjectDeploymentRuleApiFp(this.configuration).getProjectDeploymentRule(projectId, deploymentRuleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List project deployment rules
     * @summary List project deployment rules
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDeploymentRuleApi
     */
    public listProjectDeploymentRules(projectId: string, options?: AxiosRequestConfig) {
        return ProjectDeploymentRuleApiFp(this.configuration).listProjectDeploymentRules(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update deployment rules priority order
     * @summary Update deployment rules priority order
     * @param {string} projectId Project ID
     * @param {InlineObject} [inlineObject] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDeploymentRuleApi
     */
    public updateDeploymentRulesPriorityOrder(projectId: string, inlineObject?: InlineObject, options?: AxiosRequestConfig) {
        return ProjectDeploymentRuleApiFp(this.configuration).updateDeploymentRulesPriorityOrder(projectId, inlineObject, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProjectEnvironmentVariableApi - axios parameter creator
 * @export
 */
export const ProjectEnvironmentVariableApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * - Add an environment variable to the project.   - If the environment variable key already exists, then it will be replaced by the new one.   - If the environment variable value points toward an existing environment variable key, it will be considered as an alias. 
         * @summary Add an environment variable to the project
         * @param {string} projectId Project ID
         * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectEnvironmentVariable: async (projectId: string, environmentVariableRequest?: EnvironmentVariableRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createProjectEnvironmentVariable', 'projectId', projectId)
            const localVarPath = `/project/{projectId}/environmentVariable`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentVariableRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to add an alias at project level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at project level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - Only 1 alias level is allowed. You can\'t create an alias on an alias 
         * @summary Create an environment variable alias at the project level
         * @param {string} projectId Project ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectEnvironmentVariableAlias: async (projectId: string, environmentVariableId: string, key?: Key, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createProjectEnvironmentVariableAlias', 'projectId', projectId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('createProjectEnvironmentVariableAlias', 'environmentVariableId', environmentVariableId)
            const localVarPath = `/project/{projectId}/environmentVariable/{environmentVariableId}/alias`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(key, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to override at project level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at project level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
         * @summary Create an environment variable override at the project level
         * @param {string} projectId Project ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectEnvironmentVariableOverride: async (projectId: string, environmentVariableId: string, value?: Value, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createProjectEnvironmentVariableOverride', 'projectId', projectId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('createProjectEnvironmentVariableOverride', 'environmentVariableId', environmentVariableId)
            const localVarPath = `/project/{projectId}/environmentVariable/{environmentVariableId}/override`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(value, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - To delete an environment variable you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete an environment variable from a project
         * @param {string} projectId Project ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectEnvironmentVariable: async (projectId: string, environmentVariableId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteProjectEnvironmentVariable', 'projectId', projectId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('deleteProjectEnvironmentVariable', 'environmentVariableId', environmentVariableId)
            const localVarPath = `/project/{projectId}/environmentVariable/{environmentVariableId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit an environment variable belonging to the project
         * @param {string} projectId Project ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editProjectEnvironmentVariable: async (projectId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('editProjectEnvironmentVariable', 'projectId', projectId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('editProjectEnvironmentVariable', 'environmentVariableId', environmentVariableId)
            // verify required parameter 'environmentVariableEditRequest' is not null or undefined
            assertParamExists('editProjectEnvironmentVariable', 'environmentVariableEditRequest', environmentVariableEditRequest)
            const localVarPath = `/project/{projectId}/environmentVariable/{environmentVariableId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentVariableEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List project environment variables
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectEnvironmentVariable: async (projectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('listProjectEnvironmentVariable', 'projectId', projectId)
            const localVarPath = `/project/{projectId}/environmentVariable`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectEnvironmentVariableApi - functional programming interface
 * @export
 */
export const ProjectEnvironmentVariableApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectEnvironmentVariableApiAxiosParamCreator(configuration)
    return {
        /**
         * - Add an environment variable to the project.   - If the environment variable key already exists, then it will be replaced by the new one.   - If the environment variable value points toward an existing environment variable key, it will be considered as an alias. 
         * @summary Add an environment variable to the project
         * @param {string} projectId Project ID
         * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProjectEnvironmentVariable(projectId: string, environmentVariableRequest?: EnvironmentVariableRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariableResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProjectEnvironmentVariable(projectId, environmentVariableRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - Allows you to add an alias at project level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at project level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - Only 1 alias level is allowed. You can\'t create an alias on an alias 
         * @summary Create an environment variable alias at the project level
         * @param {string} projectId Project ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProjectEnvironmentVariableAlias(projectId: string, environmentVariableId: string, key?: Key, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariableResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProjectEnvironmentVariableAlias(projectId, environmentVariableId, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - Allows you to override at project level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at project level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
         * @summary Create an environment variable override at the project level
         * @param {string} projectId Project ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProjectEnvironmentVariableOverride(projectId: string, environmentVariableId: string, value?: Value, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariableResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProjectEnvironmentVariableOverride(projectId, environmentVariableId, value, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - To delete an environment variable you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete an environment variable from a project
         * @param {string} projectId Project ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProjectEnvironmentVariable(projectId: string, environmentVariableId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProjectEnvironmentVariable(projectId, environmentVariableId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit an environment variable belonging to the project
         * @param {string} projectId Project ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editProjectEnvironmentVariable(projectId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariableResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editProjectEnvironmentVariable(projectId, environmentVariableId, environmentVariableEditRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List project environment variables
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProjectEnvironmentVariable(projectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariableResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProjectEnvironmentVariable(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectEnvironmentVariableApi - factory interface
 * @export
 */
export const ProjectEnvironmentVariableApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectEnvironmentVariableApiFp(configuration)
    return {
        /**
         * - Add an environment variable to the project.   - If the environment variable key already exists, then it will be replaced by the new one.   - If the environment variable value points toward an existing environment variable key, it will be considered as an alias. 
         * @summary Add an environment variable to the project
         * @param {string} projectId Project ID
         * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectEnvironmentVariable(projectId: string, environmentVariableRequest?: EnvironmentVariableRequest, options?: any): AxiosPromise<EnvironmentVariableResponse> {
            return localVarFp.createProjectEnvironmentVariable(projectId, environmentVariableRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to add an alias at project level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at project level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - Only 1 alias level is allowed. You can\'t create an alias on an alias 
         * @summary Create an environment variable alias at the project level
         * @param {string} projectId Project ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectEnvironmentVariableAlias(projectId: string, environmentVariableId: string, key?: Key, options?: any): AxiosPromise<EnvironmentVariableResponse> {
            return localVarFp.createProjectEnvironmentVariableAlias(projectId, environmentVariableId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to override at project level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at project level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
         * @summary Create an environment variable override at the project level
         * @param {string} projectId Project ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectEnvironmentVariableOverride(projectId: string, environmentVariableId: string, value?: Value, options?: any): AxiosPromise<EnvironmentVariableResponse> {
            return localVarFp.createProjectEnvironmentVariableOverride(projectId, environmentVariableId, value, options).then((request) => request(axios, basePath));
        },
        /**
         * - To delete an environment variable you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete an environment variable from a project
         * @param {string} projectId Project ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectEnvironmentVariable(projectId: string, environmentVariableId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteProjectEnvironmentVariable(projectId, environmentVariableId, options).then((request) => request(axios, basePath));
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit an environment variable belonging to the project
         * @param {string} projectId Project ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editProjectEnvironmentVariable(projectId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options?: any): AxiosPromise<EnvironmentVariableResponse> {
            return localVarFp.editProjectEnvironmentVariable(projectId, environmentVariableId, environmentVariableEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List project environment variables
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectEnvironmentVariable(projectId: string, options?: any): AxiosPromise<EnvironmentVariableResponseList> {
            return localVarFp.listProjectEnvironmentVariable(projectId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectEnvironmentVariableApi - object-oriented interface
 * @export
 * @class ProjectEnvironmentVariableApi
 * @extends {BaseAPI}
 */
export class ProjectEnvironmentVariableApi extends BaseAPI {
    /**
     * - Add an environment variable to the project.   - If the environment variable key already exists, then it will be replaced by the new one.   - If the environment variable value points toward an existing environment variable key, it will be considered as an alias. 
     * @summary Add an environment variable to the project
     * @param {string} projectId Project ID
     * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectEnvironmentVariableApi
     */
    public createProjectEnvironmentVariable(projectId: string, environmentVariableRequest?: EnvironmentVariableRequest, options?: AxiosRequestConfig) {
        return ProjectEnvironmentVariableApiFp(this.configuration).createProjectEnvironmentVariable(projectId, environmentVariableRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to add an alias at project level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at project level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - Only 1 alias level is allowed. You can\'t create an alias on an alias 
     * @summary Create an environment variable alias at the project level
     * @param {string} projectId Project ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {Key} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectEnvironmentVariableApi
     */
    public createProjectEnvironmentVariableAlias(projectId: string, environmentVariableId: string, key?: Key, options?: AxiosRequestConfig) {
        return ProjectEnvironmentVariableApiFp(this.configuration).createProjectEnvironmentVariableAlias(projectId, environmentVariableId, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to override at project level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at project level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
     * @summary Create an environment variable override at the project level
     * @param {string} projectId Project ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {Value} [value] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectEnvironmentVariableApi
     */
    public createProjectEnvironmentVariableOverride(projectId: string, environmentVariableId: string, value?: Value, options?: AxiosRequestConfig) {
        return ProjectEnvironmentVariableApiFp(this.configuration).createProjectEnvironmentVariableOverride(projectId, environmentVariableId, value, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - To delete an environment variable you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
     * @summary Delete an environment variable from a project
     * @param {string} projectId Project ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectEnvironmentVariableApi
     */
    public deleteProjectEnvironmentVariable(projectId: string, environmentVariableId: string, options?: AxiosRequestConfig) {
        return ProjectEnvironmentVariableApiFp(this.configuration).deleteProjectEnvironmentVariable(projectId, environmentVariableId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
     * @summary Edit an environment variable belonging to the project
     * @param {string} projectId Project ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectEnvironmentVariableApi
     */
    public editProjectEnvironmentVariable(projectId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options?: AxiosRequestConfig) {
        return ProjectEnvironmentVariableApiFp(this.configuration).editProjectEnvironmentVariable(projectId, environmentVariableId, environmentVariableEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List project environment variables
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectEnvironmentVariableApi
     */
    public listProjectEnvironmentVariable(projectId: string, options?: AxiosRequestConfig) {
        return ProjectEnvironmentVariableApiFp(this.configuration).listProjectEnvironmentVariable(projectId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProjectMainCallsApi - axios parameter creator
 * @export
 */
export const ProjectMainCallsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * To delete a project you must have the admin permission
         * @summary Delete a project
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject: async (projectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteProject', 'projectId', projectId)
            const localVarPath = `/project/{projectId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To edit a project you must have the admin permission
         * @summary Edit a project
         * @param {string} projectId Project ID
         * @param {ProjectRequest} [projectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editProject: async (projectId: string, projectRequest?: ProjectRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('editProject', 'projectId', projectId)
            const localVarPath = `/project/{projectId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get project by ID
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject: async (projectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getProject', 'projectId', projectId)
            const localVarPath = `/project/{projectId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectMainCallsApi - functional programming interface
 * @export
 */
export const ProjectMainCallsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectMainCallsApiAxiosParamCreator(configuration)
    return {
        /**
         * To delete a project you must have the admin permission
         * @summary Delete a project
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProject(projectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProject(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * To edit a project you must have the admin permission
         * @summary Edit a project
         * @param {string} projectId Project ID
         * @param {ProjectRequest} [projectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editProject(projectId: string, projectRequest?: ProjectRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editProject(projectId, projectRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get project by ID
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProject(projectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProject(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectMainCallsApi - factory interface
 * @export
 */
export const ProjectMainCallsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectMainCallsApiFp(configuration)
    return {
        /**
         * To delete a project you must have the admin permission
         * @summary Delete a project
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject(projectId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteProject(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * To edit a project you must have the admin permission
         * @summary Edit a project
         * @param {string} projectId Project ID
         * @param {ProjectRequest} [projectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editProject(projectId: string, projectRequest?: ProjectRequest, options?: any): AxiosPromise<ProjectResponse> {
            return localVarFp.editProject(projectId, projectRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get project by ID
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject(projectId: string, options?: any): AxiosPromise<ProjectResponse> {
            return localVarFp.getProject(projectId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectMainCallsApi - object-oriented interface
 * @export
 * @class ProjectMainCallsApi
 * @extends {BaseAPI}
 */
export class ProjectMainCallsApi extends BaseAPI {
    /**
     * To delete a project you must have the admin permission
     * @summary Delete a project
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectMainCallsApi
     */
    public deleteProject(projectId: string, options?: AxiosRequestConfig) {
        return ProjectMainCallsApiFp(this.configuration).deleteProject(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To edit a project you must have the admin permission
     * @summary Edit a project
     * @param {string} projectId Project ID
     * @param {ProjectRequest} [projectRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectMainCallsApi
     */
    public editProject(projectId: string, projectRequest?: ProjectRequest, options?: AxiosRequestConfig) {
        return ProjectMainCallsApiFp(this.configuration).editProject(projectId, projectRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get project by ID
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectMainCallsApi
     */
    public getProject(projectId: string, options?: AxiosRequestConfig) {
        return ProjectMainCallsApiFp(this.configuration).getProject(projectId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProjectSecretApi - axios parameter creator
 * @export
 */
export const ProjectSecretApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * - Add a secret to the project.   - If the secret key already exists, then it will be replaced by the new one.   - If the secret value points toward an existing secret key, it will be considered as an alias. 
         * @summary Add a secret to the project
         * @param {string} projectId Project ID
         * @param {SecretRequest} [secretRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectSecret: async (projectId: string, secretRequest?: SecretRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createProjectSecret', 'projectId', projectId)
            const localVarPath = `/project/{projectId}/secret`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(secretRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to add an alias at project level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at project level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - Only 1 alias level is allowed. You can\'t create an alias on an alias 
         * @summary Create a secret alias at the project level
         * @param {string} projectId Project ID
         * @param {string} secretId Secret ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectSecretAlias: async (projectId: string, secretId: string, key?: Key, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createProjectSecretAlias', 'projectId', projectId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('createProjectSecretAlias', 'secretId', secretId)
            const localVarPath = `/project/{projectId}/secret/{secretId}/alias`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(key, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to override at project level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at project level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
         * @summary Create a secret override at the project level
         * @param {string} projectId Project ID
         * @param {string} secretId Secret ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectSecretOverride: async (projectId: string, secretId: string, value?: Value, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createProjectSecretOverride', 'projectId', projectId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('createProjectSecretOverride', 'secretId', secretId)
            const localVarPath = `/project/{projectId}/secret/{secretId}/override`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(value, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well  operationId: deleteProjectSecret 
         * @summary Delete a secret from a project
         * @param {string} projectId Project ID
         * @param {string} secretId Secret ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectSecret: async (projectId: string, secretId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteProjectSecret', 'projectId', projectId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('deleteProjectSecret', 'secretId', secretId)
            const localVarPath = `/project/{projectId}/secret/{secretId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit a secret belonging to the project
         * @param {string} projectId Project ID
         * @param {string} secretId Secret ID
         * @param {SecretEditRequest} secretEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editProjectSecret: async (projectId: string, secretId: string, secretEditRequest: SecretEditRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('editProjectSecret', 'projectId', projectId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('editProjectSecret', 'secretId', secretId)
            // verify required parameter 'secretEditRequest' is not null or undefined
            assertParamExists('editProjectSecret', 'secretEditRequest', secretEditRequest)
            const localVarPath = `/project/{projectId}/secret/{secretId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(secretEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List project secrets
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectSecrets: async (projectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('listProjectSecrets', 'projectId', projectId)
            const localVarPath = `/project/{projectId}/secret`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectSecretApi - functional programming interface
 * @export
 */
export const ProjectSecretApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectSecretApiAxiosParamCreator(configuration)
    return {
        /**
         * - Add a secret to the project.   - If the secret key already exists, then it will be replaced by the new one.   - If the secret value points toward an existing secret key, it will be considered as an alias. 
         * @summary Add a secret to the project
         * @param {string} projectId Project ID
         * @param {SecretRequest} [secretRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProjectSecret(projectId: string, secretRequest?: SecretRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecretResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProjectSecret(projectId, secretRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - Allows you to add an alias at project level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at project level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - Only 1 alias level is allowed. You can\'t create an alias on an alias 
         * @summary Create a secret alias at the project level
         * @param {string} projectId Project ID
         * @param {string} secretId Secret ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProjectSecretAlias(projectId: string, secretId: string, key?: Key, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecretResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProjectSecretAlias(projectId, secretId, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - Allows you to override at project level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at project level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
         * @summary Create a secret override at the project level
         * @param {string} projectId Project ID
         * @param {string} secretId Secret ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProjectSecretOverride(projectId: string, secretId: string, value?: Value, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecretResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProjectSecretOverride(projectId, secretId, value, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well  operationId: deleteProjectSecret 
         * @summary Delete a secret from a project
         * @param {string} projectId Project ID
         * @param {string} secretId Secret ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProjectSecret(projectId: string, secretId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProjectSecret(projectId, secretId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit a secret belonging to the project
         * @param {string} projectId Project ID
         * @param {string} secretId Secret ID
         * @param {SecretEditRequest} secretEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editProjectSecret(projectId: string, secretId: string, secretEditRequest: SecretEditRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecretResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editProjectSecret(projectId, secretId, secretEditRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List project secrets
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProjectSecrets(projectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecretResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProjectSecrets(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectSecretApi - factory interface
 * @export
 */
export const ProjectSecretApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectSecretApiFp(configuration)
    return {
        /**
         * - Add a secret to the project.   - If the secret key already exists, then it will be replaced by the new one.   - If the secret value points toward an existing secret key, it will be considered as an alias. 
         * @summary Add a secret to the project
         * @param {string} projectId Project ID
         * @param {SecretRequest} [secretRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectSecret(projectId: string, secretRequest?: SecretRequest, options?: any): AxiosPromise<SecretResponse> {
            return localVarFp.createProjectSecret(projectId, secretRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to add an alias at project level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at project level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - Only 1 alias level is allowed. You can\'t create an alias on an alias 
         * @summary Create a secret alias at the project level
         * @param {string} projectId Project ID
         * @param {string} secretId Secret ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectSecretAlias(projectId: string, secretId: string, key?: Key, options?: any): AxiosPromise<SecretResponse> {
            return localVarFp.createProjectSecretAlias(projectId, secretId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to override at project level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at project level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
         * @summary Create a secret override at the project level
         * @param {string} projectId Project ID
         * @param {string} secretId Secret ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectSecretOverride(projectId: string, secretId: string, value?: Value, options?: any): AxiosPromise<SecretResponse> {
            return localVarFp.createProjectSecretOverride(projectId, secretId, value, options).then((request) => request(axios, basePath));
        },
        /**
         * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well  operationId: deleteProjectSecret 
         * @summary Delete a secret from a project
         * @param {string} projectId Project ID
         * @param {string} secretId Secret ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectSecret(projectId: string, secretId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteProjectSecret(projectId, secretId, options).then((request) => request(axios, basePath));
        },
        /**
         * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit a secret belonging to the project
         * @param {string} projectId Project ID
         * @param {string} secretId Secret ID
         * @param {SecretEditRequest} secretEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editProjectSecret(projectId: string, secretId: string, secretEditRequest: SecretEditRequest, options?: any): AxiosPromise<SecretResponse> {
            return localVarFp.editProjectSecret(projectId, secretId, secretEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List project secrets
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectSecrets(projectId: string, options?: any): AxiosPromise<SecretResponseList> {
            return localVarFp.listProjectSecrets(projectId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectSecretApi - object-oriented interface
 * @export
 * @class ProjectSecretApi
 * @extends {BaseAPI}
 */
export class ProjectSecretApi extends BaseAPI {
    /**
     * - Add a secret to the project.   - If the secret key already exists, then it will be replaced by the new one.   - If the secret value points toward an existing secret key, it will be considered as an alias. 
     * @summary Add a secret to the project
     * @param {string} projectId Project ID
     * @param {SecretRequest} [secretRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSecretApi
     */
    public createProjectSecret(projectId: string, secretRequest?: SecretRequest, options?: AxiosRequestConfig) {
        return ProjectSecretApiFp(this.configuration).createProjectSecret(projectId, secretRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to add an alias at project level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at project level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - Only 1 alias level is allowed. You can\'t create an alias on an alias 
     * @summary Create a secret alias at the project level
     * @param {string} projectId Project ID
     * @param {string} secretId Secret ID
     * @param {Key} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSecretApi
     */
    public createProjectSecretAlias(projectId: string, secretId: string, key?: Key, options?: AxiosRequestConfig) {
        return ProjectSecretApiFp(this.configuration).createProjectSecretAlias(projectId, secretId, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to override at project level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at project level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
     * @summary Create a secret override at the project level
     * @param {string} projectId Project ID
     * @param {string} secretId Secret ID
     * @param {Value} [value] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSecretApi
     */
    public createProjectSecretOverride(projectId: string, secretId: string, value?: Value, options?: AxiosRequestConfig) {
        return ProjectSecretApiFp(this.configuration).createProjectSecretOverride(projectId, secretId, value, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well  operationId: deleteProjectSecret 
     * @summary Delete a secret from a project
     * @param {string} projectId Project ID
     * @param {string} secretId Secret ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSecretApi
     */
    public deleteProjectSecret(projectId: string, secretId: string, options?: AxiosRequestConfig) {
        return ProjectSecretApiFp(this.configuration).deleteProjectSecret(projectId, secretId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
     * @summary Edit a secret belonging to the project
     * @param {string} projectId Project ID
     * @param {string} secretId Secret ID
     * @param {SecretEditRequest} secretEditRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSecretApi
     */
    public editProjectSecret(projectId: string, secretId: string, secretEditRequest: SecretEditRequest, options?: AxiosRequestConfig) {
        return ProjectSecretApiFp(this.configuration).editProjectSecret(projectId, secretId, secretEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List project secrets
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSecretApi
     */
    public listProjectSecrets(projectId: string, options?: AxiosRequestConfig) {
        return ProjectSecretApiFp(this.configuration).listProjectSecrets(projectId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProjectsApi - axios parameter creator
 * @export
 */
export const ProjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a project
         * @param {string} organizationId Organization ID
         * @param {ProjectRequest} [projectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject: async (organizationId: string, projectRequest?: ProjectRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createProject', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/project`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of project ids, and for each its total numberof services and environments
         * @summary List total number of services and environments for each project of the organization
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationProjectStats: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationProjectStats', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/project/stats`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List projects
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProject: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listProject', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/project`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsApi - functional programming interface
 * @export
 */
export const ProjectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a project
         * @param {string} organizationId Organization ID
         * @param {ProjectRequest} [projectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProject(organizationId: string, projectRequest?: ProjectRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProject(organizationId, projectRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of project ids, and for each its total numberof services and environments
         * @summary List total number of services and environments for each project of the organization
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationProjectStats(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectStatsResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationProjectStats(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List projects
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProject(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProject(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectsApi - factory interface
 * @export
 */
export const ProjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a project
         * @param {string} organizationId Organization ID
         * @param {ProjectRequest} [projectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject(organizationId: string, projectRequest?: ProjectRequest, options?: any): AxiosPromise<ProjectResponse> {
            return localVarFp.createProject(organizationId, projectRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of project ids, and for each its total numberof services and environments
         * @summary List total number of services and environments for each project of the organization
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationProjectStats(organizationId: string, options?: any): AxiosPromise<ProjectStatsResponseList> {
            return localVarFp.getOrganizationProjectStats(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List projects
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProject(organizationId: string, options?: any): AxiosPromise<ProjectResponseList> {
            return localVarFp.listProject(organizationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectsApi - object-oriented interface
 * @export
 * @class ProjectsApi
 * @extends {BaseAPI}
 */
export class ProjectsApi extends BaseAPI {
    /**
     * 
     * @summary Create a project
     * @param {string} organizationId Organization ID
     * @param {ProjectRequest} [projectRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public createProject(organizationId: string, projectRequest?: ProjectRequest, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).createProject(organizationId, projectRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of project ids, and for each its total numberof services and environments
     * @summary List total number of services and environments for each project of the organization
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getOrganizationProjectStats(organizationId: string, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).getOrganizationProjectStats(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List projects
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public listProject(organizationId: string, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).listProject(organizationId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ReferralRewardsApi - axios parameter creator
 * @export
 */
export const ReferralRewardsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get your referral information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountReferral: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/referral`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A same code can be claimed only 3 times at max
         * @summary Claim a reward
         * @param {RewardClaimResponse} [rewardClaimResponse] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAccountRewardClaim: async (rewardClaimResponse?: RewardClaimResponse, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/rewardClaim`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rewardClaimResponse, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReferralRewardsApi - functional programming interface
 * @export
 */
export const ReferralRewardsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReferralRewardsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get your referral information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountReferral(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReferralResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountReferral(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A same code can be claimed only 3 times at max
         * @summary Claim a reward
         * @param {RewardClaimResponse} [rewardClaimResponse] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAccountRewardClaim(rewardClaimResponse?: RewardClaimResponse, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postAccountRewardClaim(rewardClaimResponse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ReferralRewardsApi - factory interface
 * @export
 */
export const ReferralRewardsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReferralRewardsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get your referral information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountReferral(options?: any): AxiosPromise<ReferralResponse> {
            return localVarFp.getAccountReferral(options).then((request) => request(axios, basePath));
        },
        /**
         * A same code can be claimed only 3 times at max
         * @summary Claim a reward
         * @param {RewardClaimResponse} [rewardClaimResponse] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAccountRewardClaim(rewardClaimResponse?: RewardClaimResponse, options?: any): AxiosPromise<void> {
            return localVarFp.postAccountRewardClaim(rewardClaimResponse, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReferralRewardsApi - object-oriented interface
 * @export
 * @class ReferralRewardsApi
 * @extends {BaseAPI}
 */
export class ReferralRewardsApi extends BaseAPI {
    /**
     * 
     * @summary Get your referral information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferralRewardsApi
     */
    public getAccountReferral(options?: AxiosRequestConfig) {
        return ReferralRewardsApiFp(this.configuration).getAccountReferral(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A same code can be claimed only 3 times at max
     * @summary Claim a reward
     * @param {RewardClaimResponse} [rewardClaimResponse] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferralRewardsApi
     */
    public postAccountRewardClaim(rewardClaimResponse?: RewardClaimResponse, options?: AxiosRequestConfig) {
        return ReferralRewardsApiFp(this.configuration).postAccountRewardClaim(rewardClaimResponse, options).then((request) => request(this.axios, this.basePath));
    }
}


