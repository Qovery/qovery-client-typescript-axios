/* tslint:disable */
/* eslint-disable */
/**
 * Qovery API
 * - Qovery is the fastest way to deploy your full-stack apps on any Cloud provider. - ℹ️ The API is stable and still in development. 
 *
 * The version of the OpenAPI document: 1.0.4
 * Contact: support+api+documentation@qovery.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @enum {string}
 */

export const APIVariableScopeEnum = {
    APPLICATION: 'APPLICATION',
    BUILT_IN: 'BUILT_IN',
    ENVIRONMENT: 'ENVIRONMENT',
    PROJECT: 'PROJECT',
    CONTAINER: 'CONTAINER',
    JOB: 'JOB',
    HELM: 'HELM',
    TERRAFORM: 'TERRAFORM'
} as const;

export type APIVariableScopeEnum = typeof APIVariableScopeEnum[keyof typeof APIVariableScopeEnum];


/**
 * type of the environment variable (VALUE, FILE, ALIAS, OVERRIDE or BUIT_IN) 
 * @export
 * @enum {string}
 */

export const APIVariableTypeEnum = {
    VALUE: 'VALUE',
    ALIAS: 'ALIAS',
    OVERRIDE: 'OVERRIDE',
    BUILT_IN: 'BUILT_IN',
    FILE: 'FILE'
} as const;

export type APIVariableTypeEnum = typeof APIVariableTypeEnum[keyof typeof APIVariableTypeEnum];


/**
 * 
 * @export
 * @interface AccountInfo
 */
export interface AccountInfo {
    /**
     * 
     * @type {string}
     * @memberof AccountInfo
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountInfo
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountInfo
     */
    'nickname'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountInfo
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountInfo
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountInfo
     */
    'profile_picture_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountInfo
     */
    'communication_email'?: string;
}
/**
 * 
 * @export
 * @interface AccountInfoEditRequest
 */
export interface AccountInfoEditRequest {
    /**
     * The email to be used for official Qovery communications
     * @type {string}
     * @memberof AccountInfoEditRequest
     */
    'communication_email'?: string;
}
/**
 * 
 * @export
 * @interface AksInfrastructureOutputs
 */
export interface AksInfrastructureOutputs {
    /**
     * 
     * @type {string}
     * @memberof AksInfrastructureOutputs
     */
    'kind': AksInfrastructureOutputsKindEnum;
    /**
     * 
     * @type {string}
     * @memberof AksInfrastructureOutputs
     */
    'cluster_name': string;
    /**
     * 
     * @type {string}
     * @memberof AksInfrastructureOutputs
     */
    'cluster_oidc_issuer': string;
}

export const AksInfrastructureOutputsKindEnum = {
    AKS: 'AKS'
} as const;

export type AksInfrastructureOutputsKindEnum = typeof AksInfrastructureOutputsKindEnum[keyof typeof AksInfrastructureOutputsKindEnum];

/**
 * 
 * @export
 * @interface AlertPresentation
 */
export interface AlertPresentation {
    /**
     * 
     * @type {string}
     * @memberof AlertPresentation
     */
    'summary'?: string | null;
    /**
     * URL to runbook with remediation steps
     * @type {string}
     * @memberof AlertPresentation
     */
    'runbook_url'?: string | null;
}
/**
 * 
 * @export
 * @interface AlertPresentationResponse
 */
export interface AlertPresentationResponse {
    /**
     *  Alert summary template
     * @type {string}
     * @memberof AlertPresentationResponse
     */
    'summary'?: string | null;
    /**
     * URL to runbook with remediation steps
     * @type {string}
     * @memberof AlertPresentationResponse
     */
    'runbook_url'?: string | null;
}
/**
 * 
 * @export
 * @interface AlertReceiverCreationRequest
 */
export interface AlertReceiverCreationRequest {
    /**
     * 
     * @type {string}
     * @memberof AlertReceiverCreationRequest
     */
    'organization_id': string;
    /**
     * 
     * @type {string}
     * @memberof AlertReceiverCreationRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AlertReceiverCreationRequest
     */
    'description': string;
    /**
     * 
     * @type {AlertReceiverType}
     * @memberof AlertReceiverCreationRequest
     */
    'type': AlertReceiverType;
    /**
     * 
     * @type {boolean}
     * @memberof AlertReceiverCreationRequest
     */
    'send_resolved': boolean;
}


/**
 * 
 * @export
 * @interface AlertReceiverCreationValidationRequest
 */
export interface AlertReceiverCreationValidationRequest {
    /**
     * 
     * @type {AlertReceiverCreationRequest}
     * @memberof AlertReceiverCreationValidationRequest
     */
    'alert_receiver': AlertReceiverCreationRequest;
    /**
     * 
     * @type {string}
     * @memberof AlertReceiverCreationValidationRequest
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface AlertReceiverEditRequest
 */
export interface AlertReceiverEditRequest {
    /**
     * 
     * @type {string}
     * @memberof AlertReceiverEditRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AlertReceiverEditRequest
     */
    'description': string;
    /**
     * 
     * @type {AlertReceiverType}
     * @memberof AlertReceiverEditRequest
     */
    'type': AlertReceiverType;
    /**
     * 
     * @type {boolean}
     * @memberof AlertReceiverEditRequest
     */
    'send_resolved': boolean;
}


/**
 * 
 * @export
 * @interface AlertReceiverList
 */
export interface AlertReceiverList {
    /**
     * 
     * @type {Array<AlertReceiverResponse>}
     * @memberof AlertReceiverList
     */
    'results': Array<AlertReceiverResponse>;
}
/**
 * 
 * @export
 * @interface AlertReceiverResponse
 */
export interface AlertReceiverResponse {
    /**
     * 
     * @type {string}
     * @memberof AlertReceiverResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AlertReceiverResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof AlertReceiverResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof AlertReceiverResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AlertReceiverResponse
     */
    'description': string;
    /**
     * 
     * @type {AlertReceiverType}
     * @memberof AlertReceiverResponse
     */
    'type': AlertReceiverType;
    /**
     * 
     * @type {boolean}
     * @memberof AlertReceiverResponse
     */
    'send_resolved': boolean;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const AlertReceiverType = {
    SLACK: 'SLACK'
} as const;

export type AlertReceiverType = typeof AlertReceiverType[keyof typeof AlertReceiverType];


/**
 * 
 * @export
 * @interface AlertReceiverValidationRequest
 */
export interface AlertReceiverValidationRequest {
    /**
     * 
     * @type {string}
     * @memberof AlertReceiverValidationRequest
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface AlertRuleCondition
 */
export interface AlertRuleCondition {
    /**
     * 
     * @type {AlertRuleConditionKind}
     * @memberof AlertRuleCondition
     */
    'kind': AlertRuleConditionKind;
    /**
     * 
     * @type {AlertRuleConditionOperator}
     * @memberof AlertRuleCondition
     */
    'operator'?: AlertRuleConditionOperator;
    /**
     * 
     * @type {number}
     * @memberof AlertRuleCondition
     */
    'threshold'?: number;
    /**
     * 
     * @type {AlertRuleConditionFunction}
     * @memberof AlertRuleCondition
     */
    'function'?: AlertRuleConditionFunction;
    /**
     * 
     * @type {string}
     * @memberof AlertRuleCondition
     */
    'promql': string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const AlertRuleConditionFunction = {
    NONE: 'NONE',
    AVG: 'AVG',
    MAX: 'MAX',
    MIN: 'MIN',
    SUM: 'SUM',
    COUNT: 'COUNT'
} as const;

export type AlertRuleConditionFunction = typeof AlertRuleConditionFunction[keyof typeof AlertRuleConditionFunction];


/**
 * 
 * @export
 * @enum {string}
 */

export const AlertRuleConditionKind = {
    CUSTOM: 'CUSTOM',
    BUILT: 'BUILT'
} as const;

export type AlertRuleConditionKind = typeof AlertRuleConditionKind[keyof typeof AlertRuleConditionKind];


/**
 * 
 * @export
 * @enum {string}
 */

export const AlertRuleConditionOperator = {
    NONE: 'NONE',
    ABOVE: 'ABOVE',
    BELOW: 'BELOW',
    ABOVE_OR_EQUAL: 'ABOVE_OR_EQUAL',
    BELOW_OR_EQUAL: 'BELOW_OR_EQUAL',
    EQUAL: 'EQUAL'
} as const;

export type AlertRuleConditionOperator = typeof AlertRuleConditionOperator[keyof typeof AlertRuleConditionOperator];


/**
 * 
 * @export
 * @interface AlertRuleCreationRequest
 */
export interface AlertRuleCreationRequest {
    /**
     * Organization identifier
     * @type {string}
     * @memberof AlertRuleCreationRequest
     */
    'organization_id': string;
    /**
     *  Cluster identifier where the rule will be deployed
     * @type {string}
     * @memberof AlertRuleCreationRequest
     */
    'cluster_id': string;
    /**
     * Name of the alert rule
     * @type {string}
     * @memberof AlertRuleCreationRequest
     */
    'name': string;
    /**
     * Description of what the alert monitors 
     * @type {string}
     * @memberof AlertRuleCreationRequest
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof AlertRuleCreationRequest
     */
    'tag': string;
    /**
     * 
     * @type {AlertRuleCondition}
     * @memberof AlertRuleCreationRequest
     */
    'condition': AlertRuleCondition;
    /**
     * Duration the condition must be true before firing (ISO-8601 duration format)
     * @type {string}
     * @memberof AlertRuleCreationRequest
     */
    'for_duration': string;
    /**
     * 
     * @type {AlertSeverity}
     * @memberof AlertRuleCreationRequest
     */
    'severity': AlertSeverity;
    /**
     * 
     * @type {AlertPresentation}
     * @memberof AlertRuleCreationRequest
     */
    'presentation': AlertPresentation;
    /**
     * Whether the alert rule is enabled
     * @type {boolean}
     * @memberof AlertRuleCreationRequest
     */
    'enabled': boolean;
    /**
     * List of alert receiver IDs to send notifications to
     * @type {Array<string>}
     * @memberof AlertRuleCreationRequest
     */
    'alert_receiver_ids': Array<string>;
    /**
     * 
     * @type {AlertTarget}
     * @memberof AlertRuleCreationRequest
     */
    'target': AlertTarget;
}


/**
 * 
 * @export
 * @interface AlertRuleEditRequest
 */
export interface AlertRuleEditRequest {
    /**
     * Name of the alert rule
     * @type {string}
     * @memberof AlertRuleEditRequest
     */
    'name': string;
    /**
     * Description of what the alert monitors
     * @type {string}
     * @memberof AlertRuleEditRequest
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof AlertRuleEditRequest
     */
    'tag': string;
    /**
     * 
     * @type {AlertRuleCondition}
     * @memberof AlertRuleEditRequest
     */
    'condition': AlertRuleCondition;
    /**
     * Duration the condition must be true before firing (ISO-8601 duration format)
     * @type {string}
     * @memberof AlertRuleEditRequest
     */
    'for_duration': string;
    /**
     * 
     * @type {AlertSeverity}
     * @memberof AlertRuleEditRequest
     */
    'severity': AlertSeverity;
    /**
     * Whether the alert rule is enabled
     * @type {boolean}
     * @memberof AlertRuleEditRequest
     */
    'enabled': boolean;
    /**
     * List of alert receiver IDs to send notifications to
     * @type {Array<string>}
     * @memberof AlertRuleEditRequest
     */
    'alert_receiver_ids': Array<string>;
    /**
     * 
     * @type {AlertPresentation}
     * @memberof AlertRuleEditRequest
     */
    'presentation': AlertPresentation;
}


/**
 * 
 * @export
 * @interface AlertRuleList
 */
export interface AlertRuleList {
    /**
     * 
     * @type {Array<AlertRuleListResultsInner>}
     * @memberof AlertRuleList
     */
    'results': Array<AlertRuleListResultsInner>;
}
/**
 * @type AlertRuleListResultsInner
 * @export
 */
export type AlertRuleListResultsInner = { source: 'GHOST' } & GhostAlertRuleResponse | { source: 'MANAGED' } & AlertRuleResponse;

/**
 * 
 * @export
 * @interface AlertRuleResponse
 */
export interface AlertRuleResponse extends AlertRuleResponseBase {
    /**
     * 
     * @type {string}
     * @memberof AlertRuleResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AlertRuleResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof AlertRuleResponse
     */
    'updated_at'?: string;
    /**
     * Organization identifier
     * @type {string}
     * @memberof AlertRuleResponse
     */
    'organization_id': string;
    /**
     *  Cluster identifier
     * @type {string}
     * @memberof AlertRuleResponse
     */
    'cluster_id': string;
    /**
     * Description of what the alert monitors
     * @type {string}
     * @memberof AlertRuleResponse
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof AlertRuleResponse
     */
    'tag': string;
    /**
     * 
     * @type {AlertRuleCondition}
     * @memberof AlertRuleResponse
     */
    'condition': AlertRuleCondition;
    /**
     * Duration the condition must be true before firing (ISO-8601 duration format)
     * @type {string}
     * @memberof AlertRuleResponse
     */
    'for_duration': string;
    /**
     * 
     * @type {AlertSeverity}
     * @memberof AlertRuleResponse
     */
    'severity': AlertSeverity;
    /**
     * Whether the alert rule is enabled
     * @type {boolean}
     * @memberof AlertRuleResponse
     */
    'enabled': boolean;
    /**
     * List of alert receiver IDs to send notifications to
     * @type {Array<string>}
     * @memberof AlertRuleResponse
     */
    'alert_receiver_ids': Array<string>;
    /**
     * 
     * @type {AlertPresentationResponse}
     * @memberof AlertRuleResponse
     */
    'presentation': AlertPresentationResponse;
    /**
     * 
     * @type {AlertTarget}
     * @memberof AlertRuleResponse
     */
    'target': AlertTarget;
    /**
     * Indicates whether the current version of the alert has been synced with the alerting system. If false, an outdated version is currently deployed.
     * @type {boolean}
     * @memberof AlertRuleResponse
     */
    'is_up_to_date': boolean;
    /**
     * when the alert starts firing
     * @type {string}
     * @memberof AlertRuleResponse
     */
    'starts_at'?: string;
}


/**
 * Base schema for alert rule responses with discriminator
 * @export
 * @interface AlertRuleResponseBase
 */
export interface AlertRuleResponseBase {
    /**
     * 
     * @type {AlertRuleSource}
     * @memberof AlertRuleResponseBase
     */
    'source': AlertRuleSource;
    /**
     * Name of the alert rule
     * @type {string}
     * @memberof AlertRuleResponseBase
     */
    'name': string;
    /**
     * 
     * @type {AlertRuleState}
     * @memberof AlertRuleResponseBase
     */
    'state': AlertRuleState;
}


/**
 * Source of the alert rule: - MANAGED: Alert rule created and managed through the Qovery API - GHOST: Alert rule that exists in Prometheus but has been deleted from the database
 * @export
 * @enum {string}
 */

export const AlertRuleSource = {
    MANAGED: 'MANAGED',
    GHOST: 'GHOST'
} as const;

export type AlertRuleSource = typeof AlertRuleSource[keyof typeof AlertRuleSource];


/**
 * 
 * @export
 * @enum {string}
 */

export const AlertRuleState = {
    UNDEPLOYED: 'UNDEPLOYED',
    OK: 'OK',
    TRIGGERED: 'TRIGGERED',
    PENDING_NOTIFICATION: 'PENDING_NOTIFICATION',
    NOTIFIED: 'NOTIFIED',
    SUPPRESSED: 'SUPPRESSED',
    UNROUTED: 'UNROUTED'
} as const;

export type AlertRuleState = typeof AlertRuleState[keyof typeof AlertRuleState];


/**
 * Alert severity level:         - LOW: Minor issues or informational alerts that don\'t require immediate attention. Can be addressed during normal business hours.         - MEDIUM: Moderate issues that should be investigated soon but don\'t impact critical services. May cause degraded performance or minor service disruption.         - HIGH: Serious issues affecting service quality or availability. Requires prompt attention and resolution within hours.         - CRITICAL: Critical issue requiring immediate action. Service outage, data loss risk, or severe performance degradation affecting users.
 * @export
 * @enum {string}
 */

export const AlertSeverity = {
    LOW: 'LOW',
    MEDIUM: 'MEDIUM',
    HIGH: 'HIGH',
    CRITICAL: 'CRITICAL'
} as const;

export type AlertSeverity = typeof AlertSeverity[keyof typeof AlertSeverity];


/**
 * 
 * @export
 * @interface AlertTarget
 */
export interface AlertTarget {
    /**
     * 
     * @type {AlertTargetType}
     * @memberof AlertTarget
     */
    'target_type': AlertTargetType;
    /**
     * 
     * @type {string}
     * @memberof AlertTarget
     */
    'target_id': string;
    /**
     * 
     * @type {ServiceLightResponse}
     * @memberof AlertTarget
     */
    'service'?: ServiceLightResponse;
}


/**
 * The target of an alert
 * @export
 * @enum {string}
 */

export const AlertTargetType = {
    CLUSTER: ' CLUSTER',
    ENVIRONMENT: 'ENVIRONMENT',
    APPLICATION: 'APPLICATION',
    CONTAINER: 'CONTAINER',
    JOB: 'JOB',
    CRONJOB: 'CRONJOB',
    HELM: 'HELM',
    TERRAFORM: 'TERRAFORM'
} as const;

export type AlertTargetType = typeof AlertTargetType[keyof typeof AlertTargetType];


/**
 * 
 * @export
 * @interface AlertingConfig
 */
export interface AlertingConfig {
    /**
     * 
     * @type {boolean}
     * @memberof AlertingConfig
     */
    'enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof AlertingConfig
     */
    'default_rule_labels'?: string;
    /**
     * 
     * @type {string}
     * @memberof AlertingConfig
     */
    'spec_config_secret'?: string;
    /**
     * 
     * @type {string}
     * @memberof AlertingConfig
     */
    'spec_external_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof AlertingConfig
     */
    'config_name'?: string;
}
/**
 * 
 * @export
 * @interface Annotation
 */
export interface Annotation {
    /**
     * 
     * @type {string}
     * @memberof Annotation
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof Annotation
     */
    'value': string;
}
/**
 * Annotations Group Associated Item Type
 * @export
 * @enum {string}
 */

export const AnnotationsGroupAssociatedItemType = {
    APPLICATION: 'APPLICATION',
    DATABASE: 'DATABASE',
    CONTAINER: 'CONTAINER',
    LIFECYCLE: 'LIFECYCLE',
    ENVIRONMENT: 'ENVIRONMENT',
    CLUSTER: 'CLUSTER',
    CRON: 'CRON'
} as const;

export type AnnotationsGroupAssociatedItemType = typeof AnnotationsGroupAssociatedItemType[keyof typeof AnnotationsGroupAssociatedItemType];


/**
 * 
 * @export
 * @interface Application
 */
export interface Application {
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    'updated_at'?: string;
    /**
     * 
     * @type {Array<ServiceStorageStorageInner>}
     * @memberof Application
     */
    'storage'?: Array<ServiceStorageStorageInner>;
    /**
     * 
     * @type {ReferenceObject}
     * @memberof Application
     */
    'environment': ReferenceObject;
    /**
     * 
     * @type {ApplicationGitRepository}
     * @memberof Application
     */
    'git_repository'?: ApplicationGitRepository;
    /**
     * Maximum cpu that can be allocated to the application based on organization cluster configuration. unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof Application
     */
    'maximum_cpu'?: number;
    /**
     * Maximum memory that can be allocated to the application based on organization cluster configuration. unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof Application
     */
    'maximum_memory'?: number;
    /**
     * 
     * @type {number}
     * @memberof Application
     */
    'maximun_gpu'?: number;
    /**
     * name is case insensitive
     * @type {string}
     * @memberof Application
     */
    'name': string;
    /**
     * give a description to this application
     * @type {string}
     * @memberof Application
     */
    'description'?: string;
    /**
     * 
     * @type {BuildModeEnum}
     * @memberof Application
     */
    'build_mode'?: BuildModeEnum;
    /**
     * The path of the associated Dockerfile. Only if you are using build_mode = DOCKER
     * @type {string}
     * @memberof Application
     */
    'dockerfile_path'?: string | null;
    /**
     * unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof Application
     */
    'cpu'?: number;
    /**
     * unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof Application
     */
    'memory'?: number;
    /**
     * 
     * @type {number}
     * @memberof Application
     */
    'gpu'?: number;
    /**
     * Minimum number of instances running. This resource auto-scale based on the CPU and Memory consumption. Note: 0 means that there is no application running. 
     * @type {number}
     * @memberof Application
     */
    'min_running_instances'?: number;
    /**
     * Maximum number of instances running. This resource auto-scale based on the CPU and Memory consumption. Note: -1 means that there is no limit. 
     * @type {number}
     * @memberof Application
     */
    'max_running_instances'?: number;
    /**
     * 
     * @type {Healthcheck}
     * @memberof Application
     */
    'healthchecks': Healthcheck;
    /**
     * Specify if the environment preview option is activated or not for this application.   If activated, a preview environment will be automatically cloned at each pull request.   If not specified, it takes the value of the `auto_preview` property from the associated environment. 
     * @type {boolean}
     * @memberof Application
     */
    'auto_preview'?: boolean;
    /**
     * 
     * @type {Array<ServicePort>}
     * @memberof Application
     */
    'ports'?: Array<ServicePort>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Application
     */
    'arguments'?: Array<string>;
    /**
     * optional entrypoint when launching container
     * @type {string}
     * @memberof Application
     */
    'entrypoint'?: string;
    /**
     * Specify if the application will be automatically updated after receiving a new commit.
     * @type {boolean}
     * @memberof Application
     */
    'auto_deploy'?: boolean;
    /**
     * 
     * @type {Array<OrganizationAnnotationsGroupResponse>}
     * @memberof Application
     */
    'annotations_groups'?: Array<OrganizationAnnotationsGroupResponse>;
    /**
     * 
     * @type {Array<OrganizationLabelsGroupResponse>}
     * @memberof Application
     */
    'labels_groups'?: Array<OrganizationLabelsGroupResponse>;
    /**
     * Icon URI representing the application.
     * @type {string}
     * @memberof Application
     */
    'icon_uri': string;
    /**
     * 
     * @type {ServiceTypeEnum}
     * @memberof Application
     */
    'service_type': ServiceTypeEnum;
    /**
     * The target build stage in the Dockerfile to build
     * @type {string}
     * @memberof Application
     */
    'docker_target_build_stage'?: string | null;
    /**
     * 
     * @type {AutoscalingPolicyResponse}
     * @memberof Application
     */
    'autoscaling'?: AutoscalingPolicyResponse;
}


/**
 * 
 * @export
 * @interface ApplicationAdvancedSettings
 */
export interface ApplicationAdvancedSettings {
    /**
     * disable custom domain check when deploying an application
     * @type {boolean}
     * @memberof ApplicationAdvancedSettings
     */
    'deployment.custom_domain_check_enabled'?: boolean;
    /**
     * define how long in seconds an application is supposed to be stopped gracefully
     * @type {number}
     * @memberof ApplicationAdvancedSettings
     */
    'deployment.termination_grace_period_seconds'?: number;
    /**
     * Set pod placement on specific Kubernetes nodes labels
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationAdvancedSettings
     */
    'deployment.affinity.node.required'?: { [key: string]: string; };
    /**
     * Define how you want pods affinity to behave: * `Preferred` allows, but does not require, pods of a given service are not co-located (or co-hosted) on a single node * `Requirred` ensures that the pods of a given service are not co-located (or co-hosted) on a single node (safer in term of availability but can be expensive depending on the number of replicas) 
     * @type {string}
     * @memberof ApplicationAdvancedSettings
     */
    'deployment.antiaffinity.pod'?: ApplicationAdvancedSettingsDeploymentAntiaffinityPodEnum;
    /**
     * Allows you to run a command after the application is started. The command should be a shell command or script.
     * @type {Array<string>}
     * @memberof ApplicationAdvancedSettings
     */
    'deployment.lifecycle.post_start_exec_command'?: Array<string>;
    /**
     * Allows you to run a command before the application is stopped. The command should be a shell command or script. Qovery requires the sh shell by default and sets a sleep of 15 seconds to let Nginx update its config. Avoiding error codes returned during a rolling update.
     * @type {Array<string>}
     * @memberof ApplicationAdvancedSettings
     */
    'deployment.lifecycle.pre_stop_exec_command'?: Array<string>;
    /**
     * * `RollingUpdate` gracefully rollout new versions, and automatically rollback if the new version fails to start * `Recreate` stop all current versions and create new ones once all old ones have been shutdown 
     * @type {string}
     * @memberof ApplicationAdvancedSettings
     */
    'deployment.update_strategy.type'?: ApplicationAdvancedSettingsDeploymentUpdateStrategyTypeEnum;
    /**
     * Define the percentage of a maximum number of pods that can be unavailable during the update process
     * @type {number}
     * @memberof ApplicationAdvancedSettings
     */
    'deployment.update_strategy.rolling_update.max_unavailable_percent'?: number;
    /**
     * Define the percentage of the maximum number of pods that can be created over the desired number of pods
     * @type {number}
     * @memberof ApplicationAdvancedSettings
     */
    'deployment.update_strategy.rolling_update.max_surge_percent'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApplicationAdvancedSettings
     */
    'build.timeout_max_sec'?: number;
    /**
     * define the max cpu resources (in milli)
     * @type {number}
     * @memberof ApplicationAdvancedSettings
     */
    'build.cpu_max_in_milli'?: number;
    /**
     * define the max ram resources (in gib)
     * @type {number}
     * @memberof ApplicationAdvancedSettings
     */
    'build.ram_max_in_gib'?: number;
    /**
     * disable buildkit registry cache during build
     * @type {boolean}
     * @memberof ApplicationAdvancedSettings
     */
    'build.disable_buildkit_cache'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ApplicationAdvancedSettings
     */
    'network.ingress.proxy_body_size_mb'?: number;
    /**
     * When using SSL offloading outside of cluster, you can enforce a redirect to HTTPS even when there is no TLS certificate available
     * @type {boolean}
     * @memberof ApplicationAdvancedSettings
     */
    'network.ingress.force_ssl_redirect'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationAdvancedSettings
     */
    'network.ingress.enable_cors'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ApplicationAdvancedSettings
     */
    'network.ingress.cors_allow_origin'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationAdvancedSettings
     */
    'network.ingress.cors_allow_methods'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationAdvancedSettings
     */
    'network.ingress.cors_allow_headers'?: string;
    /**
     * header buffer size used while reading response header from upstream
     * @type {number}
     * @memberof ApplicationAdvancedSettings
     */
    'network.ingress.proxy_buffer_size_kb'?: number;
    /**
     * Limits the maximum time (in seconds) during which requests can be processed through one keepalive connection
     * @type {number}
     * @memberof ApplicationAdvancedSettings
     */
    'network.ingress.keepalive_time_seconds'?: number;
    /**
     * Sets a timeout (in seconds) during which an idle keepalive connection to an upstream server will stay open.
     * @type {number}
     * @memberof ApplicationAdvancedSettings
     */
    'network.ingress.keepalive_timeout_seconds'?: number;
    /**
     * Sets a timeout (in seconds) for transmitting a response to the client
     * @type {number}
     * @memberof ApplicationAdvancedSettings
     */
    'network.ingress.send_timeout_seconds'?: number;
    /**
     * Sets a timeout (in seconds) for establishing a connection to a proxied server
     * @type {number}
     * @memberof ApplicationAdvancedSettings
     */
    'network.ingress.proxy_connect_timeout_seconds'?: number;
    /**
     * Sets a timeout (in seconds) for transmitting a request to the proxied server
     * @type {number}
     * @memberof ApplicationAdvancedSettings
     */
    'network.ingress.proxy_send_timeout_seconds'?: number;
    /**
     * Sets a timeout (in seconds) for reading a response from the proxied server
     * @type {number}
     * @memberof ApplicationAdvancedSettings
     */
    'network.ingress.proxy_read_timeout_seconds'?: number;
    /**
     * Allows to enable or disable nginx `proxy-request-buffering`
     * @type {string}
     * @memberof ApplicationAdvancedSettings
     */
    'network.ingress.proxy_buffering'?: string;
    /**
     * list of source ranges to allow access to ingress proxy.  This property can be used to whitelist source IP ranges for ingress proxy. The value is a comma separated list of CIDRs, e.g. 10.0.0.0/24,172.10.0.1 To allow all source ranges, set 0.0.0.0/0. 
     * @type {string}
     * @memberof ApplicationAdvancedSettings
     */
    'network.ingress.whitelist_source_range'?: string;
    /**
     * list of source ranges to deny access to ingress proxy.  This property can be used to blacklist source IP ranges for ingress proxy. The value is a comma separated list of CIDRs, e.g. 10.0.0.0/24,172.10.0.1 
     * @type {string}
     * @memberof ApplicationAdvancedSettings
     */
    'network.ingress.denylist_source_range'?: string;
    /**
     * Set the name of an environment variable to use as a basic authentication (`login:crypted_password`) from `htpasswd` command. 
     * @type {string}
     * @memberof ApplicationAdvancedSettings
     */
    'network.ingress.basic_auth_env_var'?: string;
    /**
     * Enable the load balancer to bind a user\'s session to a specific target. This ensures that all requests from the user during the session are sent to the same target 
     * @type {boolean}
     * @memberof ApplicationAdvancedSettings
     */
    'network.ingress.enable_sticky_session'?: boolean;
    /**
     * Sets a timeout (in seconds) for transmitting a request to the grpc server
     * @type {number}
     * @memberof ApplicationAdvancedSettings
     */
    'network.ingress.grpc_send_timeout_seconds'?: number;
    /**
     * Sets a timeout (in seconds) for transmitting a request to the grpc server
     * @type {number}
     * @memberof ApplicationAdvancedSettings
     */
    'network.ingress.grpc_read_timeout_seconds'?: number;
    /**
     * Allows to define response headers
     * @type {string}
     * @memberof ApplicationAdvancedSettings
     */
    'network.ingress.extra_headers'?: string;
    /**
     * Percentage value of cpu usage at which point pods should scale up.
     * @type {number}
     * @memberof ApplicationAdvancedSettings
     */
    'hpa.cpu.average_utilization_percent'?: number;
    /**
     * Allows you to set an existing Kubernetes service account name 
     * @type {string}
     * @memberof ApplicationAdvancedSettings
     */
    'security.service_account_name'?: string;
    /**
     * Automount Kubernetes service account token to have access to Kubernetes API from pods 
     * @type {boolean}
     * @memberof ApplicationAdvancedSettings
     */
    'security.automount_service_account_token'?: boolean;
    /**
     * Mounts the container\'s root filesystem as read-only 
     * @type {boolean}
     * @memberof ApplicationAdvancedSettings
     */
    'security.read_only_root_filesystem'?: boolean;
}

export const ApplicationAdvancedSettingsDeploymentAntiaffinityPodEnum = {
    PREFERRED: 'Preferred',
    REQUIRRED: 'Requirred'
} as const;

export type ApplicationAdvancedSettingsDeploymentAntiaffinityPodEnum = typeof ApplicationAdvancedSettingsDeploymentAntiaffinityPodEnum[keyof typeof ApplicationAdvancedSettingsDeploymentAntiaffinityPodEnum];
export const ApplicationAdvancedSettingsDeploymentUpdateStrategyTypeEnum = {
    ROLLING_UPDATE: 'RollingUpdate',
    RECREATE: 'Recreate'
} as const;

export type ApplicationAdvancedSettingsDeploymentUpdateStrategyTypeEnum = typeof ApplicationAdvancedSettingsDeploymentUpdateStrategyTypeEnum[keyof typeof ApplicationAdvancedSettingsDeploymentUpdateStrategyTypeEnum];

/**
 * 
 * @export
 * @interface ApplicationDeploymentRestriction
 */
export interface ApplicationDeploymentRestriction {
    /**
     * 
     * @type {string}
     * @memberof ApplicationDeploymentRestriction
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationDeploymentRestriction
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationDeploymentRestriction
     */
    'updated_at'?: string;
    /**
     * 
     * @type {DeploymentRestrictionModeEnum}
     * @memberof ApplicationDeploymentRestriction
     */
    'mode': DeploymentRestrictionModeEnum;
    /**
     * 
     * @type {DeploymentRestrictionTypeEnum}
     * @memberof ApplicationDeploymentRestriction
     */
    'type': DeploymentRestrictionTypeEnum;
    /**
     * For `PATH` restrictions, the value must not start with `/`
     * @type {string}
     * @memberof ApplicationDeploymentRestriction
     */
    'value': string;
}


/**
 * 
 * @export
 * @interface ApplicationDeploymentRestrictionRequest
 */
export interface ApplicationDeploymentRestrictionRequest {
    /**
     * 
     * @type {DeploymentRestrictionModeEnum}
     * @memberof ApplicationDeploymentRestrictionRequest
     */
    'mode': DeploymentRestrictionModeEnum;
    /**
     * 
     * @type {DeploymentRestrictionTypeEnum}
     * @memberof ApplicationDeploymentRestrictionRequest
     */
    'type': DeploymentRestrictionTypeEnum;
    /**
     * For `PATH` restrictions, the value must not start with `/`
     * @type {string}
     * @memberof ApplicationDeploymentRestrictionRequest
     */
    'value': string;
}


/**
 * 
 * @export
 * @interface ApplicationDeploymentRestrictionResponseList
 */
export interface ApplicationDeploymentRestrictionResponseList {
    /**
     * 
     * @type {Array<ApplicationDeploymentRestriction>}
     * @memberof ApplicationDeploymentRestrictionResponseList
     */
    'results'?: Array<ApplicationDeploymentRestriction>;
}
/**
 * 
 * @export
 * @interface ApplicationEditRequest
 */
export interface ApplicationEditRequest {
    /**
     * 
     * @type {Array<ServiceStorageRequestStorageInner>}
     * @memberof ApplicationEditRequest
     */
    'storage'?: Array<ServiceStorageRequestStorageInner>;
    /**
     * name is case insensitive
     * @type {string}
     * @memberof ApplicationEditRequest
     */
    'name'?: string;
    /**
     * give a description to this application
     * @type {string}
     * @memberof ApplicationEditRequest
     */
    'description'?: string;
    /**
     * 
     * @type {ApplicationGitRepositoryRequest}
     * @memberof ApplicationEditRequest
     */
    'git_repository'?: ApplicationGitRepositoryRequest;
    /**
     * 
     * @type {BuildModeEnum}
     * @memberof ApplicationEditRequest
     */
    'build_mode'?: BuildModeEnum;
    /**
     * The path of the associated Dockerfile
     * @type {string}
     * @memberof ApplicationEditRequest
     */
    'dockerfile_path'?: string | null;
    /**
     * unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof ApplicationEditRequest
     */
    'cpu'?: number;
    /**
     * unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof ApplicationEditRequest
     */
    'memory'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApplicationEditRequest
     */
    'gpu'?: number;
    /**
     * Minimum number of instances running. This resource auto-scale based on the CPU and Memory consumption. Note: 0 means that there is no application running. 
     * @type {number}
     * @memberof ApplicationEditRequest
     */
    'min_running_instances'?: number;
    /**
     * Maximum number of instances running. This resource auto-scale based on the CPU and Memory consumption. Note: -1 means that there is no limit. 
     * @type {number}
     * @memberof ApplicationEditRequest
     */
    'max_running_instances'?: number;
    /**
     * 
     * @type {Healthcheck}
     * @memberof ApplicationEditRequest
     */
    'healthchecks': Healthcheck;
    /**
     * Specify if the environment preview option is activated or not for this application.   If activated, a preview environment will be automatically cloned at each pull request.   If not specified, it takes the value of the `auto_preview` property from the associated environment. 
     * @type {boolean}
     * @memberof ApplicationEditRequest
     */
    'auto_preview'?: boolean;
    /**
     * 
     * @type {Array<ServicePort>}
     * @memberof ApplicationEditRequest
     */
    'ports'?: Array<ServicePort>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApplicationEditRequest
     */
    'arguments'?: Array<string>;
    /**
     * optional entrypoint when launching container
     * @type {string}
     * @memberof ApplicationEditRequest
     */
    'entrypoint'?: string;
    /**
     * Specify if the application will be automatically updated after receiving a new commit.
     * @type {boolean}
     * @memberof ApplicationEditRequest
     */
    'auto_deploy'?: boolean | null;
    /**
     * 
     * @type {Array<ServiceAnnotationRequest>}
     * @memberof ApplicationEditRequest
     */
    'annotations_groups'?: Array<ServiceAnnotationRequest>;
    /**
     * 
     * @type {Array<ServiceLabelRequest>}
     * @memberof ApplicationEditRequest
     */
    'labels_groups'?: Array<ServiceLabelRequest>;
    /**
     * Icon URI representing the application.
     * @type {string}
     * @memberof ApplicationEditRequest
     */
    'icon_uri'?: string;
    /**
     * The target build stage in the Dockerfile to build
     * @type {string}
     * @memberof ApplicationEditRequest
     */
    'docker_target_build_stage'?: string | null;
}


/**
 * 
 * @export
 * @interface ApplicationGitRepository
 */
export interface ApplicationGitRepository {
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationGitRepository
     */
    'has_access'?: boolean;
    /**
     * 
     * @type {GitProviderEnum}
     * @memberof ApplicationGitRepository
     */
    'provider': GitProviderEnum;
    /**
     * 
     * @type {string}
     * @memberof ApplicationGitRepository
     */
    'owner': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationGitRepository
     */
    'url': string;
    /**
     * repository name
     * @type {string}
     * @memberof ApplicationGitRepository
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationGitRepository
     */
    'branch'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationGitRepository
     */
    'root_path'?: string;
    /**
     * Git commit ID corresponding to the deployed version of the app
     * @type {string}
     * @memberof ApplicationGitRepository
     */
    'deployed_commit_id'?: string;
    /**
     * Git commit date corresponding to the deployed version of the app
     * @type {string}
     * @memberof ApplicationGitRepository
     */
    'deployed_commit_date'?: string;
    /**
     * Git commit user corresponding to the deployed version of the app
     * @type {string}
     * @memberof ApplicationGitRepository
     */
    'deployed_commit_contributor'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationGitRepository
     */
    'deployed_commit_tag'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationGitRepository
     */
    'git_token_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApplicationGitRepository
     */
    'git_token_name'?: string | null;
}


/**
 * 
 * @export
 * @interface ApplicationGitRepositoryRequest
 */
export interface ApplicationGitRepositoryRequest {
    /**
     * application git repository URL
     * @type {string}
     * @memberof ApplicationGitRepositoryRequest
     */
    'url': string;
    /**
     * Name of the branch to use. This is optional If not specified, then the branch used is the `main` or `master` one 
     * @type {string}
     * @memberof ApplicationGitRepositoryRequest
     */
    'branch'?: string;
    /**
     * indicates the root path of the application.
     * @type {string}
     * @memberof ApplicationGitRepositoryRequest
     */
    'root_path'?: string;
    /**
     * The git token id on Qovery side
     * @type {string}
     * @memberof ApplicationGitRepositoryRequest
     */
    'git_token_id'?: string | null;
    /**
     * 
     * @type {GitProviderEnum}
     * @memberof ApplicationGitRepositoryRequest
     */
    'provider': GitProviderEnum;
}


/**
 * 
 * @export
 * @interface ApplicationNetwork
 */
export interface ApplicationNetwork {
    /**
     * Specify if the sticky session option (also called persistant session) is activated or not for this application. If activated, user will be redirected by the load balancer to the same instance each time he access to the application. 
     * @type {boolean}
     * @memberof ApplicationNetwork
     */
    'sticky_session'?: boolean;
}
/**
 * 
 * @export
 * @interface ApplicationNetworkRequest
 */
export interface ApplicationNetworkRequest {
    /**
     * Specify if the sticky session option (also called persistant session) is activated or not for this application. If activated, user will be redirected by the load balancer to the same instance each time he access to the application. 
     * @type {boolean}
     * @memberof ApplicationNetworkRequest
     */
    'sticky_session'?: boolean;
}
/**
 * 
 * @export
 * @interface ApplicationRequest
 */
export interface ApplicationRequest {
    /**
     * 
     * @type {Array<ServiceStorageRequestStorageInner>}
     * @memberof ApplicationRequest
     */
    'storage'?: Array<ServiceStorageRequestStorageInner>;
    /**
     * 
     * @type {Array<ServicePortRequestPortsInner>}
     * @memberof ApplicationRequest
     */
    'ports'?: Array<ServicePortRequestPortsInner>;
    /**
     * name is case insensitive
     * @type {string}
     * @memberof ApplicationRequest
     */
    'name': string;
    /**
     * give a description to this application
     * @type {string}
     * @memberof ApplicationRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {ApplicationGitRepositoryRequest}
     * @memberof ApplicationRequest
     */
    'git_repository': ApplicationGitRepositoryRequest;
    /**
     * 
     * @type {BuildModeEnum}
     * @memberof ApplicationRequest
     */
    'build_mode'?: BuildModeEnum;
    /**
     * The path of the associated Dockerfile. Only if you are using build_mode = DOCKER
     * @type {string}
     * @memberof ApplicationRequest
     */
    'dockerfile_path'?: string | null;
    /**
     * unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof ApplicationRequest
     */
    'cpu'?: number;
    /**
     * unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof ApplicationRequest
     */
    'memory'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApplicationRequest
     */
    'gpu'?: number;
    /**
     * Minimum number of instances running. This resource auto-scale based on the CPU and Memory consumption. Note: 0 means that there is no application running. 
     * @type {number}
     * @memberof ApplicationRequest
     */
    'min_running_instances'?: number;
    /**
     * Maximum number of instances running. This resource auto-scale based on the CPU and Memory consumption. Note: -1 means that there is no limit. 
     * @type {number}
     * @memberof ApplicationRequest
     */
    'max_running_instances'?: number;
    /**
     * 
     * @type {Healthcheck}
     * @memberof ApplicationRequest
     */
    'healthchecks': Healthcheck;
    /**
     * Specify if the environment preview option is activated or not for this application.   If activated, a preview environment will be automatically cloned at each pull request.   If not specified, it takes the value of the `auto_preview` property from the associated environment. 
     * @type {boolean}
     * @memberof ApplicationRequest
     */
    'auto_preview'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApplicationRequest
     */
    'arguments'?: Array<string>;
    /**
     * optional entrypoint when launching container
     * @type {string}
     * @memberof ApplicationRequest
     */
    'entrypoint'?: string;
    /**
     * Specify if the application will be automatically updated after receiving a new commit.
     * @type {boolean}
     * @memberof ApplicationRequest
     */
    'auto_deploy'?: boolean | null;
    /**
     * 
     * @type {Array<ServiceAnnotationRequest>}
     * @memberof ApplicationRequest
     */
    'annotations_groups'?: Array<ServiceAnnotationRequest>;
    /**
     * 
     * @type {Array<ServiceLabelRequest>}
     * @memberof ApplicationRequest
     */
    'labels_groups'?: Array<ServiceLabelRequest>;
    /**
     * Icon URI representing the application.
     * @type {string}
     * @memberof ApplicationRequest
     */
    'icon_uri'?: string;
    /**
     * The target build stage in the Dockerfile to build
     * @type {string}
     * @memberof ApplicationRequest
     */
    'docker_target_build_stage'?: string | null;
    /**
     * 
     * @type {AutoscalingPolicyRequest}
     * @memberof ApplicationRequest
     */
    'autoscaling'?: AutoscalingPolicyRequest;
}


/**
 * 
 * @export
 * @interface ApplicationResponseList
 */
export interface ApplicationResponseList {
    /**
     * 
     * @type {Array<Application>}
     * @memberof ApplicationResponseList
     */
    'results'?: Array<Application>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const AutoscalingMode = {
    KEDA: 'KEDA'
} as const;

export type AutoscalingMode = typeof AutoscalingMode[keyof typeof AutoscalingMode];


/**
 * @type AutoscalingPolicyRequest
 * @export
 */
export type AutoscalingPolicyRequest = { mode: 'KEDA' } & KedaAutoscalingRequest;

/**
 * @type AutoscalingPolicyResponse
 * @export
 */
export type AutoscalingPolicyResponse = { mode: 'KEDA' } & KedaAutoscalingResponse;

/**
 * 
 * @export
 * @interface AvailableContainerRegistryResponse
 */
export interface AvailableContainerRegistryResponse {
    /**
     * 
     * @type {ContainerRegistryKindEnum}
     * @memberof AvailableContainerRegistryResponse
     */
    'kind': ContainerRegistryKindEnum;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof AvailableContainerRegistryResponse
     */
    'required_config': { [key: string]: any; };
    /**
     * 
     * @type {boolean}
     * @memberof AvailableContainerRegistryResponse
     */
    'is_mandatory': boolean;
}


/**
 * 
 * @export
 * @interface AvailableContainerRegistryResponseList
 */
export interface AvailableContainerRegistryResponseList {
    /**
     * 
     * @type {Array<AvailableContainerRegistryResponse>}
     * @memberof AvailableContainerRegistryResponseList
     */
    'results'?: Array<AvailableContainerRegistryResponse>;
}
/**
 * 
 * @export
 * @interface AvailableHelmRepositoryResponse
 */
export interface AvailableHelmRepositoryResponse {
    /**
     * 
     * @type {HelmRepositoryKindEnum}
     * @memberof AvailableHelmRepositoryResponse
     */
    'kind': HelmRepositoryKindEnum;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof AvailableHelmRepositoryResponse
     */
    'required_config': { [key: string]: any; };
    /**
     * 
     * @type {boolean}
     * @memberof AvailableHelmRepositoryResponse
     */
    'is_mandatory': boolean;
}


/**
 * 
 * @export
 * @interface AvailableHelmRepositoryResponseList
 */
export interface AvailableHelmRepositoryResponseList {
    /**
     * 
     * @type {Array<AvailableHelmRepositoryResponse>}
     * @memberof AvailableHelmRepositoryResponseList
     */
    'results'?: Array<AvailableHelmRepositoryResponse>;
}
/**
 * @type AwsCredentialsRequest
 * @export
 */
export type AwsCredentialsRequest = AwsRoleCredentialsRequest | AwsStaticCredentialsRequest;

/**
 * 
 * @export
 * @interface AwsRoleClusterCredentials
 */
export interface AwsRoleClusterCredentials {
    /**
     * 
     * @type {string}
     * @memberof AwsRoleClusterCredentials
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AwsRoleClusterCredentials
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AwsRoleClusterCredentials
     */
    'role_arn': string;
    /**
     * 
     * @type {string}
     * @memberof AwsRoleClusterCredentials
     */
    'object_type': AwsRoleClusterCredentialsObjectTypeEnum;
}

export const AwsRoleClusterCredentialsObjectTypeEnum = {
    AWS_ROLE: 'AWS_ROLE'
} as const;

export type AwsRoleClusterCredentialsObjectTypeEnum = typeof AwsRoleClusterCredentialsObjectTypeEnum[keyof typeof AwsRoleClusterCredentialsObjectTypeEnum];

/**
 * 
 * @export
 * @interface AwsRoleCredentialsRequest
 */
export interface AwsRoleCredentialsRequest {
    /**
     * 
     * @type {string}
     * @memberof AwsRoleCredentialsRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AwsRoleCredentialsRequest
     */
    'role_arn': string;
}
/**
 * 
 * @export
 * @interface AwsStaticClusterCredentials
 */
export interface AwsStaticClusterCredentials {
    /**
     * 
     * @type {string}
     * @memberof AwsStaticClusterCredentials
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AwsStaticClusterCredentials
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AwsStaticClusterCredentials
     */
    'access_key_id': string;
    /**
     * 
     * @type {string}
     * @memberof AwsStaticClusterCredentials
     */
    'object_type': AwsStaticClusterCredentialsObjectTypeEnum;
}

export const AwsStaticClusterCredentialsObjectTypeEnum = {
    AWS: 'AWS'
} as const;

export type AwsStaticClusterCredentialsObjectTypeEnum = typeof AwsStaticClusterCredentialsObjectTypeEnum[keyof typeof AwsStaticClusterCredentialsObjectTypeEnum];

/**
 * 
 * @export
 * @interface AwsStaticCredentialsRequest
 */
export interface AwsStaticCredentialsRequest {
    /**
     * 
     * @type {string}
     * @memberof AwsStaticCredentialsRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AwsStaticCredentialsRequest
     */
    'access_key_id': string;
    /**
     * 
     * @type {string}
     * @memberof AwsStaticCredentialsRequest
     */
    'secret_access_key': string;
}
/**
 * 
 * @export
 * @interface AzureCredentialsRequest
 */
export interface AzureCredentialsRequest {
    /**
     * 
     * @type {string}
     * @memberof AzureCredentialsRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AzureCredentialsRequest
     */
    'azure_subscription_id': string;
    /**
     * 
     * @type {string}
     * @memberof AzureCredentialsRequest
     */
    'azure_tenant_id': string;
}
/**
 * 
 * @export
 * @interface AzureStaticClusterCredentials
 */
export interface AzureStaticClusterCredentials {
    /**
     * 
     * @type {string}
     * @memberof AzureStaticClusterCredentials
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AzureStaticClusterCredentials
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AzureStaticClusterCredentials
     */
    'azure_subscription_id': string;
    /**
     * 
     * @type {string}
     * @memberof AzureStaticClusterCredentials
     */
    'azure_tenant_id': string;
    /**
     * 
     * @type {string}
     * @memberof AzureStaticClusterCredentials
     */
    'object_type': AzureStaticClusterCredentialsObjectTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof AzureStaticClusterCredentials
     */
    'azure_application_id': string;
    /**
     * 
     * @type {string}
     * @memberof AzureStaticClusterCredentials
     */
    'azure_application_object_id': string;
}

export const AzureStaticClusterCredentialsObjectTypeEnum = {
    AZURE: 'AZURE'
} as const;

export type AzureStaticClusterCredentialsObjectTypeEnum = typeof AzureStaticClusterCredentialsObjectTypeEnum[keyof typeof AzureStaticClusterCredentialsObjectTypeEnum];

/**
 * 
 * @export
 * @interface Backup
 */
export interface Backup {
    /**
     * 
     * @type {string}
     * @memberof Backup
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Backup
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Backup
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Backup
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Backup
     */
    'message': string;
    /**
     * 
     * @type {Status}
     * @memberof Backup
     */
    'status'?: Status;
}
/**
 * 
 * @export
 * @interface BackupPaginatedResponseList
 */
export interface BackupPaginatedResponseList {
    /**
     * 
     * @type {number}
     * @memberof BackupPaginatedResponseList
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof BackupPaginatedResponseList
     */
    'page_size': number;
    /**
     * 
     * @type {Array<Backup>}
     * @memberof BackupPaginatedResponseList
     */
    'results'?: Array<Backup>;
}
/**
 * 
 * @export
 * @interface BackupRequest
 */
export interface BackupRequest {
    /**
     * 
     * @type {string}
     * @memberof BackupRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BackupRequest
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface BackupResponseList
 */
export interface BackupResponseList {
    /**
     * 
     * @type {Array<Backup>}
     * @memberof BackupResponseList
     */
    'results'?: Array<Backup>;
}
/**
 * 
 * @export
 * @interface Base
 */
export interface Base {
    /**
     * 
     * @type {string}
     * @memberof Base
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Base
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Base
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface BaseJobResponse
 */
export interface BaseJobResponse {
    /**
     * 
     * @type {string}
     * @memberof BaseJobResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BaseJobResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof BaseJobResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {ReferenceObject}
     * @memberof BaseJobResponse
     */
    'environment': ReferenceObject;
    /**
     * Maximum cpu that can be allocated to the job based on organization cluster configuration. unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof BaseJobResponse
     */
    'maximum_cpu': number;
    /**
     * Maximum memory that can be allocated to the job based on organization cluster configuration. unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof BaseJobResponse
     */
    'maximum_memory': number;
    /**
     * Maximum memory that can be allocated to the job based on organization cluster configuration. unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof BaseJobResponse
     */
    'maximum_gpu': number;
    /**
     * name is case insensitive
     * @type {string}
     * @memberof BaseJobResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BaseJobResponse
     */
    'description'?: string;
    /**
     * unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof BaseJobResponse
     */
    'cpu': number;
    /**
     * unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof BaseJobResponse
     */
    'memory': number;
    /**
     * 
     * @type {number}
     * @memberof BaseJobResponse
     */
    'gpu': number;
    /**
     * Maximum number of restart allowed before the job is considered as failed 0 means that no restart/crash of the job is allowed 
     * @type {number}
     * @memberof BaseJobResponse
     */
    'max_nb_restart'?: number;
    /**
     * Maximum number of seconds allowed for the job to run before killing it and mark it as failed 
     * @type {number}
     * @memberof BaseJobResponse
     */
    'max_duration_seconds'?: number;
    /**
     * Indicates if the \'environment preview option\' is enabled for this container.   If enabled, a preview environment will be automatically cloned when `/preview` endpoint is called.   If not specified, it takes the value of the `auto_preview` property from the associated environment. 
     * @type {boolean}
     * @memberof BaseJobResponse
     */
    'auto_preview': boolean;
    /**
     * Port where to run readiness and liveliness probes checks. The port will not be exposed externally
     * @type {number}
     * @memberof BaseJobResponse
     */
    'port'?: number | null;
    /**
     * 
     * @type {BaseJobResponseAllOfSource}
     * @memberof BaseJobResponse
     */
    'source': BaseJobResponseAllOfSource;
    /**
     * 
     * @type {Healthcheck}
     * @memberof BaseJobResponse
     */
    'healthchecks': Healthcheck;
    /**
     * Specify if the job will be automatically updated after receiving a new image tag or a new commit according to the source type.  The new image tag shall be communicated via the \"Auto Deploy job\" endpoint https://api-doc.qovery.com/#tag/Jobs/operation/autoDeployJobEnvironments 
     * @type {boolean}
     * @memberof BaseJobResponse
     */
    'auto_deploy'?: boolean;
    /**
     * Icon URI representing the job.
     * @type {string}
     * @memberof BaseJobResponse
     */
    'icon_uri': string;
    /**
     * 
     * @type {ServiceTypeEnum}
     * @memberof BaseJobResponse
     */
    'service_type': ServiceTypeEnum;
}


/**
 * @type BaseJobResponseAllOfSource
 * @export
 */
export type BaseJobResponseAllOfSource = BaseJobResponseAllOfSourceOneOf | BaseJobResponseAllOfSourceOneOf1;

/**
 * 
 * @export
 * @interface BaseJobResponseAllOfSourceOneOf
 */
export interface BaseJobResponseAllOfSourceOneOf {
    /**
     * 
     * @type {ContainerSource}
     * @memberof BaseJobResponseAllOfSourceOneOf
     */
    'image': ContainerSource;
}
/**
 * 
 * @export
 * @interface BaseJobResponseAllOfSourceOneOf1
 */
export interface BaseJobResponseAllOfSourceOneOf1 {
    /**
     * 
     * @type {JobSourceDockerResponse}
     * @memberof BaseJobResponseAllOfSourceOneOf1
     */
    'docker': JobSourceDockerResponse;
}
/**
 * 
 * @export
 * @interface BillingExternalId
 */
export interface BillingExternalId {
    /**
     * 
     * @type {string}
     * @memberof BillingExternalId
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface BillingInfo
 */
export interface BillingInfo {
    /**
     * 
     * @type {string}
     * @memberof BillingInfo
     */
    'first_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BillingInfo
     */
    'last_name'?: string | null;
    /**
     * email used for billing, and to receive all invoices by email
     * @type {string}
     * @memberof BillingInfo
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BillingInfo
     */
    'address'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BillingInfo
     */
    'city'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BillingInfo
     */
    'zip'?: string | null;
    /**
     * only for US
     * @type {string}
     * @memberof BillingInfo
     */
    'state'?: string | null;
    /**
     * ISO code of the country
     * @type {string}
     * @memberof BillingInfo
     */
    'country_code'?: string | null;
    /**
     * name of the company to bill
     * @type {string}
     * @memberof BillingInfo
     */
    'company'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BillingInfo
     */
    'vat_number'?: string | null;
}
/**
 * 
 * @export
 * @interface BillingInfoRequest
 */
export interface BillingInfoRequest {
    /**
     * 
     * @type {string}
     * @memberof BillingInfoRequest
     */
    'first_name': string;
    /**
     * 
     * @type {string}
     * @memberof BillingInfoRequest
     */
    'last_name': string;
    /**
     * email used for billing, and to receive all invoices by email
     * @type {string}
     * @memberof BillingInfoRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof BillingInfoRequest
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof BillingInfoRequest
     */
    'city': string;
    /**
     * 
     * @type {string}
     * @memberof BillingInfoRequest
     */
    'zip': string;
    /**
     * only for US
     * @type {string}
     * @memberof BillingInfoRequest
     */
    'state'?: string;
    /**
     * ISO code of the country
     * @type {string}
     * @memberof BillingInfoRequest
     */
    'country_code': string;
    /**
     * name of the company to bill
     * @type {string}
     * @memberof BillingInfoRequest
     */
    'company'?: string;
    /**
     * 
     * @type {string}
     * @memberof BillingInfoRequest
     */
    'vat_number'?: string;
}
/**
 * 
 * @export
 * @interface BillingStatus
 */
export interface BillingStatus {
    /**
     * 
     * @type {boolean}
     * @memberof BillingStatus
     */
    'is_valid'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof BillingStatus
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface Budget
 */
export interface Budget {
    /**
     * 
     * @type {number}
     * @memberof Budget
     */
    'total_in_cents'?: number;
    /**
     * 
     * @type {number}
     * @memberof Budget
     */
    'total'?: number;
    /**
     * 
     * @type {string}
     * @memberof Budget
     */
    'currency_code'?: string;
}
/**
 * `DOCKER` requires `dockerfile_path` 
 * @export
 * @enum {string}
 */

export const BuildModeEnum = {
    DOCKER: 'DOCKER'
} as const;

export type BuildModeEnum = typeof BuildModeEnum[keyof typeof BuildModeEnum];


/**
 * 
 * @export
 * @interface CancelEnvironmentDeploymentRequest
 */
export interface CancelEnvironmentDeploymentRequest {
    /**
     * Force cancel everything running in this environment if set to true (e.q lifecycle jobs triggered during the deployment).
     * @type {boolean}
     * @memberof CancelEnvironmentDeploymentRequest
     */
    'force_cancel'?: boolean;
}
/**
 * 
 * @export
 * @interface CheckedCustomDomainResponse
 */
export interface CheckedCustomDomainResponse {
    /**
     * domain name checked
     * @type {string}
     * @memberof CheckedCustomDomainResponse
     */
    'domain_name': string;
    /**
     * 
     * @type {CheckedCustomDomainStatus}
     * @memberof CheckedCustomDomainResponse
     */
    'status': CheckedCustomDomainStatus;
    /**
     * optional field containing information about failure check
     * @type {string}
     * @memberof CheckedCustomDomainResponse
     */
    'error_details'?: string | null;
}


/**
 * This enum represents the final status for your domain. There are 2 successful statuses:   * `RESOLVES_TO_IP`: we succeeded to resolve an IP to your domain. This is the successful final status for custom domains where `use_cdn` is `true`   * `MATCHES_LOAD_BALANCER_HOST`: we succeeded to lookup CNAMEs & found that it matches your cluser Load Balancer host. This is the successful final status for custom domain where `use_cdn` is `false`   * `DOMAIN_NOT_CONFIGURED`: the domain is not configured, look at the `error_details` field for more information    * `DOMAIN_LINKED_TO_WRONG_HOST`: the domain has CNAME(s) that matches a different host than your Load Balancer one   * `GENERIC_FAILURE`: an error occured when attempting to validate your domain, look at the `error_details` field for more information 
 * @export
 * @enum {string}
 */

export const CheckedCustomDomainStatus = {
    RESOLVES_TO_IP: 'RESOLVES_TO_IP',
    MATCHES_LOAD_BALANCER_HOST: 'MATCHES_LOAD_BALANCER_HOST',
    DOMAIN_NOT_CONFIGURED: 'DOMAIN_NOT_CONFIGURED',
    DOMAIN_LINKED_TO_WRONG_HOST: 'DOMAIN_LINKED_TO_WRONG_HOST',
    GENERIC_FAILURE: 'GENERIC_FAILURE'
} as const;

export type CheckedCustomDomainStatus = typeof CheckedCustomDomainStatus[keyof typeof CheckedCustomDomainStatus];


/**
 * 
 * @export
 * @interface CheckedCustomDomainsResponse
 */
export interface CheckedCustomDomainsResponse {
    /**
     * 
     * @type {Array<CheckedCustomDomainResponse>}
     * @memberof CheckedCustomDomainsResponse
     */
    'results': Array<CheckedCustomDomainResponse>;
}
/**
 * 
 * @export
 * @interface CleanFailedJob200Response
 */
export interface CleanFailedJob200Response {
    /**
     * 
     * @type {Array<string>}
     * @memberof CleanFailedJob200Response
     */
    'clean_kubernetes_jobs'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CleanFailedJobs200Response
 */
export interface CleanFailedJobs200Response {
    /**
     * 
     * @type {Array<string>}
     * @memberof CleanFailedJobs200Response
     */
    'clean_job_ids'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CleanFailedJobs200Response
     */
    'clean_kubernetes_jobs'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CleanFailedJobsRequest
 */
export interface CleanFailedJobsRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof CleanFailedJobsRequest
     */
    'job_ids'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CloneEnvironmentRequest
 */
export interface CloneEnvironmentRequest {
    /**
     * name is case insensitive
     * @type {string}
     * @memberof CloneEnvironmentRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CloneEnvironmentRequest
     */
    'cluster_id'?: string;
    /**
     * 
     * @type {EnvironmentModeEnum}
     * @memberof CloneEnvironmentRequest
     */
    'mode'?: EnvironmentModeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof CloneEnvironmentRequest
     */
    'apply_deployment_rule'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CloneEnvironmentRequest
     */
    'project_id'?: string;
}


/**
 * 
 * @export
 * @interface CloneServiceRequest
 */
export interface CloneServiceRequest {
    /**
     * 
     * @type {string}
     * @memberof CloneServiceRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CloneServiceRequest
     */
    'environment_id': string;
}
/**
 * 
 * @export
 * @interface CloudProvider
 */
export interface CloudProvider {
    /**
     * 
     * @type {string}
     * @memberof CloudProvider
     */
    'short_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CloudProvider
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CloudProvider
     */
    'logo_url'?: string;
    /**
     * 
     * @type {Array<ClusterRegion>}
     * @memberof CloudProvider
     */
    'regions'?: Array<ClusterRegion>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CloudProviderEnum = {
    AWS: 'AWS',
    SCW: 'SCW',
    GCP: 'GCP',
    ON_PREMISE: 'ON_PREMISE',
    AZURE: 'AZURE'
} as const;

export type CloudProviderEnum = typeof CloudProviderEnum[keyof typeof CloudProviderEnum];


/**
 * 
 * @export
 * @interface CloudProviderResponseList
 */
export interface CloudProviderResponseList {
    /**
     * 
     * @type {Array<CloudProvider>}
     * @memberof CloudProviderResponseList
     */
    'results'?: Array<CloudProvider>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CloudVendorEnum = {
    AWS: 'AWS',
    SCW: 'SCW',
    GCP: 'GCP',
    DO: 'DO',
    AZURE: 'AZURE',
    OVH: 'OVH',
    CIVO: 'CIVO',
    HETZNER: 'HETZNER',
    ORACLE: 'ORACLE',
    IBM: 'IBM',
    ON_PREMISE: 'ON_PREMISE'
} as const;

export type CloudVendorEnum = typeof CloudVendorEnum[keyof typeof CloudVendorEnum];


/**
 * 
 * @export
 * @interface CloudWatchExportConfig
 */
export interface CloudWatchExportConfig {
    /**
     * To enable the cloudwatch exporter.
     * @type {boolean}
     * @memberof CloudWatchExportConfig
     */
    'enabled': boolean;
}
/**
 * 
 * @export
 * @interface Cluster
 */
export interface Cluster {
    /**
     * 
     * @type {string}
     * @memberof Cluster
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Cluster
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Cluster
     */
    'updated_at'?: string;
    /**
     * 
     * @type {ReferenceObject}
     * @memberof Cluster
     */
    'organization': ReferenceObject;
    /**
     * name is case-insensitive
     * @type {string}
     * @memberof Cluster
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Cluster
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Cluster
     */
    'region': string;
    /**
     * 
     * @type {CloudVendorEnum}
     * @memberof Cluster
     */
    'cloud_provider': CloudVendorEnum;
    /**
     * 
     * @type {number}
     * @memberof Cluster
     */
    'min_running_nodes'?: number;
    /**
     * 
     * @type {number}
     * @memberof Cluster
     */
    'max_running_nodes'?: number;
    /**
     * Unit is in GB. The disk size to be used for the node configuration
     * @type {number}
     * @memberof Cluster
     */
    'disk_size'?: number;
    /**
     * the instance type to be used for this cluster. The list of values can be retrieved via the endpoint /{CloudProvider}/instanceType
     * @type {string}
     * @memberof Cluster
     */
    'instance_type'?: string;
    /**
     * 
     * @type {KubernetesEnum}
     * @memberof Cluster
     */
    'kubernetes'?: KubernetesEnum;
    /**
     * unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof Cluster
     */
    'cpu'?: number;
    /**
     * unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof Cluster
     */
    'memory'?: number;
    /**
     * This is an estimation of the cost this cluster will represent on your cloud proider bill, based on your current configuration
     * @type {number}
     * @memberof Cluster
     */
    'estimated_cloud_provider_cost'?: number;
    /**
     * 
     * @type {ClusterStateEnum}
     * @memberof Cluster
     */
    'status'?: ClusterStateEnum;
    /**
     * 
     * @type {boolean}
     * @memberof Cluster
     */
    'has_access'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Cluster
     */
    'version'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Cluster
     */
    'is_default'?: boolean;
    /**
     * specific flag to indicate that this cluster is a demo one
     * @type {boolean}
     * @memberof Cluster
     */
    'is_demo'?: boolean;
    /**
     * specific flag to indicate that this cluster is a production one
     * @type {boolean}
     * @memberof Cluster
     */
    'production'?: boolean;
    /**
     * Indicate your public ssh_key to remotely connect to your EC2 instance.
     * @type {Array<string>}
     * @memberof Cluster
     */
    'ssh_keys'?: Array<string>;
    /**
     * 
     * @type {Array<ClusterFeatureResponse>}
     * @memberof Cluster
     */
    'features'?: Array<ClusterFeatureResponse>;
    /**
     * 
     * @type {ClusterDeploymentStatusEnum}
     * @memberof Cluster
     */
    'deployment_status'?: ClusterDeploymentStatusEnum;
    /**
     * 
     * @type {MetricsParameters}
     * @memberof Cluster
     */
    'metrics_parameters'?: MetricsParameters;
    /**
     * 
     * @type {InfrastructureOutputs}
     * @memberof Cluster
     */
    'infrastructure_outputs'?: InfrastructureOutputs;
    /**
     * 
     * @type {ClusterInfrastructureChartsParameters}
     * @memberof Cluster
     */
    'infrastructure_charts_parameters'?: ClusterInfrastructureChartsParameters;
    /**
     * 
     * @type {ClusterKeda}
     * @memberof Cluster
     */
    'keda'?: ClusterKeda;
}


/**
 * 
 * @export
 * @interface ClusterAdvancedSettings
 */
export interface ClusterAdvancedSettings {
    /**
     * Set the number of retention days for EKS Cloudwatch logs
     * @type {number}
     * @memberof ClusterAdvancedSettings
     */
    'aws.cloudwatch.eks_logs_retention_days'?: number;
    /**
     * Enable flow logs for on the VPC and store them in an S3 bucket
     * @type {boolean}
     * @memberof ClusterAdvancedSettings
     */
    'aws.vpc.enable_s3_flow_logs'?: boolean;
    /**
     * Set the number of retention days for flow logs. Disable with value \"0\"
     * @type {number}
     * @memberof ClusterAdvancedSettings
     */
    'aws.vpc.flow_logs_retention_days'?: number;
    /**
     * For how long in week loki is going to keep logs of your applications
     * @type {number}
     * @memberof ClusterAdvancedSettings
     */
    'loki.log_retention_in_week'?: number;
    /**
     * Configure the number of seconds before cleaning images in the registry
     * @type {number}
     * @memberof ClusterAdvancedSettings
     */
    'registry.image_retention_time'?: number;
    /**
     * Add additional tags on the cluster dedicated registry
     * @type {{ [key: string]: string; }}
     * @memberof ClusterAdvancedSettings
     */
    'cloud_provider.container_registry.tags'?: { [key: string]: string; };
    /**
     * Enable the AWS ALB controller to manage the load balancer for the cluster. Note: Changing this feature will create a 10 min max downtime on your application\'s public access (time to delete, replace and propagate DNS of the new load balancer) and will requiere to update all services with TCP/UDP open ports.
     * @type {boolean}
     * @memberof ClusterAdvancedSettings
     */
    'aws.eks.enable_alb_controller'?: boolean;
    /**
     * Select the size of the main load_balancer (only effective for Scaleway)
     * @type {string}
     * @memberof ClusterAdvancedSettings
     */
    'load_balancer.size'?: string;
    /**
     * Deny public access to any PostgreSQL database
     * @type {boolean}
     * @memberof ClusterAdvancedSettings
     */
    'database.postgresql.deny_any_access'?: boolean;
    /**
     * List of CIDRs allowed to access the PostgreSQL database
     * @type {Array<string>}
     * @memberof ClusterAdvancedSettings
     */
    'database.postgresql.allowed_cidrs'?: Array<string>;
    /**
     * Deny public access to any MySql database
     * @type {boolean}
     * @memberof ClusterAdvancedSettings
     */
    'database.mysql.deny_any_access'?: boolean;
    /**
     * List of CIDRs allowed to access the MySql database
     * @type {Array<string>}
     * @memberof ClusterAdvancedSettings
     */
    'database.mysql.allowed_cidrs'?: Array<string>;
    /**
     * Deny public access to any MongoDB/DocumentDB database
     * @type {boolean}
     * @memberof ClusterAdvancedSettings
     */
    'database.mongodb.deny_any_access'?: boolean;
    /**
     * List of CIDRs allowed to access the MongoDB/DocumentDB database
     * @type {Array<string>}
     * @memberof ClusterAdvancedSettings
     */
    'database.mongodb.allowed_cidrs'?: Array<string>;
    /**
     * Deny public access to any Redis database
     * @type {boolean}
     * @memberof ClusterAdvancedSettings
     */
    'database.redis.deny_any_access'?: boolean;
    /**
     * List of CIDRs allowed to access the Redis database
     * @type {Array<string>}
     * @memberof ClusterAdvancedSettings
     */
    'database.redis.allowed_cidrs'?: Array<string>;
    /**
     * AWS IAM group name with cluster access
     * @type {string}
     * @memberof ClusterAdvancedSettings
     */
    'aws.iam.admin_group'?: string;
    /**
     * Specify the [IMDS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html) version you want to use:   * `required`: IMDS V2 only   * `optional`: IMDS V1 + V2 
     * @type {string}
     * @memberof ClusterAdvancedSettings
     */
    'aws.eks.ec2.metadata_imds'?: ClusterAdvancedSettingsAwsEksEc2MetadataImdsEnum;
    /**
     * 
     * @type {number}
     * @memberof ClusterAdvancedSettings
     * @deprecated
     */
    'pleco.resources_ttl'?: number;
    /**
     * 
     * @type {RegistryMirroringModeEnum}
     * @memberof ClusterAdvancedSettings
     */
    'registry.mirroring_mode'?: RegistryMirroringModeEnum;
    /**
     * vcpu request in millicores
     * @type {number}
     * @memberof ClusterAdvancedSettings
     */
    'nginx.vcpu.request_in_milli_cpu'?: number;
    /**
     * vcpu limit in millicores
     * @type {number}
     * @memberof ClusterAdvancedSettings
     */
    'nginx.vcpu.limit_in_milli_cpu'?: number;
    /**
     * memory request in MiB
     * @type {number}
     * @memberof ClusterAdvancedSettings
     */
    'nginx.memory.request_in_mib'?: number;
    /**
     * memory limit in MiB
     * @type {number}
     * @memberof ClusterAdvancedSettings
     */
    'nginx.memory.limit_in_mib'?: number;
    /**
     * hpa cpu threshold in percentage
     * @type {number}
     * @memberof ClusterAdvancedSettings
     */
    'nginx.hpa.cpu_utilization_percentage_threshold'?: number;
    /**
     * hpa minimum number of instances
     * @type {number}
     * @memberof ClusterAdvancedSettings
     */
    'nginx.hpa.min_number_instances'?: number;
    /**
     * hpa maximum number of instances
     * @type {number}
     * @memberof ClusterAdvancedSettings
     */
    'nginx.hpa.max_number_instances'?: number;
    /**
     * storage class name to use to provision pvc
     * @type {string}
     * @memberof ClusterAdvancedSettings
     */
    'storageclass.fast_ssd'?: string;
    /**
     * To limit public access from the internet to your Kubernetes cluster endpoint. You can define whitelisted CIDR in k8s.api.allowed_public_access_cidrs.
     * @type {boolean}
     * @memberof ClusterAdvancedSettings
     */
    'qovery.static_ip_mode'?: boolean;
    /**
     * Set custom sources to public access endpoint. Use CIDR notation to specify an IP address range  (for example, [\'203.0.113.5/32\',\'203.0.100/32\'])
     * @type {Array<string>}
     * @memberof ClusterAdvancedSettings
     */
    'k8s.api.allowed_public_access_cidrs'?: Array<string>;
}

export const ClusterAdvancedSettingsAwsEksEc2MetadataImdsEnum = {
    OPTIONAL: 'optional',
    REQUIRED: 'required'
} as const;

export type ClusterAdvancedSettingsAwsEksEc2MetadataImdsEnum = typeof ClusterAdvancedSettingsAwsEksEc2MetadataImdsEnum[keyof typeof ClusterAdvancedSettingsAwsEksEc2MetadataImdsEnum];

/**
 * 
 * @export
 * @interface ClusterCloudProviderInfo
 */
export interface ClusterCloudProviderInfo {
    /**
     * 
     * @type {CloudProviderEnum}
     * @memberof ClusterCloudProviderInfo
     */
    'cloud_provider'?: CloudProviderEnum;
    /**
     * 
     * @type {ClusterCloudProviderInfoCredentials}
     * @memberof ClusterCloudProviderInfo
     */
    'credentials'?: ClusterCloudProviderInfoCredentials;
    /**
     * 
     * @type {string}
     * @memberof ClusterCloudProviderInfo
     */
    'region'?: string;
}


/**
 * 
 * @export
 * @interface ClusterCloudProviderInfoCredentials
 */
export interface ClusterCloudProviderInfoCredentials {
    /**
     * 
     * @type {string}
     * @memberof ClusterCloudProviderInfoCredentials
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterCloudProviderInfoCredentials
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface ClusterCloudProviderInfoRequest
 */
export interface ClusterCloudProviderInfoRequest {
    /**
     * 
     * @type {CloudProviderEnum}
     * @memberof ClusterCloudProviderInfoRequest
     */
    'cloud_provider'?: CloudProviderEnum;
    /**
     * 
     * @type {ClusterCloudProviderInfoCredentials}
     * @memberof ClusterCloudProviderInfoRequest
     */
    'credentials'?: ClusterCloudProviderInfoCredentials;
    /**
     * 
     * @type {string}
     * @memberof ClusterCloudProviderInfoRequest
     */
    'region'?: string;
}


/**
 * @type ClusterCredentials
 * @export
 */
export type ClusterCredentials = { object_type: 'AWS' } & AwsStaticClusterCredentials | { object_type: 'AWS_ROLE' } & AwsRoleClusterCredentials | { object_type: 'AZURE' } & AzureStaticClusterCredentials | { object_type: 'GCP' } & GcpStaticClusterCredentials | { object_type: 'OTHER' } & GenericClusterCredentials | { object_type: 'SCW' } & ScalewayClusterCredentials;

/**
 * 
 * @export
 * @interface ClusterCredentialsResponseList
 */
export interface ClusterCredentialsResponseList {
    /**
     * 
     * @type {Array<ClusterCredentials>}
     * @memberof ClusterCredentialsResponseList
     */
    'results'?: Array<ClusterCredentials>;
}
/**
 * Indicates the mode to apply on cluster deletion   **\"hard delete\"** means that we delete directly from our database, this is different from a **\"trigger delete\"** that cleans the resource - `DEFAULT`: this is the normal way, trigger delete the cluster only if no environment linked to this cluster remains - `DELETE_CLUSTER_AND_QOVERY_CONFIG`: hard delete environments linked to this cluster then trigger delete the cluster - `DELETE_QOVERY_CONFIG`: ⚠️ ⚠️ ⚠️ hard delete environments linked to this cluster then hard delete the cluster - whole cluster ressources **are not deleted** on our side and must be deleted on your side 
 * @export
 * @enum {string}
 */

export const ClusterDeleteMode = {
    DEFAULT: 'DEFAULT',
    DELETE_CLUSTER_AND_QOVERY_CONFIG: 'DELETE_CLUSTER_AND_QOVERY_CONFIG',
    DELETE_QOVERY_CONFIG: 'DELETE_QOVERY_CONFIG'
} as const;

export type ClusterDeleteMode = typeof ClusterDeleteMode[keyof typeof ClusterDeleteMode];


/**
 * 
 * @export
 * @enum {string}
 */

export const ClusterDeploymentStatusEnum = {
    NEVER_DEPLOYED: 'NEVER_DEPLOYED',
    OUT_OF_DATE: 'OUT_OF_DATE',
    UP_TO_DATE: 'UP_TO_DATE'
} as const;

export type ClusterDeploymentStatusEnum = typeof ClusterDeploymentStatusEnum[keyof typeof ClusterDeploymentStatusEnum];


/**
 * 
 * @export
 * @interface ClusterFeatureAwsExistingVpc
 */
export interface ClusterFeatureAwsExistingVpc {
    /**
     * 
     * @type {string}
     * @memberof ClusterFeatureAwsExistingVpc
     */
    'aws_vpc_eks_id': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClusterFeatureAwsExistingVpc
     */
    'eks_subnets_zone_a_ids': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClusterFeatureAwsExistingVpc
     */
    'eks_subnets_zone_b_ids': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClusterFeatureAwsExistingVpc
     */
    'eks_subnets_zone_c_ids': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClusterFeatureAwsExistingVpc
     */
    'documentdb_subnets_zone_a_ids'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClusterFeatureAwsExistingVpc
     */
    'documentdb_subnets_zone_b_ids'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClusterFeatureAwsExistingVpc
     */
    'documentdb_subnets_zone_c_ids'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClusterFeatureAwsExistingVpc
     */
    'elasticache_subnets_zone_a_ids'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClusterFeatureAwsExistingVpc
     */
    'elasticache_subnets_zone_b_ids'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClusterFeatureAwsExistingVpc
     */
    'elasticache_subnets_zone_c_ids'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClusterFeatureAwsExistingVpc
     */
    'rds_subnets_zone_a_ids'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClusterFeatureAwsExistingVpc
     */
    'rds_subnets_zone_b_ids'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClusterFeatureAwsExistingVpc
     */
    'rds_subnets_zone_c_ids'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClusterFeatureAwsExistingVpc
     */
    'eks_karpenter_fargate_subnets_zone_a_ids'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClusterFeatureAwsExistingVpc
     */
    'eks_karpenter_fargate_subnets_zone_b_ids'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClusterFeatureAwsExistingVpc
     */
    'eks_karpenter_fargate_subnets_zone_c_ids'?: Array<string> | null;
    /**
     * 
     * @type {boolean}
     * @memberof ClusterFeatureAwsExistingVpc
     */
    'eks_create_nodes_in_private_subnet'?: boolean;
}
/**
 * 
 * @export
 * @interface ClusterFeatureAwsExistingVpcResponse
 */
export interface ClusterFeatureAwsExistingVpcResponse {
    /**
     * 
     * @type {ClusterFeatureResponseTypeEnum}
     * @memberof ClusterFeatureAwsExistingVpcResponse
     */
    'type': ClusterFeatureResponseTypeEnum;
    /**
     * 
     * @type {ClusterFeatureAwsExistingVpc}
     * @memberof ClusterFeatureAwsExistingVpcResponse
     */
    'value': ClusterFeatureAwsExistingVpc;
}


/**
 * 
 * @export
 * @interface ClusterFeatureBooleanResponse
 */
export interface ClusterFeatureBooleanResponse {
    /**
     * 
     * @type {ClusterFeatureResponseTypeEnum}
     * @memberof ClusterFeatureBooleanResponse
     */
    'type': ClusterFeatureResponseTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof ClusterFeatureBooleanResponse
     */
    'value': boolean;
}


/**
 * 
 * @export
 * @interface ClusterFeatureGcpExistingVpc
 */
export interface ClusterFeatureGcpExistingVpc {
    /**
     * 
     * @type {string}
     * @memberof ClusterFeatureGcpExistingVpc
     */
    'vpc_name': string;
    /**
     * 
     * @type {string}
     * @memberof ClusterFeatureGcpExistingVpc
     */
    'vpc_project_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ClusterFeatureGcpExistingVpc
     */
    'subnetwork_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ClusterFeatureGcpExistingVpc
     */
    'ip_range_services_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ClusterFeatureGcpExistingVpc
     */
    'ip_range_pods_name'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClusterFeatureGcpExistingVpc
     */
    'additional_ip_range_pods_names'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ClusterFeatureGcpExistingVpcResponse
 */
export interface ClusterFeatureGcpExistingVpcResponse {
    /**
     * 
     * @type {ClusterFeatureResponseTypeEnum}
     * @memberof ClusterFeatureGcpExistingVpcResponse
     */
    'type': ClusterFeatureResponseTypeEnum;
    /**
     * 
     * @type {ClusterFeatureGcpExistingVpc}
     * @memberof ClusterFeatureGcpExistingVpcResponse
     */
    'value': ClusterFeatureGcpExistingVpc;
}


/**
 * 
 * @export
 * @interface ClusterFeatureKarpenterParameters
 */
export interface ClusterFeatureKarpenterParameters {
    /**
     * 
     * @type {boolean}
     * @memberof ClusterFeatureKarpenterParameters
     */
    'spot_enabled': boolean;
    /**
     * 
     * @type {number}
     * @memberof ClusterFeatureKarpenterParameters
     */
    'disk_size_in_gib': number;
    /**
     * 
     * @type {CpuArchitectureEnum}
     * @memberof ClusterFeatureKarpenterParameters
     */
    'default_service_architecture': CpuArchitectureEnum;
    /**
     * 
     * @type {KarpenterNodePool}
     * @memberof ClusterFeatureKarpenterParameters
     */
    'qovery_node_pools': KarpenterNodePool;
}


/**
 * 
 * @export
 * @interface ClusterFeatureKarpenterParametersResponse
 */
export interface ClusterFeatureKarpenterParametersResponse {
    /**
     * 
     * @type {ClusterFeatureResponseTypeEnum}
     * @memberof ClusterFeatureKarpenterParametersResponse
     */
    'type': ClusterFeatureResponseTypeEnum;
    /**
     * 
     * @type {ClusterFeatureKarpenterParameters}
     * @memberof ClusterFeatureKarpenterParametersResponse
     */
    'value': ClusterFeatureKarpenterParameters;
}


/**
 * 
 * @export
 * @interface ClusterFeatureResponse
 */
export interface ClusterFeatureResponse {
    /**
     * 
     * @type {string}
     * @memberof ClusterFeatureResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterFeatureResponse
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterFeatureResponse
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ClusterFeatureResponse
     * @deprecated
     */
    'cost_per_month_in_cents'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ClusterFeatureResponse
     * @deprecated
     */
    'cost_per_month'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ClusterFeatureResponse
     * @deprecated
     */
    'currency_code'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ClusterFeatureResponse
     */
    'is_cloud_provider_paying_feature'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ClusterFeatureResponse
     */
    'cloud_provider_feature_documentation'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ClusterFeatureResponse
     */
    'is_qovery_paying_feature'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ClusterFeatureResponse
     */
    'qovery_feature_documentation'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ClusterFeatureResponse
     */
    'value_type'?: ClusterFeatureResponseValueTypeEnum;
    /**
     * 
     * @type {ClusterFeatureResponseValueObject}
     * @memberof ClusterFeatureResponse
     */
    'value_object'?: ClusterFeatureResponseValueObject | null;
    /**
     * 
     * @type {boolean}
     * @memberof ClusterFeatureResponse
     */
    'is_value_updatable'?: boolean;
    /**
     * 
     * @type {Array<ClusterFeatureResponseAcceptedValuesInner>}
     * @memberof ClusterFeatureResponse
     */
    'accepted_values'?: Array<ClusterFeatureResponseAcceptedValuesInner>;
}

export const ClusterFeatureResponseValueTypeEnum = {
    BOOLEAN: 'BOOLEAN'
} as const;

export type ClusterFeatureResponseValueTypeEnum = typeof ClusterFeatureResponseValueTypeEnum[keyof typeof ClusterFeatureResponseValueTypeEnum];

/**
 * @type ClusterFeatureResponseAcceptedValuesInner
 * @export
 */
export type ClusterFeatureResponseAcceptedValuesInner = boolean | string;

/**
 * 
 * @export
 * @interface ClusterFeatureResponseList
 */
export interface ClusterFeatureResponseList {
    /**
     * 
     * @type {Array<ClusterFeatureResponse>}
     * @memberof ClusterFeatureResponseList
     */
    'results'?: Array<ClusterFeatureResponse>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ClusterFeatureResponseTypeEnum = {
    STRING: 'STRING',
    BOOLEAN: 'BOOLEAN',
    AWS_USER_PROVIDED_NETWORK: 'AWS_USER_PROVIDED_NETWORK',
    GCP_USER_PROVIDED_NETWORK: 'GCP_USER_PROVIDED_NETWORK',
    KARPENTER: 'KARPENTER'
} as const;

export type ClusterFeatureResponseTypeEnum = typeof ClusterFeatureResponseTypeEnum[keyof typeof ClusterFeatureResponseTypeEnum];


/**
 * @type ClusterFeatureResponseValueObject
 * @export
 */
export type ClusterFeatureResponseValueObject = { type: 'AWS_USER_PROVIDED_NETWORK' } & ClusterFeatureAwsExistingVpcResponse | { type: 'BOOLEAN' } & ClusterFeatureBooleanResponse | { type: 'GCP_USER_PROVIDED_NETWORK' } & ClusterFeatureGcpExistingVpcResponse | { type: 'KARPENTER' } & ClusterFeatureKarpenterParametersResponse | { type: 'STRING' } & ClusterFeatureStringResponse;

/**
 * 
 * @export
 * @interface ClusterFeatureStringResponse
 */
export interface ClusterFeatureStringResponse {
    /**
     * 
     * @type {ClusterFeatureResponseTypeEnum}
     * @memberof ClusterFeatureStringResponse
     */
    'type': ClusterFeatureResponseTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ClusterFeatureStringResponse
     */
    'value': string;
}


/**
 * 
 * @export
 * @interface ClusterInfrastructureCertManagerChartParameters
 */
export interface ClusterInfrastructureCertManagerChartParameters {
    /**
     * 
     * @type {string}
     * @memberof ClusterInfrastructureCertManagerChartParameters
     */
    'kubernetes_namespace'?: string;
}
/**
 * 
 * @export
 * @interface ClusterInfrastructureChartsParameters
 */
export interface ClusterInfrastructureChartsParameters {
    /**
     * 
     * @type {ClusterInfrastructureNginxChartParameters}
     * @memberof ClusterInfrastructureChartsParameters
     */
    'nginx_parameters'?: ClusterInfrastructureNginxChartParameters;
    /**
     * 
     * @type {ClusterInfrastructureCertManagerChartParameters}
     * @memberof ClusterInfrastructureChartsParameters
     */
    'cert_manager_parameters'?: ClusterInfrastructureCertManagerChartParameters;
    /**
     * 
     * @type {ClusterInfrastructureMetalLbChartParameters}
     * @memberof ClusterInfrastructureChartsParameters
     */
    'metal_lb_parameters'?: ClusterInfrastructureMetalLbChartParameters;
}
/**
 * 
 * @export
 * @interface ClusterInfrastructureMetalLbChartParameters
 */
export interface ClusterInfrastructureMetalLbChartParameters {
    /**
     * 
     * @type {Array<string>}
     * @memberof ClusterInfrastructureMetalLbChartParameters
     */
    'ip_address_pools'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ClusterInfrastructureNginxChartParameters
 */
export interface ClusterInfrastructureNginxChartParameters {
    /**
     * 
     * @type {number}
     * @memberof ClusterInfrastructureNginxChartParameters
     */
    'replica_count'?: number;
    /**
     * 
     * @type {string}
     * @memberof ClusterInfrastructureNginxChartParameters
     */
    'default_ssl_certificate'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterInfrastructureNginxChartParameters
     */
    'publish_status_address'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterInfrastructureNginxChartParameters
     */
    'annotation_metal_lb_load_balancer_ips'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterInfrastructureNginxChartParameters
     */
    'annotation_external_dns_kubernetes_target'?: string;
}
/**
 * 
 * @export
 * @interface ClusterInstanceAttributes
 */
export interface ClusterInstanceAttributes {
    /**
     * The category of the instance.
     * @type {string}
     * @memberof ClusterInstanceAttributes
     */
    'instance_category'?: string;
    /**
     * The generation of the instance.
     * @type {number}
     * @memberof ClusterInstanceAttributes
     */
    'instance_generation'?: number;
    /**
     * The family or series of the instance.
     * @type {string}
     * @memberof ClusterInstanceAttributes
     */
    'instance_family'?: string;
    /**
     * Specifies the size of the instance within its family.
     * @type {string}
     * @memberof ClusterInstanceAttributes
     */
    'instance_size'?: string;
    /**
     * The instance has sufficient resources to be chosen as a standalone instance in a cluster.
     * @type {boolean}
     * @memberof ClusterInstanceAttributes
     */
    'meets_resource_reqs'?: boolean;
}
/**
 * 
 * @export
 * @interface ClusterInstanceGpuInfo
 */
export interface ClusterInstanceGpuInfo {
    /**
     * The number of GPUs included in the instance.
     * @type {number}
     * @memberof ClusterInstanceGpuInfo
     */
    'count'?: number;
    /**
     * The model name of the GPU.
     * @type {string}
     * @memberof ClusterInstanceGpuInfo
     */
    'name'?: string;
    /**
     * The manufacturer of the GPUs in the instance.
     * @type {string}
     * @memberof ClusterInstanceGpuInfo
     */
    'manufacturer'?: string;
    /**
     * The total GPU memory available.
     * @type {string}
     * @memberof ClusterInstanceGpuInfo
     */
    'memory_in_mib'?: string;
}
/**
 * 
 * @export
 * @interface ClusterInstanceTypeResponseList
 */
export interface ClusterInstanceTypeResponseList {
    /**
     * 
     * @type {Array<ClusterInstanceTypeResponseListResultsInner>}
     * @memberof ClusterInstanceTypeResponseList
     */
    'results'?: Array<ClusterInstanceTypeResponseListResultsInner>;
}
/**
 * 
 * @export
 * @interface ClusterInstanceTypeResponseListResultsInner
 */
export interface ClusterInstanceTypeResponseListResultsInner {
    /**
     * 
     * @type {string}
     * @memberof ClusterInstanceTypeResponseListResultsInner
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof ClusterInstanceTypeResponseListResultsInner
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof ClusterInstanceTypeResponseListResultsInner
     */
    'cpu': number;
    /**
     * 
     * @type {number}
     * @memberof ClusterInstanceTypeResponseListResultsInner
     */
    'ram_in_gb': number;
    /**
     * 
     * @type {string}
     * @memberof ClusterInstanceTypeResponseListResultsInner
     */
    'bandwidth_in_gbps': string;
    /**
     * 
     * @type {string}
     * @memberof ClusterInstanceTypeResponseListResultsInner
     */
    'bandwidth_guarantee': string;
    /**
     * 
     * @type {string}
     * @memberof ClusterInstanceTypeResponseListResultsInner
     */
    'architecture'?: string;
    /**
     * 
     * @type {ClusterInstanceGpuInfo}
     * @memberof ClusterInstanceTypeResponseListResultsInner
     */
    'gpu_info'?: ClusterInstanceGpuInfo;
    /**
     * 
     * @type {ClusterInstanceAttributes}
     * @memberof ClusterInstanceTypeResponseListResultsInner
     */
    'attributes'?: ClusterInstanceAttributes;
}
/**
 * 
 * @export
 * @interface ClusterKarpenterPrivateSubnetIdsPutRequest
 */
export interface ClusterKarpenterPrivateSubnetIdsPutRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof ClusterKarpenterPrivateSubnetIdsPutRequest
     */
    'eks_karpenter_fargate_subnets_zone_a_ids'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClusterKarpenterPrivateSubnetIdsPutRequest
     */
    'eks_karpenter_fargate_subnets_zone_b_ids'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClusterKarpenterPrivateSubnetIdsPutRequest
     */
    'eks_karpenter_fargate_subnets_zone_c_ids'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ClusterKeda
 */
export interface ClusterKeda {
    /**
     * 
     * @type {boolean}
     * @memberof ClusterKeda
     */
    'enabled': boolean;
}
/**
 * 
 * @export
 * @interface ClusterLock
 */
export interface ClusterLock {
    /**
     * 
     * @type {string}
     * @memberof ClusterLock
     */
    'reason': string;
    /**
     * 
     * @type {number}
     * @memberof ClusterLock
     */
    'ttl_in_days'?: number;
    /**
     * 
     * @type {string}
     * @memberof ClusterLock
     */
    'cluster_id': string;
    /**
     * 
     * @type {string}
     * @memberof ClusterLock
     */
    'locked_at': string;
    /**
     * 
     * @type {string}
     * @memberof ClusterLock
     */
    'owner_name': string;
}
/**
 * 
 * @export
 * @interface ClusterLockList
 */
export interface ClusterLockList {
    /**
     * 
     * @type {Array<ClusterLock>}
     * @memberof ClusterLockList
     */
    'results'?: Array<ClusterLock>;
}
/**
 * 
 * @export
 * @interface ClusterLockRequest
 */
export interface ClusterLockRequest {
    /**
     * 
     * @type {string}
     * @memberof ClusterLockRequest
     */
    'reason': string;
    /**
     * 
     * @type {number}
     * @memberof ClusterLockRequest
     */
    'ttl_in_days'?: number;
}
/**
 * 
 * @export
 * @interface ClusterLogs
 */
export interface ClusterLogs {
    /**
     * log level
     * @type {string}
     * @memberof ClusterLogs
     */
    'type'?: string;
    /**
     * log date creation
     * @type {string}
     * @memberof ClusterLogs
     */
    'timestamp'?: string;
    /**
     * log step
     * @type {string}
     * @memberof ClusterLogs
     */
    'step'?: ClusterLogsStepEnum;
    /**
     * 
     * @type {ClusterLogsMessage}
     * @memberof ClusterLogs
     */
    'message'?: ClusterLogsMessage;
    /**
     * 
     * @type {ClusterLogsError}
     * @memberof ClusterLogs
     */
    'error'?: ClusterLogsError;
    /**
     * 
     * @type {ClusterLogsDetails}
     * @memberof ClusterLogs
     */
    'details'?: ClusterLogsDetails;
}

export const ClusterLogsStepEnum = {
    LOAD_CONFIGURATION: 'LoadConfiguration',
    CREATE: 'Create',
    CREATED: 'Created',
    CREATE_ERROR: 'CreateError',
    PAUSE: 'Pause',
    PAUSED: 'Paused',
    PAUSE_ERROR: 'PauseError',
    DELETE: 'Delete',
    DELETED: 'Deleted',
    DELETE_ERROR: 'DeleteError',
    RETRIEVE_CLUSTER_CONFIG: 'RetrieveClusterConfig',
    RETRIEVE_CLUSTER_RESOURCES: 'RetrieveClusterResources',
    VALIDATE_SYSTEM_REQUIREMENTS: 'ValidateSystemRequirements',
    UNDER_MIGRATION: 'UnderMigration',
    UNKNOWN: 'Unknown'
} as const;

export type ClusterLogsStepEnum = typeof ClusterLogsStepEnum[keyof typeof ClusterLogsStepEnum];

/**
 * Present only for `info`, `warning` and `debug` logs
 * @export
 * @interface ClusterLogsDetails
 */
export interface ClusterLogsDetails {
    /**
     * cloud provider used
     * @type {string}
     * @memberof ClusterLogsDetails
     */
    'provider_kind'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterLogsDetails
     */
    'region'?: string;
    /**
     * 
     * @type {ClusterLogsErrorEventDetailsTransmitter}
     * @memberof ClusterLogsDetails
     */
    'transmitter'?: ClusterLogsErrorEventDetailsTransmitter;
}
/**
 * Present only for `error` log
 * @export
 * @interface ClusterLogsError
 */
export interface ClusterLogsError {
    /**
     * log error tag
     * @type {string}
     * @memberof ClusterLogsError
     */
    'tag'?: string;
    /**
     * log details about the error
     * @type {string}
     * @memberof ClusterLogsError
     */
    'user_log_message'?: string;
    /**
     * link to our documentation
     * @type {string}
     * @memberof ClusterLogsError
     */
    'link'?: string;
    /**
     * hint the user can follow
     * @type {string}
     * @memberof ClusterLogsError
     */
    'hint_message'?: string;
    /**
     * 
     * @type {ClusterLogsErrorEventDetails}
     * @memberof ClusterLogsError
     */
    'event_details'?: ClusterLogsErrorEventDetails;
    /**
     * 
     * @type {ClusterLogsErrorUnderlyingError}
     * @memberof ClusterLogsError
     */
    'underlying_error'?: ClusterLogsErrorUnderlyingError;
}
/**
 * 
 * @export
 * @interface ClusterLogsErrorEventDetails
 */
export interface ClusterLogsErrorEventDetails {
    /**
     * cloud provider used
     * @type {string}
     * @memberof ClusterLogsErrorEventDetails
     */
    'provider_kind'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterLogsErrorEventDetails
     */
    'region'?: string;
    /**
     * 
     * @type {ClusterLogsErrorEventDetailsTransmitter}
     * @memberof ClusterLogsErrorEventDetails
     */
    'transmitter'?: ClusterLogsErrorEventDetailsTransmitter;
}
/**
 * 
 * @export
 * @interface ClusterLogsErrorEventDetailsTransmitter
 */
export interface ClusterLogsErrorEventDetailsTransmitter {
    /**
     * 
     * @type {string}
     * @memberof ClusterLogsErrorEventDetailsTransmitter
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterLogsErrorEventDetailsTransmitter
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterLogsErrorEventDetailsTransmitter
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface ClusterLogsErrorUnderlyingError
 */
export interface ClusterLogsErrorUnderlyingError {
    /**
     * technical details about the error
     * @type {string}
     * @memberof ClusterLogsErrorUnderlyingError
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ClusterLogsMessage
 */
export interface ClusterLogsMessage {
    /**
     * log global message
     * @type {string}
     * @memberof ClusterLogsMessage
     */
    'safe_message'?: string;
}
/**
 * 
 * @export
 * @interface ClusterLogsResponse
 */
export interface ClusterLogsResponse {
    /**
     * 
     * @type {string}
     * @memberof ClusterLogsResponse
     */
    'response'?: string;
}
/**
 * 
 * @export
 * @interface ClusterLogsResponseList
 */
export interface ClusterLogsResponseList {
    /**
     * 
     * @type {Array<ClusterLogs>}
     * @memberof ClusterLogsResponseList
     */
    'results'?: Array<ClusterLogs>;
}
/**
 * 
 * @export
 * @interface ClusterMetricsResponse
 */
export interface ClusterMetricsResponse {
    /**
     * 
     * @type {string}
     * @memberof ClusterMetricsResponse
     */
    'metrics'?: string;
}
/**
 * 
 * @export
 * @interface ClusterReadinessStatus
 */
export interface ClusterReadinessStatus {
    /**
     * 
     * @type {boolean}
     * @memberof ClusterReadinessStatus
     */
    'is_ready'?: boolean;
}
/**
 * 
 * @export
 * @interface ClusterRegion
 */
export interface ClusterRegion {
    /**
     * 
     * @type {string}
     * @memberof ClusterRegion
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ClusterRegion
     */
    'country_code': string;
    /**
     * 
     * @type {string}
     * @memberof ClusterRegion
     */
    'country': string;
    /**
     * 
     * @type {string}
     * @memberof ClusterRegion
     */
    'city': string;
}
/**
 * 
 * @export
 * @interface ClusterRegionResponseList
 */
export interface ClusterRegionResponseList {
    /**
     * 
     * @type {Array<ClusterRegion>}
     * @memberof ClusterRegionResponseList
     */
    'results'?: Array<ClusterRegion>;
}
/**
 * 
 * @export
 * @interface ClusterRequest
 */
export interface ClusterRequest {
    /**
     * name is case-insensitive
     * @type {string}
     * @memberof ClusterRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ClusterRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterRequest
     */
    'region': string;
    /**
     * 
     * @type {CloudVendorEnum}
     * @memberof ClusterRequest
     */
    'cloud_provider': CloudVendorEnum;
    /**
     * 
     * @type {ClusterCloudProviderInfoRequest}
     * @memberof ClusterRequest
     */
    'cloud_provider_credentials'?: ClusterCloudProviderInfoRequest;
    /**
     * 
     * @type {number}
     * @memberof ClusterRequest
     */
    'min_running_nodes'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterRequest
     */
    'max_running_nodes'?: number;
    /**
     * Unit is in GB. The disk size to be used for the node configuration
     * @type {number}
     * @memberof ClusterRequest
     */
    'disk_size'?: number;
    /**
     * the instance type to be used for this cluster. The list of values can be retrieved via the endpoint /{CloudProvider}/instanceType
     * @type {string}
     * @memberof ClusterRequest
     */
    'instance_type'?: string;
    /**
     * 
     * @type {KubernetesEnum}
     * @memberof ClusterRequest
     */
    'kubernetes'?: KubernetesEnum;
    /**
     * specific flag to indicate that this cluster is a production one
     * @type {boolean}
     * @memberof ClusterRequest
     */
    'production'?: boolean;
    /**
     * Indicate your public ssh_key to remotely connect to your EC2 instance.
     * @type {Array<string>}
     * @memberof ClusterRequest
     */
    'ssh_keys'?: Array<string>;
    /**
     * 
     * @type {Array<ClusterRequestFeaturesInner>}
     * @memberof ClusterRequest
     */
    'features'?: Array<ClusterRequestFeaturesInner>;
    /**
     * 
     * @type {MetricsParameters}
     * @memberof ClusterRequest
     */
    'metrics_parameters'?: MetricsParameters;
    /**
     * 
     * @type {ClusterInfrastructureChartsParameters}
     * @memberof ClusterRequest
     */
    'infrastructure_charts_parameters'?: ClusterInfrastructureChartsParameters;
    /**
     * 
     * @type {ClusterKeda}
     * @memberof ClusterRequest
     */
    'keda'?: ClusterKeda;
}


/**
 * 
 * @export
 * @interface ClusterRequestFeaturesInner
 */
export interface ClusterRequestFeaturesInner {
    /**
     * 
     * @type {string}
     * @memberof ClusterRequestFeaturesInner
     */
    'id'?: string;
    /**
     * 
     * @type {ClusterRequestFeaturesInnerValue}
     * @memberof ClusterRequestFeaturesInner
     */
    'value'?: ClusterRequestFeaturesInnerValue | null;
}
/**
 * @type ClusterRequestFeaturesInnerValue
 * @export
 */
export type ClusterRequestFeaturesInnerValue = ClusterFeatureAwsExistingVpc | ClusterFeatureGcpExistingVpc | ClusterFeatureKarpenterParameters | boolean | string;

/**
 * 
 * @export
 * @interface ClusterResponseList
 */
export interface ClusterResponseList {
    /**
     * 
     * @type {Array<Cluster>}
     * @memberof ClusterResponseList
     */
    'results'?: Array<Cluster>;
}
/**
 * 
 * @export
 * @interface ClusterRoutingTable
 */
export interface ClusterRoutingTable {
    /**
     * 
     * @type {Array<ClusterRoutingTableResultsInner>}
     * @memberof ClusterRoutingTable
     */
    'results'?: Array<ClusterRoutingTableResultsInner>;
}
/**
 * 
 * @export
 * @interface ClusterRoutingTableRequest
 */
export interface ClusterRoutingTableRequest {
    /**
     * 
     * @type {Array<ClusterRoutingTableResultsInner>}
     * @memberof ClusterRoutingTableRequest
     */
    'routes': Array<ClusterRoutingTableResultsInner>;
}
/**
 * 
 * @export
 * @interface ClusterRoutingTableResultsInner
 */
export interface ClusterRoutingTableResultsInner {
    /**
     * 
     * @type {string}
     * @memberof ClusterRoutingTableResultsInner
     */
    'destination': string;
    /**
     * 
     * @type {string}
     * @memberof ClusterRoutingTableResultsInner
     */
    'target': string;
    /**
     * 
     * @type {string}
     * @memberof ClusterRoutingTableResultsInner
     */
    'description': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ClusterStateEnum = {
    BUILDING: 'BUILDING',
    BUILD_ERROR: 'BUILD_ERROR',
    CANCELED: 'CANCELED',
    CANCELING: 'CANCELING',
    DELETED: 'DELETED',
    DELETE_ERROR: 'DELETE_ERROR',
    DELETE_QUEUED: 'DELETE_QUEUED',
    DELETING: 'DELETING',
    DEPLOYED: 'DEPLOYED',
    DEPLOYING: 'DEPLOYING',
    DEPLOYMENT_ERROR: 'DEPLOYMENT_ERROR',
    DEPLOYMENT_QUEUED: 'DEPLOYMENT_QUEUED',
    DRY_RUN: 'DRY_RUN',
    QUEUED: 'QUEUED',
    READY: 'READY',
    STOPPED: 'STOPPED',
    STOPPING: 'STOPPING',
    STOP_ERROR: 'STOP_ERROR',
    STOP_QUEUED: 'STOP_QUEUED',
    RESTART_QUEUED: 'RESTART_QUEUED',
    RESTARTING: 'RESTARTING',
    RESTARTED: 'RESTARTED',
    RESTART_ERROR: 'RESTART_ERROR',
    INVALID_CREDENTIALS: 'INVALID_CREDENTIALS'
} as const;

export type ClusterStateEnum = typeof ClusterStateEnum[keyof typeof ClusterStateEnum];


/**
 * 
 * @export
 * @interface ClusterStatus
 */
export interface ClusterStatus {
    /**
     * 
     * @type {string}
     * @memberof ClusterStatus
     */
    'cluster_id'?: string;
    /**
     * 
     * @type {ClusterStateEnum}
     * @memberof ClusterStatus
     */
    'status'?: ClusterStateEnum;
    /**
     * 
     * @type {boolean}
     * @memberof ClusterStatus
     */
    'is_deployed'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ClusterStatus
     */
    'next_k8s_available_version'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ClusterStatus
     */
    'last_execution_id'?: string;
    /**
     * 
     * @type {ClusterLock}
     * @memberof ClusterStatus
     */
    'cluster_lock'?: ClusterLock;
    /**
     * 
     * @type {string}
     * @memberof ClusterStatus
     */
    'last_deployment_date'?: string;
}


/**
 * 
 * @export
 * @interface ClusterStatusResponseList
 */
export interface ClusterStatusResponseList {
    /**
     * 
     * @type {Array<ClusterStatus>}
     * @memberof ClusterStatusResponseList
     */
    'results'?: Array<ClusterStatus>;
}
/**
 * 
 * @export
 * @interface Commit
 */
export interface Commit {
    /**
     * 
     * @type {string}
     * @memberof Commit
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Commit
     */
    'git_commit_id': string;
    /**
     * 
     * @type {string}
     * @memberof Commit
     */
    'tag': string;
    /**
     * 
     * @type {string}
     * @memberof Commit
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof Commit
     */
    'author_name': string;
    /**
     * 
     * @type {string}
     * @memberof Commit
     */
    'author_avatar_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof Commit
     */
    'commit_page_url'?: string;
}
/**
 * 
 * @export
 * @interface CommitResponseList
 */
export interface CommitResponseList {
    /**
     * 
     * @type {Array<Commit>}
     * @memberof CommitResponseList
     */
    'results'?: Array<Commit>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CompanySizeEnum = {
    _1_10: '1-10',
    _11_50: '11-50',
    _51_200: '51-200',
    _201_500: '201-500',
    _500: '500+'
} as const;

export type CompanySizeEnum = typeof CompanySizeEnum[keyof typeof CompanySizeEnum];


/**
 * 
 * @export
 * @interface ContainerAdvancedSettings
 */
export interface ContainerAdvancedSettings {
    /**
     * disable custom domain check when deploying an application
     * @type {boolean}
     * @memberof ContainerAdvancedSettings
     */
    'deployment.custom_domain_check_enabled'?: boolean;
    /**
     * define how long in seconds an application is supposed to be stopped gracefully
     * @type {number}
     * @memberof ContainerAdvancedSettings
     */
    'deployment.termination_grace_period_seconds'?: number;
    /**
     * Set pod placement on specific Kubernetes nodes labels
     * @type {{ [key: string]: string; }}
     * @memberof ContainerAdvancedSettings
     */
    'deployment.affinity.node.required'?: { [key: string]: string; };
    /**
     * Define how you want pods affinity to behave: * `Preferred` allows, but does not require, pods of a given service are not co-located (or co-hosted) on a single node * `Requirred` ensures that the pods of a given service are not co-located (or co-hosted) on a single node (safer in term of availability but can be expensive depending on the number of replicas) 
     * @type {string}
     * @memberof ContainerAdvancedSettings
     */
    'deployment.antiaffinity.pod'?: ContainerAdvancedSettingsDeploymentAntiaffinityPodEnum;
    /**
     * * `RollingUpdate` gracefully rollout new versions, and automatically rollback if the new version fails to start * `Recreate` stop all current versions and create new ones once all old ones have been shutdown 
     * @type {string}
     * @memberof ContainerAdvancedSettings
     */
    'deployment.update_strategy.type'?: ContainerAdvancedSettingsDeploymentUpdateStrategyTypeEnum;
    /**
     * Define the percentage of a maximum number of pods that can be unavailable during the update process
     * @type {number}
     * @memberof ContainerAdvancedSettings
     */
    'deployment.update_strategy.rolling_update.max_unavailable_percent'?: number;
    /**
     * Define the percentage of the maximum number of pods that can be created over the desired number of pods
     * @type {number}
     * @memberof ContainerAdvancedSettings
     */
    'deployment.update_strategy.rolling_update.max_surge_percent'?: number;
    /**
     * 
     * @type {number}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.proxy_body_size_mb'?: number;
    /**
     * When using SSL offloading outside of cluster, you can enforce a redirect to HTTPS even when there is no TLS certificate available
     * @type {boolean}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.force_ssl_redirect'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.enable_cors'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.cors_allow_origin'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.cors_allow_methods'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.cors_allow_headers'?: string;
    /**
     * header buffer size used while reading response header from upstream
     * @type {number}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.proxy_buffer_size_kb'?: number;
    /**
     * Limits the maximum time (in seconds) during which requests can be processed through one keepalive connection
     * @type {number}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.keepalive_time_seconds'?: number;
    /**
     * Sets a timeout (in seconds) during which an idle keepalive connection to an upstream server will stay open.
     * @type {number}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.keepalive_timeout_seconds'?: number;
    /**
     * Sets a timeout (in seconds) for transmitting a response to the client
     * @type {number}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.send_timeout_seconds'?: number;
    /**
     * Sets a timeout (in seconds) for establishing a connection to a proxied server
     * @type {number}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.proxy_connect_timeout_seconds'?: number;
    /**
     * Sets a timeout (in seconds) for transmitting a request to the proxied server
     * @type {number}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.proxy_send_timeout_seconds'?: number;
    /**
     * Sets a timeout (in seconds) for reading a response from the proxied server
     * @type {number}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.proxy_read_timeout_seconds'?: number;
    /**
     * Allows to enable or disable nginx `proxy-buffering`
     * @type {string}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.proxy_buffering'?: string;
    /**
     * Allows to enable or disable nginx `proxy-request-buffering`
     * @type {string}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.proxy_request_buffering'?: string;
    /**
     * Sets a timeout (in seconds) for transmitting a request to the grpc server
     * @type {number}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.grpc_send_timeout_seconds'?: number;
    /**
     * Sets a timeout (in seconds) for transmitting a request to the grpc server
     * @type {number}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.grpc_read_timeout_seconds'?: number;
    /**
     * list of source ranges to allow access to ingress proxy.  This property can be used to whitelist source IP ranges for ingress proxy. The value is a comma separated list of CIDRs, e.g. 10.0.0.0/24,172.10.0.1 To allow all source ranges, set 0.0.0.0/0. 
     * @type {string}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.whitelist_source_range'?: string;
    /**
     * list of source ranges to deny access to ingress proxy.  This property can be used to blacklist source IP ranges for ingress proxy. The value is a comma separated list of CIDRs, e.g. 10.0.0.0/24,172.10.0.1 
     * @type {string}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.denylist_source_range'?: string;
    /**
     * Allows to define response headers
     * @type {string}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.extra_headers'?: string;
    /**
     * Set the name of an environment variable to use as a basic authentication (`login:crypted_password`) from `htpasswd` command. You can add multiples comma separated values. 
     * @type {string}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.basic_auth_env_var'?: string;
    /**
     * Enable the load balancer to bind a user\'s session to a specific target. This ensures that all requests from the user during the session are sent to the same target 
     * @type {boolean}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.enable_sticky_session'?: boolean;
    /**
     * Allows you to set an existing Kubernetes service account name 
     * @type {string}
     * @memberof ContainerAdvancedSettings
     */
    'security.service_account_name'?: string;
    /**
     * Percentage value of cpu usage at which point pods should scale up.
     * @type {number}
     * @memberof ContainerAdvancedSettings
     */
    'hpa.cpu.average_utilization_percent'?: number;
    /**
     * Automount Kubernetes service account token to have access to Kubernetes API from pods 
     * @type {boolean}
     * @memberof ContainerAdvancedSettings
     */
    'security.automount_service_account_token'?: boolean;
    /**
     * Mounts the container\'s root filesystem as read-only 
     * @type {boolean}
     * @memberof ContainerAdvancedSettings
     */
    'security.read_only_root_filesystem'?: boolean;
}

export const ContainerAdvancedSettingsDeploymentAntiaffinityPodEnum = {
    PREFERRED: 'Preferred',
    REQUIRRED: 'Requirred'
} as const;

export type ContainerAdvancedSettingsDeploymentAntiaffinityPodEnum = typeof ContainerAdvancedSettingsDeploymentAntiaffinityPodEnum[keyof typeof ContainerAdvancedSettingsDeploymentAntiaffinityPodEnum];
export const ContainerAdvancedSettingsDeploymentUpdateStrategyTypeEnum = {
    ROLLING_UPDATE: 'RollingUpdate',
    RECREATE: 'Recreate'
} as const;

export type ContainerAdvancedSettingsDeploymentUpdateStrategyTypeEnum = typeof ContainerAdvancedSettingsDeploymentUpdateStrategyTypeEnum[keyof typeof ContainerAdvancedSettingsDeploymentUpdateStrategyTypeEnum];

/**
 * 
 * @export
 * @interface ContainerDeployRequest
 */
export interface ContainerDeployRequest {
    /**
     * Image tag to deploy
     * @type {string}
     * @memberof ContainerDeployRequest
     */
    'image_tag': string;
}
/**
 * 
 * @export
 * @interface ContainerImageCheckRequest
 */
export interface ContainerImageCheckRequest {
    /**
     * 
     * @type {string}
     * @memberof ContainerImageCheckRequest
     */
    'registry_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerImageCheckRequest
     */
    'image_name': string;
    /**
     * 
     * @type {string}
     * @memberof ContainerImageCheckRequest
     */
    'tag': string;
}
/**
 * 
 * @export
 * @interface ContainerNetwork
 */
export interface ContainerNetwork {
    /**
     * Specify if the sticky session option (also called persistant session) is activated or not for this container. If activated, user will be redirected by the load balancer to the same instance each time he access to the container. 
     * @type {boolean}
     * @memberof ContainerNetwork
     */
    'sticky_session'?: boolean;
}
/**
 * 
 * @export
 * @interface ContainerNetworkRequest
 */
export interface ContainerNetworkRequest {
    /**
     * Specify if the sticky session option (also called persistant session) is activated or not for this container. If activated, user will be redirected by the load balancer to the same instance each time he access to the container. 
     * @type {boolean}
     * @memberof ContainerNetworkRequest
     */
    'sticky_session'?: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ContainerRegistryAssociatedServiceType = {
    CONTAINER: 'CONTAINER',
    LIFECYCLE: 'LIFECYCLE',
    CRON: 'CRON'
} as const;

export type ContainerRegistryAssociatedServiceType = typeof ContainerRegistryAssociatedServiceType[keyof typeof ContainerRegistryAssociatedServiceType];


/**
 * 
 * @export
 * @interface ContainerRegistryAssociatedServicesResponse
 */
export interface ContainerRegistryAssociatedServicesResponse {
    /**
     * 
     * @type {string}
     * @memberof ContainerRegistryAssociatedServicesResponse
     */
    'project_id': string;
    /**
     * 
     * @type {string}
     * @memberof ContainerRegistryAssociatedServicesResponse
     */
    'project_name': string;
    /**
     * 
     * @type {string}
     * @memberof ContainerRegistryAssociatedServicesResponse
     */
    'environment_id': string;
    /**
     * 
     * @type {string}
     * @memberof ContainerRegistryAssociatedServicesResponse
     */
    'environment_name': string;
    /**
     * 
     * @type {string}
     * @memberof ContainerRegistryAssociatedServicesResponse
     */
    'service_id': string;
    /**
     * 
     * @type {string}
     * @memberof ContainerRegistryAssociatedServicesResponse
     */
    'service_name': string;
    /**
     * 
     * @type {ContainerRegistryAssociatedServiceType}
     * @memberof ContainerRegistryAssociatedServicesResponse
     */
    'service_type': ContainerRegistryAssociatedServiceType;
}


/**
 * 
 * @export
 * @interface ContainerRegistryAssociatedServicesResponseList
 */
export interface ContainerRegistryAssociatedServicesResponseList {
    /**
     * 
     * @type {Array<ContainerRegistryAssociatedServicesResponse>}
     * @memberof ContainerRegistryAssociatedServicesResponseList
     */
    'results'?: Array<ContainerRegistryAssociatedServicesResponse>;
}
/**
 * The type of your container registry
 * @export
 * @enum {string}
 */

export const ContainerRegistryKindEnum = {
    ECR: 'ECR',
    SCALEWAY_CR: 'SCALEWAY_CR',
    DOCKER_HUB: 'DOCKER_HUB',
    GITHUB_CR: 'GITHUB_CR',
    GITHUB_ENTERPRISE_CR: 'GITHUB_ENTERPRISE_CR',
    GITLAB_CR: 'GITLAB_CR',
    PUBLIC_ECR: 'PUBLIC_ECR',
    DOCR: 'DOCR',
    GENERIC_CR: 'GENERIC_CR',
    GCP_ARTIFACT_REGISTRY: 'GCP_ARTIFACT_REGISTRY',
    AZURE_CR: 'AZURE_CR'
} as const;

export type ContainerRegistryKindEnum = typeof ContainerRegistryKindEnum[keyof typeof ContainerRegistryKindEnum];


/**
 * 
 * @export
 * @interface ContainerRegistryProviderDetailsResponse
 */
export interface ContainerRegistryProviderDetailsResponse {
    /**
     * 
     * @type {string}
     * @memberof ContainerRegistryProviderDetailsResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ContainerRegistryProviderDetailsResponse
     */
    'name': string;
    /**
     * URL of the container registry
     * @type {string}
     * @memberof ContainerRegistryProviderDetailsResponse
     */
    'url': string;
    /**
     * 
     * @type {ContainerRegistryKindEnum}
     * @memberof ContainerRegistryProviderDetailsResponse
     */
    'kind': ContainerRegistryKindEnum;
}


/**
 * 
 * @export
 * @interface ContainerRegistryRequest
 */
export interface ContainerRegistryRequest {
    /**
     * 
     * @type {string}
     * @memberof ContainerRegistryRequest
     */
    'name': string;
    /**
     * 
     * @type {ContainerRegistryKindEnum}
     * @memberof ContainerRegistryRequest
     */
    'kind': ContainerRegistryKindEnum;
    /**
     * 
     * @type {string}
     * @memberof ContainerRegistryRequest
     */
    'description'?: string;
    /**
     * URL of the container registry: * For `DOCKER_HUB`: it must be `https://docker.io` (default with \'https://docker.io\' if no url provided for `DOCKER_HUB`) * For `GITHUB_CR`: it must be `https://ghcr.io` (default with \'https://ghcr.io\' if no url provided for `GITHUB_CR`) * For `GITLAB_CR`: it must be `https://registry.gitlab.com` (default with \'https://registry.gitlab.com\' if no url provided for `GITLAB_CR`) * For others: it\'s required and must start by `https://` 
     * @type {string}
     * @memberof ContainerRegistryRequest
     */
    'url'?: string;
    /**
     * 
     * @type {ContainerRegistryRequestConfig}
     * @memberof ContainerRegistryRequest
     */
    'config': ContainerRegistryRequestConfig;
}


/**
 * This field is dependent of the container registry kind: * `ECR` needs in the config: region, access_key_id, secret_access_key * `SCALEWAY_CR` needs in the config: region, scaleway_access_key, scaleway_secret_key * `GCP_ARTIFACT_REGISTRY` needs in the config: region, json_credentials * `DOCKER_HUB` needs in the config (optional): username, password * `GITHUB_CR` needs in the config (optional): username, password * `GITLAB_CR` needs in the config (optional): username, password * `PUBLIC_ECR` doesn\'t need credentials info * `GENERIC_CR` needs in the config (optional): username, password * `DOCR` is not supported anymore 
 * @export
 * @interface ContainerRegistryRequestConfig
 */
export interface ContainerRegistryRequestConfig {
    /**
     * Required if kind is `ECR` or `PUBLIC_ECR`
     * @type {string}
     * @memberof ContainerRegistryRequestConfig
     */
    'access_key_id'?: string;
    /**
     * Required if kind is `ECR` or `PUBLIC_ECR`
     * @type {string}
     * @memberof ContainerRegistryRequestConfig
     */
    'secret_access_key'?: string;
    /**
     * Required if kind is `ECR` or `SCALEWAY_CR`
     * @type {string}
     * @memberof ContainerRegistryRequestConfig
     */
    'region'?: string;
    /**
     * Required if kind is `SCALEWAY_CR`
     * @type {string}
     * @memberof ContainerRegistryRequestConfig
     */
    'scaleway_access_key'?: string;
    /**
     * Required if kind is `SCALEWAY_CR`
     * @type {string}
     * @memberof ContainerRegistryRequestConfig
     */
    'scaleway_secret_key'?: string;
    /**
     * Required if kind is `SCALEWAY_CR`
     * @type {string}
     * @memberof ContainerRegistryRequestConfig
     */
    'scaleway_project_id'?: string;
    /**
     * Required if kind is `GCP_ARTIFACT_REGISTRY`
     * @type {string}
     * @memberof ContainerRegistryRequestConfig
     */
    'json_credentials'?: string;
    /**
     * optional, for kind `DOCKER_HUB`   We encourage you to set credentials for Docker Hub due to the limits on the pull rate 
     * @type {string}
     * @memberof ContainerRegistryRequestConfig
     */
    'username'?: string;
    /**
     * optional, for kind `DOCKER_HUB`   We encourage you to set credentials for Docker Hub due to the limits on the pull rate 
     * @type {string}
     * @memberof ContainerRegistryRequestConfig
     */
    'password'?: string;
    /**
     * For ECR, you can either set a static access_key or use a role arn that we are going to assume
     * @type {string}
     * @memberof ContainerRegistryRequestConfig
     */
    'role_arn'?: string;
    /**
     * Required if kind is `AZURE_CR`.
     * @type {string}
     * @memberof ContainerRegistryRequestConfig
     */
    'azure_tenant_id'?: string;
    /**
     * Required if kind is `AZURE_CR`.
     * @type {string}
     * @memberof ContainerRegistryRequestConfig
     */
    'azure_subscription_id'?: string;
}
/**
 * 
 * @export
 * @interface ContainerRegistryResponse
 */
export interface ContainerRegistryResponse {
    /**
     * 
     * @type {string}
     * @memberof ContainerRegistryResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ContainerRegistryResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ContainerRegistryResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerRegistryResponse
     */
    'name'?: string;
    /**
     * 
     * @type {ContainerRegistryKindEnum}
     * @memberof ContainerRegistryResponse
     */
    'kind'?: ContainerRegistryKindEnum;
    /**
     * 
     * @type {string}
     * @memberof ContainerRegistryResponse
     */
    'description'?: string;
    /**
     * URL of the container registry
     * @type {string}
     * @memberof ContainerRegistryResponse
     */
    'url'?: string;
    /**
     * 
     * @type {ContainerRegistryResponseAllOfCluster}
     * @memberof ContainerRegistryResponse
     */
    'cluster'?: ContainerRegistryResponseAllOfCluster;
    /**
     * The number of services using this container registry
     * @type {number}
     * @memberof ContainerRegistryResponse
     */
    'associated_services_count'?: number;
    /**
     * 
     * @type {ContainerRegistryResponseAllOfConfig}
     * @memberof ContainerRegistryResponse
     */
    'config'?: ContainerRegistryResponseAllOfConfig;
}


/**
 * 
 * @export
 * @interface ContainerRegistryResponseAllOfCluster
 */
export interface ContainerRegistryResponseAllOfCluster {
    /**
     * 
     * @type {string}
     * @memberof ContainerRegistryResponseAllOfCluster
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ContainerRegistryResponseAllOfCluster
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ContainerRegistryResponseAllOfConfig
 */
export interface ContainerRegistryResponseAllOfConfig {
    /**
     * 
     * @type {string}
     * @memberof ContainerRegistryResponseAllOfConfig
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerRegistryResponseAllOfConfig
     */
    'region'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerRegistryResponseAllOfConfig
     */
    'scaleway_access_key'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerRegistryResponseAllOfConfig
     */
    'scaleway_project_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerRegistryResponseAllOfConfig
     */
    'access_key_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerRegistryResponseAllOfConfig
     */
    'role_arn'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerRegistryResponseAllOfConfig
     */
    'azure_tenant_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerRegistryResponseAllOfConfig
     */
    'azure_subscription_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerRegistryResponseAllOfConfig
     */
    'azure_application_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerRegistryResponseAllOfConfig
     */
    'azure_application_object_id'?: string;
}
/**
 * 
 * @export
 * @interface ContainerRegistryResponseList
 */
export interface ContainerRegistryResponseList {
    /**
     * 
     * @type {Array<ContainerRegistryResponse>}
     * @memberof ContainerRegistryResponseList
     */
    'results'?: Array<ContainerRegistryResponse>;
}
/**
 * 
 * @export
 * @interface ContainerRequest
 */
export interface ContainerRequest {
    /**
     * 
     * @type {Array<ServiceStorageRequestStorageInner>}
     * @memberof ContainerRequest
     */
    'storage'?: Array<ServiceStorageRequestStorageInner>;
    /**
     * 
     * @type {Array<ServicePortRequestPortsInner>}
     * @memberof ContainerRequest
     */
    'ports'?: Array<ServicePortRequestPortsInner>;
    /**
     * name is case insensitive
     * @type {string}
     * @memberof ContainerRequest
     */
    'name': string;
    /**
     * give a description to this container
     * @type {string}
     * @memberof ContainerRequest
     */
    'description'?: string;
    /**
     * id of the linked registry
     * @type {string}
     * @memberof ContainerRequest
     */
    'registry_id': string;
    /**
     * The image name pattern differs according to chosen container registry provider:   * `ECR`: `repository` * `SCALEWAY_CR`: `namespace/image` * `DOCKER_HUB`: `image` or `repository/image` * `PUBLIC_ECR`: `registry_alias/repository` 
     * @type {string}
     * @memberof ContainerRequest
     */
    'image_name': string;
    /**
     * tag of the image container
     * @type {string}
     * @memberof ContainerRequest
     */
    'tag': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ContainerRequest
     */
    'arguments'?: Array<string>;
    /**
     * optional entrypoint when launching container
     * @type {string}
     * @memberof ContainerRequest
     */
    'entrypoint'?: string;
    /**
     * unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof ContainerRequest
     */
    'cpu'?: number;
    /**
     * unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof ContainerRequest
     */
    'memory'?: number;
    /**
     * 
     * @type {number}
     * @memberof ContainerRequest
     */
    'gpu'?: number;
    /**
     * Minimum number of instances running. This resource auto-scale based on the CPU and Memory consumption. Note: 0 means that there is no container running. 
     * @type {number}
     * @memberof ContainerRequest
     */
    'min_running_instances'?: number;
    /**
     * Maximum number of instances running. This resource auto-scale based on the CPU and Memory consumption. Note: -1 means that there is no limit. 
     * @type {number}
     * @memberof ContainerRequest
     */
    'max_running_instances'?: number;
    /**
     * 
     * @type {Healthcheck}
     * @memberof ContainerRequest
     */
    'healthchecks': Healthcheck;
    /**
     * Indicates if the \'environment preview option\' is enabled for this container.   If enabled, a preview environment will be automatically cloned when `/preview` endpoint is called.   If not specified, it takes the value of the `auto_preview` property from the associated environment. 
     * @type {boolean}
     * @memberof ContainerRequest
     */
    'auto_preview'?: boolean;
    /**
     * Specify if the container will be automatically updated after receiving a new image tag.  The new image tag shall be communicated via the \"Auto Deploy container\" endpoint https://api-doc.qovery.com/#tag/Containers/operation/autoDeployContainerEnvironments 
     * @type {boolean}
     * @memberof ContainerRequest
     */
    'auto_deploy'?: boolean | null;
    /**
     * 
     * @type {Array<ServiceAnnotationRequest>}
     * @memberof ContainerRequest
     */
    'annotations_groups'?: Array<ServiceAnnotationRequest>;
    /**
     * 
     * @type {Array<ServiceLabelRequest>}
     * @memberof ContainerRequest
     */
    'labels_groups'?: Array<ServiceLabelRequest>;
    /**
     * Icon URI representing the container.
     * @type {string}
     * @memberof ContainerRequest
     */
    'icon_uri'?: string;
    /**
     * 
     * @type {AutoscalingPolicyRequest}
     * @memberof ContainerRequest
     */
    'autoscaling'?: AutoscalingPolicyRequest;
}
/**
 * 
 * @export
 * @interface ContainerResponse
 */
export interface ContainerResponse {
    /**
     * 
     * @type {string}
     * @memberof ContainerResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ContainerResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ContainerResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {Array<ServiceStorageStorageInner>}
     * @memberof ContainerResponse
     */
    'storage'?: Array<ServiceStorageStorageInner>;
    /**
     * The image name pattern differs according to chosen container registry provider: * `ECR`: `repository` * `SCALEWAY_CR`: `namespace/image` * `DOCKER_HUB`: `image` or `repository/image` * `PUBLIC_ECR`: `registry_alias/repository` 
     * @type {string}
     * @memberof ContainerResponse
     */
    'image_name': string;
    /**
     * tag of the image container
     * @type {string}
     * @memberof ContainerResponse
     */
    'tag': string;
    /**
     * tag of the image container
     * @type {string}
     * @memberof ContainerResponse
     */
    'registry_id'?: string;
    /**
     * 
     * @type {ContainerRegistryProviderDetailsResponse}
     * @memberof ContainerResponse
     */
    'registry': ContainerRegistryProviderDetailsResponse;
    /**
     * 
     * @type {ReferenceObject}
     * @memberof ContainerResponse
     */
    'environment': ReferenceObject;
    /**
     * Maximum cpu that can be allocated to the container based on organization cluster configuration. unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof ContainerResponse
     */
    'maximum_cpu': number;
    /**
     * Maximum memory that can be allocated to the container based on organization cluster configuration. unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof ContainerResponse
     */
    'maximum_memory': number;
    /**
     * Maximum memory that can be allocated to the container based on organization cluster configuration. unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof ContainerResponse
     */
    'maximum_gpu': number;
    /**
     * name is case insensitive
     * @type {string}
     * @memberof ContainerResponse
     */
    'name': string;
    /**
     * give a description to this container
     * @type {string}
     * @memberof ContainerResponse
     */
    'description'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ContainerResponse
     */
    'arguments'?: Array<string>;
    /**
     * optional entrypoint when launching container
     * @type {string}
     * @memberof ContainerResponse
     */
    'entrypoint'?: string;
    /**
     * unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof ContainerResponse
     */
    'cpu': number;
    /**
     * unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof ContainerResponse
     */
    'memory': number;
    /**
     * 
     * @type {number}
     * @memberof ContainerResponse
     */
    'gpu': number;
    /**
     * Minimum number of instances running. This resource auto-scale based on the CPU and Memory consumption. Note: 0 means that there is no container running. 
     * @type {number}
     * @memberof ContainerResponse
     */
    'min_running_instances': number;
    /**
     * Maximum number of instances running. This resource auto-scale based on the CPU and Memory consumption. Note: -1 means that there is no limit. 
     * @type {number}
     * @memberof ContainerResponse
     */
    'max_running_instances': number;
    /**
     * 
     * @type {Healthcheck}
     * @memberof ContainerResponse
     */
    'healthchecks': Healthcheck;
    /**
     * Indicates if the \'environment preview option\' is enabled for this container.   If enabled, a preview environment will be automatically cloned when `/preview` endpoint is called.   If not specified, it takes the value of the `auto_preview` property from the associated environment. 
     * @type {boolean}
     * @memberof ContainerResponse
     */
    'auto_preview': boolean;
    /**
     * 
     * @type {Array<ServicePort>}
     * @memberof ContainerResponse
     */
    'ports'?: Array<ServicePort>;
    /**
     * Specify if the container will be automatically updated after receiving a new image tag.  The new image tag shall be communicated via the \"Auto Deploy container\" endpoint https://api-doc.qovery.com/#tag/Containers/operation/autoDeployContainerEnvironments 
     * @type {boolean}
     * @memberof ContainerResponse
     */
    'auto_deploy'?: boolean;
    /**
     * 
     * @type {Array<OrganizationAnnotationsGroupResponse>}
     * @memberof ContainerResponse
     */
    'annotations_groups'?: Array<OrganizationAnnotationsGroupResponse>;
    /**
     * 
     * @type {Array<OrganizationLabelsGroupResponse>}
     * @memberof ContainerResponse
     */
    'labels_groups'?: Array<OrganizationLabelsGroupResponse>;
    /**
     * Icon URI representing the container.
     * @type {string}
     * @memberof ContainerResponse
     */
    'icon_uri': string;
    /**
     * 
     * @type {ServiceTypeEnum}
     * @memberof ContainerResponse
     */
    'service_type': ServiceTypeEnum;
    /**
     * 
     * @type {AutoscalingPolicyResponse}
     * @memberof ContainerResponse
     */
    'autoscaling'?: AutoscalingPolicyResponse;
}


/**
 * 
 * @export
 * @interface ContainerResponseList
 */
export interface ContainerResponseList {
    /**
     * 
     * @type {Array<ContainerResponse>}
     * @memberof ContainerResponseList
     */
    'results'?: Array<ContainerResponse>;
}
/**
 * 
 * @export
 * @interface ContainerSource
 */
export interface ContainerSource {
    /**
     * The image name pattern differs according to chosen container registry provider: * `ECR`: `repository` * `SCALEWAY_CR`: `namespace/image` * `DOCKER_HUB`: `image` or `repository/image` * `PUBLIC_ECR`: `registry_alias/repository` 
     * @type {string}
     * @memberof ContainerSource
     */
    'image_name': string;
    /**
     * tag of the image container
     * @type {string}
     * @memberof ContainerSource
     */
    'tag': string;
    /**
     * tag of the image container
     * @type {string}
     * @memberof ContainerSource
     */
    'registry_id'?: string;
    /**
     * 
     * @type {ContainerRegistryProviderDetailsResponse}
     * @memberof ContainerSource
     */
    'registry': ContainerRegistryProviderDetailsResponse;
}
/**
 * 
 * @export
 * @interface ContainerVersionResponse
 */
export interface ContainerVersionResponse {
    /**
     * 
     * @type {string}
     * @memberof ContainerVersionResponse
     */
    'image_name'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ContainerVersionResponse
     */
    'versions'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ContainerVersionResponseList
 */
export interface ContainerVersionResponseList {
    /**
     * 
     * @type {Array<ContainerVersionResponse>}
     * @memberof ContainerVersionResponseList
     */
    'results'?: Array<ContainerVersionResponse>;
}
/**
 * 
 * @export
 * @interface Cost
 */
export interface Cost {
    /**
     * 
     * @type {number}
     * @memberof Cost
     */
    'total_in_cents': number;
    /**
     * 
     * @type {number}
     * @memberof Cost
     */
    'total': number;
    /**
     * 
     * @type {string}
     * @memberof Cost
     */
    'currency_code': string;
}
/**
 * 
 * @export
 * @interface CostRange
 */
export interface CostRange {
    /**
     * 
     * @type {number}
     * @memberof CostRange
     */
    'min_cost_in_cents'?: number;
    /**
     * 
     * @type {number}
     * @memberof CostRange
     */
    'min_cost'?: number;
    /**
     * 
     * @type {number}
     * @memberof CostRange
     */
    'max_cost_in_cents'?: number;
    /**
     * 
     * @type {number}
     * @memberof CostRange
     */
    'max_cost'?: number;
    /**
     * 
     * @type {string}
     * @memberof CostRange
     */
    'currency_code': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CpuArchitectureEnum = {
    AMD64: 'AMD64',
    ARM64: 'ARM64'
} as const;

export type CpuArchitectureEnum = typeof CpuArchitectureEnum[keyof typeof CpuArchitectureEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const CreateEnvironmentModeEnum = {
    DEVELOPMENT: 'DEVELOPMENT',
    PRODUCTION: 'PRODUCTION',
    STAGING: 'STAGING'
} as const;

export type CreateEnvironmentModeEnum = typeof CreateEnvironmentModeEnum[keyof typeof CreateEnvironmentModeEnum];


/**
 * 
 * @export
 * @interface CreateEnvironmentRequest
 */
export interface CreateEnvironmentRequest {
    /**
     * name is case insensitive
     * @type {string}
     * @memberof CreateEnvironmentRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateEnvironmentRequest
     */
    'cluster'?: string;
    /**
     * 
     * @type {CreateEnvironmentModeEnum}
     * @memberof CreateEnvironmentRequest
     */
    'mode'?: CreateEnvironmentModeEnum;
}


/**
 * 
 * @export
 * @interface CredentialCluster
 */
export interface CredentialCluster {
    /**
     * 
     * @type {string}
     * @memberof CredentialCluster
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CredentialCluster
     */
    'name'?: string;
    /**
     * 
     * @type {CloudProviderEnum}
     * @memberof CredentialCluster
     */
    'cloud_provider'?: CloudProviderEnum;
}


/**
 * 
 * @export
 * @interface Credentials
 */
export interface Credentials {
    /**
     * 
     * @type {string}
     * @memberof Credentials
     */
    'host': string;
    /**
     * 
     * @type {number}
     * @memberof Credentials
     */
    'port': number;
    /**
     * 
     * @type {string}
     * @memberof Credentials
     */
    'login': string;
    /**
     * 
     * @type {string}
     * @memberof Credentials
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface CredentialsRequest
 */
export interface CredentialsRequest {
    /**
     * 
     * @type {string}
     * @memberof CredentialsRequest
     */
    'login': string;
    /**
     * 
     * @type {string}
     * @memberof CredentialsRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface CreditCard
 */
export interface CreditCard {
    /**
     * 
     * @type {string}
     * @memberof CreditCard
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CreditCard
     */
    'created_at': string;
    /**
     * 
     * @type {number}
     * @memberof CreditCard
     */
    'expiry_month': number;
    /**
     * 
     * @type {number}
     * @memberof CreditCard
     */
    'expiry_year': number;
    /**
     * 
     * @type {string}
     * @memberof CreditCard
     */
    'last_digit': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreditCard
     */
    'is_expired': boolean;
    /**
     * 
     * @type {string}
     * @memberof CreditCard
     */
    'brand': string;
}
/**
 * 
 * @export
 * @interface CreditCardRequest
 */
export interface CreditCardRequest {
    /**
     * 
     * @type {string}
     * @memberof CreditCardRequest
     */
    'number': string;
    /**
     * 
     * @type {string}
     * @memberof CreditCardRequest
     */
    'cvv': string;
    /**
     * 
     * @type {number}
     * @memberof CreditCardRequest
     */
    'expiry_month': number;
    /**
     * 
     * @type {number}
     * @memberof CreditCardRequest
     */
    'expiry_year': number;
    /**
     * Token generated by payment solution platform.
     * @type {string}
     * @memberof CreditCardRequest
     */
    'token'?: string | null;
}
/**
 * 
 * @export
 * @interface CreditCardResponseList
 */
export interface CreditCardResponseList {
    /**
     * 
     * @type {Array<CreditCard>}
     * @memberof CreditCardResponseList
     */
    'results'?: Array<CreditCard>;
}
/**
 * 
 * @export
 * @interface CronJobResponse
 */
export interface CronJobResponse {
    /**
     * 
     * @type {string}
     * @memberof CronJobResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CronJobResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof CronJobResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {ReferenceObject}
     * @memberof CronJobResponse
     */
    'environment': ReferenceObject;
    /**
     * Maximum cpu that can be allocated to the job based on organization cluster configuration. unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof CronJobResponse
     */
    'maximum_cpu': number;
    /**
     * Maximum memory that can be allocated to the job based on organization cluster configuration. unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof CronJobResponse
     */
    'maximum_memory': number;
    /**
     * Maximum memory that can be allocated to the job based on organization cluster configuration. unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof CronJobResponse
     */
    'maximum_gpu': number;
    /**
     * name is case insensitive
     * @type {string}
     * @memberof CronJobResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CronJobResponse
     */
    'description'?: string;
    /**
     * unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof CronJobResponse
     */
    'cpu': number;
    /**
     * unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof CronJobResponse
     */
    'memory': number;
    /**
     * 
     * @type {number}
     * @memberof CronJobResponse
     */
    'gpu': number;
    /**
     * Maximum number of restart allowed before the job is considered as failed 0 means that no restart/crash of the job is allowed 
     * @type {number}
     * @memberof CronJobResponse
     */
    'max_nb_restart'?: number;
    /**
     * Maximum number of seconds allowed for the job to run before killing it and mark it as failed 
     * @type {number}
     * @memberof CronJobResponse
     */
    'max_duration_seconds'?: number;
    /**
     * Indicates if the \'environment preview option\' is enabled for this container.   If enabled, a preview environment will be automatically cloned when `/preview` endpoint is called.   If not specified, it takes the value of the `auto_preview` property from the associated environment. 
     * @type {boolean}
     * @memberof CronJobResponse
     */
    'auto_preview': boolean;
    /**
     * Port where to run readiness and liveliness probes checks. The port will not be exposed externally
     * @type {number}
     * @memberof CronJobResponse
     */
    'port'?: number | null;
    /**
     * 
     * @type {BaseJobResponseAllOfSource}
     * @memberof CronJobResponse
     */
    'source': BaseJobResponseAllOfSource;
    /**
     * 
     * @type {Healthcheck}
     * @memberof CronJobResponse
     */
    'healthchecks': Healthcheck;
    /**
     * Specify if the job will be automatically updated after receiving a new image tag or a new commit according to the source type.  The new image tag shall be communicated via the \"Auto Deploy job\" endpoint https://api-doc.qovery.com/#tag/Jobs/operation/autoDeployJobEnvironments 
     * @type {boolean}
     * @memberof CronJobResponse
     */
    'auto_deploy'?: boolean;
    /**
     * Icon URI representing the job.
     * @type {string}
     * @memberof CronJobResponse
     */
    'icon_uri': string;
    /**
     * 
     * @type {ServiceTypeEnum}
     * @memberof CronJobResponse
     */
    'service_type': ServiceTypeEnum;
    /**
     * 
     * @type {JobTypeEnum}
     * @memberof CronJobResponse
     */
    'job_type': JobTypeEnum;
    /**
     * 
     * @type {CronJobResponseAllOfSchedule}
     * @memberof CronJobResponse
     */
    'schedule': CronJobResponseAllOfSchedule;
    /**
     * 
     * @type {Array<OrganizationAnnotationsGroupResponse>}
     * @memberof CronJobResponse
     */
    'annotations_groups'?: Array<OrganizationAnnotationsGroupResponse>;
    /**
     * 
     * @type {Array<OrganizationLabelsGroupResponse>}
     * @memberof CronJobResponse
     */
    'labels_groups'?: Array<OrganizationLabelsGroupResponse>;
}


/**
 * 
 * @export
 * @interface CronJobResponseAllOfSchedule
 */
export interface CronJobResponseAllOfSchedule {
    /**
     * 
     * @type {CronJobResponseAllOfScheduleCronjob}
     * @memberof CronJobResponseAllOfSchedule
     */
    'cronjob': CronJobResponseAllOfScheduleCronjob;
}
/**
 * 
 * @export
 * @interface CronJobResponseAllOfScheduleCronjob
 */
export interface CronJobResponseAllOfScheduleCronjob {
    /**
     * 
     * @type {Array<string>}
     * @memberof CronJobResponseAllOfScheduleCronjob
     */
    'arguments'?: Array<string>;
    /**
     * optional entrypoint when launching container
     * @type {string}
     * @memberof CronJobResponseAllOfScheduleCronjob
     */
    'entrypoint'?: string;
    /**
     * tz identifier at which the schedule at will be executed
     * @type {string}
     * @memberof CronJobResponseAllOfScheduleCronjob
     */
    'timezone': string;
    /**
     * Can only be set if the event is CRON.   Represent the cron format for the job schedule without seconds.   For example: `* * * * *` represent the cron to launch the job every minute.   See https://crontab.guru/ to WISIWIG interface.   Timezone is UT 
     * @type {string}
     * @memberof CronJobResponseAllOfScheduleCronjob
     */
    'scheduled_at': string;
}
/**
 * 
 * @export
 * @interface CurrentCost
 */
export interface CurrentCost {
    /**
     * 
     * @type {PlanEnum}
     * @memberof CurrentCost
     */
    'plan'?: PlanEnum;
    /**
     * number of days remaining before the end of the trial period
     * @type {number}
     * @memberof CurrentCost
     */
    'remaining_trial_day'?: number;
    /**
     * date when the current plan will be renewed
     * @type {string}
     * @memberof CurrentCost
     */
    'renewal_at'?: string | null;
    /**
     * 
     * @type {Cost}
     * @memberof CurrentCost
     */
    'cost'?: Cost;
}


/**
 * 
 * @export
 * @interface CustomDomain
 */
export interface CustomDomain {
    /**
     * 
     * @type {string}
     * @memberof CustomDomain
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CustomDomain
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof CustomDomain
     */
    'updated_at'?: string;
    /**
     * your custom domain
     * @type {string}
     * @memberof CustomDomain
     */
    'domain': string;
    /**
     * to control if a certificate has to be generated for this custom domain by Qovery. The default value is `true`. This flag should be set to `false` if a CDN or other entities are managing the certificate for the specified domain and the traffic is proxied by the CDN to Qovery.
     * @type {boolean}
     * @memberof CustomDomain
     */
    'generate_certificate': boolean;
    /**
     * Indicates if the custom domain is behind a CDN (i.e Cloudflare). This will condition the way we are checking CNAME before & during a deployment: * If `true` then we only check the domain points to an IP * If `false` then we check that the domain resolves to the correct service Load Balancer 
     * @type {boolean}
     * @memberof CustomDomain
     */
    'use_cdn'?: boolean;
    /**
     * URL provided by Qovery. You must create a CNAME on your DNS provider using that URL
     * @type {string}
     * @memberof CustomDomain
     */
    'validation_domain'?: string;
    /**
     * 
     * @type {CustomDomainStatusEnum}
     * @memberof CustomDomain
     */
    'status'?: CustomDomainStatusEnum;
}


/**
 * 
 * @export
 * @interface CustomDomainRequest
 */
export interface CustomDomainRequest {
    /**
     * your custom domain
     * @type {string}
     * @memberof CustomDomainRequest
     */
    'domain': string;
    /**
     * to control if a certificate has to be generated for this custom domain by Qovery. The default value is `true`. This flag should be set to `false` if a CDN or other entities are managing the certificate for the specified domain and the traffic is proxied by the CDN to Qovery.
     * @type {boolean}
     * @memberof CustomDomainRequest
     */
    'generate_certificate': boolean;
    /**
     * Indicates if the custom domain is behind a CDN (i.e Cloudflare). This will condition the way we are checking CNAME before & during a deployment: * If `true` then we only check the domain points to an IP * If `false` then we check that the domain resolves to the correct service Load Balancer 
     * @type {boolean}
     * @memberof CustomDomainRequest
     */
    'use_cdn'?: boolean;
}
/**
 * 
 * @export
 * @interface CustomDomainResponseList
 */
export interface CustomDomainResponseList {
    /**
     * 
     * @type {Array<CustomDomain>}
     * @memberof CustomDomainResponseList
     */
    'results'?: Array<CustomDomain>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CustomDomainStatusEnum = {
    VALIDATION_PENDING: 'VALIDATION_PENDING'
} as const;

export type CustomDomainStatusEnum = typeof CustomDomainStatusEnum[keyof typeof CustomDomainStatusEnum];


/**
 * 
 * @export
 * @interface Database
 */
export interface Database {
    /**
     * 
     * @type {string}
     * @memberof Database
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Database
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Database
     */
    'updated_at'?: string;
    /**
     * name is case insensitive
     * @type {string}
     * @memberof Database
     */
    'name': string;
    /**
     * give a description to this database
     * @type {string}
     * @memberof Database
     */
    'description'?: string;
    /**
     * 
     * @type {DatabaseTypeEnum}
     * @memberof Database
     */
    'type': DatabaseTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Database
     */
    'version': string;
    /**
     * 
     * @type {DatabaseModeEnum}
     * @memberof Database
     */
    'mode': DatabaseModeEnum;
    /**
     * 
     * @type {DatabaseAccessibilityEnum}
     * @memberof Database
     */
    'accessibility'?: DatabaseAccessibilityEnum;
    /**
     * unit is millicores (m). 1000m = 1 cpu This field will be ignored for managed DB (instance type will be used instead). 
     * @type {number}
     * @memberof Database
     */
    'cpu'?: number;
    /**
     * Database instance type to be used for this database. The list of values can be retrieved via the endpoint /{CloudProvider}/managedDatabase/instanceType/{region}/{dbType}. This field is null for container DB.
     * @type {string}
     * @memberof Database
     */
    'instance_type'?: string;
    /**
     * unit is MB. 1024 MB = 1GB This field will be ignored for managed DB (instance type will be used instead). Default value is linked to the database type: - MANAGED: `100` - CONTAINER   - POSTGRES: `100`   - REDIS: `100`   - MYSQL: `512`   - MONGODB: `256` 
     * @type {number}
     * @memberof Database
     */
    'memory'?: number;
    /**
     * unit is GB
     * @type {number}
     * @memberof Database
     */
    'storage'?: number;
    /**
     * 
     * @type {Array<OrganizationAnnotationsGroupResponse>}
     * @memberof Database
     */
    'annotations_groups'?: Array<OrganizationAnnotationsGroupResponse>;
    /**
     * 
     * @type {Array<OrganizationLabelsGroupResponse>}
     * @memberof Database
     */
    'labels_groups'?: Array<OrganizationLabelsGroupResponse>;
    /**
     * Icon URI representing the database.
     * @type {string}
     * @memberof Database
     */
    'icon_uri': string;
    /**
     * 
     * @type {ReferenceObject}
     * @memberof Database
     */
    'environment': ReferenceObject;
    /**
     * 
     * @type {string}
     * @memberof Database
     */
    'host'?: string;
    /**
     * 
     * @type {number}
     * @memberof Database
     */
    'port'?: number;
    /**
     * Maximum cpu that can be allocated to the database based on organization cluster configuration. unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof Database
     */
    'maximum_cpu'?: number;
    /**
     * Maximum memory that can be allocated to the database based on organization cluster configuration. unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof Database
     */
    'maximum_memory'?: number;
    /**
     * indicates if the database disk is encrypted or not
     * @type {boolean}
     * @memberof Database
     */
    'disk_encrypted'?: boolean;
    /**
     * 
     * @type {ServiceTypeEnum}
     * @memberof Database
     */
    'service_type': ServiceTypeEnum;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const DatabaseAccessibilityEnum = {
    PRIVATE: 'PRIVATE',
    PUBLIC: 'PUBLIC'
} as const;

export type DatabaseAccessibilityEnum = typeof DatabaseAccessibilityEnum[keyof typeof DatabaseAccessibilityEnum];


/**
 * 
 * @export
 * @interface DatabaseConfiguration
 */
export interface DatabaseConfiguration {
    /**
     * 
     * @type {DatabaseTypeEnum}
     * @memberof DatabaseConfiguration
     */
    'database_type'?: DatabaseTypeEnum;
    /**
     * 
     * @type {Array<DatabaseVersionMode>}
     * @memberof DatabaseConfiguration
     */
    'version'?: Array<DatabaseVersionMode>;
}


/**
 * 
 * @export
 * @interface DatabaseConfigurationResponseList
 */
export interface DatabaseConfigurationResponseList {
    /**
     * 
     * @type {Array<DatabaseConfiguration>}
     * @memberof DatabaseConfigurationResponseList
     */
    'results'?: Array<DatabaseConfiguration>;
}
/**
 * 
 * @export
 * @interface DatabaseEditRequest
 */
export interface DatabaseEditRequest {
    /**
     * name is case-insensitive
     * @type {string}
     * @memberof DatabaseEditRequest
     */
    'name'?: string;
    /**
     * give a description to this database
     * @type {string}
     * @memberof DatabaseEditRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof DatabaseEditRequest
     */
    'version'?: string;
    /**
     * 
     * @type {DatabaseAccessibilityEnum}
     * @memberof DatabaseEditRequest
     */
    'accessibility'?: DatabaseAccessibilityEnum;
    /**
     * unit is millicores (m). 1000m = 1 cpu. This field will be ignored for managed DB (instance type will be used instead). 
     * @type {number}
     * @memberof DatabaseEditRequest
     */
    'cpu'?: number;
    /**
     * unit is MB. 1024 MB = 1GB This field will be ignored for managed DB (instance type will be used instead). Default value is linked to the database type: - MANAGED: 100 - CONTAINER   - POSTGRES: 100   - REDIS: 100   - MYSQL: 512   - MONGODB: 256 
     * @type {number}
     * @memberof DatabaseEditRequest
     */
    'memory'?: number;
    /**
     * unit is GB
     * @type {number}
     * @memberof DatabaseEditRequest
     */
    'storage'?: number;
    /**
     * Database instance type to be used for this database. The list of values can be retrieved via the endpoint /{CloudProvider}/managedDatabase/instanceType/{region}/{dbType}. This field SHOULD NOT be set for container DB.
     * @type {string}
     * @memberof DatabaseEditRequest
     */
    'instance_type'?: string;
    /**
     * 
     * @type {Array<ServiceAnnotationRequest>}
     * @memberof DatabaseEditRequest
     */
    'annotations_groups'?: Array<ServiceAnnotationRequest>;
    /**
     * 
     * @type {Array<ServiceLabelRequest>}
     * @memberof DatabaseEditRequest
     */
    'labels_groups'?: Array<ServiceLabelRequest>;
    /**
     * Icon URI representing the database.
     * @type {string}
     * @memberof DatabaseEditRequest
     */
    'icon_uri'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const DatabaseModeEnum = {
    CONTAINER: 'CONTAINER',
    MANAGED: 'MANAGED'
} as const;

export type DatabaseModeEnum = typeof DatabaseModeEnum[keyof typeof DatabaseModeEnum];


/**
 * 
 * @export
 * @interface DatabaseRequest
 */
export interface DatabaseRequest {
    /**
     * name is case insensitive
     * @type {string}
     * @memberof DatabaseRequest
     */
    'name': string;
    /**
     * give a description to this database
     * @type {string}
     * @memberof DatabaseRequest
     */
    'description'?: string;
    /**
     * 
     * @type {DatabaseTypeEnum}
     * @memberof DatabaseRequest
     */
    'type': DatabaseTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof DatabaseRequest
     */
    'version': string;
    /**
     * 
     * @type {DatabaseModeEnum}
     * @memberof DatabaseRequest
     */
    'mode': DatabaseModeEnum;
    /**
     * 
     * @type {DatabaseAccessibilityEnum}
     * @memberof DatabaseRequest
     */
    'accessibility'?: DatabaseAccessibilityEnum;
    /**
     * unit is millicores (m). 1000m = 1 cpu This field will be ignored for managed DB (instance type will be used instead). 
     * @type {number}
     * @memberof DatabaseRequest
     */
    'cpu'?: number;
    /**
     * Database instance type to be used for this database. The list of values can be retrieved via the endpoint /{CloudProvider}/managedDatabase/instanceType/{region}/{dbType}. This field SHOULD NOT be set for container DB.
     * @type {string}
     * @memberof DatabaseRequest
     */
    'instance_type'?: string;
    /**
     * unit is MB. 1024 MB = 1GB This field will be ignored for managed DB (instance type will be used instead). Default value is linked to the database type: - MANAGED: `100` - CONTAINER   - POSTGRES: `100`   - REDIS: `100`   - MYSQL: `512`   - MONGODB: `256` 
     * @type {number}
     * @memberof DatabaseRequest
     */
    'memory'?: number;
    /**
     * unit is GB
     * @type {number}
     * @memberof DatabaseRequest
     */
    'storage'?: number;
    /**
     * 
     * @type {Array<ServiceAnnotationRequest>}
     * @memberof DatabaseRequest
     */
    'annotations_groups'?: Array<ServiceAnnotationRequest>;
    /**
     * 
     * @type {Array<ServiceLabelRequest>}
     * @memberof DatabaseRequest
     */
    'labels_groups'?: Array<ServiceLabelRequest>;
    /**
     * Icon URI representing the database.
     * @type {string}
     * @memberof DatabaseRequest
     */
    'icon_uri'?: string;
}


/**
 * 
 * @export
 * @interface DatabaseResponseList
 */
export interface DatabaseResponseList {
    /**
     * 
     * @type {Array<Database>}
     * @memberof DatabaseResponseList
     */
    'results'?: Array<Database>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const DatabaseTypeEnum = {
    MONGODB: 'MONGODB',
    MYSQL: 'MYSQL',
    POSTGRESQL: 'POSTGRESQL',
    REDIS: 'REDIS'
} as const;

export type DatabaseTypeEnum = typeof DatabaseTypeEnum[keyof typeof DatabaseTypeEnum];


/**
 * 
 * @export
 * @interface DatabaseVersionMode
 */
export interface DatabaseVersionMode {
    /**
     * 
     * @type {string}
     * @memberof DatabaseVersionMode
     */
    'name'?: string;
    /**
     * 
     * @type {DatabaseModeEnum}
     * @memberof DatabaseVersionMode
     */
    'supported_mode'?: DatabaseModeEnum;
}


/**
 * 
 * @export
 * @interface DeleteMemberRequest
 */
export interface DeleteMemberRequest {
    /**
     * 
     * @type {string}
     * @memberof DeleteMemberRequest
     */
    'user_id': string;
}
/**
 * Action to force a specific Terraform behavior during deletion/uninstall.
 * @export
 * @enum {string}
 */

export const DeleteTerraformAction = {
    SKIP_DESTROY: 'SKIP_DESTROY'
} as const;

export type DeleteTerraformAction = typeof DeleteTerraformAction[keyof typeof DeleteTerraformAction];


/**
 * 
 * @export
 * @interface DeployAllRequest
 */
export interface DeployAllRequest {
    /**
     * 
     * @type {Array<DeployAllRequestApplicationsInner>}
     * @memberof DeployAllRequest
     */
    'applications'?: Array<DeployAllRequestApplicationsInner>;
    /**
     * 
     * @type {Array<string>}
     * @memberof DeployAllRequest
     */
    'databases'?: Array<string>;
    /**
     * 
     * @type {Array<DeployAllRequestContainersInner>}
     * @memberof DeployAllRequest
     */
    'containers'?: Array<DeployAllRequestContainersInner>;
    /**
     * 
     * @type {Array<DeployAllRequestJobsInner>}
     * @memberof DeployAllRequest
     */
    'jobs'?: Array<DeployAllRequestJobsInner>;
    /**
     * 
     * @type {Array<DeployAllRequestHelmsInner>}
     * @memberof DeployAllRequest
     */
    'helms'?: Array<DeployAllRequestHelmsInner>;
    /**
     * 
     * @type {Array<TerraformDeployRequest>}
     * @memberof DeployAllRequest
     */
    'terraforms'?: Array<TerraformDeployRequest>;
}
/**
 * 
 * @export
 * @interface DeployAllRequestApplicationsInner
 */
export interface DeployAllRequestApplicationsInner {
    /**
     * id of the application to be deployed.
     * @type {string}
     * @memberof DeployAllRequestApplicationsInner
     */
    'application_id': string;
    /**
     * Commit ID to deploy. Can be empty only if the service has been already deployed (in this case the service version won\'t be changed)
     * @type {string}
     * @memberof DeployAllRequestApplicationsInner
     */
    'git_commit_id'?: string;
}
/**
 * 
 * @export
 * @interface DeployAllRequestContainersInner
 */
export interface DeployAllRequestContainersInner {
    /**
     * id of the container to be updated.
     * @type {string}
     * @memberof DeployAllRequestContainersInner
     */
    'id': string;
    /**
     * new tag for the container. Can be empty only if the service has been already deployed (in this case the service version won\'t be changed)
     * @type {string}
     * @memberof DeployAllRequestContainersInner
     */
    'image_tag'?: string;
}
/**
 * 
 * @export
 * @interface DeployAllRequestHelmsInner
 */
export interface DeployAllRequestHelmsInner {
    /**
     * id of the helm to be updated.
     * @type {string}
     * @memberof DeployAllRequestHelmsInner
     */
    'id'?: string;
    /**
     * The new chart version for the Helm source. Use this only if the helm has a Helm repository source.
     * @type {string}
     * @memberof DeployAllRequestHelmsInner
     */
    'chart_version'?: string;
    /**
     * The commit Id to deploy. Use this only if the helm has a Git repository source.
     * @type {string}
     * @memberof DeployAllRequestHelmsInner
     */
    'git_commit_id'?: string;
    /**
     * The commit Id of the override values to deploy. Use only if the helm has a Git override values repository.
     * @type {string}
     * @memberof DeployAllRequestHelmsInner
     */
    'values_override_git_commit_id'?: string;
}
/**
 * 
 * @export
 * @interface DeployAllRequestJobsInner
 */
export interface DeployAllRequestJobsInner {
    /**
     * id of the job to be updated.
     * @type {string}
     * @memberof DeployAllRequestJobsInner
     */
    'id'?: string;
    /**
     * new tag for the job image. Use only if job is an image source. Can be empty only if the service has been already deployed (in this case the service version won\'t be changed)
     * @type {string}
     * @memberof DeployAllRequestJobsInner
     */
    'image_tag'?: string;
    /**
     * Commit ID to deploy. Use only if job is a repository source. Can be empty only if the service has been already deployed (in this case the service version won\'t be changed)
     * @type {string}
     * @memberof DeployAllRequestJobsInner
     */
    'git_commit_id'?: string;
}
/**
 * 
 * @export
 * @interface DeployRequest
 */
export interface DeployRequest {
    /**
     * Commit ID to deploy
     * @type {string}
     * @memberof DeployRequest
     */
    'git_commit_id': string;
}
/**
 * 
 * @export
 * @interface DeploymentHistory
 */
export interface DeploymentHistory {
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistory
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistory
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistory
     */
    'updated_at'?: string;
    /**
     * name of the service
     * @type {string}
     * @memberof DeploymentHistory
     */
    'name'?: string;
    /**
     * 
     * @type {Commit}
     * @memberof DeploymentHistory
     */
    'commit'?: Commit | null;
    /**
     * 
     * @type {DeploymentHistoryStatusEnum}
     * @memberof DeploymentHistory
     */
    'status'?: DeploymentHistoryStatusEnum;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const DeploymentHistoryActionStatus = {
    QUEUED: 'QUEUED',
    ONGOING: 'ONGOING',
    SUCCESS: 'SUCCESS',
    ERROR: 'ERROR',
    CANCELED: 'CANCELED',
    CANCELING: 'CANCELING',
    NEVER: 'NEVER'
} as const;

export type DeploymentHistoryActionStatus = typeof DeploymentHistoryActionStatus[keyof typeof DeploymentHistoryActionStatus];


/**
 * 
 * @export
 * @interface DeploymentHistoryApplication
 */
export interface DeploymentHistoryApplication {
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryApplication
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryApplication
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryApplication
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryApplication
     */
    'name'?: string;
    /**
     * 
     * @type {Commit}
     * @memberof DeploymentHistoryApplication
     */
    'commit'?: Commit | null;
    /**
     * 
     * @type {StateEnum}
     * @memberof DeploymentHistoryApplication
     */
    'status'?: StateEnum;
}


/**
 * 
 * @export
 * @interface DeploymentHistoryAuditingData
 */
export interface DeploymentHistoryAuditingData {
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryAuditingData
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryAuditingData
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryAuditingData
     */
    'triggered_by': string;
    /**
     * 
     * @type {OrganizationEventOrigin}
     * @memberof DeploymentHistoryAuditingData
     */
    'origin'?: OrganizationEventOrigin;
}


/**
 * 
 * @export
 * @interface DeploymentHistoryContainer
 */
export interface DeploymentHistoryContainer {
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryContainer
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryContainer
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryContainer
     */
    'updated_at'?: string;
    /**
     * name of the container
     * @type {string}
     * @memberof DeploymentHistoryContainer
     */
    'name'?: string;
    /**
     * 
     * @type {StateEnum}
     * @memberof DeploymentHistoryContainer
     */
    'status'?: StateEnum;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryContainer
     */
    'image_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryContainer
     */
    'tag'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DeploymentHistoryContainer
     */
    'arguments'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryContainer
     */
    'entrypoint'?: string;
}


/**
 * 
 * @export
 * @interface DeploymentHistoryDatabase
 */
export interface DeploymentHistoryDatabase {
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryDatabase
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryDatabase
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryDatabase
     */
    'updated_at'?: string;
    /**
     * name of the service
     * @type {string}
     * @memberof DeploymentHistoryDatabase
     */
    'name'?: string;
    /**
     * 
     * @type {StateEnum}
     * @memberof DeploymentHistoryDatabase
     */
    'status'?: StateEnum;
}


/**
 * 
 * @export
 * @interface DeploymentHistoryEnvironment
 */
export interface DeploymentHistoryEnvironment {
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryEnvironment
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryEnvironment
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryEnvironment
     */
    'updated_at'?: string;
    /**
     * 
     * @type {StateEnum}
     * @memberof DeploymentHistoryEnvironment
     */
    'status'?: StateEnum;
    /**
     * 
     * @type {OrganizationEventOrigin}
     * @memberof DeploymentHistoryEnvironment
     */
    'origin'?: OrganizationEventOrigin;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryEnvironment
     */
    'triggered_by'?: string;
    /**
     * 
     * @type {Array<DeploymentHistoryApplication>}
     * @memberof DeploymentHistoryEnvironment
     */
    'applications'?: Array<DeploymentHistoryApplication>;
    /**
     * 
     * @type {Array<DeploymentHistoryContainer>}
     * @memberof DeploymentHistoryEnvironment
     */
    'containers'?: Array<DeploymentHistoryContainer>;
    /**
     * 
     * @type {Array<DeploymentHistoryDatabase>}
     * @memberof DeploymentHistoryEnvironment
     */
    'databases'?: Array<DeploymentHistoryDatabase>;
    /**
     * 
     * @type {Array<DeploymentHistoryJobResponse>}
     * @memberof DeploymentHistoryEnvironment
     */
    'jobs'?: Array<DeploymentHistoryJobResponse>;
    /**
     * 
     * @type {Array<DeploymentHistoryHelmResponse>}
     * @memberof DeploymentHistoryEnvironment
     */
    'helms'?: Array<DeploymentHistoryHelmResponse>;
}


/**
 * 
 * @export
 * @interface DeploymentHistoryEnvironmentPaginatedResponseList
 */
export interface DeploymentHistoryEnvironmentPaginatedResponseList {
    /**
     * 
     * @type {number}
     * @memberof DeploymentHistoryEnvironmentPaginatedResponseList
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof DeploymentHistoryEnvironmentPaginatedResponseList
     */
    'page_size': number;
    /**
     * 
     * @type {Array<DeploymentHistoryEnvironment>}
     * @memberof DeploymentHistoryEnvironmentPaginatedResponseList
     */
    'results'?: Array<DeploymentHistoryEnvironment>;
}
/**
 * 
 * @export
 * @interface DeploymentHistoryEnvironmentPaginatedResponseListV2
 */
export interface DeploymentHistoryEnvironmentPaginatedResponseListV2 {
    /**
     * 
     * @type {number}
     * @memberof DeploymentHistoryEnvironmentPaginatedResponseListV2
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof DeploymentHistoryEnvironmentPaginatedResponseListV2
     */
    'page_size': number;
    /**
     * 
     * @type {Array<DeploymentHistoryEnvironmentV2>}
     * @memberof DeploymentHistoryEnvironmentPaginatedResponseListV2
     */
    'results'?: Array<DeploymentHistoryEnvironmentV2>;
}
/**
 * 
 * @export
 * @interface DeploymentHistoryEnvironmentV2
 */
export interface DeploymentHistoryEnvironmentV2 {
    /**
     * 
     * @type {DeploymentHistoryEnvironmentV2Identifier}
     * @memberof DeploymentHistoryEnvironmentV2
     */
    'identifier': DeploymentHistoryEnvironmentV2Identifier;
    /**
     * 
     * @type {DeploymentHistoryAuditingData}
     * @memberof DeploymentHistoryEnvironmentV2
     */
    'auditing_data': DeploymentHistoryAuditingData;
    /**
     * 
     * @type {StateEnum}
     * @memberof DeploymentHistoryEnvironmentV2
     */
    'status': StateEnum;
    /**
     * 
     * @type {DeploymentHistoryTriggerAction}
     * @memberof DeploymentHistoryEnvironmentV2
     */
    'trigger_action': DeploymentHistoryTriggerAction;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryEnvironmentV2
     */
    'total_duration': string;
    /**
     * 
     * @type {Array<DeploymentHistoryStage>}
     * @memberof DeploymentHistoryEnvironmentV2
     */
    'stages': Array<DeploymentHistoryStage>;
    /**
     * 
     * @type {DeploymentHistoryActionStatus}
     * @memberof DeploymentHistoryEnvironmentV2
     */
    'action_status': DeploymentHistoryActionStatus;
}


/**
 * 
 * @export
 * @interface DeploymentHistoryEnvironmentV2Identifier
 */
export interface DeploymentHistoryEnvironmentV2Identifier {
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryEnvironmentV2Identifier
     */
    'execution_id': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryEnvironmentV2Identifier
     */
    'environment_id': string;
}
/**
 * 
 * @export
 * @interface DeploymentHistoryHelmResponse
 */
export interface DeploymentHistoryHelmResponse {
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryHelmResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryHelmResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryHelmResponse
     */
    'updated_at'?: string;
    /**
     * name of the helm
     * @type {string}
     * @memberof DeploymentHistoryHelmResponse
     */
    'name'?: string;
    /**
     * 
     * @type {StateEnum}
     * @memberof DeploymentHistoryHelmResponse
     */
    'status'?: StateEnum;
    /**
     * 
     * @type {Commit}
     * @memberof DeploymentHistoryHelmResponse
     */
    'commit'?: Commit | null;
    /**
     * 
     * @type {DeploymentHistoryHelmResponseAllOfRepository}
     * @memberof DeploymentHistoryHelmResponse
     */
    'repository'?: DeploymentHistoryHelmResponseAllOfRepository | null;
}


/**
 * If the chart source if from a repository, the chart name and its version
 * @export
 * @interface DeploymentHistoryHelmResponseAllOfRepository
 */
export interface DeploymentHistoryHelmResponseAllOfRepository {
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryHelmResponseAllOfRepository
     */
    'chart_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryHelmResponseAllOfRepository
     */
    'chart_version'?: string;
}
/**
 * 
 * @export
 * @interface DeploymentHistoryJobResponse
 */
export interface DeploymentHistoryJobResponse {
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryJobResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryJobResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryJobResponse
     */
    'updated_at'?: string;
    /**
     * name of the job
     * @type {string}
     * @memberof DeploymentHistoryJobResponse
     */
    'name'?: string;
    /**
     * 
     * @type {StateEnum}
     * @memberof DeploymentHistoryJobResponse
     */
    'status'?: StateEnum;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryJobResponse
     */
    'image_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryJobResponse
     */
    'tag'?: string;
    /**
     * 
     * @type {Commit}
     * @memberof DeploymentHistoryJobResponse
     */
    'commit'?: Commit | null;
    /**
     * 
     * @type {DeploymentHistoryJobResponseAllOfSchedule}
     * @memberof DeploymentHistoryJobResponse
     */
    'schedule'?: DeploymentHistoryJobResponseAllOfSchedule;
    /**
     * 
     * @type {Array<string>}
     * @memberof DeploymentHistoryJobResponse
     */
    'arguments'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryJobResponse
     */
    'entrypoint'?: string;
}


/**
 * 
 * @export
 * @interface DeploymentHistoryJobResponseAllOfSchedule
 */
export interface DeploymentHistoryJobResponseAllOfSchedule {
    /**
     * 
     * @type {JobScheduleEvent}
     * @memberof DeploymentHistoryJobResponseAllOfSchedule
     */
    'event'?: JobScheduleEvent;
    /**
     * Can only be set if the event is CRON. Represent the cron format for the job schedule without seconds. For example: `* * * * *` represent the cron to launch the job every minute. See https://crontab.guru/ to WISIWIG interface. Timezone is UTC 
     * @type {string}
     * @memberof DeploymentHistoryJobResponseAllOfSchedule
     */
    'schedule_at'?: string | null;
}


/**
 * 
 * @export
 * @interface DeploymentHistoryPaginatedResponseList
 */
export interface DeploymentHistoryPaginatedResponseList {
    /**
     * 
     * @type {number}
     * @memberof DeploymentHistoryPaginatedResponseList
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof DeploymentHistoryPaginatedResponseList
     */
    'page_size': number;
    /**
     * 
     * @type {Array<DeploymentHistory>}
     * @memberof DeploymentHistoryPaginatedResponseList
     */
    'results'?: Array<DeploymentHistory>;
}
/**
 * 
 * @export
 * @interface DeploymentHistoryService
 */
export interface DeploymentHistoryService {
    /**
     * 
     * @type {DeploymentHistoryServiceIdentifier}
     * @memberof DeploymentHistoryService
     */
    'identifier': DeploymentHistoryServiceIdentifier;
    /**
     * 
     * @type {StateEnum}
     * @memberof DeploymentHistoryService
     */
    'status': StateEnum;
    /**
     * 
     * @type {DeploymentHistoryAuditingData}
     * @memberof DeploymentHistoryService
     */
    'auditing_data': DeploymentHistoryAuditingData;
    /**
     * 
     * @type {DeploymentHistoryServiceDetails}
     * @memberof DeploymentHistoryService
     */
    'details': DeploymentHistoryServiceDetails;
    /**
     * 
     * @type {StatusDetails}
     * @memberof DeploymentHistoryService
     */
    'status_details': StatusDetails;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryService
     */
    'icon_uri': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryService
     */
    'total_duration'?: string;
}


/**
 * @type DeploymentHistoryServiceDetails
 * @export
 */
export type DeploymentHistoryServiceDetails = DeploymentHistoryServiceDetailsOneOf | DeploymentHistoryServiceDetailsOneOf1 | DeploymentHistoryServiceDetailsOneOf2 | DeploymentHistoryServiceDetailsOneOf3;

/**
 * ApplicationDeploymentHistoryData
 * @export
 * @interface DeploymentHistoryServiceDetailsOneOf
 */
export interface DeploymentHistoryServiceDetailsOneOf {
    /**
     * 
     * @type {Commit}
     * @memberof DeploymentHistoryServiceDetailsOneOf
     */
    'commit': Commit | null;
}
/**
 * ContainerDeploymentHistoryData
 * @export
 * @interface DeploymentHistoryServiceDetailsOneOf1
 */
export interface DeploymentHistoryServiceDetailsOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryServiceDetailsOneOf1
     */
    'image_name': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryServiceDetailsOneOf1
     */
    'tag': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DeploymentHistoryServiceDetailsOneOf1
     */
    'arguments': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryServiceDetailsOneOf1
     */
    'entrypoint'?: string;
}
/**
 * JobDeploymentHistoryDetails
 * @export
 * @interface DeploymentHistoryServiceDetailsOneOf2
 */
export interface DeploymentHistoryServiceDetailsOneOf2 {
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryServiceDetailsOneOf2
     */
    'image_name': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryServiceDetailsOneOf2
     */
    'tag': string;
    /**
     * 
     * @type {Commit}
     * @memberof DeploymentHistoryServiceDetailsOneOf2
     */
    'commit'?: Commit | null;
    /**
     * 
     * @type {DeploymentHistoryServiceDetailsOneOf2Schedule}
     * @memberof DeploymentHistoryServiceDetailsOneOf2
     */
    'schedule'?: DeploymentHistoryServiceDetailsOneOf2Schedule;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryServiceDetailsOneOf2
     */
    'job_type': DeploymentHistoryServiceDetailsOneOf2JobTypeEnum;
}

export const DeploymentHistoryServiceDetailsOneOf2JobTypeEnum = {
    CRON: 'CRON',
    LIFECYCLE: 'LIFECYCLE'
} as const;

export type DeploymentHistoryServiceDetailsOneOf2JobTypeEnum = typeof DeploymentHistoryServiceDetailsOneOf2JobTypeEnum[keyof typeof DeploymentHistoryServiceDetailsOneOf2JobTypeEnum];

/**
 * 
 * @export
 * @interface DeploymentHistoryServiceDetailsOneOf2Schedule
 */
export interface DeploymentHistoryServiceDetailsOneOf2Schedule {
    /**
     * 
     * @type {JobLifecyleSchedule}
     * @memberof DeploymentHistoryServiceDetailsOneOf2Schedule
     */
    'on_start'?: JobLifecyleSchedule;
    /**
     * 
     * @type {JobLifecyleSchedule}
     * @memberof DeploymentHistoryServiceDetailsOneOf2Schedule
     */
    'on_stop'?: JobLifecyleSchedule;
    /**
     * 
     * @type {JobLifecyleSchedule}
     * @memberof DeploymentHistoryServiceDetailsOneOf2Schedule
     */
    'on_delete'?: JobLifecyleSchedule;
    /**
     * 
     * @type {JobCronSchedule}
     * @memberof DeploymentHistoryServiceDetailsOneOf2Schedule
     */
    'cron_job'?: JobCronSchedule;
    /**
     * 
     * @type {JobLifecycleTypeEnum}
     * @memberof DeploymentHistoryServiceDetailsOneOf2Schedule
     */
    'lifecycle_type'?: JobLifecycleTypeEnum;
}


/**
 * HelmDeploymentHistoryDetails
 * @export
 * @interface DeploymentHistoryServiceDetailsOneOf3
 */
export interface DeploymentHistoryServiceDetailsOneOf3 {
    /**
     * 
     * @type {Commit}
     * @memberof DeploymentHistoryServiceDetailsOneOf3
     */
    'commit'?: Commit | null;
    /**
     * 
     * @type {DeploymentHistoryServiceDetailsOneOf3Repository}
     * @memberof DeploymentHistoryServiceDetailsOneOf3
     */
    'repository'?: DeploymentHistoryServiceDetailsOneOf3Repository;
}
/**
 * 
 * @export
 * @interface DeploymentHistoryServiceDetailsOneOf3Repository
 */
export interface DeploymentHistoryServiceDetailsOneOf3Repository {
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryServiceDetailsOneOf3Repository
     */
    'chart_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryServiceDetailsOneOf3Repository
     */
    'chart_version'?: string;
}
/**
 * 
 * @export
 * @interface DeploymentHistoryServiceIdentifier
 */
export interface DeploymentHistoryServiceIdentifier {
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryServiceIdentifier
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryServiceIdentifier
     */
    'service_id': string;
    /**
     * 
     * @type {ServiceTypeEnum}
     * @memberof DeploymentHistoryServiceIdentifier
     */
    'service_type': ServiceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryServiceIdentifier
     */
    'execution_id'?: string;
}


/**
 * 
 * @export
 * @interface DeploymentHistoryServicePaginatedResponseListV2
 */
export interface DeploymentHistoryServicePaginatedResponseListV2 {
    /**
     * 
     * @type {number}
     * @memberof DeploymentHistoryServicePaginatedResponseListV2
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof DeploymentHistoryServicePaginatedResponseListV2
     */
    'page_size': number;
    /**
     * 
     * @type {Array<DeploymentHistoryService>}
     * @memberof DeploymentHistoryServicePaginatedResponseListV2
     */
    'results'?: Array<DeploymentHistoryService>;
}
/**
 * 
 * @export
 * @interface DeploymentHistoryStage
 */
export interface DeploymentHistoryStage {
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryStage
     */
    'name': string;
    /**
     * 
     * @type {StageStatusEnum}
     * @memberof DeploymentHistoryStage
     */
    'status': StageStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryStage
     */
    'duration': string;
    /**
     * 
     * @type {Array<DeploymentHistoryService>}
     * @memberof DeploymentHistoryStage
     */
    'services': Array<DeploymentHistoryService>;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const DeploymentHistoryStatusEnum = {
    FAILED: 'FAILED',
    SUCCESS: 'SUCCESS'
} as const;

export type DeploymentHistoryStatusEnum = typeof DeploymentHistoryStatusEnum[keyof typeof DeploymentHistoryStatusEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const DeploymentHistoryTriggerAction = {
    DEPLOY: 'DEPLOY',
    DELETE: 'DELETE',
    RESTART: 'RESTART',
    STOP: 'STOP',
    DEPLOY_DRY_RUN: 'DEPLOY_DRY_RUN',
    TERRAFORM_FORCE_UNLOCK: 'TERRAFORM_FORCE_UNLOCK',
    TERRAFORM_MIGRATE_STATE: 'TERRAFORM_MIGRATE_STATE',
    DELETE_RESOURCES_ONLY: 'DELETE_RESOURCES_ONLY',
    UNKNOWN: 'UNKNOWN',
    UNINSTALL: 'UNINSTALL'
} as const;

export type DeploymentHistoryTriggerAction = typeof DeploymentHistoryTriggerAction[keyof typeof DeploymentHistoryTriggerAction];


/**
 * Match mode will rebuild app only if specified items are updated. Exclude mode will not rebuild app if specified items are updated.
 * @export
 * @enum {string}
 */

export const DeploymentRestrictionModeEnum = {
    EXCLUDE: 'EXCLUDE',
    MATCH: 'MATCH'
} as const;

export type DeploymentRestrictionModeEnum = typeof DeploymentRestrictionModeEnum[keyof typeof DeploymentRestrictionModeEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const DeploymentRestrictionTypeEnum = {
    PATH: 'PATH'
} as const;

export type DeploymentRestrictionTypeEnum = typeof DeploymentRestrictionTypeEnum[keyof typeof DeploymentRestrictionTypeEnum];


/**
 * 
 * @export
 * @interface DeploymentStageRequest
 */
export interface DeploymentStageRequest {
    /**
     * The name of the deployment stage
     * @type {string}
     * @memberof DeploymentStageRequest
     */
    'name': string;
    /**
     * free test describing this stage
     * @type {string}
     * @memberof DeploymentStageRequest
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface DeploymentStageResponse
 */
export interface DeploymentStageResponse {
    /**
     * 
     * @type {string}
     * @memberof DeploymentStageResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentStageResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentStageResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {ReferenceObject}
     * @memberof DeploymentStageResponse
     */
    'environment': ReferenceObject;
    /**
     * name is case insensitive
     * @type {string}
     * @memberof DeploymentStageResponse
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentStageResponse
     */
    'description'?: string;
    /**
     * Position of the deployment stage within the environment
     * @type {number}
     * @memberof DeploymentStageResponse
     */
    'deployment_order'?: number;
    /**
     * 
     * @type {Array<DeploymentStageServiceResponse>}
     * @memberof DeploymentStageResponse
     */
    'services'?: Array<DeploymentStageServiceResponse>;
}
/**
 * 
 * @export
 * @interface DeploymentStageResponseList
 */
export interface DeploymentStageResponseList {
    /**
     * 
     * @type {Array<DeploymentStageResponse>}
     * @memberof DeploymentStageResponseList
     */
    'results'?: Array<DeploymentStageResponse>;
}
/**
 * 
 * @export
 * @interface DeploymentStageServiceResponse
 */
export interface DeploymentStageServiceResponse {
    /**
     * 
     * @type {string}
     * @memberof DeploymentStageServiceResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentStageServiceResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentStageServiceResponse
     */
    'updated_at'?: string;
    /**
     * id of the service attached to the stage
     * @type {string}
     * @memberof DeploymentStageServiceResponse
     */
    'service_id'?: string;
    /**
     * type of the service (i.e APPLICATION, JOB, DATABASE, ...)
     * @type {string}
     * @memberof DeploymentStageServiceResponse
     */
    'service_type'?: string;
}
/**
 * 
 * @export
 * @interface DeploymentStageWithServicesStatuses
 */
export interface DeploymentStageWithServicesStatuses {
    /**
     * 
     * @type {Array<Status>}
     * @memberof DeploymentStageWithServicesStatuses
     */
    'applications'?: Array<Status>;
    /**
     * 
     * @type {Array<Status>}
     * @memberof DeploymentStageWithServicesStatuses
     */
    'containers'?: Array<Status>;
    /**
     * 
     * @type {Array<Status>}
     * @memberof DeploymentStageWithServicesStatuses
     */
    'jobs'?: Array<Status>;
    /**
     * 
     * @type {Array<Status>}
     * @memberof DeploymentStageWithServicesStatuses
     */
    'databases'?: Array<Status>;
    /**
     * 
     * @type {Array<Status>}
     * @memberof DeploymentStageWithServicesStatuses
     */
    'helms'?: Array<Status>;
    /**
     * 
     * @type {Array<Status>}
     * @memberof DeploymentStageWithServicesStatuses
     */
    'terraforms'?: Array<Status>;
    /**
     * 
     * @type {Stage}
     * @memberof DeploymentStageWithServicesStatuses
     */
    'stage'?: Stage;
}
/**
 * 
 * @export
 * @interface DockerfileCheckRequest
 */
export interface DockerfileCheckRequest {
    /**
     * 
     * @type {ApplicationGitRepositoryRequest}
     * @memberof DockerfileCheckRequest
     */
    'git_repository': ApplicationGitRepositoryRequest;
    /**
     * path of the dockerfile with root_path as base path
     * @type {string}
     * @memberof DockerfileCheckRequest
     */
    'dockerfile_path': string;
}
/**
 * 
 * @export
 * @interface DockerfileCheckResponse
 */
export interface DockerfileCheckResponse {
    /**
     * 
     * @type {string}
     * @memberof DockerfileCheckResponse
     */
    'dockerfile_path': string;
    /**
     * All ARG variable declared in the Dockerfile
     * @type {Array<string>}
     * @memberof DockerfileCheckResponse
     */
    'arg'?: Array<string>;
    /**
     * All image repositories we found declared in the Dockerfile
     * @type {Array<string>}
     * @memberof DockerfileCheckResponse
     */
    'repositories'?: Array<string>;
}
/**
 * Reference a Dockerfile fragment file from your Git repository.
 * @export
 * @interface DockerfileFragmentFile
 */
export interface DockerfileFragmentFile {
    /**
     * Fragment type discriminator
     * @type {string}
     * @memberof DockerfileFragmentFile
     */
    'type': DockerfileFragmentFileTypeEnum;
    /**
     * Absolute path to the fragment file.
     * @type {string}
     * @memberof DockerfileFragmentFile
     */
    'path': string;
}

export const DockerfileFragmentFileTypeEnum = {
    FILE: 'file'
} as const;

export type DockerfileFragmentFileTypeEnum = typeof DockerfileFragmentFileTypeEnum[keyof typeof DockerfileFragmentFileTypeEnum];

/**
 * Define Dockerfile commands directly in the configuration.
 * @export
 * @interface DockerfileFragmentInline
 */
export interface DockerfileFragmentInline {
    /**
     * Fragment type discriminator
     * @type {string}
     * @memberof DockerfileFragmentInline
     */
    'type': DockerfileFragmentInlineTypeEnum;
    /**
     * Dockerfile commands to inject (max 8KB).
     * @type {string}
     * @memberof DockerfileFragmentInline
     */
    'content': string;
}

export const DockerfileFragmentInlineTypeEnum = {
    INLINE: 'inline'
} as const;

export type DockerfileFragmentInlineTypeEnum = typeof DockerfileFragmentInlineTypeEnum[keyof typeof DockerfileFragmentInlineTypeEnum];

/**
 * 
 * @export
 * @interface EksInfrastructureOutputs
 */
export interface EksInfrastructureOutputs {
    /**
     * 
     * @type {string}
     * @memberof EksInfrastructureOutputs
     */
    'kind': EksInfrastructureOutputsKindEnum;
    /**
     * 
     * @type {string}
     * @memberof EksInfrastructureOutputs
     */
    'cluster_name': string;
    /**
     * 
     * @type {string}
     * @memberof EksInfrastructureOutputs
     */
    'cluster_arn': string;
    /**
     * 
     * @type {string}
     * @memberof EksInfrastructureOutputs
     */
    'cluster_oidc_issuer': string;
    /**
     * 
     * @type {string}
     * @memberof EksInfrastructureOutputs
     */
    'vpc_id': string;
}

export const EksInfrastructureOutputsKindEnum = {
    EKS: 'EKS'
} as const;

export type EksInfrastructureOutputsKindEnum = typeof EksInfrastructureOutputsKindEnum[keyof typeof EksInfrastructureOutputsKindEnum];

/**
 * 
 * @export
 * @interface EnterpriseConnectionDto
 */
export interface EnterpriseConnectionDto {
    /**
     * The connection name
     * @type {string}
     * @memberof EnterpriseConnectionDto
     */
    'connection_name': string;
    /**
     * The purpose of this default role is to be associated to your users if: - you choose to not expose your IDPs groups to the SAML / OIDC connection - no associated group is found in your `group_mappings` defined  You can define either a Qovery provided role (i.e `viewer`) or one of your custom role`s uuid. 
     * @type {string}
     * @memberof EnterpriseConnectionDto
     */
    'default_role': string;
    /**
     * * if `true`, roles will be synchronized at each user login according to your `group_mappings` configuration based on your IDP groups * if `false`, no synchronization is done for your users and `group_mappings` configuration will be ignored 
     * @type {boolean}
     * @memberof EnterpriseConnectionDto
     */
    'enforce_group_sync': boolean;
    /**
     * This will allow to create mapping rules based on your IDP group names.   It\'s a dictionnary having: - key: either a Qovery provided role (i.e `viewer`) or one of your custom role`s uuid - value: an array of your IDP group names  Example: \"I want to associate the Qovery role `devops` to my IDP groups [\'Administrators\', \'DevSecOps\']\" 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof EnterpriseConnectionDto
     */
    'group_mappings': { [key: string]: Array<string>; };
}
/**
 * 
 * @export
 * @interface EnterpriseConnectionResponseList
 */
export interface EnterpriseConnectionResponseList {
    /**
     * 
     * @type {Array<EnterpriseConnectionDto>}
     * @memberof EnterpriseConnectionResponseList
     */
    'results'?: Array<EnterpriseConnectionDto>;
}
/**
 * 
 * @export
 * @interface EnvDeploymentStatus
 */
export interface EnvDeploymentStatus {
    /**
     * 
     * @type {string}
     * @memberof EnvDeploymentStatus
     */
    'deployment_request_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvDeploymentStatus
     */
    'environment_id'?: string;
    /**
     * 
     * @type {StateEnum}
     * @memberof EnvDeploymentStatus
     */
    'status'?: StateEnum;
}


/**
 * 
 * @export
 * @interface Environment
 */
export interface Environment {
    /**
     * 
     * @type {string}
     * @memberof Environment
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Environment
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Environment
     */
    'updated_at'?: string;
    /**
     * name is case insensitive
     * @type {string}
     * @memberof Environment
     */
    'name': string;
    /**
     * 
     * @type {ReferenceObject}
     * @memberof Environment
     */
    'organization': ReferenceObject;
    /**
     * 
     * @type {ReferenceObject}
     * @memberof Environment
     */
    'project': ReferenceObject;
    /**
     * uuid of the user that made the last update
     * @type {string}
     * @memberof Environment
     */
    'last_updated_by'?: string;
    /**
     * 
     * @type {EnvironmentAllOfCloudProvider}
     * @memberof Environment
     */
    'cloud_provider': EnvironmentAllOfCloudProvider;
    /**
     * 
     * @type {EnvironmentModeEnum}
     * @memberof Environment
     */
    'mode': EnvironmentModeEnum;
    /**
     * 
     * @type {string}
     * @memberof Environment
     */
    'cluster_id': string;
    /**
     * 
     * @type {string}
     * @memberof Environment
     */
    'cluster_name'?: string;
}


/**
 * 
 * @export
 * @interface EnvironmentAllOfCloudProvider
 */
export interface EnvironmentAllOfCloudProvider {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentAllOfCloudProvider
     */
    'provider'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentAllOfCloudProvider
     */
    'cluster'?: string;
}
/**
 * 
 * @export
 * @interface EnvironmentDeploymentRule
 */
export interface EnvironmentDeploymentRule {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentDeploymentRule
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentDeploymentRule
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentDeploymentRule
     */
    'updated_at'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EnvironmentDeploymentRule
     */
    'on_demand_preview'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EnvironmentDeploymentRule
     */
    'auto_stop'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EnvironmentDeploymentRule
     */
    'auto_preview'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentDeploymentRule
     */
    'timezone': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentDeploymentRule
     */
    'start_time': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentDeploymentRule
     */
    'stop_time': string;
    /**
     * 
     * @type {Array<WeekdayEnum>}
     * @memberof EnvironmentDeploymentRule
     */
    'weekdays': Array<WeekdayEnum>;
}
/**
 * 
 * @export
 * @interface EnvironmentDeploymentRuleEditRequest
 */
export interface EnvironmentDeploymentRuleEditRequest {
    /**
     * 
     * @type {boolean}
     * @memberof EnvironmentDeploymentRuleEditRequest
     */
    'on_demand_preview'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EnvironmentDeploymentRuleEditRequest
     */
    'auto_preview'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EnvironmentDeploymentRuleEditRequest
     */
    'auto_stop'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentDeploymentRuleEditRequest
     */
    'timezone': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentDeploymentRuleEditRequest
     */
    'start_time': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentDeploymentRuleEditRequest
     */
    'stop_time': string;
    /**
     * 
     * @type {Array<WeekdayEnum>}
     * @memberof EnvironmentDeploymentRuleEditRequest
     */
    'weekdays': Array<WeekdayEnum>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const EnvironmentDeploymentStatusEnum = {
    NEVER_DEPLOYED: 'NEVER_DEPLOYED',
    UP_TO_DATE: 'UP_TO_DATE',
    OUT_OF_DATE: 'OUT_OF_DATE'
} as const;

export type EnvironmentDeploymentStatusEnum = typeof EnvironmentDeploymentStatusEnum[keyof typeof EnvironmentDeploymentStatusEnum];


/**
 * 
 * @export
 * @interface EnvironmentEditRequest
 */
export interface EnvironmentEditRequest {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentEditRequest
     */
    'name'?: string;
    /**
     * 
     * @type {CreateEnvironmentModeEnum}
     * @memberof EnvironmentEditRequest
     */
    'mode'?: CreateEnvironmentModeEnum;
}


/**
 * 
 * @export
 * @interface EnvironmentLog
 */
export interface EnvironmentLog {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLog
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLog
     */
    'created_at': string;
    /**
     * 
     * @type {EnvironmentLogScope}
     * @memberof EnvironmentLog
     */
    'scope'?: EnvironmentLogScope;
    /**
     * 
     * @type {StatusKindEnum}
     * @memberof EnvironmentLog
     */
    'state'?: StatusKindEnum;
    /**
     * Log message
     * @type {string}
     * @memberof EnvironmentLog
     */
    'message': string | null;
    /**
     * Only for errors. Helps Qovery team to investigate.
     * @type {string}
     * @memberof EnvironmentLog
     */
    'execution_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLog
     */
    'hint'?: string;
}


/**
 * 
 * @export
 * @interface EnvironmentLogResponseList
 */
export interface EnvironmentLogResponseList {
    /**
     * 
     * @type {Array<EnvironmentLog>}
     * @memberof EnvironmentLogResponseList
     */
    'results'?: Array<EnvironmentLog>;
}
/**
 * 
 * @export
 * @interface EnvironmentLogScope
 */
export interface EnvironmentLogScope {
    /**
     * 
     * @type {EnvironmentLogTypeEnum}
     * @memberof EnvironmentLogScope
     */
    'type'?: EnvironmentLogTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogScope
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogScope
     */
    'id'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const EnvironmentLogTypeEnum = {
    APPLICATION: 'APPLICATION',
    DATABASE: 'DATABASE',
    ENVIRONMENT: 'ENVIRONMENT'
} as const;

export type EnvironmentLogTypeEnum = typeof EnvironmentLogTypeEnum[keyof typeof EnvironmentLogTypeEnum];


/**
 * 
 * @export
 * @interface EnvironmentLogs
 */
export interface EnvironmentLogs {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogs
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogs
     */
    'timestamp': string;
    /**
     * 
     * @type {EnvironmentLogsDetails}
     * @memberof EnvironmentLogs
     */
    'details': EnvironmentLogsDetails;
    /**
     * 
     * @type {EnvironmentLogsError}
     * @memberof EnvironmentLogs
     */
    'error'?: EnvironmentLogsError | null;
    /**
     * 
     * @type {EnvironmentLogsMessage}
     * @memberof EnvironmentLogs
     */
    'message'?: EnvironmentLogsMessage | null;
}
/**
 * 
 * @export
 * @interface EnvironmentLogsDetails
 */
export interface EnvironmentLogsDetails {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogsDetails
     */
    'organization_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogsDetails
     */
    'cluster_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogsDetails
     */
    'execution_id'?: string;
    /**
     * 
     * @type {EnvironmentLogsDetailsTransmitter}
     * @memberof EnvironmentLogsDetails
     */
    'transmitter'?: EnvironmentLogsDetailsTransmitter;
    /**
     * 
     * @type {EnvironmentLogsDetailsStage}
     * @memberof EnvironmentLogsDetails
     */
    'stage'?: EnvironmentLogsDetailsStage;
}
/**
 * 
 * @export
 * @interface EnvironmentLogsDetailsStage
 */
export interface EnvironmentLogsDetailsStage {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogsDetailsStage
     */
    'step'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogsDetailsStage
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogsDetailsStage
     */
    'name'?: string | null;
}
/**
 * 
 * @export
 * @interface EnvironmentLogsDetailsTransmitter
 */
export interface EnvironmentLogsDetailsTransmitter {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogsDetailsTransmitter
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogsDetailsTransmitter
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogsDetailsTransmitter
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface EnvironmentLogsError
 */
export interface EnvironmentLogsError {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogsError
     */
    'tag'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogsError
     */
    'user_log_message'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogsError
     */
    'link'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogsError
     */
    'hint_message'?: string;
    /**
     * 
     * @type {EnvironmentLogsErrorUnderlyingError}
     * @memberof EnvironmentLogsError
     */
    'underlying_error'?: EnvironmentLogsErrorUnderlyingError;
}
/**
 * 
 * @export
 * @interface EnvironmentLogsErrorUnderlyingError
 */
export interface EnvironmentLogsErrorUnderlyingError {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogsErrorUnderlyingError
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogsErrorUnderlyingError
     */
    'full_details'?: string;
}
/**
 * 
 * @export
 * @interface EnvironmentLogsMessage
 */
export interface EnvironmentLogsMessage {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogsMessage
     */
    'safe_message'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogsMessage
     */
    'full_details'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const EnvironmentModeEnum = {
    DEVELOPMENT: 'DEVELOPMENT',
    PREVIEW: 'PREVIEW',
    PRODUCTION: 'PRODUCTION',
    STAGING: 'STAGING'
} as const;

export type EnvironmentModeEnum = typeof EnvironmentModeEnum[keyof typeof EnvironmentModeEnum];


/**
 * 
 * @export
 * @interface EnvironmentResponseList
 */
export interface EnvironmentResponseList {
    /**
     * 
     * @type {Array<Environment>}
     * @memberof EnvironmentResponseList
     */
    'results'?: Array<Environment>;
}
/**
 * 
 * @export
 * @interface EnvironmentServiceIdsAllRequest
 */
export interface EnvironmentServiceIdsAllRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof EnvironmentServiceIdsAllRequest
     */
    'application_ids'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof EnvironmentServiceIdsAllRequest
     */
    'container_ids'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof EnvironmentServiceIdsAllRequest
     */
    'database_ids'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof EnvironmentServiceIdsAllRequest
     */
    'job_ids'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof EnvironmentServiceIdsAllRequest
     */
    'helm_ids'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof EnvironmentServiceIdsAllRequest
     */
    'terraform_ids'?: Array<string>;
}
/**
 * 
 * @export
 * @interface EnvironmentStats
 */
export interface EnvironmentStats {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentStats
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentStats
     */
    'service_total_number'?: number;
}
/**
 * 
 * @export
 * @interface EnvironmentStatsResponseList
 */
export interface EnvironmentStatsResponseList {
    /**
     * 
     * @type {Array<EnvironmentStats>}
     * @memberof EnvironmentStatsResponseList
     */
    'results'?: Array<EnvironmentStats>;
}
/**
 * 
 * @export
 * @interface EnvironmentStatus
 */
export interface EnvironmentStatus {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentStatus
     */
    'id': string;
    /**
     * 
     * @type {StateEnum}
     * @memberof EnvironmentStatus
     */
    'state': StateEnum;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentStatus
     */
    'last_deployment_date'?: string | null;
    /**
     * 
     * @type {StateEnum}
     * @memberof EnvironmentStatus
     */
    'last_deployment_state': StateEnum;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentStatus
     */
    'last_deployment_id'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentStatus
     */
    'total_deployment_duration_in_seconds'?: number | null;
    /**
     * 
     * @type {EnvironmentStatusEventOriginEnum}
     * @memberof EnvironmentStatus
     */
    'origin'?: EnvironmentStatusEventOriginEnum | null;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentStatus
     */
    'triggered_by'?: string | null;
    /**
     * 
     * @type {EnvironmentDeploymentStatusEnum}
     * @memberof EnvironmentStatus
     */
    'deployment_status'?: EnvironmentDeploymentStatusEnum;
}


/**
 * Origin of the organization event
 * @export
 * @enum {string}
 */

export const EnvironmentStatusEventOriginEnum = {
    API: 'API',
    CLI: 'CLI',
    CONSOLE: 'CONSOLE',
    GIT: 'GIT',
    QOVERY_INTERNAL: 'QOVERY_INTERNAL',
    TERRAFORM_PROVIDER: 'TERRAFORM_PROVIDER'
} as const;

export type EnvironmentStatusEventOriginEnum = typeof EnvironmentStatusEventOriginEnum[keyof typeof EnvironmentStatusEventOriginEnum];


/**
 * 
 * @export
 * @interface EnvironmentStatusList
 */
export interface EnvironmentStatusList {
    /**
     * 
     * @type {Array<EnvironmentStatus>}
     * @memberof EnvironmentStatusList
     */
    'results'?: Array<EnvironmentStatus>;
}
/**
 * 
 * @export
 * @interface EnvironmentStatuses
 */
export interface EnvironmentStatuses {
    /**
     * 
     * @type {EnvironmentStatus}
     * @memberof EnvironmentStatuses
     */
    'environment': EnvironmentStatus;
    /**
     * 
     * @type {Array<Status>}
     * @memberof EnvironmentStatuses
     */
    'applications': Array<Status>;
    /**
     * 
     * @type {Array<Status>}
     * @memberof EnvironmentStatuses
     */
    'containers': Array<Status>;
    /**
     * 
     * @type {Array<Status>}
     * @memberof EnvironmentStatuses
     */
    'jobs': Array<Status>;
    /**
     * 
     * @type {Array<Status>}
     * @memberof EnvironmentStatuses
     */
    'databases': Array<Status>;
    /**
     * 
     * @type {Array<Status>}
     * @memberof EnvironmentStatuses
     */
    'helms': Array<Status>;
    /**
     * 
     * @type {Array<Status>}
     * @memberof EnvironmentStatuses
     */
    'terraforms': Array<Status>;
}
/**
 * 
 * @export
 * @interface EnvironmentStatusesWithStages
 */
export interface EnvironmentStatusesWithStages {
    /**
     * 
     * @type {EnvironmentStatus}
     * @memberof EnvironmentStatusesWithStages
     */
    'environment'?: EnvironmentStatus;
    /**
     * 
     * @type {Array<DeploymentStageWithServicesStatuses>}
     * @memberof EnvironmentStatusesWithStages
     */
    'stages'?: Array<DeploymentStageWithServicesStatuses>;
    /**
     * 
     * @type {EnvironmentStatusesWithStagesPreCheckStage}
     * @memberof EnvironmentStatusesWithStages
     */
    'pre_check_stage'?: EnvironmentStatusesWithStagesPreCheckStage;
}
/**
 * 
 * @export
 * @interface EnvironmentStatusesWithStagesPreCheckStage
 */
export interface EnvironmentStatusesWithStagesPreCheckStage {
    /**
     * 
     * @type {StepMetricStatusEnum}
     * @memberof EnvironmentStatusesWithStagesPreCheckStage
     */
    'status'?: StepMetricStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentStatusesWithStagesPreCheckStage
     */
    'total_duration_sec'?: number;
}


/**
 * 
 * @export
 * @interface EnvironmentTotalNumber
 */
export interface EnvironmentTotalNumber {
    /**
     * 
     * @type {number}
     * @memberof EnvironmentTotalNumber
     */
    'environment_total_number'?: number;
}
/**
 * 
 * @export
 * @interface EnvironmentVariable
 */
export interface EnvironmentVariable {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentVariable
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentVariable
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentVariable
     */
    'updated_at'?: string;
    /**
     * key is case sensitive.
     * @type {string}
     * @memberof EnvironmentVariable
     */
    'key': string;
    /**
     * value of the env variable.
     * @type {string}
     * @memberof EnvironmentVariable
     */
    'value'?: string;
    /**
     * should be set for file only. variable mount path makes variable a file (where file should be mounted).
     * @type {string}
     * @memberof EnvironmentVariable
     */
    'mount_path'?: string | null;
    /**
     * optional variable description (255 characters maximum)
     * @type {string}
     * @memberof EnvironmentVariable
     */
    'description'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof EnvironmentVariable
     */
    'enable_interpolation_in_file'?: boolean | null;
    /**
     * 
     * @type {EnvironmentVariableOverride}
     * @memberof EnvironmentVariable
     */
    'overridden_variable'?: EnvironmentVariableOverride;
    /**
     * 
     * @type {EnvironmentVariableAlias}
     * @memberof EnvironmentVariable
     */
    'aliased_variable'?: EnvironmentVariableAlias;
    /**
     * 
     * @type {APIVariableScopeEnum}
     * @memberof EnvironmentVariable
     */
    'scope': APIVariableScopeEnum;
    /**
     * 
     * @type {APIVariableTypeEnum}
     * @memberof EnvironmentVariable
     */
    'variable_type': APIVariableTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentVariable
     */
    'service_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentVariable
     */
    'service_name'?: string;
    /**
     * 
     * @type {LinkedServiceTypeEnum}
     * @memberof EnvironmentVariable
     */
    'service_type'?: LinkedServiceTypeEnum;
    /**
     * Entity that created/own the variable (i.e: Qovery, Doppler)
     * @type {string}
     * @memberof EnvironmentVariable
     */
    'owned_by'?: string;
}


/**
 * 
 * @export
 * @interface EnvironmentVariableAlias
 */
export interface EnvironmentVariableAlias {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentVariableAlias
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentVariableAlias
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentVariableAlias
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentVariableAlias
     */
    'mount_path': string;
    /**
     * 
     * @type {APIVariableScopeEnum}
     * @memberof EnvironmentVariableAlias
     */
    'scope': APIVariableScopeEnum;
    /**
     * 
     * @type {APIVariableTypeEnum}
     * @memberof EnvironmentVariableAlias
     */
    'variable_type': APIVariableTypeEnum;
}


/**
 * 
 * @export
 * @interface EnvironmentVariableEditRequest
 */
export interface EnvironmentVariableEditRequest {
    /**
     * key is case sensitive
     * @type {string}
     * @memberof EnvironmentVariableEditRequest
     */
    'key': string;
    /**
     * value of the env variable.
     * @type {string}
     * @memberof EnvironmentVariableEditRequest
     */
    'value'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentVariableEditRequest
     */
    'mount_path'?: string | null;
    /**
     * optional variable description (255 characters maximum)
     * @type {string}
     * @memberof EnvironmentVariableEditRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof EnvironmentVariableEditRequest
     */
    'enable_interpolation_in_file'?: boolean | null;
}
/**
 * 
 * @export
 * @interface EnvironmentVariableOverride
 */
export interface EnvironmentVariableOverride {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentVariableOverride
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentVariableOverride
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentVariableOverride
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentVariableOverride
     */
    'mount_path': string;
    /**
     * 
     * @type {APIVariableScopeEnum}
     * @memberof EnvironmentVariableOverride
     */
    'scope': APIVariableScopeEnum;
    /**
     * 
     * @type {APIVariableTypeEnum}
     * @memberof EnvironmentVariableOverride
     */
    'variable_type': APIVariableTypeEnum;
}


/**
 * 
 * @export
 * @interface EnvironmentVariableRequest
 */
export interface EnvironmentVariableRequest {
    /**
     * key is case sensitive.
     * @type {string}
     * @memberof EnvironmentVariableRequest
     */
    'key': string;
    /**
     * value of the env variable.
     * @type {string}
     * @memberof EnvironmentVariableRequest
     */
    'value'?: string;
    /**
     * should be set for file only. variable mount path makes variable a file (where file should be mounted).
     * @type {string}
     * @memberof EnvironmentVariableRequest
     */
    'mount_path'?: string | null;
    /**
     * optional variable description (255 characters maximum)
     * @type {string}
     * @memberof EnvironmentVariableRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof EnvironmentVariableRequest
     */
    'enable_interpolation_in_file'?: boolean | null;
}
/**
 * 
 * @export
 * @interface EnvironmentVariableResponseList
 */
export interface EnvironmentVariableResponseList {
    /**
     * 
     * @type {Array<EnvironmentVariable>}
     * @memberof EnvironmentVariableResponseList
     */
    'results'?: Array<EnvironmentVariable>;
}
/**
 * 
 * @export
 * @interface GcpCredentialsRequest
 */
export interface GcpCredentialsRequest {
    /**
     * 
     * @type {string}
     * @memberof GcpCredentialsRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GcpCredentialsRequest
     */
    'gcp_credentials': string;
}
/**
 * 
 * @export
 * @interface GcpStaticClusterCredentials
 */
export interface GcpStaticClusterCredentials {
    /**
     * 
     * @type {string}
     * @memberof GcpStaticClusterCredentials
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GcpStaticClusterCredentials
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GcpStaticClusterCredentials
     */
    'object_type': GcpStaticClusterCredentialsObjectTypeEnum;
}

export const GcpStaticClusterCredentialsObjectTypeEnum = {
    GCP: 'GCP'
} as const;

export type GcpStaticClusterCredentialsObjectTypeEnum = typeof GcpStaticClusterCredentialsObjectTypeEnum[keyof typeof GcpStaticClusterCredentialsObjectTypeEnum];

/**
 * 
 * @export
 * @interface GenericClusterCredentials
 */
export interface GenericClusterCredentials {
    /**
     * 
     * @type {string}
     * @memberof GenericClusterCredentials
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GenericClusterCredentials
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GenericClusterCredentials
     */
    'object_type': GenericClusterCredentialsObjectTypeEnum;
}

export const GenericClusterCredentialsObjectTypeEnum = {
    OTHER: 'OTHER'
} as const;

export type GenericClusterCredentialsObjectTypeEnum = typeof GenericClusterCredentialsObjectTypeEnum[keyof typeof GenericClusterCredentialsObjectTypeEnum];

/**
 * 
 * @export
 * @interface GenericObjectCurrentCost
 */
export interface GenericObjectCurrentCost {
    /**
     * 
     * @type {string}
     * @memberof GenericObjectCurrentCost
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GenericObjectCurrentCost
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof GenericObjectCurrentCost
     */
    'consumed_time_in_seconds': number;
    /**
     * 
     * @type {Cost}
     * @memberof GenericObjectCurrentCost
     */
    'cost': Cost;
}
/**
 * 
 * @export
 * @interface GetClusterKubernetesEvents200Response
 */
export interface GetClusterKubernetesEvents200Response {
    /**
     * 
     * @type {Array<GetClusterKubernetesEvents200ResponseResultsInner>}
     * @memberof GetClusterKubernetesEvents200Response
     */
    'results'?: Array<GetClusterKubernetesEvents200ResponseResultsInner>;
}
/**
 * 
 * @export
 * @interface GetClusterKubernetesEvents200ResponseResultsInner
 */
export interface GetClusterKubernetesEvents200ResponseResultsInner {
    /**
     * The created date following ISO-8601 format
     * @type {string}
     * @memberof GetClusterKubernetesEvents200ResponseResultsInner
     */
    'created_at'?: string;
    /**
     * The source kubernetes object related to the Event
     * @type {string}
     * @memberof GetClusterKubernetesEvents200ResponseResultsInner
     */
    'kind'?: string;
    /**
     * The namespace of the kubernetes object related to the Event (optional)
     * @type {string}
     * @memberof GetClusterKubernetesEvents200ResponseResultsInner
     */
    'namespace'?: string;
    /**
     * The name of the Event
     * @type {string}
     * @memberof GetClusterKubernetesEvents200ResponseResultsInner
     */
    'name'?: string;
    /**
     * The action that triggered the Event
     * @type {string}
     * @memberof GetClusterKubernetesEvents200ResponseResultsInner
     */
    'reason'?: string;
    /**
     * A description of the Event
     * @type {string}
     * @memberof GetClusterKubernetesEvents200ResponseResultsInner
     */
    'message'?: string;
    /**
     * As of today it can be either Warning or Normal (can evolve in the next releases)
     * @type {string}
     * @memberof GetClusterKubernetesEvents200ResponseResultsInner
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetClusterKubernetesEvents200ResponseResultsInner
     */
    'reporting_component'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetClusterKubernetesEvents200ResponseResultsInner
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetClusterKubernetesEvents200ResponseResultsInner
     */
    'first_occurrence'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetClusterKubernetesEvents200ResponseResultsInner
     */
    'last_occurrence'?: string;
}
/**
 * 
 * @export
 * @interface GetClusterTokenByClusterId200Response
 */
export interface GetClusterTokenByClusterId200Response {
    /**
     * 
     * @type {string}
     * @memberof GetClusterTokenByClusterId200Response
     */
    'apiVersion': string;
    /**
     * 
     * @type {string}
     * @memberof GetClusterTokenByClusterId200Response
     */
    'kind': string;
    /**
     * 
     * @type {object}
     * @memberof GetClusterTokenByClusterId200Response
     */
    'spec': object;
    /**
     * 
     * @type {GetClusterTokenByClusterId200ResponseStatus}
     * @memberof GetClusterTokenByClusterId200Response
     */
    'status': GetClusterTokenByClusterId200ResponseStatus;
}
/**
 * 
 * @export
 * @interface GetClusterTokenByClusterId200ResponseStatus
 */
export interface GetClusterTokenByClusterId200ResponseStatus {
    /**
     * 
     * @type {string}
     * @memberof GetClusterTokenByClusterId200ResponseStatus
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof GetClusterTokenByClusterId200ResponseStatus
     */
    'expirationTimestamp': string;
}
/**
 * Response for ghost alerts that exist in Prometheus but have been deleted from the database
 * @export
 * @interface GhostAlertRuleResponse
 */
export interface GhostAlertRuleResponse extends AlertRuleResponseBase {
    /**
     * 
     * @type {GhostAlertRuleResponseAllOfTarget}
     * @memberof GhostAlertRuleResponse
     */
    'target'?: GhostAlertRuleResponseAllOfTarget;
    /**
     * When the ghost alert started firing
     * @type {string}
     * @memberof GhostAlertRuleResponse
     */
    'starts_at'?: string | null;
}


/**
 * May be null if target info couldn\'t be extracted from Prometheus
 * @export
 * @interface GhostAlertRuleResponseAllOfTarget
 */
export interface GhostAlertRuleResponseAllOfTarget {
    /**
     * 
     * @type {AlertTargetType}
     * @memberof GhostAlertRuleResponseAllOfTarget
     */
    'target_type': AlertTargetType;
    /**
     * 
     * @type {string}
     * @memberof GhostAlertRuleResponseAllOfTarget
     */
    'target_id': string;
    /**
     * 
     * @type {ServiceLightResponse}
     * @memberof GhostAlertRuleResponseAllOfTarget
     */
    'service'?: ServiceLightResponse;
}


/**
 * 
 * @export
 * @interface GitAuthProvider
 */
export interface GitAuthProvider {
    /**
     * 
     * @type {string}
     * @memberof GitAuthProvider
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GitAuthProvider
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GitAuthProvider
     */
    'owner': string;
    /**
     * 
     * @type {boolean}
     * @memberof GitAuthProvider
     */
    'use_bot'?: boolean;
}
/**
 * 
 * @export
 * @interface GitAuthProviderResponseList
 */
export interface GitAuthProviderResponseList {
    /**
     * 
     * @type {Array<GitAuthProvider>}
     * @memberof GitAuthProviderResponseList
     */
    'results'?: Array<GitAuthProvider>;
}
/**
 * 
 * @export
 * @interface GitFileCheckRequest
 */
export interface GitFileCheckRequest {
    /**
     * 
     * @type {HelmGitRepositoryRequest}
     * @memberof GitFileCheckRequest
     */
    'git_repository': HelmGitRepositoryRequest;
    /**
     * 
     * @type {Array<string>}
     * @memberof GitFileCheckRequest
     */
    'files': Array<string>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const GitProviderEnum = {
    BITBUCKET: 'BITBUCKET',
    GITHUB: 'GITHUB',
    GITLAB: 'GITLAB'
} as const;

export type GitProviderEnum = typeof GitProviderEnum[keyof typeof GitProviderEnum];


/**
 * 
 * @export
 * @interface GitRepository
 */
export interface GitRepository {
    /**
     * 
     * @type {string}
     * @memberof GitRepository
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GitRepository
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GitRepository
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof GitRepository
     */
    'default_branch'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GitRepository
     */
    'is_private'?: boolean;
}
/**
 * 
 * @export
 * @interface GitRepositoryBranch
 */
export interface GitRepositoryBranch {
    /**
     * 
     * @type {string}
     * @memberof GitRepositoryBranch
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface GitRepositoryBranchResponseList
 */
export interface GitRepositoryBranchResponseList {
    /**
     * 
     * @type {Array<GitRepositoryBranch>}
     * @memberof GitRepositoryBranchResponseList
     */
    'results'?: Array<GitRepositoryBranch>;
}
/**
 * 
 * @export
 * @interface GitRepositoryResponseList
 */
export interface GitRepositoryResponseList {
    /**
     * 
     * @type {Array<GitRepository>}
     * @memberof GitRepositoryResponseList
     */
    'results'?: Array<GitRepository>;
}
/**
 * 
 * @export
 * @interface GitTokenAssociatedServiceResponse
 */
export interface GitTokenAssociatedServiceResponse {
    /**
     * 
     * @type {string}
     * @memberof GitTokenAssociatedServiceResponse
     */
    'project_id': string;
    /**
     * 
     * @type {string}
     * @memberof GitTokenAssociatedServiceResponse
     */
    'project_name': string;
    /**
     * 
     * @type {string}
     * @memberof GitTokenAssociatedServiceResponse
     */
    'environment_id': string;
    /**
     * 
     * @type {string}
     * @memberof GitTokenAssociatedServiceResponse
     */
    'environment_name': string;
    /**
     * 
     * @type {string}
     * @memberof GitTokenAssociatedServiceResponse
     */
    'service_id': string;
    /**
     * 
     * @type {string}
     * @memberof GitTokenAssociatedServiceResponse
     */
    'service_name': string;
    /**
     * 
     * @type {GitTokenAssociatedServiceType}
     * @memberof GitTokenAssociatedServiceResponse
     */
    'service_type': GitTokenAssociatedServiceType;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const GitTokenAssociatedServiceType = {
    APPLICATION: 'APPLICATION',
    CRON: 'CRON',
    LIFECYCLE: 'LIFECYCLE',
    HELM: 'HELM',
    TERRAFORM: 'TERRAFORM'
} as const;

export type GitTokenAssociatedServiceType = typeof GitTokenAssociatedServiceType[keyof typeof GitTokenAssociatedServiceType];


/**
 * 
 * @export
 * @interface GitTokenAssociatedServicesResponseList
 */
export interface GitTokenAssociatedServicesResponseList {
    /**
     * 
     * @type {Array<GitTokenAssociatedServiceResponse>}
     * @memberof GitTokenAssociatedServicesResponseList
     */
    'results'?: Array<GitTokenAssociatedServiceResponse>;
}
/**
 * 
 * @export
 * @interface GitTokenRequest
 */
export interface GitTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof GitTokenRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GitTokenRequest
     */
    'description'?: string;
    /**
     * 
     * @type {GitProviderEnum}
     * @memberof GitTokenRequest
     */
    'type': GitProviderEnum;
    /**
     * The token from your git provider side
     * @type {string}
     * @memberof GitTokenRequest
     */
    'token': string;
    /**
     * Mandatory only for BITBUCKET git provider, to allow us to fetch repositories at creation/edition of a service
     * @type {string}
     * @memberof GitTokenRequest
     */
    'workspace'?: string;
    /**
     * custom git api url for the given git provider/type. I.e: Self-hosted version of Gitlab
     * @type {string}
     * @memberof GitTokenRequest
     */
    'git_api_url'?: string;
}


/**
 * 
 * @export
 * @interface GitTokenResponse
 */
export interface GitTokenResponse {
    /**
     * 
     * @type {string}
     * @memberof GitTokenResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GitTokenResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof GitTokenResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof GitTokenResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GitTokenResponse
     */
    'description'?: string;
    /**
     * 
     * @type {GitProviderEnum}
     * @memberof GitTokenResponse
     */
    'type': GitProviderEnum;
    /**
     * 
     * @type {string}
     * @memberof GitTokenResponse
     */
    'expired_at'?: string;
    /**
     * Mandatory only for BITBUCKET git provider
     * @type {string}
     * @memberof GitTokenResponse
     */
    'workspace'?: string;
    /**
     * The number of services using this git token
     * @type {number}
     * @memberof GitTokenResponse
     */
    'associated_services_count': number;
    /**
     * 
     * @type {string}
     * @memberof GitTokenResponse
     */
    'git_api_url': string;
}


/**
 * 
 * @export
 * @interface GitTokenResponseList
 */
export interface GitTokenResponseList {
    /**
     * 
     * @type {Array<GitTokenResponse>}
     * @memberof GitTokenResponseList
     */
    'results'?: Array<GitTokenResponse>;
}
/**
 * 
 * @export
 * @interface GkeInfrastructureOutputs
 */
export interface GkeInfrastructureOutputs {
    /**
     * 
     * @type {string}
     * @memberof GkeInfrastructureOutputs
     */
    'kind': GkeInfrastructureOutputsKindEnum;
    /**
     * 
     * @type {string}
     * @memberof GkeInfrastructureOutputs
     */
    'cluster_name': string;
    /**
     * 
     * @type {string}
     * @memberof GkeInfrastructureOutputs
     */
    'cluster_self_link': string;
}

export const GkeInfrastructureOutputsKindEnum = {
    GKE: 'GKE'
} as const;

export type GkeInfrastructureOutputsKindEnum = typeof GkeInfrastructureOutputsKindEnum[keyof typeof GkeInfrastructureOutputsKindEnum];

/**
 * 
 * @export
 * @interface Healthcheck
 */
export interface Healthcheck {
    /**
     * 
     * @type {Probe}
     * @memberof Healthcheck
     */
    'readiness_probe'?: Probe | null;
    /**
     * 
     * @type {Probe}
     * @memberof Healthcheck
     */
    'liveness_probe'?: Probe | null;
}
/**
 * 
 * @export
 * @interface HelmAdvancedSettings
 */
export interface HelmAdvancedSettings {
    /**
     * disable custom domain check when deploying a helm
     * @type {boolean}
     * @memberof HelmAdvancedSettings
     */
    'deployment.custom_domain_check_enabled'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof HelmAdvancedSettings
     */
    'network.ingress.proxy_body_size_mb'?: number;
    /**
     * When using SSL offloading outside of cluster, you can enforce a redirect to HTTPS even when there is no TLS certificate available
     * @type {boolean}
     * @memberof HelmAdvancedSettings
     */
    'network.ingress.force_ssl_redirect'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HelmAdvancedSettings
     */
    'network.ingress.enable_cors'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof HelmAdvancedSettings
     */
    'network.ingress.cors_allow_origin'?: string;
    /**
     * 
     * @type {string}
     * @memberof HelmAdvancedSettings
     */
    'network.ingress.cors_allow_methods'?: string;
    /**
     * 
     * @type {string}
     * @memberof HelmAdvancedSettings
     */
    'network.ingress.cors_allow_headers'?: string;
    /**
     * header buffer size used while reading response header from upstream
     * @type {number}
     * @memberof HelmAdvancedSettings
     */
    'network.ingress.proxy_buffer_size_kb'?: number;
    /**
     * Limits the maximum time (in seconds) during which requests can be processed through one keepalive connection
     * @type {number}
     * @memberof HelmAdvancedSettings
     */
    'network.ingress.keepalive_time_seconds'?: number;
    /**
     * Sets a timeout (in seconds) during which an idle keepalive connection to an upstream server will stay open.
     * @type {number}
     * @memberof HelmAdvancedSettings
     */
    'network.ingress.keepalive_timeout_seconds'?: number;
    /**
     * Sets a timeout (in seconds) for transmitting a response to the client
     * @type {number}
     * @memberof HelmAdvancedSettings
     */
    'network.ingress.send_timeout_seconds'?: number;
    /**
     * Sets a timeout (in seconds) for establishing a connection to a proxied server
     * @type {number}
     * @memberof HelmAdvancedSettings
     */
    'network.ingress.proxy_connect_timeout_seconds'?: number;
    /**
     * Sets a timeout (in seconds) for transmitting a request to the proxied server
     * @type {number}
     * @memberof HelmAdvancedSettings
     */
    'network.ingress.proxy_send_timeout_seconds'?: number;
    /**
     * Sets a timeout (in seconds) for reading a response from the proxied server
     * @type {number}
     * @memberof HelmAdvancedSettings
     */
    'network.ingress.proxy_read_timeout_seconds'?: number;
    /**
     * Allows to enable or disable nginx `proxy-buffering`
     * @type {string}
     * @memberof HelmAdvancedSettings
     */
    'network.ingress.proxy_buffering'?: string;
    /**
     * Allows to enable or disable nginx `proxy-request-buffering`
     * @type {string}
     * @memberof HelmAdvancedSettings
     */
    'network.ingress.proxy_request_buffering'?: string;
    /**
     * Sets a timeout (in seconds) for transmitting a request to the grpc server
     * @type {number}
     * @memberof HelmAdvancedSettings
     */
    'network.ingress.grpc_send_timeout_seconds'?: number;
    /**
     * Sets a timeout (in seconds) for transmitting a request to the grpc server
     * @type {number}
     * @memberof HelmAdvancedSettings
     */
    'network.ingress.grpc_read_timeout_seconds'?: number;
    /**
     * list of source ranges to allow access to ingress proxy.  This property can be used to whitelist source IP ranges for ingress proxy. The value is a comma separated list of CIDRs, e.g. 10.0.0.0/24,172.10.0.1 To allow all source ranges, set 0.0.0.0/0. 
     * @type {string}
     * @memberof HelmAdvancedSettings
     */
    'network.ingress.whitelist_source_range'?: string;
    /**
     * list of source ranges to deny access to ingress proxy.  This property can be used to blacklist source IP ranges for ingress proxy. The value is a comma separated list of CIDRs, e.g. 10.0.0.0/24,172.10.0.1 
     * @type {string}
     * @memberof HelmAdvancedSettings
     */
    'network.ingress.denylist_source_range'?: string;
    /**
     * Allows to define response headers
     * @type {string}
     * @memberof HelmAdvancedSettings
     */
    'network.ingress.extra_headers'?: string;
    /**
     * Set the name of an environment variable to use as a basic authentication (`login:crypted_password`) from `htpasswd` command. You can add multiples comma separated values. 
     * @type {string}
     * @memberof HelmAdvancedSettings
     */
    'network.ingress.basic_auth_env_var'?: string;
    /**
     * Enable the load balancer to bind a user\'s session to a specific target. This ensures that all requests from the user during the session are sent to the same target 
     * @type {boolean}
     * @memberof HelmAdvancedSettings
     */
    'network.ingress.enable_sticky_session'?: boolean;
}
/**
 * 
 * @export
 * @interface HelmCheckRequest
 */
export interface HelmCheckRequest {
    /**
     * 
     * @type {HelmGitRepositoryRequest}
     * @memberof HelmCheckRequest
     */
    'git_repository': HelmGitRepositoryRequest;
}
/**
 * 
 * @export
 * @interface HelmDefaultValuesRequest
 */
export interface HelmDefaultValuesRequest {
    /**
     * 
     * @type {HelmDefaultValuesRequestAllOfSource}
     * @memberof HelmDefaultValuesRequest
     */
    'source': HelmDefaultValuesRequestAllOfSource;
}
/**
 * @type HelmDefaultValuesRequestAllOfSource
 * @export
 */
export type HelmDefaultValuesRequestAllOfSource = HelmRequestAllOfSourceOneOf | HelmRequestAllOfSourceOneOf1;

/**
 * 
 * @export
 * @interface HelmDeployRequest
 */
export interface HelmDeployRequest {
    /**
     * version of the chart to deploy. Cannot be set if `git_commit_id` is defined 
     * @type {string}
     * @memberof HelmDeployRequest
     */
    'chart_version'?: string;
    /**
     * Commit to deploy for chart source. Cannot be set if `version` is defined 
     * @type {string}
     * @memberof HelmDeployRequest
     */
    'git_commit_id'?: string;
    /**
     * Commit to deploy for values override 
     * @type {string}
     * @memberof HelmDeployRequest
     */
    'values_override_git_commit_id'?: string;
}
/**
 * 
 * @export
 * @interface HelmDeploymentRestrictionRequest
 */
export interface HelmDeploymentRestrictionRequest {
    /**
     * 
     * @type {DeploymentRestrictionModeEnum}
     * @memberof HelmDeploymentRestrictionRequest
     */
    'mode': DeploymentRestrictionModeEnum;
    /**
     * 
     * @type {DeploymentRestrictionTypeEnum}
     * @memberof HelmDeploymentRestrictionRequest
     */
    'type': DeploymentRestrictionTypeEnum;
    /**
     * For `PATH` restrictions, the value must not start with `/`
     * @type {string}
     * @memberof HelmDeploymentRestrictionRequest
     */
    'value': string;
}


/**
 * 
 * @export
 * @interface HelmDeploymentRestrictionResponse
 */
export interface HelmDeploymentRestrictionResponse {
    /**
     * 
     * @type {string}
     * @memberof HelmDeploymentRestrictionResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof HelmDeploymentRestrictionResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof HelmDeploymentRestrictionResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {DeploymentRestrictionModeEnum}
     * @memberof HelmDeploymentRestrictionResponse
     */
    'mode': DeploymentRestrictionModeEnum;
    /**
     * 
     * @type {DeploymentRestrictionTypeEnum}
     * @memberof HelmDeploymentRestrictionResponse
     */
    'type': DeploymentRestrictionTypeEnum;
    /**
     * For `PATH` restrictions, the value must not start with `/`
     * @type {string}
     * @memberof HelmDeploymentRestrictionResponse
     */
    'value': string;
}


/**
 * 
 * @export
 * @interface HelmDeploymentRestrictionResponseList
 */
export interface HelmDeploymentRestrictionResponseList {
    /**
     * 
     * @type {Array<HelmDeploymentRestrictionResponse>}
     * @memberof HelmDeploymentRestrictionResponseList
     */
    'results'?: Array<HelmDeploymentRestrictionResponse>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const HelmForceEvent = {
    DIFF: 'DIFF'
} as const;

export type HelmForceEvent = typeof HelmForceEvent[keyof typeof HelmForceEvent];


/**
 * 
 * @export
 * @interface HelmGitRepositoryRequest
 */
export interface HelmGitRepositoryRequest {
    /**
     * application git repository URL
     * @type {string}
     * @memberof HelmGitRepositoryRequest
     */
    'url': string;
    /**
     * Name of the branch to use. This is optional If not specified, then the branch used is the `main` or `master` one 
     * @type {string}
     * @memberof HelmGitRepositoryRequest
     */
    'branch'?: string;
    /**
     * indicates the root path of the application.
     * @type {string}
     * @memberof HelmGitRepositoryRequest
     */
    'root_path'?: string;
    /**
     * The git token id on Qovery side
     * @type {string}
     * @memberof HelmGitRepositoryRequest
     */
    'git_token_id'?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const HelmPortProtocolEnum = {
    HTTP: 'HTTP',
    GRPC: 'GRPC'
} as const;

export type HelmPortProtocolEnum = typeof HelmPortProtocolEnum[keyof typeof HelmPortProtocolEnum];


/**
 * 
 * @export
 * @interface HelmPortRequest
 */
export interface HelmPortRequest {
    /**
     * 
     * @type {Array<HelmPortRequestPortsInner>}
     * @memberof HelmPortRequest
     */
    'ports'?: Array<HelmPortRequestPortsInner>;
}
/**
 * 
 * @export
 * @interface HelmPortRequestPortsInner
 */
export interface HelmPortRequestPortsInner {
    /**
     * 
     * @type {string}
     * @memberof HelmPortRequestPortsInner
     */
    'name'?: string;
    /**
     * The listening port of your service.
     * @type {number}
     * @memberof HelmPortRequestPortsInner
     */
    'internal_port': number;
    /**
     * The exposed port for your service. This is optional. If not set a default port will be used.
     * @type {number}
     * @memberof HelmPortRequestPortsInner
     */
    'external_port'?: number;
    /**
     * 
     * @type {string}
     * @memberof HelmPortRequestPortsInner
     */
    'namespace'?: string;
    /**
     * 
     * @type {HelmPortProtocolEnum}
     * @memberof HelmPortRequestPortsInner
     */
    'protocol'?: HelmPortProtocolEnum;
    /**
     * is the default port to use for domain
     * @type {boolean}
     * @memberof HelmPortRequestPortsInner
     */
    'is_default'?: boolean;
    /**
     * 
     * @type {Array<KubernetesSelector>}
     * @memberof HelmPortRequestPortsInner
     */
    'service_selectors'?: Array<KubernetesSelector>;
    /**
     * 
     * @type {string}
     * @memberof HelmPortRequestPortsInner
     */
    'service_name'?: string;
}


/**
 * 
 * @export
 * @interface HelmPortRequestPortsInnerAllOfOneOf
 */
export interface HelmPortRequestPortsInnerAllOfOneOf {
    /**
     * 
     * @type {Array<KubernetesSelector>}
     * @memberof HelmPortRequestPortsInnerAllOfOneOf
     */
    'service_selectors'?: Array<KubernetesSelector>;
}
/**
 * 
 * @export
 * @interface HelmPortRequestPortsInnerAllOfOneOf1
 */
export interface HelmPortRequestPortsInnerAllOfOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof HelmPortRequestPortsInnerAllOfOneOf1
     */
    'service_name'?: string;
}
/**
 * 
 * @export
 * @interface HelmPortResponseBase
 */
export interface HelmPortResponseBase {
    /**
     * 
     * @type {string}
     * @memberof HelmPortResponseBase
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof HelmPortResponseBase
     */
    'port_type': string;
    /**
     * 
     * @type {string}
     * @memberof HelmPortResponseBase
     */
    'name'?: string;
    /**
     * The listening port of your service.
     * @type {number}
     * @memberof HelmPortResponseBase
     */
    'internal_port': number;
    /**
     * The exposed port for your service. This is optional. If not set a default port will be used.
     * @type {number}
     * @memberof HelmPortResponseBase
     */
    'external_port'?: number;
    /**
     * 
     * @type {string}
     * @memberof HelmPortResponseBase
     */
    'namespace'?: string;
    /**
     * 
     * @type {HelmPortProtocolEnum}
     * @memberof HelmPortResponseBase
     */
    'protocol': HelmPortProtocolEnum;
    /**
     * is the default port to use for domain
     * @type {boolean}
     * @memberof HelmPortResponseBase
     */
    'is_default'?: boolean;
}


/**
 * 
 * @export
 * @interface HelmPortResponseWithServiceName
 */
export interface HelmPortResponseWithServiceName {
    /**
     * 
     * @type {string}
     * @memberof HelmPortResponseWithServiceName
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof HelmPortResponseWithServiceName
     */
    'port_type': string;
    /**
     * 
     * @type {string}
     * @memberof HelmPortResponseWithServiceName
     */
    'name'?: string;
    /**
     * The listening port of your service.
     * @type {number}
     * @memberof HelmPortResponseWithServiceName
     */
    'internal_port': number;
    /**
     * The exposed port for your service. This is optional. If not set a default port will be used.
     * @type {number}
     * @memberof HelmPortResponseWithServiceName
     */
    'external_port'?: number;
    /**
     * 
     * @type {string}
     * @memberof HelmPortResponseWithServiceName
     */
    'namespace'?: string;
    /**
     * 
     * @type {HelmPortProtocolEnum}
     * @memberof HelmPortResponseWithServiceName
     */
    'protocol': HelmPortProtocolEnum;
    /**
     * is the default port to use for domain
     * @type {boolean}
     * @memberof HelmPortResponseWithServiceName
     */
    'is_default'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof HelmPortResponseWithServiceName
     */
    'service_name': string;
}


/**
 * 
 * @export
 * @interface HelmPortResponseWithServiceSelectors
 */
export interface HelmPortResponseWithServiceSelectors {
    /**
     * 
     * @type {string}
     * @memberof HelmPortResponseWithServiceSelectors
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof HelmPortResponseWithServiceSelectors
     */
    'port_type': string;
    /**
     * 
     * @type {string}
     * @memberof HelmPortResponseWithServiceSelectors
     */
    'name'?: string;
    /**
     * The listening port of your service.
     * @type {number}
     * @memberof HelmPortResponseWithServiceSelectors
     */
    'internal_port': number;
    /**
     * The exposed port for your service. This is optional. If not set a default port will be used.
     * @type {number}
     * @memberof HelmPortResponseWithServiceSelectors
     */
    'external_port'?: number;
    /**
     * 
     * @type {string}
     * @memberof HelmPortResponseWithServiceSelectors
     */
    'namespace'?: string;
    /**
     * 
     * @type {HelmPortProtocolEnum}
     * @memberof HelmPortResponseWithServiceSelectors
     */
    'protocol': HelmPortProtocolEnum;
    /**
     * is the default port to use for domain
     * @type {boolean}
     * @memberof HelmPortResponseWithServiceSelectors
     */
    'is_default'?: boolean;
    /**
     * 
     * @type {Array<KubernetesSelector>}
     * @memberof HelmPortResponseWithServiceSelectors
     */
    'service_selectors': Array<KubernetesSelector>;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const HelmRepositoryAssociatedServiceType = {
    HELM: 'HELM'
} as const;

export type HelmRepositoryAssociatedServiceType = typeof HelmRepositoryAssociatedServiceType[keyof typeof HelmRepositoryAssociatedServiceType];


/**
 * 
 * @export
 * @interface HelmRepositoryAssociatedServicesResponse
 */
export interface HelmRepositoryAssociatedServicesResponse {
    /**
     * 
     * @type {string}
     * @memberof HelmRepositoryAssociatedServicesResponse
     */
    'project_id': string;
    /**
     * 
     * @type {string}
     * @memberof HelmRepositoryAssociatedServicesResponse
     */
    'project_name': string;
    /**
     * 
     * @type {string}
     * @memberof HelmRepositoryAssociatedServicesResponse
     */
    'environment_id': string;
    /**
     * 
     * @type {string}
     * @memberof HelmRepositoryAssociatedServicesResponse
     */
    'environment_name': string;
    /**
     * 
     * @type {string}
     * @memberof HelmRepositoryAssociatedServicesResponse
     */
    'service_id': string;
    /**
     * 
     * @type {string}
     * @memberof HelmRepositoryAssociatedServicesResponse
     */
    'service_name': string;
    /**
     * 
     * @type {HelmRepositoryAssociatedServiceType}
     * @memberof HelmRepositoryAssociatedServicesResponse
     */
    'service_type': HelmRepositoryAssociatedServiceType;
}


/**
 * 
 * @export
 * @interface HelmRepositoryAssociatedServicesResponseList
 */
export interface HelmRepositoryAssociatedServicesResponseList {
    /**
     * 
     * @type {Array<HelmRepositoryAssociatedServicesResponse>}
     * @memberof HelmRepositoryAssociatedServicesResponseList
     */
    'results'?: Array<HelmRepositoryAssociatedServicesResponse>;
}
/**
 * The type of your helm repository
 * @export
 * @enum {string}
 */

export const HelmRepositoryKindEnum = {
    HTTPS: 'HTTPS',
    OCI_ECR: 'OCI_ECR',
    OCI_SCALEWAY_CR: 'OCI_SCALEWAY_CR',
    OCI_DOCKER_HUB: 'OCI_DOCKER_HUB',
    OCI_PUBLIC_ECR: 'OCI_PUBLIC_ECR',
    OCI_GENERIC_CR: 'OCI_GENERIC_CR',
    OCI_GITHUB_CR: 'OCI_GITHUB_CR',
    OCI_GITLAB_CR: 'OCI_GITLAB_CR'
} as const;

export type HelmRepositoryKindEnum = typeof HelmRepositoryKindEnum[keyof typeof HelmRepositoryKindEnum];


/**
 * 
 * @export
 * @interface HelmRepositoryRequest
 */
export interface HelmRepositoryRequest {
    /**
     * 
     * @type {string}
     * @memberof HelmRepositoryRequest
     */
    'name': string;
    /**
     * 
     * @type {HelmRepositoryKindEnum}
     * @memberof HelmRepositoryRequest
     */
    'kind': HelmRepositoryKindEnum;
    /**
     * 
     * @type {string}
     * @memberof HelmRepositoryRequest
     */
    'description'?: string;
    /**
     * URL of the helm chart repository: * For `OCI`: it must start by oci:// * For `HTTPS`: it must be start by https:// 
     * @type {string}
     * @memberof HelmRepositoryRequest
     */
    'url'?: string;
    /**
     * Bypass tls certificate verification when connecting to repository
     * @type {boolean}
     * @memberof HelmRepositoryRequest
     */
    'skip_tls_verification': boolean;
    /**
     * 
     * @type {HelmRepositoryRequestConfig}
     * @memberof HelmRepositoryRequest
     */
    'config': HelmRepositoryRequestConfig;
}


/**
 * 
 * @export
 * @interface HelmRepositoryRequestConfig
 */
export interface HelmRepositoryRequestConfig {
    /**
     * Required if the repository is private
     * @type {string}
     * @memberof HelmRepositoryRequestConfig
     */
    'username'?: string;
    /**
     * Required if the repository is private
     * @type {string}
     * @memberof HelmRepositoryRequestConfig
     */
    'password'?: string;
    /**
     * Required if kind is `ECR` or `PUBLIC_ECR`
     * @type {string}
     * @memberof HelmRepositoryRequestConfig
     */
    'access_key_id'?: string;
    /**
     * Required if kind is `ECR` or `PUBLIC_ECR`
     * @type {string}
     * @memberof HelmRepositoryRequestConfig
     */
    'secret_access_key'?: string;
    /**
     * Required if kind is `ECR` or `SCALEWAY_CR`
     * @type {string}
     * @memberof HelmRepositoryRequestConfig
     */
    'region'?: string;
    /**
     * Required if kind is `SCALEWAY_CR`
     * @type {string}
     * @memberof HelmRepositoryRequestConfig
     */
    'scaleway_access_key'?: string;
    /**
     * Required if kind is `SCALEWAY_CR`
     * @type {string}
     * @memberof HelmRepositoryRequestConfig
     */
    'scaleway_secret_key'?: string;
    /**
     * Required if kind is `SCALEWAY_CR`
     * @type {string}
     * @memberof HelmRepositoryRequestConfig
     */
    'scaleway_project_id'?: string;
    /**
     * Required if kind is `AZURE_CR`.
     * @type {string}
     * @memberof HelmRepositoryRequestConfig
     */
    'azure_tenant_id'?: string;
    /**
     * Required if kind is `AZURE_CR`.
     * @type {string}
     * @memberof HelmRepositoryRequestConfig
     */
    'azure_subscription_id'?: string;
    /**
     * For ECR, you can either set a static access_key or use a role arn that we are going to assume
     * @type {string}
     * @memberof HelmRepositoryRequestConfig
     */
    'role_arn'?: string;
}
/**
 * 
 * @export
 * @interface HelmRepositoryResponse
 */
export interface HelmRepositoryResponse {
    /**
     * 
     * @type {string}
     * @memberof HelmRepositoryResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof HelmRepositoryResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof HelmRepositoryResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof HelmRepositoryResponse
     */
    'name': string;
    /**
     * 
     * @type {HelmRepositoryKindEnum}
     * @memberof HelmRepositoryResponse
     */
    'kind'?: HelmRepositoryKindEnum;
    /**
     * 
     * @type {string}
     * @memberof HelmRepositoryResponse
     */
    'description'?: string;
    /**
     * URL of the helm repository
     * @type {string}
     * @memberof HelmRepositoryResponse
     */
    'url'?: string;
    /**
     * Bypass tls certificate verification when connecting to repository
     * @type {boolean}
     * @memberof HelmRepositoryResponse
     */
    'skip_tls_verification'?: boolean;
    /**
     * The number of services using this helm repository
     * @type {number}
     * @memberof HelmRepositoryResponse
     */
    'associated_services_count'?: number;
    /**
     * 
     * @type {HelmRepositoryResponseAllOfConfig}
     * @memberof HelmRepositoryResponse
     */
    'config'?: HelmRepositoryResponseAllOfConfig;
}


/**
 * 
 * @export
 * @interface HelmRepositoryResponseAllOfConfig
 */
export interface HelmRepositoryResponseAllOfConfig {
    /**
     * 
     * @type {string}
     * @memberof HelmRepositoryResponseAllOfConfig
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof HelmRepositoryResponseAllOfConfig
     */
    'region'?: string;
    /**
     * 
     * @type {string}
     * @memberof HelmRepositoryResponseAllOfConfig
     */
    'access_key_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof HelmRepositoryResponseAllOfConfig
     */
    'role_arn'?: string;
    /**
     * 
     * @type {string}
     * @memberof HelmRepositoryResponseAllOfConfig
     */
    'scaleway_access_key'?: string;
    /**
     * 
     * @type {string}
     * @memberof HelmRepositoryResponseAllOfConfig
     */
    'scaleway_project_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof HelmRepositoryResponseAllOfConfig
     */
    'azure_tenant_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof HelmRepositoryResponseAllOfConfig
     */
    'azure_subscription_id'?: string;
}
/**
 * 
 * @export
 * @interface HelmRepositoryResponseList
 */
export interface HelmRepositoryResponseList {
    /**
     * 
     * @type {Array<HelmRepositoryResponse>}
     * @memberof HelmRepositoryResponseList
     */
    'results'?: Array<HelmRepositoryResponse>;
}
/**
 * 
 * @export
 * @interface HelmRequest
 */
export interface HelmRequest {
    /**
     * 
     * @type {Array<HelmPortRequestPortsInner>}
     * @memberof HelmRequest
     */
    'ports'?: Array<HelmPortRequestPortsInner>;
    /**
     * name is case insensitive
     * @type {string}
     * @memberof HelmRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof HelmRequest
     */
    'description'?: string;
    /**
     * Maximum number of seconds allowed for helm to run before killing it and mark it as failed 
     * @type {number}
     * @memberof HelmRequest
     */
    'timeout_sec'?: number;
    /**
     * Indicates if the \'environment preview option\' is enabled.   If enabled, a preview environment will be automatically cloned when `/preview` endpoint is called or when a new commit is updated. If not specified, it takes the value of the `auto_preview` property from the associated environment. 
     * @type {boolean}
     * @memberof HelmRequest
     */
    'auto_preview'?: boolean | null;
    /**
     * Specify if the helm will be automatically updated after receiving a new image tag or a new commit according to the source type. 
     * @type {boolean}
     * @memberof HelmRequest
     */
    'auto_deploy': boolean;
    /**
     * 
     * @type {HelmRequestAllOfSource}
     * @memberof HelmRequest
     */
    'source': HelmRequestAllOfSource;
    /**
     * The extra arguments to pass to helm
     * @type {Array<string>}
     * @memberof HelmRequest
     */
    'arguments': Array<string>;
    /**
     * If we should allow the chart to deploy object outside his specified namespace. Setting this flag to true, requires special rights 
     * @type {boolean}
     * @memberof HelmRequest
     */
    'allow_cluster_wide_resources'?: boolean;
    /**
     * 
     * @type {HelmRequestAllOfValuesOverride}
     * @memberof HelmRequest
     */
    'values_override': HelmRequestAllOfValuesOverride;
    /**
     * Icon URI representing the helm service.
     * @type {string}
     * @memberof HelmRequest
     */
    'icon_uri'?: string;
}
/**
 * @type HelmRequestAllOfSource
 * @export
 */
export type HelmRequestAllOfSource = HelmRequestAllOfSourceOneOf | HelmRequestAllOfSourceOneOf1;

/**
 * 
 * @export
 * @interface HelmRequestAllOfSourceOneOf
 */
export interface HelmRequestAllOfSourceOneOf {
    /**
     * 
     * @type {HelmGitRepositoryRequest}
     * @memberof HelmRequestAllOfSourceOneOf
     */
    'git_repository'?: HelmGitRepositoryRequest;
}
/**
 * 
 * @export
 * @interface HelmRequestAllOfSourceOneOf1
 */
export interface HelmRequestAllOfSourceOneOf1 {
    /**
     * 
     * @type {HelmRequestAllOfSourceOneOf1HelmRepository}
     * @memberof HelmRequestAllOfSourceOneOf1
     */
    'helm_repository'?: HelmRequestAllOfSourceOneOf1HelmRepository;
}
/**
 * 
 * @export
 * @interface HelmRequestAllOfSourceOneOf1HelmRepository
 */
export interface HelmRequestAllOfSourceOneOf1HelmRepository {
    /**
     * The id of the helm repository
     * @type {string}
     * @memberof HelmRequestAllOfSourceOneOf1HelmRepository
     */
    'repository'?: string | null;
    /**
     * The name of the chart in the repository
     * @type {string}
     * @memberof HelmRequestAllOfSourceOneOf1HelmRepository
     */
    'chart_name'?: string;
    /**
     * The version of the chart to use
     * @type {string}
     * @memberof HelmRequestAllOfSourceOneOf1HelmRepository
     */
    'chart_version'?: string;
}
/**
 * Specify helm values you want to set or override 
 * @export
 * @interface HelmRequestAllOfValuesOverride
 */
export interface HelmRequestAllOfValuesOverride {
    /**
     * The input is in json array format: [ [$KEY,$VALUE], [...] ]
     * @type {Array<Array<string>>}
     * @memberof HelmRequestAllOfValuesOverride
     */
    'set'?: Array<Array<string>>;
    /**
     * The input is in json array format: [ [$KEY,$VALUE], [...] ]
     * @type {Array<Array<string>>}
     * @memberof HelmRequestAllOfValuesOverride
     */
    'set_string'?: Array<Array<string>>;
    /**
     * The input is in json array format: [ [$KEY,$VALUE], [...] ]
     * @type {Array<Array<string>>}
     * @memberof HelmRequestAllOfValuesOverride
     */
    'set_json'?: Array<Array<string>>;
    /**
     * 
     * @type {HelmRequestAllOfValuesOverrideFile}
     * @memberof HelmRequestAllOfValuesOverride
     */
    'file'?: HelmRequestAllOfValuesOverrideFile | null;
}
/**
 * 
 * @export
 * @interface HelmRequestAllOfValuesOverrideFile
 */
export interface HelmRequestAllOfValuesOverrideFile {
    /**
     * 
     * @type {HelmRequestAllOfValuesOverrideFileGit}
     * @memberof HelmRequestAllOfValuesOverrideFile
     */
    'git'?: HelmRequestAllOfValuesOverrideFileGit | null;
    /**
     * 
     * @type {HelmRequestAllOfValuesOverrideFileRaw}
     * @memberof HelmRequestAllOfValuesOverrideFile
     */
    'raw'?: HelmRequestAllOfValuesOverrideFileRaw | null;
}
/**
 * 
 * @export
 * @interface HelmRequestAllOfValuesOverrideFileGit
 */
export interface HelmRequestAllOfValuesOverrideFileGit {
    /**
     * 
     * @type {ApplicationGitRepositoryRequest}
     * @memberof HelmRequestAllOfValuesOverrideFileGit
     */
    'git_repository': ApplicationGitRepositoryRequest;
    /**
     * List of path inside your git repository to locate values file. Must start by a /
     * @type {Array<string>}
     * @memberof HelmRequestAllOfValuesOverrideFileGit
     */
    'paths': Array<string>;
}
/**
 * 
 * @export
 * @interface HelmRequestAllOfValuesOverrideFileRaw
 */
export interface HelmRequestAllOfValuesOverrideFileRaw {
    /**
     * 
     * @type {Array<HelmRequestAllOfValuesOverrideFileRawValues>}
     * @memberof HelmRequestAllOfValuesOverrideFileRaw
     */
    'values'?: Array<HelmRequestAllOfValuesOverrideFileRawValues>;
}
/**
 * 
 * @export
 * @interface HelmRequestAllOfValuesOverrideFileRawValues
 */
export interface HelmRequestAllOfValuesOverrideFileRawValues {
    /**
     * The name of the value file
     * @type {string}
     * @memberof HelmRequestAllOfValuesOverrideFileRawValues
     */
    'name'?: string;
    /**
     * The content of the value file
     * @type {string}
     * @memberof HelmRequestAllOfValuesOverrideFileRawValues
     */
    'content'?: string;
}
/**
 * 
 * @export
 * @interface HelmResponse
 */
export interface HelmResponse {
    /**
     * 
     * @type {string}
     * @memberof HelmResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof HelmResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof HelmResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {ReferenceObject}
     * @memberof HelmResponse
     */
    'environment': ReferenceObject;
    /**
     * name is case insensitive
     * @type {string}
     * @memberof HelmResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof HelmResponse
     */
    'description'?: string;
    /**
     * Maximum number of seconds allowed for helm to run before killing it and mark it as failed 
     * @type {number}
     * @memberof HelmResponse
     */
    'timeout_sec'?: number;
    /**
     * Indicates if the \'environment preview option\' is enabled.   If enabled, a preview environment will be automatically cloned when `/preview` endpoint is called.   If not specified, it takes the value of the `auto_preview` property from the associated environment. 
     * @type {boolean}
     * @memberof HelmResponse
     */
    'auto_preview': boolean;
    /**
     * Specify if the service will be automatically updated after receiving a new image tag or a new commit according to the source type. 
     * @type {boolean}
     * @memberof HelmResponse
     */
    'auto_deploy': boolean;
    /**
     * 
     * @type {Array<HelmResponseAllOfPorts>}
     * @memberof HelmResponse
     */
    'ports'?: Array<HelmResponseAllOfPorts>;
    /**
     * 
     * @type {HelmResponseAllOfSource}
     * @memberof HelmResponse
     */
    'source': HelmResponseAllOfSource;
    /**
     * The extra arguments to pass to helm
     * @type {Array<string>}
     * @memberof HelmResponse
     */
    'arguments': Array<string>;
    /**
     * If we should allow the chart to deploy object outside his specified namespace. Setting this flag to true, requires special rights 
     * @type {boolean}
     * @memberof HelmResponse
     */
    'allow_cluster_wide_resources': boolean;
    /**
     * 
     * @type {HelmResponseAllOfValuesOverride}
     * @memberof HelmResponse
     */
    'values_override': HelmResponseAllOfValuesOverride;
    /**
     * Icon URI representing the helm service.
     * @type {string}
     * @memberof HelmResponse
     */
    'icon_uri': string;
    /**
     * 
     * @type {ServiceTypeEnum}
     * @memberof HelmResponse
     */
    'service_type': ServiceTypeEnum;
}


/**
 * @type HelmResponseAllOfPorts
 * @export
 */
export type HelmResponseAllOfPorts = { port_type: 'SERVICE_NAME' } & HelmPortResponseWithServiceName | { port_type: 'SERVICE_SELECTORS' } & HelmPortResponseWithServiceSelectors;

/**
 * @type HelmResponseAllOfSource
 * @export
 */
export type HelmResponseAllOfSource = HelmResponseAllOfSourceOneOf | HelmResponseAllOfSourceOneOf1;

/**
 * 
 * @export
 * @interface HelmResponseAllOfSourceOneOf
 */
export interface HelmResponseAllOfSourceOneOf {
    /**
     * 
     * @type {HelmSourceGitResponse}
     * @memberof HelmResponseAllOfSourceOneOf
     */
    'git': HelmSourceGitResponse;
}
/**
 * 
 * @export
 * @interface HelmResponseAllOfSourceOneOf1
 */
export interface HelmResponseAllOfSourceOneOf1 {
    /**
     * 
     * @type {HelmSourceRepositoryResponse}
     * @memberof HelmResponseAllOfSourceOneOf1
     */
    'repository': HelmSourceRepositoryResponse;
}
/**
 * Specify helm values you want to set or override 
 * @export
 * @interface HelmResponseAllOfValuesOverride
 */
export interface HelmResponseAllOfValuesOverride {
    /**
     * The input is in json array format: [ [$KEY,$VALUE], [...] ]
     * @type {Array<Array<string>>}
     * @memberof HelmResponseAllOfValuesOverride
     */
    'set'?: Array<Array<string>>;
    /**
     * The input is in json array format: [ [$KEY,$VALUE], [...] ]
     * @type {Array<Array<string>>}
     * @memberof HelmResponseAllOfValuesOverride
     */
    'set_string'?: Array<Array<string>>;
    /**
     * The input is in json array format: [ [$KEY,$VALUE], [...] ]
     * @type {Array<Array<string>>}
     * @memberof HelmResponseAllOfValuesOverride
     */
    'set_json'?: Array<Array<string>>;
    /**
     * 
     * @type {HelmResponseAllOfValuesOverrideFile}
     * @memberof HelmResponseAllOfValuesOverride
     */
    'file'?: HelmResponseAllOfValuesOverrideFile | null;
}
/**
 * 
 * @export
 * @interface HelmResponseAllOfValuesOverrideFile
 */
export interface HelmResponseAllOfValuesOverrideFile {
    /**
     * 
     * @type {HelmResponseAllOfValuesOverrideFileRaw}
     * @memberof HelmResponseAllOfValuesOverrideFile
     */
    'raw'?: HelmResponseAllOfValuesOverrideFileRaw | null;
    /**
     * 
     * @type {HelmResponseAllOfValuesOverrideFileGit}
     * @memberof HelmResponseAllOfValuesOverrideFile
     */
    'git'?: HelmResponseAllOfValuesOverrideFileGit | null;
}
/**
 * 
 * @export
 * @interface HelmResponseAllOfValuesOverrideFileGit
 */
export interface HelmResponseAllOfValuesOverrideFileGit {
    /**
     * 
     * @type {ApplicationGitRepository}
     * @memberof HelmResponseAllOfValuesOverrideFileGit
     */
    'git_repository': ApplicationGitRepository;
    /**
     * List of path inside your git repository to locate values file. Must start by a /
     * @type {Array<string>}
     * @memberof HelmResponseAllOfValuesOverrideFileGit
     */
    'paths': Array<string>;
}
/**
 * 
 * @export
 * @interface HelmResponseAllOfValuesOverrideFileRaw
 */
export interface HelmResponseAllOfValuesOverrideFileRaw {
    /**
     * 
     * @type {Array<HelmResponseAllOfValuesOverrideFileRawValues>}
     * @memberof HelmResponseAllOfValuesOverrideFileRaw
     */
    'values': Array<HelmResponseAllOfValuesOverrideFileRawValues>;
}
/**
 * 
 * @export
 * @interface HelmResponseAllOfValuesOverrideFileRawValues
 */
export interface HelmResponseAllOfValuesOverrideFileRawValues {
    /**
     * The name of the value file
     * @type {string}
     * @memberof HelmResponseAllOfValuesOverrideFileRawValues
     */
    'name': string;
    /**
     * The content of the value file
     * @type {string}
     * @memberof HelmResponseAllOfValuesOverrideFileRawValues
     */
    'content': string;
}
/**
 * 
 * @export
 * @interface HelmResponseList
 */
export interface HelmResponseList {
    /**
     * 
     * @type {Array<HelmResponse>}
     * @memberof HelmResponseList
     */
    'results'?: Array<HelmResponse>;
}
/**
 * 
 * @export
 * @interface HelmSourceGitResponse
 */
export interface HelmSourceGitResponse {
    /**
     * 
     * @type {ApplicationGitRepository}
     * @memberof HelmSourceGitResponse
     */
    'git_repository': ApplicationGitRepository;
}
/**
 * 
 * @export
 * @interface HelmSourceRepositoryResponse
 */
export interface HelmSourceRepositoryResponse {
    /**
     * 
     * @type {string}
     * @memberof HelmSourceRepositoryResponse
     */
    'chart_name': string;
    /**
     * 
     * @type {string}
     * @memberof HelmSourceRepositoryResponse
     */
    'chart_version': string;
    /**
     * 
     * @type {HelmSourceRepositoryResponseRepository}
     * @memberof HelmSourceRepositoryResponse
     */
    'repository': HelmSourceRepositoryResponseRepository;
}
/**
 * 
 * @export
 * @interface HelmSourceRepositoryResponseRepository
 */
export interface HelmSourceRepositoryResponseRepository {
    /**
     * 
     * @type {string}
     * @memberof HelmSourceRepositoryResponseRepository
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof HelmSourceRepositoryResponseRepository
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof HelmSourceRepositoryResponseRepository
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface HelmVersionResponse
 */
export interface HelmVersionResponse {
    /**
     * 
     * @type {string}
     * @memberof HelmVersionResponse
     */
    'chart_name'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof HelmVersionResponse
     */
    'versions'?: Array<string>;
}
/**
 * 
 * @export
 * @interface HelmVersionResponseList
 */
export interface HelmVersionResponseList {
    /**
     * 
     * @type {Array<HelmVersionResponse>}
     * @memberof HelmVersionResponseList
     */
    'results'?: Array<HelmVersionResponse>;
}
/**
 * @type InfrastructureOutputs
 * @export
 */
export type InfrastructureOutputs = { kind: 'AKS' } & AksInfrastructureOutputs | { kind: 'EKS' } & EksInfrastructureOutputs | { kind: 'GKE' } & GkeInfrastructureOutputs | { kind: 'SCW_KAPSULE' } & KapsuleInfrastructureOutputs;

/**
 * 
 * @export
 * @interface IngressDeploymentStatusResponse
 */
export interface IngressDeploymentStatusResponse {
    /**
     * 
     * @type {string}
     * @memberof IngressDeploymentStatusResponse
     */
    'routerId'?: string;
    /**
     * 
     * @type {StateEnum}
     * @memberof IngressDeploymentStatusResponse
     */
    'status'?: StateEnum;
}


/**
 * 
 * @export
 * @interface InternalNetworkMonitoring
 */
export interface InternalNetworkMonitoring {
    /**
     * 
     * @type {boolean}
     * @memberof InternalNetworkMonitoring
     */
    'enabled': boolean;
}
/**
 * 
 * @export
 * @interface InviteMember
 */
export interface InviteMember {
    /**
     * 
     * @type {string}
     * @memberof InviteMember
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof InviteMember
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof InviteMember
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof InviteMember
     */
    'email': string;
    /**
     * 
     * @type {InviteMemberRoleEnum}
     * @memberof InviteMember
     */
    'role': InviteMemberRoleEnum;
    /**
     * 
     * @type {string}
     * @memberof InviteMember
     */
    'invitation_link': string;
    /**
     * 
     * @type {InviteStatusEnum}
     * @memberof InviteMember
     */
    'invitation_status': InviteStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof InviteMember
     */
    'organization_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof InviteMember
     */
    'inviter': string;
    /**
     * 
     * @type {string}
     * @memberof InviteMember
     */
    'logo_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof InviteMember
     */
    'role_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof InviteMember
     */
    'role_name'?: string;
}


/**
 * 
 * @export
 * @interface InviteMemberRequest
 */
export interface InviteMemberRequest {
    /**
     * 
     * @type {string}
     * @memberof InviteMemberRequest
     */
    'email': string;
    /**
     * 
     * @type {InviteMemberRoleEnum}
     * @memberof InviteMemberRequest
     */
    'role'?: InviteMemberRoleEnum;
    /**
     * the target role to attribute to the new member
     * @type {string}
     * @memberof InviteMemberRequest
     */
    'role_id'?: string;
}


/**
 * 
 * @export
 * @interface InviteMemberResponseList
 */
export interface InviteMemberResponseList {
    /**
     * 
     * @type {Array<InviteMember>}
     * @memberof InviteMemberResponseList
     */
    'results'?: Array<InviteMember>;
}
/**
 * deprecated
 * @export
 * @enum {string}
 */

export const InviteMemberRoleEnum = {
    ADMIN: 'ADMIN',
    DEVELOPER: 'DEVELOPER',
    OWNER: 'OWNER',
    VIEWER: 'VIEWER'
} as const;

export type InviteMemberRoleEnum = typeof InviteMemberRoleEnum[keyof typeof InviteMemberRoleEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const InviteStatusEnum = {
    EXPIRED: 'EXPIRED',
    PENDING: 'PENDING'
} as const;

export type InviteStatusEnum = typeof InviteStatusEnum[keyof typeof InviteStatusEnum];


/**
 * 
 * @export
 * @interface Invoice
 */
export interface Invoice {
    /**
     * 
     * @type {number}
     * @memberof Invoice
     */
    'total_in_cents': number;
    /**
     * 
     * @type {number}
     * @memberof Invoice
     */
    'total': number;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'currency_code': string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'created_at': string;
    /**
     * 
     * @type {InvoiceStatusEnum}
     * @memberof Invoice
     */
    'status': InvoiceStatusEnum;
}


/**
 * 
 * @export
 * @interface InvoiceResponseList
 */
export interface InvoiceResponseList {
    /**
     * 
     * @type {Array<Invoice>}
     * @memberof InvoiceResponseList
     */
    'results'?: Array<Invoice>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const InvoiceStatusEnum = {
    NOT_PAID: 'NOT_PAID',
    PAID: 'PAID',
    PAYMENT_DUE: 'PAYMENT_DUE',
    PENDING: 'PENDING',
    POSTED: 'POSTED',
    UNKNOWN: 'UNKNOWN',
    VOIDED: 'VOIDED'
} as const;

export type InvoiceStatusEnum = typeof InvoiceStatusEnum[keyof typeof InvoiceStatusEnum];


/**
 * 
 * @export
 * @interface JobAdvancedSettings
 */
export interface JobAdvancedSettings {
    /**
     * define the max timeout for the build
     * @type {number}
     * @memberof JobAdvancedSettings
     */
    'build.timeout_max_sec'?: number;
    /**
     * define the max cpu resources (in milli)
     * @type {number}
     * @memberof JobAdvancedSettings
     */
    'build.cpu_max_in_milli'?: number;
    /**
     * define the max ram resources (in gib)
     * @type {number}
     * @memberof JobAdvancedSettings
     */
    'build.ram_max_in_gib'?: number;
    /**
     * disable buildkit registry cache during build
     * @type {boolean}
     * @memberof JobAdvancedSettings
     */
    'build.disable_buildkit_cache'?: boolean;
    /**
     * define how long in seconds an application is supposed to be stopped gracefully
     * @type {number}
     * @memberof JobAdvancedSettings
     */
    'deployment.termination_grace_period_seconds'?: number;
    /**
     * Set pod placement on specific Kubernetes nodes labels
     * @type {{ [key: string]: string; }}
     * @memberof JobAdvancedSettings
     */
    'deployment.affinity.node.required'?: { [key: string]: string; };
    /**
     * 
     * @type {number}
     * @memberof JobAdvancedSettings
     */
    'job.delete_ttl_seconds_after_finished'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof JobAdvancedSettings
     */
    'cronjob.concurrency_policy'?: string;
    /**
     * 
     * @type {number}
     * @memberof JobAdvancedSettings
     */
    'cronjob.failed_jobs_history_limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof JobAdvancedSettings
     */
    'cronjob.success_jobs_history_limit'?: number;
    /**
     * Allows you to set an existing Kubernetes service account name 
     * @type {string}
     * @memberof JobAdvancedSettings
     */
    'security.service_account_name'?: string;
    /**
     * Automount Kubernetes service account token to have access to Kubernetes API from pods 
     * @type {boolean}
     * @memberof JobAdvancedSettings
     */
    'security.automount_service_account_token'?: boolean;
    /**
     * Mounts the container\'s root filesystem as read-only 
     * @type {boolean}
     * @memberof JobAdvancedSettings
     */
    'security.read_only_root_filesystem'?: boolean;
}
/**
 * 
 * @export
 * @interface JobCronSchedule
 */
export interface JobCronSchedule {
    /**
     * 
     * @type {Array<string>}
     * @memberof JobCronSchedule
     */
    'arguments': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof JobCronSchedule
     */
    'entrypoint'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobCronSchedule
     */
    'scheduled_at': string;
    /**
     * 
     * @type {string}
     * @memberof JobCronSchedule
     */
    'timezone': string;
}
/**
 * 
 * @export
 * @interface JobDeployRequest
 */
export interface JobDeployRequest {
    /**
     * Image tag to deploy.   Cannot be set if `git_commit_id` is defined 
     * @type {string}
     * @memberof JobDeployRequest
     */
    'image_tag'?: string;
    /**
     * Commit to deploy Cannot be set if `image_tag` is defined 
     * @type {string}
     * @memberof JobDeployRequest
     */
    'git_commit_id'?: string;
}
/**
 * 
 * @export
 * @interface JobDeploymentRestrictionRequest
 */
export interface JobDeploymentRestrictionRequest {
    /**
     * 
     * @type {DeploymentRestrictionModeEnum}
     * @memberof JobDeploymentRestrictionRequest
     */
    'mode': DeploymentRestrictionModeEnum;
    /**
     * 
     * @type {DeploymentRestrictionTypeEnum}
     * @memberof JobDeploymentRestrictionRequest
     */
    'type': DeploymentRestrictionTypeEnum;
    /**
     * For `PATH` restrictions, the value must not start with `/`
     * @type {string}
     * @memberof JobDeploymentRestrictionRequest
     */
    'value': string;
}


/**
 * 
 * @export
 * @interface JobDeploymentRestrictionResponse
 */
export interface JobDeploymentRestrictionResponse {
    /**
     * 
     * @type {string}
     * @memberof JobDeploymentRestrictionResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof JobDeploymentRestrictionResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof JobDeploymentRestrictionResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {DeploymentRestrictionModeEnum}
     * @memberof JobDeploymentRestrictionResponse
     */
    'mode': DeploymentRestrictionModeEnum;
    /**
     * 
     * @type {DeploymentRestrictionTypeEnum}
     * @memberof JobDeploymentRestrictionResponse
     */
    'type': DeploymentRestrictionTypeEnum;
    /**
     * For `PATH` restrictions, the value must not start with `/`
     * @type {string}
     * @memberof JobDeploymentRestrictionResponse
     */
    'value': string;
}


/**
 * 
 * @export
 * @interface JobDeploymentRestrictionResponseList
 */
export interface JobDeploymentRestrictionResponseList {
    /**
     * 
     * @type {Array<JobDeploymentRestrictionResponse>}
     * @memberof JobDeploymentRestrictionResponseList
     */
    'results'?: Array<JobDeploymentRestrictionResponse>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const JobForceEvent = {
    START: 'START',
    STOP: 'STOP',
    DELETE: 'DELETE',
    CRON: 'CRON'
} as const;

export type JobForceEvent = typeof JobForceEvent[keyof typeof JobForceEvent];


/**
 * 
 * @export
 * @enum {string}
 */

export const JobLifecycleTypeEnum = {
    GENERIC: 'GENERIC',
    TERRAFORM: 'TERRAFORM',
    CLOUDFORMATION: 'CLOUDFORMATION'
} as const;

export type JobLifecycleTypeEnum = typeof JobLifecycleTypeEnum[keyof typeof JobLifecycleTypeEnum];


/**
 * 
 * @export
 * @interface JobLifecyleSchedule
 */
export interface JobLifecyleSchedule {
    /**
     * 
     * @type {Array<string>}
     * @memberof JobLifecyleSchedule
     */
    'arguments': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof JobLifecyleSchedule
     */
    'entrypoint'?: string;
}
/**
 * 
 * @export
 * @interface JobRequest
 */
export interface JobRequest {
    /**
     * name is case insensitive
     * @type {string}
     * @memberof JobRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof JobRequest
     */
    'description'?: string;
    /**
     * unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof JobRequest
     */
    'cpu'?: number;
    /**
     * unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof JobRequest
     */
    'memory'?: number;
    /**
     * 
     * @type {number}
     * @memberof JobRequest
     */
    'gpu'?: number;
    /**
     * Maximum number of restart allowed before the job is considered as failed 0 means that no restart/crash of the job is allowed 
     * @type {number}
     * @memberof JobRequest
     */
    'max_nb_restart'?: number;
    /**
     * Maximum number of seconds allowed for the job to run before killing it and mark it as failed 
     * @type {number}
     * @memberof JobRequest
     */
    'max_duration_seconds'?: number;
    /**
     * Indicates if the \'environment preview option\' is enabled for this container.   If enabled, a preview environment will be automatically cloned when `/preview` endpoint is called.   If not specified, it takes the value of the `auto_preview` property from the associated environment. 
     * @type {boolean}
     * @memberof JobRequest
     */
    'auto_preview'?: boolean;
    /**
     * Port where to run readiness and liveliness probes checks. The port will not be exposed externally
     * @type {number}
     * @memberof JobRequest
     */
    'port'?: number | null;
    /**
     * 
     * @type {JobRequestAllOfSource}
     * @memberof JobRequest
     */
    'source'?: JobRequestAllOfSource;
    /**
     * 
     * @type {Healthcheck}
     * @memberof JobRequest
     */
    'healthchecks': Healthcheck;
    /**
     * 
     * @type {JobRequestAllOfSchedule}
     * @memberof JobRequest
     */
    'schedule'?: JobRequestAllOfSchedule;
    /**
     * Specify if the job will be automatically updated after receiving a new image tag or a new commit according to the source type.  The new image tag shall be communicated via the \"Auto Deploy job\" endpoint https://api-doc.qovery.com/#tag/Jobs/operation/autoDeployJobEnvironments 
     * @type {boolean}
     * @memberof JobRequest
     */
    'auto_deploy'?: boolean | null;
    /**
     * 
     * @type {Array<ServiceAnnotationRequest>}
     * @memberof JobRequest
     */
    'annotations_groups'?: Array<ServiceAnnotationRequest>;
    /**
     * 
     * @type {Array<ServiceLabelRequest>}
     * @memberof JobRequest
     */
    'labels_groups'?: Array<ServiceLabelRequest>;
    /**
     * Icon URI representing the job.
     * @type {string}
     * @memberof JobRequest
     */
    'icon_uri'?: string;
}
/**
 * If you want to define a Cron job, only the `cronjob` property must be filled   A Lifecycle job should contain at least one property `on_XXX` among the 3 properties: `on_start`, `on_stop`, `on_delete` 
 * @export
 * @interface JobRequestAllOfSchedule
 */
export interface JobRequestAllOfSchedule {
    /**
     * 
     * @type {JobRequestAllOfScheduleOnStart}
     * @memberof JobRequestAllOfSchedule
     */
    'on_start'?: JobRequestAllOfScheduleOnStart;
    /**
     * 
     * @type {JobRequestAllOfScheduleOnStart}
     * @memberof JobRequestAllOfSchedule
     */
    'on_stop'?: JobRequestAllOfScheduleOnStart;
    /**
     * 
     * @type {JobRequestAllOfScheduleOnStart}
     * @memberof JobRequestAllOfSchedule
     */
    'on_delete'?: JobRequestAllOfScheduleOnStart;
    /**
     * 
     * @type {JobRequestAllOfScheduleCronjob}
     * @memberof JobRequestAllOfSchedule
     */
    'cronjob'?: JobRequestAllOfScheduleCronjob;
    /**
     * 
     * @type {JobLifecycleTypeEnum}
     * @memberof JobRequestAllOfSchedule
     */
    'lifecycle_type'?: JobLifecycleTypeEnum;
}


/**
 * 
 * @export
 * @interface JobRequestAllOfScheduleCronjob
 */
export interface JobRequestAllOfScheduleCronjob {
    /**
     * 
     * @type {Array<string>}
     * @memberof JobRequestAllOfScheduleCronjob
     */
    'arguments'?: Array<string>;
    /**
     * optional entrypoint when launching container
     * @type {string}
     * @memberof JobRequestAllOfScheduleCronjob
     */
    'entrypoint'?: string;
    /**
     * Specify a timezone identifier to run the schedule at. By default Etc/UTC
     * @type {string}
     * @memberof JobRequestAllOfScheduleCronjob
     */
    'timezone'?: string;
    /**
     * Can only be set if the event is CRON.   Represent the cron format for the job schedule without seconds.   For example: `* * * * *` represent the cron to launch the job every minute.   See https://crontab.guru/ to WISIWIG interface.   Timezone is UTC 
     * @type {string}
     * @memberof JobRequestAllOfScheduleCronjob
     */
    'scheduled_at': string;
}
/**
 * 
 * @export
 * @interface JobRequestAllOfScheduleOnStart
 */
export interface JobRequestAllOfScheduleOnStart {
    /**
     * 
     * @type {Array<string>}
     * @memberof JobRequestAllOfScheduleOnStart
     */
    'arguments'?: Array<string>;
    /**
     * optional entrypoint when launching container
     * @type {string}
     * @memberof JobRequestAllOfScheduleOnStart
     */
    'entrypoint'?: string;
}
/**
 * 
 * @export
 * @interface JobRequestAllOfSource
 */
export interface JobRequestAllOfSource {
    /**
     * 
     * @type {JobRequestAllOfSourceImage}
     * @memberof JobRequestAllOfSource
     */
    'image'?: JobRequestAllOfSourceImage | null;
    /**
     * 
     * @type {JobRequestAllOfSourceDocker}
     * @memberof JobRequestAllOfSource
     */
    'docker'?: JobRequestAllOfSourceDocker | null;
}
/**
 * 
 * @export
 * @interface JobRequestAllOfSourceDocker
 */
export interface JobRequestAllOfSourceDocker {
    /**
     * 
     * @type {ApplicationGitRepositoryRequest}
     * @memberof JobRequestAllOfSourceDocker
     */
    'git_repository'?: ApplicationGitRepositoryRequest;
    /**
     * The path of the associated Dockerfile. Only if you are using build_mode = DOCKER
     * @type {string}
     * @memberof JobRequestAllOfSourceDocker
     */
    'dockerfile_path'?: string | null;
    /**
     * The content of your dockerfile if it is not stored inside your git repository
     * @type {string}
     * @memberof JobRequestAllOfSourceDocker
     */
    'dockerfile_raw'?: string | null;
    /**
     * The target build stage in the Dockerfile to build
     * @type {string}
     * @memberof JobRequestAllOfSourceDocker
     */
    'docker_target_build_stage'?: string | null;
}
/**
 * 
 * @export
 * @interface JobRequestAllOfSourceImage
 */
export interface JobRequestAllOfSourceImage {
    /**
     * The image name pattern differs according to chosen container registry provider:   * `ECR`: `repository` * `SCALEWAY_CR`: `namespace/image` * `DOCKER_HUB`: `image` or `repository/image` * `PUBLIC_ECR`: `registry_alias/repository` 
     * @type {string}
     * @memberof JobRequestAllOfSourceImage
     */
    'image_name'?: string;
    /**
     * tag of the image container
     * @type {string}
     * @memberof JobRequestAllOfSourceImage
     */
    'tag'?: string;
    /**
     * tag of the image container
     * @type {string}
     * @memberof JobRequestAllOfSourceImage
     */
    'registry_id'?: string;
}
/**
 * @type JobResponse
 * @export
 */
export type JobResponse = { job_type: 'CRON' } & CronJobResponse | { job_type: 'LIFECYCLE' } & LifecycleJobResponse;

/**
 * 
 * @export
 * @interface JobResponseList
 */
export interface JobResponseList {
    /**
     * 
     * @type {Array<JobResponse>}
     * @memberof JobResponseList
     */
    'results'?: Array<JobResponse>;
}
/**
 * On which event the job is going to run.   ON_START means when a deployment is requested for the environment   ON_STOP means when a stop of the environment is requested   ON_DELETE means when an environment delete is requested   CRON means at a scheduled interval 
 * @export
 * @enum {string}
 */

export const JobScheduleEvent = {
    ON_START: 'ON_START',
    ON_STOP: 'ON_STOP',
    ON_DELETE: 'ON_DELETE',
    CRON: 'CRON'
} as const;

export type JobScheduleEvent = typeof JobScheduleEvent[keyof typeof JobScheduleEvent];


/**
 * 
 * @export
 * @interface JobSourceDockerResponse
 */
export interface JobSourceDockerResponse {
    /**
     * 
     * @type {ApplicationGitRepository}
     * @memberof JobSourceDockerResponse
     */
    'git_repository'?: ApplicationGitRepository;
    /**
     * The path of the associated Dockerfile. Only if you are using build_mode = DOCKER
     * @type {string}
     * @memberof JobSourceDockerResponse
     */
    'dockerfile_path'?: string | null;
    /**
     * The content of your dockerfile if it is not stored inside your git repository
     * @type {string}
     * @memberof JobSourceDockerResponse
     */
    'dockerfile_raw'?: string | null;
    /**
     * The target build stage in the Dockerfile to build
     * @type {string}
     * @memberof JobSourceDockerResponse
     */
    'docker_target_build_stage'?: string | null;
}
/**
 * type of job
 * @export
 * @enum {string}
 */

export const JobTypeEnum = {
    LIFECYCLE: 'LIFECYCLE',
    CRON: 'CRON'
} as const;

export type JobTypeEnum = typeof JobTypeEnum[keyof typeof JobTypeEnum];


/**
 * 
 * @export
 * @interface KapsuleInfrastructureOutputs
 */
export interface KapsuleInfrastructureOutputs {
    /**
     * 
     * @type {string}
     * @memberof KapsuleInfrastructureOutputs
     */
    'kind': KapsuleInfrastructureOutputsKindEnum;
    /**
     * 
     * @type {string}
     * @memberof KapsuleInfrastructureOutputs
     */
    'cluster_name': string;
}

export const KapsuleInfrastructureOutputsKindEnum = {
    SCW_KAPSULE: 'SCW_KAPSULE'
} as const;

export type KapsuleInfrastructureOutputsKindEnum = typeof KapsuleInfrastructureOutputsKindEnum[keyof typeof KapsuleInfrastructureOutputsKindEnum];

/**
 * 
 * @export
 * @interface KarpenterDefaultNodePoolOverride
 */
export interface KarpenterDefaultNodePoolOverride {
    /**
     * 
     * @type {KarpenterNodePoolLimits}
     * @memberof KarpenterDefaultNodePoolOverride
     */
    'limits'?: KarpenterNodePoolLimits;
}
/**
 * 
 * @export
 * @interface KarpenterGpuNodePoolOverride
 */
export interface KarpenterGpuNodePoolOverride {
    /**
     * 
     * @type {KarpenterNodePoolConsolidation}
     * @memberof KarpenterGpuNodePoolOverride
     */
    'consolidation'?: KarpenterNodePoolConsolidation;
    /**
     * 
     * @type {KarpenterNodePoolLimits}
     * @memberof KarpenterGpuNodePoolOverride
     */
    'limits'?: KarpenterNodePoolLimits;
    /**
     * 
     * @type {Array<KarpenterNodePoolRequirement>}
     * @memberof KarpenterGpuNodePoolOverride
     */
    'requirements'?: Array<KarpenterNodePoolRequirement>;
    /**
     * 
     * @type {number}
     * @memberof KarpenterGpuNodePoolOverride
     */
    'disk_size_in_gib'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof KarpenterGpuNodePoolOverride
     */
    'spot_enabled'?: boolean;
}
/**
 * 
 * @export
 * @interface KarpenterNodePool
 */
export interface KarpenterNodePool {
    /**
     * 
     * @type {Array<KarpenterNodePoolRequirement>}
     * @memberof KarpenterNodePool
     */
    'requirements': Array<KarpenterNodePoolRequirement>;
    /**
     * 
     * @type {KarpenterStableNodePoolOverride}
     * @memberof KarpenterNodePool
     */
    'stable_override'?: KarpenterStableNodePoolOverride;
    /**
     * 
     * @type {KarpenterDefaultNodePoolOverride}
     * @memberof KarpenterNodePool
     */
    'default_override'?: KarpenterDefaultNodePoolOverride;
    /**
     * 
     * @type {KarpenterGpuNodePoolOverride}
     * @memberof KarpenterNodePool
     */
    'gpu_override'?: KarpenterGpuNodePoolOverride;
}
/**
 * 
 * @export
 * @interface KarpenterNodePoolConsolidation
 */
export interface KarpenterNodePoolConsolidation {
    /**
     * 
     * @type {boolean}
     * @memberof KarpenterNodePoolConsolidation
     */
    'enabled': boolean;
    /**
     * 
     * @type {Array<WeekdayEnum>}
     * @memberof KarpenterNodePoolConsolidation
     */
    'days': Array<WeekdayEnum>;
    /**
     * The start date of the consolidation. The format should follow ISO-8601 convention: \"PThh:mm\" 
     * @type {string}
     * @memberof KarpenterNodePoolConsolidation
     */
    'start_time': string;
    /**
     * The duration during the consolidation will be active. The format should follow ISO-8601 convention: \"PThhHmmM\" 
     * @type {string}
     * @memberof KarpenterNodePoolConsolidation
     */
    'duration': string;
}
/**
 * 
 * @export
 * @interface KarpenterNodePoolLimits
 */
export interface KarpenterNodePoolLimits {
    /**
     * 
     * @type {boolean}
     * @memberof KarpenterNodePoolLimits
     */
    'enabled': boolean;
    /**
     * CPU limit that will be applied for the node pool (in vCPU unit: 1 vCPU = 1000 millicores)
     * @type {number}
     * @memberof KarpenterNodePoolLimits
     */
    'max_cpu_in_vcpu': number;
    /**
     * Memory limit that will be applied for the node pool (in Gibibytes unit: 1Gi = 1024 mebibytes)
     * @type {number}
     * @memberof KarpenterNodePoolLimits
     */
    'max_memory_in_gibibytes': number;
    /**
     * GPU limit that will be applied for the node pool
     * @type {number}
     * @memberof KarpenterNodePoolLimits
     */
    'max_gpu': number;
}
/**
 * 
 * @export
 * @interface KarpenterNodePoolRequirement
 */
export interface KarpenterNodePoolRequirement {
    /**
     * 
     * @type {KarpenterNodePoolRequirementKey}
     * @memberof KarpenterNodePoolRequirement
     */
    'key': KarpenterNodePoolRequirementKey;
    /**
     * 
     * @type {KarpenterNodePoolRequirementOperator}
     * @memberof KarpenterNodePoolRequirement
     */
    'operator': KarpenterNodePoolRequirementOperator;
    /**
     * 
     * @type {Array<string>}
     * @memberof KarpenterNodePoolRequirement
     */
    'values': Array<string>;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const KarpenterNodePoolRequirementKey = {
    INSTANCE_FAMILY: 'InstanceFamily',
    INSTANCE_SIZE: 'InstanceSize',
    ARCH: 'Arch',
    SKU_FAMILY: 'SkuFamily',
    SKU_VERSION: 'SkuVersion'
} as const;

export type KarpenterNodePoolRequirementKey = typeof KarpenterNodePoolRequirementKey[keyof typeof KarpenterNodePoolRequirementKey];


/**
 * 
 * @export
 * @enum {string}
 */

export const KarpenterNodePoolRequirementOperator = {
    IN: 'In'
} as const;

export type KarpenterNodePoolRequirementOperator = typeof KarpenterNodePoolRequirementOperator[keyof typeof KarpenterNodePoolRequirementOperator];


/**
 * 
 * @export
 * @interface KarpenterStableNodePoolOverride
 */
export interface KarpenterStableNodePoolOverride {
    /**
     * 
     * @type {KarpenterNodePoolConsolidation}
     * @memberof KarpenterStableNodePoolOverride
     */
    'consolidation'?: KarpenterNodePoolConsolidation;
    /**
     * 
     * @type {KarpenterNodePoolLimits}
     * @memberof KarpenterStableNodePoolOverride
     */
    'limits'?: KarpenterNodePoolLimits;
}
/**
 * 
 * @export
 * @interface KedaAutoscalingRequest
 */
export interface KedaAutoscalingRequest {
    /**
     * 
     * @type {AutoscalingMode}
     * @memberof KedaAutoscalingRequest
     */
    'mode': AutoscalingMode;
    /**
     * 
     * @type {number}
     * @memberof KedaAutoscalingRequest
     */
    'polling_interval_seconds'?: number;
    /**
     * 
     * @type {number}
     * @memberof KedaAutoscalingRequest
     */
    'cooldown_period_seconds'?: number;
    /**
     * 
     * @type {Array<KedaScalerRequest>}
     * @memberof KedaAutoscalingRequest
     */
    'scalers': Array<KedaScalerRequest>;
}


/**
 * 
 * @export
 * @interface KedaAutoscalingResponse
 */
export interface KedaAutoscalingResponse {
    /**
     * 
     * @type {string}
     * @memberof KedaAutoscalingResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof KedaAutoscalingResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof KedaAutoscalingResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof KedaAutoscalingResponse
     */
    'service_id': string;
    /**
     * 
     * @type {AutoscalingMode}
     * @memberof KedaAutoscalingResponse
     */
    'mode': AutoscalingMode;
    /**
     * 
     * @type {number}
     * @memberof KedaAutoscalingResponse
     */
    'polling_interval_seconds': number;
    /**
     * 
     * @type {number}
     * @memberof KedaAutoscalingResponse
     */
    'cooldown_period_seconds': number;
    /**
     * 
     * @type {Array<KedaScalerResponse>}
     * @memberof KedaAutoscalingResponse
     */
    'scalers': Array<KedaScalerResponse>;
}


/**
 * 
 * @export
 * @interface KedaScalerRequest
 */
export interface KedaScalerRequest {
    /**
     * 
     * @type {string}
     * @memberof KedaScalerRequest
     */
    'scaler_type': string;
    /**
     * 
     * @type {boolean}
     * @memberof KedaScalerRequest
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {KedaScalerRole}
     * @memberof KedaScalerRequest
     */
    'role': KedaScalerRole;
    /**
     * 
     * @type {object}
     * @memberof KedaScalerRequest
     */
    'config_json'?: object;
    /**
     * 
     * @type {string}
     * @memberof KedaScalerRequest
     */
    'config_yaml'?: string;
}


/**
 * 
 * @export
 * @interface KedaScalerResponse
 */
export interface KedaScalerResponse {
    /**
     * 
     * @type {string}
     * @memberof KedaScalerResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof KedaScalerResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof KedaScalerResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof KedaScalerResponse
     */
    'scaler_type': string;
    /**
     * 
     * @type {boolean}
     * @memberof KedaScalerResponse
     */
    'enabled': boolean;
    /**
     * 
     * @type {KedaScalerRole}
     * @memberof KedaScalerResponse
     */
    'role': KedaScalerRole;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof KedaScalerResponse
     */
    'config_json'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {string}
     * @memberof KedaScalerResponse
     */
    'config_yaml'?: string | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const KedaScalerRole = {
    PRIMARY: 'PRIMARY',
    SAFETY: 'SAFETY'
} as const;

export type KedaScalerRole = typeof KedaScalerRole[keyof typeof KedaScalerRole];


/**
 * 
 * @export
 * @interface Key
 */
export interface Key {
    /**
     * 
     * @type {string}
     * @memberof Key
     */
    'key': string;
    /**
     * optional variable description (255 characters maximum)
     * @type {string}
     * @memberof Key
     */
    'description'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Key
     */
    'enable_interpolation_in_file'?: boolean | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const KubernetesEnum = {
    MANAGED: 'MANAGED',
    SELF_MANAGED: 'SELF_MANAGED',
    PARTIALLY_MANAGED: 'PARTIALLY_MANAGED'
} as const;

export type KubernetesEnum = typeof KubernetesEnum[keyof typeof KubernetesEnum];


/**
 * 
 * @export
 * @interface KubernetesMetadata
 */
export interface KubernetesMetadata {
    /**
     * 
     * @type {string}
     * @memberof KubernetesMetadata
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface KubernetesSelector
 */
export interface KubernetesSelector {
    /**
     * 
     * @type {string}
     * @memberof KubernetesSelector
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof KubernetesSelector
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface KubernetesService
 */
export interface KubernetesService {
    /**
     * 
     * @type {KubernetesMetadata}
     * @memberof KubernetesService
     */
    'metadata': KubernetesMetadata;
    /**
     * 
     * @type {KubernetesServiceSpec}
     * @memberof KubernetesService
     */
    'service_spec': KubernetesServiceSpec;
}
/**
 * 
 * @export
 * @interface KubernetesServicePort
 */
export interface KubernetesServicePort {
    /**
     * 
     * @type {string}
     * @memberof KubernetesServicePort
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof KubernetesServicePort
     */
    'port': number;
}
/**
 * 
 * @export
 * @interface KubernetesServiceResponseList
 */
export interface KubernetesServiceResponseList {
    /**
     * 
     * @type {Array<KubernetesService>}
     * @memberof KubernetesServiceResponseList
     */
    'results'?: Array<KubernetesService>;
}
/**
 * 
 * @export
 * @interface KubernetesServiceSpec
 */
export interface KubernetesServiceSpec {
    /**
     * 
     * @type {string}
     * @memberof KubernetesServiceSpec
     */
    'type'?: string;
    /**
     * 
     * @type {Array<KubernetesServicePort>}
     * @memberof KubernetesServiceSpec
     */
    'ports'?: Array<KubernetesServicePort>;
    /**
     * 
     * @type {Array<KubernetesSelector>}
     * @memberof KubernetesServiceSpec
     */
    'selectors'?: Array<KubernetesSelector>;
}
/**
 * 
 * @export
 * @interface Label
 */
export interface Label {
    /**
     * 
     * @type {string}
     * @memberof Label
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof Label
     */
    'value': string;
    /**
     * 
     * @type {boolean}
     * @memberof Label
     */
    'propagate_to_cloud_provider': boolean;
}
/**
 * Labels Group Associated Item Type
 * @export
 * @enum {string}
 */

export const LabelsGroupAssociatedItemType = {
    APPLICATION: 'APPLICATION',
    DATABASE: 'DATABASE',
    CONTAINER: 'CONTAINER',
    LIFECYCLE: 'LIFECYCLE',
    ENVIRONMENT: 'ENVIRONMENT',
    CLUSTER: 'CLUSTER',
    CRON: 'CRON'
} as const;

export type LabelsGroupAssociatedItemType = typeof LabelsGroupAssociatedItemType[keyof typeof LabelsGroupAssociatedItemType];


/**
 * 
 * @export
 * @interface LifecycleJobResponse
 */
export interface LifecycleJobResponse {
    /**
     * 
     * @type {string}
     * @memberof LifecycleJobResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof LifecycleJobResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof LifecycleJobResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {ReferenceObject}
     * @memberof LifecycleJobResponse
     */
    'environment': ReferenceObject;
    /**
     * Maximum cpu that can be allocated to the job based on organization cluster configuration. unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof LifecycleJobResponse
     */
    'maximum_cpu': number;
    /**
     * Maximum memory that can be allocated to the job based on organization cluster configuration. unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof LifecycleJobResponse
     */
    'maximum_memory': number;
    /**
     * Maximum memory that can be allocated to the job based on organization cluster configuration. unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof LifecycleJobResponse
     */
    'maximum_gpu': number;
    /**
     * name is case insensitive
     * @type {string}
     * @memberof LifecycleJobResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof LifecycleJobResponse
     */
    'description'?: string;
    /**
     * unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof LifecycleJobResponse
     */
    'cpu': number;
    /**
     * unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof LifecycleJobResponse
     */
    'memory': number;
    /**
     * 
     * @type {number}
     * @memberof LifecycleJobResponse
     */
    'gpu': number;
    /**
     * Maximum number of restart allowed before the job is considered as failed 0 means that no restart/crash of the job is allowed 
     * @type {number}
     * @memberof LifecycleJobResponse
     */
    'max_nb_restart'?: number;
    /**
     * Maximum number of seconds allowed for the job to run before killing it and mark it as failed 
     * @type {number}
     * @memberof LifecycleJobResponse
     */
    'max_duration_seconds'?: number;
    /**
     * Indicates if the \'environment preview option\' is enabled for this container.   If enabled, a preview environment will be automatically cloned when `/preview` endpoint is called.   If not specified, it takes the value of the `auto_preview` property from the associated environment. 
     * @type {boolean}
     * @memberof LifecycleJobResponse
     */
    'auto_preview': boolean;
    /**
     * Port where to run readiness and liveliness probes checks. The port will not be exposed externally
     * @type {number}
     * @memberof LifecycleJobResponse
     */
    'port'?: number | null;
    /**
     * 
     * @type {BaseJobResponseAllOfSource}
     * @memberof LifecycleJobResponse
     */
    'source': BaseJobResponseAllOfSource;
    /**
     * 
     * @type {Healthcheck}
     * @memberof LifecycleJobResponse
     */
    'healthchecks': Healthcheck;
    /**
     * Specify if the job will be automatically updated after receiving a new image tag or a new commit according to the source type.  The new image tag shall be communicated via the \"Auto Deploy job\" endpoint https://api-doc.qovery.com/#tag/Jobs/operation/autoDeployJobEnvironments 
     * @type {boolean}
     * @memberof LifecycleJobResponse
     */
    'auto_deploy'?: boolean;
    /**
     * Icon URI representing the job.
     * @type {string}
     * @memberof LifecycleJobResponse
     */
    'icon_uri': string;
    /**
     * 
     * @type {ServiceTypeEnum}
     * @memberof LifecycleJobResponse
     */
    'service_type': ServiceTypeEnum;
    /**
     * 
     * @type {JobTypeEnum}
     * @memberof LifecycleJobResponse
     */
    'job_type': JobTypeEnum;
    /**
     * 
     * @type {LifecycleJobResponseAllOfSchedule}
     * @memberof LifecycleJobResponse
     */
    'schedule': LifecycleJobResponseAllOfSchedule;
    /**
     * 
     * @type {Array<OrganizationAnnotationsGroupResponse>}
     * @memberof LifecycleJobResponse
     */
    'annotations_groups'?: Array<OrganizationAnnotationsGroupResponse>;
    /**
     * 
     * @type {Array<OrganizationLabelsGroupResponse>}
     * @memberof LifecycleJobResponse
     */
    'labels_groups'?: Array<OrganizationLabelsGroupResponse>;
}


/**
 * 
 * @export
 * @interface LifecycleJobResponseAllOfSchedule
 */
export interface LifecycleJobResponseAllOfSchedule {
    /**
     * 
     * @type {JobRequestAllOfScheduleOnStart}
     * @memberof LifecycleJobResponseAllOfSchedule
     */
    'on_start'?: JobRequestAllOfScheduleOnStart;
    /**
     * 
     * @type {JobRequestAllOfScheduleOnStart}
     * @memberof LifecycleJobResponseAllOfSchedule
     */
    'on_stop'?: JobRequestAllOfScheduleOnStart;
    /**
     * 
     * @type {JobRequestAllOfScheduleOnStart}
     * @memberof LifecycleJobResponseAllOfSchedule
     */
    'on_delete'?: JobRequestAllOfScheduleOnStart;
    /**
     * 
     * @type {JobLifecycleTypeEnum}
     * @memberof LifecycleJobResponseAllOfSchedule
     */
    'lifecycle_type'?: JobLifecycleTypeEnum;
}


/**
 * 
 * @export
 * @interface LifecycleTemplateListResponse
 */
export interface LifecycleTemplateListResponse {
    /**
     * 
     * @type {Array<LifecycleTemplateListResponseResultsInner>}
     * @memberof LifecycleTemplateListResponse
     */
    'results': Array<LifecycleTemplateListResponseResultsInner>;
}
/**
 * 
 * @export
 * @interface LifecycleTemplateListResponseResultsInner
 */
export interface LifecycleTemplateListResponseResultsInner {
    /**
     * 
     * @type {string}
     * @memberof LifecycleTemplateListResponseResultsInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof LifecycleTemplateListResponseResultsInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof LifecycleTemplateListResponseResultsInner
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface LifecycleTemplateResponse
 */
export interface LifecycleTemplateResponse {
    /**
     * 
     * @type {string}
     * @memberof LifecycleTemplateResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof LifecycleTemplateResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof LifecycleTemplateResponse
     */
    'description': string;
    /**
     * location of the template
     * @type {string}
     * @memberof LifecycleTemplateResponse
     */
    'sourceUrl': string;
    /**
     * 
     * @type {CloudProviderEnum}
     * @memberof LifecycleTemplateResponse
     */
    'cloud_provider': CloudProviderEnum;
    /**
     * lis of pre-defined command for each event
     * @type {Array<LifecycleTemplateResponseEventsInner>}
     * @memberof LifecycleTemplateResponse
     */
    'events': Array<LifecycleTemplateResponseEventsInner>;
    /**
     * Job max allowed duration in seconds. After this allowed time, the job is going to be killed.
     * @type {number}
     * @memberof LifecycleTemplateResponse
     */
    'max_duration_in_sec': number;
    /**
     * 
     * @type {LifecycleTemplateResponseResources}
     * @memberof LifecycleTemplateResponse
     */
    'resources': LifecycleTemplateResponseResources;
    /**
     * Variables to inject at the creation of this lifecycle job
     * @type {Array<LifecycleTemplateResponseVariablesInner>}
     * @memberof LifecycleTemplateResponse
     */
    'variables': Array<LifecycleTemplateResponseVariablesInner>;
    /**
     * Dockerfile of the template
     * @type {string}
     * @memberof LifecycleTemplateResponse
     */
    'dockerfile': string;
}


/**
 * 
 * @export
 * @interface LifecycleTemplateResponseEventsInner
 */
export interface LifecycleTemplateResponseEventsInner {
    /**
     * 
     * @type {string}
     * @memberof LifecycleTemplateResponseEventsInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof LifecycleTemplateResponseEventsInner
     */
    'entrypoint'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof LifecycleTemplateResponseEventsInner
     */
    'command': Array<string>;
}
/**
 * 
 * @export
 * @interface LifecycleTemplateResponseResources
 */
export interface LifecycleTemplateResponseResources {
    /**
     * 
     * @type {number}
     * @memberof LifecycleTemplateResponseResources
     */
    'cpu_milli': number;
    /**
     * 
     * @type {number}
     * @memberof LifecycleTemplateResponseResources
     */
    'ram_mib': number;
}
/**
 * 
 * @export
 * @interface LifecycleTemplateResponseVariablesInner
 */
export interface LifecycleTemplateResponseVariablesInner {
    /**
     * 
     * @type {string}
     * @memberof LifecycleTemplateResponseVariablesInner
     */
    'name': string;
    /**
     * Short description to explain the purpose of the variable
     * @type {string}
     * @memberof LifecycleTemplateResponseVariablesInner
     */
    'description': string;
    /**
     * Default value for the variable
     * @type {string}
     * @memberof LifecycleTemplateResponseVariablesInner
     */
    'default': string;
    /**
     * If the variable should be injected as a secret
     * @type {boolean}
     * @memberof LifecycleTemplateResponseVariablesInner
     */
    'is_secret': boolean;
    /**
     * 
     * @type {LifecycleTemplateResponseVariablesInnerFile}
     * @memberof LifecycleTemplateResponseVariablesInner
     */
    'file'?: LifecycleTemplateResponseVariablesInnerFile;
}
/**
 * If present, the variable should be a file instead of a raw value
 * @export
 * @interface LifecycleTemplateResponseVariablesInnerFile
 */
export interface LifecycleTemplateResponseVariablesInnerFile {
    /**
     * 
     * @type {string}
     * @memberof LifecycleTemplateResponseVariablesInnerFile
     */
    'path': string;
    /**
     * if we should interpolate variable inside the file
     * @type {boolean}
     * @memberof LifecycleTemplateResponseVariablesInnerFile
     */
    'enable_interpolation'?: boolean;
}
/**
 * 
 * @export
 * @interface Link
 */
export interface Link {
    /**
     * ID of the associated service
     * @type {string}
     * @memberof Link
     */
    'service_id': string;
    /**
     * 
     * @type {ServiceTypeEnum}
     * @memberof Link
     */
    'service_type': ServiceTypeEnum;
    /**
     * URL to access the service
     * @type {string}
     * @memberof Link
     */
    'url': string;
    /**
     * The port from which the service is reachable from within the cluster
     * @type {number}
     * @memberof Link
     */
    'internal_port': number;
    /**
     * The port from which the service is reachable from externally (i.e: 443 for HTTPS)
     * @type {number}
     * @memberof Link
     */
    'external_port': number;
    /**
     * True if the domain is managed by Qovery, false if it belongs to the user
     * @type {boolean}
     * @memberof Link
     */
    'is_qovery_domain': boolean;
    /**
     * Indicate if the link is using the root of the domain and not one derivated from port i.e: p8080.zxxxx.jvm.worl      => is_default = false, is_qovery = true zxxxx.jvm.world           => is_default = true, is_qovery = true p8080-my-super-domain.com => is_default = false, is_qovery = false my-super-domain.com       => is_default = true, is_qovery = false 
     * @type {boolean}
     * @memberof Link
     */
    'is_default': boolean;
}


/**
 * 
 * @export
 * @interface LinkResponseList
 */
export interface LinkResponseList {
    /**
     * 
     * @type {Array<Link>}
     * @memberof LinkResponseList
     */
    'results'?: Array<Link>;
}
/**
 * type of the service (application, database, job, gateway...)
 * @export
 * @enum {string}
 */

export const LinkedServiceTypeEnum = {
    APPLICATION: 'APPLICATION',
    CONTAINER: 'CONTAINER',
    DATABASE: 'DATABASE',
    JOB: 'JOB',
    HELM: 'HELM',
    TERRAFORM: 'TERRAFORM'
} as const;

export type LinkedServiceTypeEnum = typeof LinkedServiceTypeEnum[keyof typeof LinkedServiceTypeEnum];


/**
 * 
 * @export
 * @interface ListContainerDeploymentHistory200Response
 */
export interface ListContainerDeploymentHistory200Response {
    /**
     * 
     * @type {number}
     * @memberof ListContainerDeploymentHistory200Response
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof ListContainerDeploymentHistory200Response
     */
    'page_size': number;
    /**
     * 
     * @type {Array<DeploymentHistoryContainer>}
     * @memberof ListContainerDeploymentHistory200Response
     */
    'results'?: Array<DeploymentHistoryContainer>;
}
/**
 * 
 * @export
 * @interface ListDatabaseDeploymentHistory200Response
 */
export interface ListDatabaseDeploymentHistory200Response {
    /**
     * 
     * @type {number}
     * @memberof ListDatabaseDeploymentHistory200Response
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof ListDatabaseDeploymentHistory200Response
     */
    'page_size': number;
    /**
     * 
     * @type {Array<DeploymentHistoryDatabase>}
     * @memberof ListDatabaseDeploymentHistory200Response
     */
    'results'?: Array<DeploymentHistoryDatabase>;
}
/**
 * 
 * @export
 * @interface ListDeploymentRequestByEnvironmentId200Response
 */
export interface ListDeploymentRequestByEnvironmentId200Response {
    /**
     * 
     * @type {Array<QueuedDeploymentRequestWithStages>}
     * @memberof ListDeploymentRequestByEnvironmentId200Response
     */
    'results'?: Array<QueuedDeploymentRequestWithStages>;
}
/**
 * 
 * @export
 * @interface ListDeploymentRequestByServiceId200Response
 */
export interface ListDeploymentRequestByServiceId200Response {
    /**
     * 
     * @type {Array<QueuedDeploymentRequestForService>}
     * @memberof ListDeploymentRequestByServiceId200Response
     */
    'results'?: Array<QueuedDeploymentRequestForService>;
}
/**
 * 
 * @export
 * @interface ListDirectoriesFromGitRepository200Response
 */
export interface ListDirectoriesFromGitRepository200Response {
    /**
     * 
     * @type {Array<string>}
     * @memberof ListDirectoriesFromGitRepository200Response
     */
    'results'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ListHelmDeploymentHistory200Response
 */
export interface ListHelmDeploymentHistory200Response {
    /**
     * 
     * @type {number}
     * @memberof ListHelmDeploymentHistory200Response
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof ListHelmDeploymentHistory200Response
     */
    'page_size': number;
    /**
     * 
     * @type {Array<DeploymentHistoryHelmResponse>}
     * @memberof ListHelmDeploymentHistory200Response
     */
    'results'?: Array<DeploymentHistoryHelmResponse>;
}
/**
 * 
 * @export
 * @interface ListJobDeploymentHistory200Response
 */
export interface ListJobDeploymentHistory200Response {
    /**
     * 
     * @type {number}
     * @memberof ListJobDeploymentHistory200Response
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof ListJobDeploymentHistory200Response
     */
    'page_size': number;
    /**
     * 
     * @type {Array<DeploymentHistoryJobResponse>}
     * @memberof ListJobDeploymentHistory200Response
     */
    'results'?: Array<DeploymentHistoryJobResponse>;
}
/**
 * 
 * @export
 * @interface ListOrganizationAnnotationsGroup200Response
 */
export interface ListOrganizationAnnotationsGroup200Response {
    /**
     * 
     * @type {Array<OrganizationAnnotationsGroupEnrichedResponse>}
     * @memberof ListOrganizationAnnotationsGroup200Response
     */
    'results'?: Array<OrganizationAnnotationsGroupEnrichedResponse>;
}
/**
 * 
 * @export
 * @interface ListOrganizationLabelsGroup200Response
 */
export interface ListOrganizationLabelsGroup200Response {
    /**
     * 
     * @type {Array<OrganizationLabelsGroupEnrichedResponse>}
     * @memberof ListOrganizationLabelsGroup200Response
     */
    'results'?: Array<OrganizationLabelsGroupEnrichedResponse>;
}
/**
 * 
 * @export
 * @interface ListServicesByEnvironmentId200Response
 */
export interface ListServicesByEnvironmentId200Response {
    /**
     * 
     * @type {Array<ListServicesByEnvironmentId200ResponseResultsInner>}
     * @memberof ListServicesByEnvironmentId200Response
     */
    'results'?: Array<ListServicesByEnvironmentId200ResponseResultsInner>;
}
/**
 * @type ListServicesByEnvironmentId200ResponseResultsInner
 * @export
 */
export type ListServicesByEnvironmentId200ResponseResultsInner = { service_type: 'APPLICATION' } & Application | { service_type: 'CONTAINER' } & ContainerResponse | { service_type: 'DATABASE' } & Database | { service_type: 'HELM' } & HelmResponse | { service_type: 'JOB' } & JobResponse | { service_type: 'TERRAFORM' } & TerraformResponse;

/**
 * 
 * @export
 * @interface ListServicesByOrganizationId200Response
 */
export interface ListServicesByOrganizationId200Response {
    /**
     * 
     * @type {Array<ServiceLightResponse>}
     * @memberof ListServicesByOrganizationId200Response
     */
    'results'?: Array<ServiceLightResponse>;
}
/**
 * 
 * @export
 * @interface ListTfVarsFilesFromGitRepo200Response
 */
export interface ListTfVarsFilesFromGitRepo200Response {
    /**
     * 
     * @type {Array<TfVarsFileResponse>}
     * @memberof ListTfVarsFilesFromGitRepo200Response
     */
    'results'?: Array<TfVarsFileResponse>;
}
/**
 * 
 * @export
 * @interface Log
 */
export interface Log {
    /**
     * 
     * @type {string}
     * @memberof Log
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Log
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Log
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof Log
     */
    'pod_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Log
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface LogResponseList
 */
export interface LogResponseList {
    /**
     * 
     * @type {Array<Log>}
     * @memberof LogResponseList
     */
    'results'?: Array<Log>;
}
/**
 * 
 * @export
 * @interface ManagedDatabaseInstanceTypeResponse
 */
export interface ManagedDatabaseInstanceTypeResponse {
    /**
     * 
     * @type {string}
     * @memberof ManagedDatabaseInstanceTypeResponse
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ManagedDatabaseInstanceTypeResponseList
 */
export interface ManagedDatabaseInstanceTypeResponseList {
    /**
     * 
     * @type {Array<ManagedDatabaseInstanceTypeResponse>}
     * @memberof ManagedDatabaseInstanceTypeResponseList
     */
    'results'?: Array<ManagedDatabaseInstanceTypeResponse>;
}
/**
 * 
 * @export
 * @interface ManagedDatabaseTypeResponse
 */
export interface ManagedDatabaseTypeResponse {
    /**
     * 
     * @type {string}
     * @memberof ManagedDatabaseTypeResponse
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ManagedDatabaseTypeResponseList
 */
export interface ManagedDatabaseTypeResponseList {
    /**
     * 
     * @type {Array<ManagedDatabaseTypeResponse>}
     * @memberof ManagedDatabaseTypeResponseList
     */
    'results'?: Array<ManagedDatabaseTypeResponse>;
}
/**
 * 
 * @export
 * @interface Member
 */
export interface Member {
    /**
     * 
     * @type {string}
     * @memberof Member
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Member
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Member
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Member
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Member
     */
    'nickname'?: string;
    /**
     * 
     * @type {string}
     * @memberof Member
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof Member
     */
    'profile_picture_url'?: string;
    /**
     * last time the user was connected
     * @type {string}
     * @memberof Member
     */
    'last_activity_at'?: string;
    /**
     * 
     * @type {InviteMemberRoleEnum}
     * @memberof Member
     */
    'role'?: InviteMemberRoleEnum;
    /**
     * the role linked to the user
     * @type {string}
     * @memberof Member
     */
    'role_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Member
     */
    'role_id'?: string;
}


/**
 * 
 * @export
 * @interface MemberResponseList
 */
export interface MemberResponseList {
    /**
     * 
     * @type {Array<Member>}
     * @memberof MemberResponseList
     */
    'results'?: Array<Member>;
}
/**
 * 
 * @export
 * @interface MemberRoleUpdateRequest
 */
export interface MemberRoleUpdateRequest {
    /**
     * specify the git provider user id
     * @type {string}
     * @memberof MemberRoleUpdateRequest
     */
    'user_id': string;
    /**
     * 
     * @type {string}
     * @memberof MemberRoleUpdateRequest
     */
    'role_id': string;
}
/**
 * 
 * @export
 * @interface MetricsConfigurationManagedByQovery
 */
export interface MetricsConfigurationManagedByQovery {
    /**
     * 
     * @type {string}
     * @memberof MetricsConfigurationManagedByQovery
     */
    'kind'?: MetricsConfigurationManagedByQoveryKindEnum;
    /**
     * 
     * @type {ObservabilityResourceProfile}
     * @memberof MetricsConfigurationManagedByQovery
     */
    'resource_profile'?: ObservabilityResourceProfile;
    /**
     * 
     * @type {CloudWatchExportConfig}
     * @memberof MetricsConfigurationManagedByQovery
     */
    'cloud_watch_export_config'?: CloudWatchExportConfig;
    /**
     * 
     * @type {boolean}
     * @memberof MetricsConfigurationManagedByQovery
     */
    'high_availability'?: boolean;
    /**
     * 
     * @type {InternalNetworkMonitoring}
     * @memberof MetricsConfigurationManagedByQovery
     */
    'internal_network_monitoring'?: InternalNetworkMonitoring;
    /**
     * 
     * @type {AlertingConfig}
     * @memberof MetricsConfigurationManagedByQovery
     */
    'alerting'?: AlertingConfig;
}

export const MetricsConfigurationManagedByQoveryKindEnum = {
    MANAGED_BY_QOVERY: 'MANAGED_BY_QOVERY'
} as const;

export type MetricsConfigurationManagedByQoveryKindEnum = typeof MetricsConfigurationManagedByQoveryKindEnum[keyof typeof MetricsConfigurationManagedByQoveryKindEnum];

/**
 * 
 * @export
 * @interface MetricsParameters
 */
export interface MetricsParameters {
    /**
     * 
     * @type {boolean}
     * @memberof MetricsParameters
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {MetricsParametersConfiguration}
     * @memberof MetricsParameters
     */
    'configuration'?: MetricsParametersConfiguration;
}
/**
 * @type MetricsParametersConfiguration
 * @export
 */
export type MetricsParametersConfiguration = { kind: 'MANAGED_BY_QOVERY' } & MetricsConfigurationManagedByQovery;

/**
 * 
 * @export
 * @enum {string}
 */

export const ObservabilityResourceProfile = {
    LOW: 'LOW',
    NORMAL: 'NORMAL',
    HIGH: 'HIGH'
} as const;

export type ObservabilityResourceProfile = typeof ObservabilityResourceProfile[keyof typeof ObservabilityResourceProfile];


/**
 * 
 * @export
 * @interface OnPremiseCredentialsRequest
 */
export interface OnPremiseCredentialsRequest {
    /**
     * 
     * @type {string}
     * @memberof OnPremiseCredentialsRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface Organization
 */
export interface Organization {
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'updated_at'?: string;
    /**
     * name is case insensitive
     * @type {string}
     * @memberof Organization
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'description'?: string | null;
    /**
     * 
     * @type {PlanEnum}
     * @memberof Organization
     */
    'plan': PlanEnum;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'website_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'repository'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'logo_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'icon_url'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof Organization
     */
    'admin_emails'?: Array<string> | null;
    /**
     * uuid of the user owning the organization
     * @type {string}
     * @memberof Organization
     */
    'owner'?: string;
    /**
     * 
     * @type {OrganizationAllOfOrganizationPlan}
     * @memberof Organization
     */
    'organization_plan'?: OrganizationAllOfOrganizationPlan;
}


/**
 * 
 * @export
 * @interface OrganizationAllOfOrganizationPlan
 */
export interface OrganizationAllOfOrganizationPlan {
    /**
     * 
     * @type {PlanEnum}
     * @memberof OrganizationAllOfOrganizationPlan
     */
    'plan'?: PlanEnum;
    /**
     * audit logs maximum period available in days
     * @type {number}
     * @memberof OrganizationAllOfOrganizationPlan
     */
    'audit_logs_retention_in_days'?: number;
}


/**
 * 
 * @export
 * @interface OrganizationAnnotationsGroupAssociatedItemsResponseList
 */
export interface OrganizationAnnotationsGroupAssociatedItemsResponseList {
    /**
     * 
     * @type {Array<OrganizationAnnotationsGroupAssociatedItemsResponseListResultsInner>}
     * @memberof OrganizationAnnotationsGroupAssociatedItemsResponseList
     */
    'results'?: Array<OrganizationAnnotationsGroupAssociatedItemsResponseListResultsInner>;
}
/**
 * 
 * @export
 * @interface OrganizationAnnotationsGroupAssociatedItemsResponseListResultsInner
 */
export interface OrganizationAnnotationsGroupAssociatedItemsResponseListResultsInner {
    /**
     * 
     * @type {string}
     * @memberof OrganizationAnnotationsGroupAssociatedItemsResponseListResultsInner
     */
    'cluster_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationAnnotationsGroupAssociatedItemsResponseListResultsInner
     */
    'cluster_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationAnnotationsGroupAssociatedItemsResponseListResultsInner
     */
    'project_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationAnnotationsGroupAssociatedItemsResponseListResultsInner
     */
    'project_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationAnnotationsGroupAssociatedItemsResponseListResultsInner
     */
    'environment_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationAnnotationsGroupAssociatedItemsResponseListResultsInner
     */
    'environment_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationAnnotationsGroupAssociatedItemsResponseListResultsInner
     */
    'item_id': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationAnnotationsGroupAssociatedItemsResponseListResultsInner
     */
    'item_name': string;
    /**
     * 
     * @type {AnnotationsGroupAssociatedItemType}
     * @memberof OrganizationAnnotationsGroupAssociatedItemsResponseListResultsInner
     */
    'item_type': AnnotationsGroupAssociatedItemType;
}


/**
 * 
 * @export
 * @interface OrganizationAnnotationsGroupCreateRequest
 */
export interface OrganizationAnnotationsGroupCreateRequest {
    /**
     * name of the annotations group
     * @type {string}
     * @memberof OrganizationAnnotationsGroupCreateRequest
     */
    'name': string;
    /**
     * 
     * @type {Array<Annotation>}
     * @memberof OrganizationAnnotationsGroupCreateRequest
     */
    'annotations': Array<Annotation>;
    /**
     * 
     * @type {Array<OrganizationAnnotationsGroupScopeEnum>}
     * @memberof OrganizationAnnotationsGroupCreateRequest
     */
    'scopes': Array<OrganizationAnnotationsGroupScopeEnum>;
}
/**
 * 
 * @export
 * @interface OrganizationAnnotationsGroupEnrichedResponse
 */
export interface OrganizationAnnotationsGroupEnrichedResponse {
    /**
     * 
     * @type {string}
     * @memberof OrganizationAnnotationsGroupEnrichedResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationAnnotationsGroupEnrichedResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationAnnotationsGroupEnrichedResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationAnnotationsGroupEnrichedResponse
     */
    'name': string;
    /**
     * 
     * @type {Array<Annotation>}
     * @memberof OrganizationAnnotationsGroupEnrichedResponse
     */
    'annotations': Array<Annotation>;
    /**
     * 
     * @type {Array<OrganizationAnnotationsGroupScopeEnum>}
     * @memberof OrganizationAnnotationsGroupEnrichedResponse
     */
    'scopes': Array<OrganizationAnnotationsGroupScopeEnum>;
    /**
     * 
     * @type {number}
     * @memberof OrganizationAnnotationsGroupEnrichedResponse
     */
    'associated_items_count'?: number;
}
/**
 * 
 * @export
 * @interface OrganizationAnnotationsGroupResponse
 */
export interface OrganizationAnnotationsGroupResponse {
    /**
     * 
     * @type {string}
     * @memberof OrganizationAnnotationsGroupResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationAnnotationsGroupResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationAnnotationsGroupResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationAnnotationsGroupResponse
     */
    'name': string;
    /**
     * 
     * @type {Array<Annotation>}
     * @memberof OrganizationAnnotationsGroupResponse
     */
    'annotations': Array<Annotation>;
    /**
     * 
     * @type {Array<OrganizationAnnotationsGroupScopeEnum>}
     * @memberof OrganizationAnnotationsGroupResponse
     */
    'scopes': Array<OrganizationAnnotationsGroupScopeEnum>;
}
/**
 * Annotations Group Scope
 * @export
 * @enum {string}
 */

export const OrganizationAnnotationsGroupScopeEnum = {
    DEPLOYMENTS: 'DEPLOYMENTS',
    STATEFUL_SETS: 'STATEFUL_SETS',
    SERVICES: 'SERVICES',
    INGRESS: 'INGRESS',
    HPA: 'HPA',
    PODS: 'PODS',
    SECRETS: 'SECRETS',
    JOBS: 'JOBS',
    CRON_JOBS: 'CRON_JOBS'
} as const;

export type OrganizationAnnotationsGroupScopeEnum = typeof OrganizationAnnotationsGroupScopeEnum[keyof typeof OrganizationAnnotationsGroupScopeEnum];


/**
 * 
 * @export
 * @interface OrganizationApiToken
 */
export interface OrganizationApiToken {
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiToken
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiToken
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiToken
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiToken
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiToken
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiToken
     */
    'role_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiToken
     */
    'role_id'?: string;
}
/**
 * 
 * @export
 * @interface OrganizationApiTokenCreate
 */
export interface OrganizationApiTokenCreate {
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiTokenCreate
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiTokenCreate
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiTokenCreate
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiTokenCreate
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiTokenCreate
     */
    'description'?: string;
    /**
     * the generated token to send in \'Authorization\' header prefixed by \'Token \'
     * @type {string}
     * @memberof OrganizationApiTokenCreate
     */
    'token'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiTokenCreate
     */
    'role_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiTokenCreate
     */
    'role_id'?: string;
}
/**
 * 
 * @export
 * @interface OrganizationApiTokenCreateRequest
 */
export interface OrganizationApiTokenCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiTokenCreateRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiTokenCreateRequest
     */
    'description'?: string;
    /**
     * 
     * @type {OrganizationApiTokenScope}
     * @memberof OrganizationApiTokenCreateRequest
     */
    'scope'?: OrganizationApiTokenScope | null;
    /**
     * the roleId provided by the \"List organization custom roles\" endpoint.
     * @type {string}
     * @memberof OrganizationApiTokenCreateRequest
     */
    'role_id': string | null;
}


/**
 * 
 * @export
 * @interface OrganizationApiTokenResponseList
 */
export interface OrganizationApiTokenResponseList {
    /**
     * 
     * @type {Array<OrganizationApiToken>}
     * @memberof OrganizationApiTokenResponseList
     */
    'results'?: Array<OrganizationApiToken>;
}
/**
 * deprecated
 * @export
 * @enum {string}
 */

export const OrganizationApiTokenScope = {
    ADMIN: 'ADMIN'
} as const;

export type OrganizationApiTokenScope = typeof OrganizationApiTokenScope[keyof typeof OrganizationApiTokenScope];


/**
 * 
 * @export
 * @interface OrganizationAvailableRole
 */
export interface OrganizationAvailableRole {
    /**
     * 
     * @type {string}
     * @memberof OrganizationAvailableRole
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationAvailableRole
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface OrganizationAvailableRoleList
 */
export interface OrganizationAvailableRoleList {
    /**
     * 
     * @type {Array<OrganizationAvailableRole>}
     * @memberof OrganizationAvailableRoleList
     */
    'results'?: Array<OrganizationAvailableRole>;
}
/**
 * 
 * @export
 * @interface OrganizationBillingUsageReportRequest
 */
export interface OrganizationBillingUsageReportRequest {
    /**
     * The start date of the report
     * @type {string}
     * @memberof OrganizationBillingUsageReportRequest
     */
    'from': string;
    /**
     * The end date of the report
     * @type {string}
     * @memberof OrganizationBillingUsageReportRequest
     */
    'to': string;
    /**
     * The number of seconds the report will be publicly available
     * @type {number}
     * @memberof OrganizationBillingUsageReportRequest
     */
    'report_expiration_in_seconds': number;
}
/**
 * 
 * @export
 * @interface OrganizationBillingUsageReportResponse
 */
export interface OrganizationBillingUsageReportResponse {
    /**
     * The URL of the report
     * @type {string}
     * @memberof OrganizationBillingUsageReportResponse
     */
    'report_url'?: string;
    /**
     * The URL to delete the report. Use this URL to pro-actively delete the report before it expires
     * @type {string}
     * @memberof OrganizationBillingUsageReportResponse
     */
    'delete_report_url'?: string;
}
/**
 * 
 * @export
 * @interface OrganizationChangePlanRequest
 */
export interface OrganizationChangePlanRequest {
    /**
     * 
     * @type {string}
     * @memberof OrganizationChangePlanRequest
     */
    'plan'?: string;
}
/**
 * 
 * @export
 * @interface OrganizationContainerAutoDeployRequest
 */
export interface OrganizationContainerAutoDeployRequest {
    /**
     * the container image name to deploy
     * @type {string}
     * @memberof OrganizationContainerAutoDeployRequest
     */
    'image_name'?: string;
    /**
     * the new tag to deploy
     * @type {string}
     * @memberof OrganizationContainerAutoDeployRequest
     */
    'tag'?: string;
}
/**
 * 
 * @export
 * @interface OrganizationContainerPreviewRequest
 */
export interface OrganizationContainerPreviewRequest {
    /**
     * the container image name to trigger preview environment
     * @type {string}
     * @memberof OrganizationContainerPreviewRequest
     */
    'image_name'?: string;
    /**
     * the tag to be used in the preview environment
     * @type {string}
     * @memberof OrganizationContainerPreviewRequest
     */
    'tag'?: string;
}
/**
 * 
 * @export
 * @interface OrganizationCreditCodeRequest
 */
export interface OrganizationCreditCodeRequest {
    /**
     * 
     * @type {string}
     * @memberof OrganizationCreditCodeRequest
     */
    'code'?: string;
}
/**
 * 
 * @export
 * @interface OrganizationCrendentialsResponseList
 */
export interface OrganizationCrendentialsResponseList {
    /**
     * 
     * @type {Array<OrganizationCrendentialsResponseListResultsInner>}
     * @memberof OrganizationCrendentialsResponseList
     */
    'results'?: Array<OrganizationCrendentialsResponseListResultsInner>;
}
/**
 * 
 * @export
 * @interface OrganizationCrendentialsResponseListResultsInner
 */
export interface OrganizationCrendentialsResponseListResultsInner {
    /**
     * 
     * @type {ClusterCredentials}
     * @memberof OrganizationCrendentialsResponseListResultsInner
     */
    'credential'?: ClusterCredentials;
    /**
     * 
     * @type {Array<CredentialCluster>}
     * @memberof OrganizationCrendentialsResponseListResultsInner
     */
    'clusters'?: Array<CredentialCluster>;
}
/**
 * 
 * @export
 * @interface OrganizationCurrentCost
 */
export interface OrganizationCurrentCost {
    /**
     * 
     * @type {PlanEnum}
     * @memberof OrganizationCurrentCost
     */
    'plan'?: PlanEnum;
    /**
     * number of days remaining before the end of the trial period
     * @type {number}
     * @memberof OrganizationCurrentCost
     */
    'remaining_trial_day'?: number;
    /**
     * date when the current plan will be renewed
     * @type {string}
     * @memberof OrganizationCurrentCost
     */
    'renewal_at'?: string | null;
    /**
     * 
     * @type {Cost}
     * @memberof OrganizationCurrentCost
     */
    'cost'?: Cost;
}


/**
 * 
 * @export
 * @interface OrganizationCustomRole
 */
export interface OrganizationCustomRole {
    /**
     * 
     * @type {string}
     * @memberof OrganizationCustomRole
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationCustomRole
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationCustomRole
     */
    'description'?: string;
    /**
     * 
     * @type {Array<OrganizationCustomRoleClusterPermissionsInner>}
     * @memberof OrganizationCustomRole
     */
    'cluster_permissions'?: Array<OrganizationCustomRoleClusterPermissionsInner>;
    /**
     * 
     * @type {Array<OrganizationCustomRoleProjectPermissionsInner>}
     * @memberof OrganizationCustomRole
     */
    'project_permissions'?: Array<OrganizationCustomRoleProjectPermissionsInner>;
}
/**
 * Indicates the permission for a target cluster, from the lowest to the highest: - `VIEWER` user has only read access on target cluster - `ENV_CREATOR` user can deploy on the cluster - `ADMIN` user can modify the cluster settings 
 * @export
 * @enum {string}
 */

export const OrganizationCustomRoleClusterPermission = {
    VIEWER: 'VIEWER',
    ENV_CREATOR: 'ENV_CREATOR',
    ADMIN: 'ADMIN'
} as const;

export type OrganizationCustomRoleClusterPermission = typeof OrganizationCustomRoleClusterPermission[keyof typeof OrganizationCustomRoleClusterPermission];


/**
 * 
 * @export
 * @interface OrganizationCustomRoleClusterPermissionsInner
 */
export interface OrganizationCustomRoleClusterPermissionsInner {
    /**
     * 
     * @type {string}
     * @memberof OrganizationCustomRoleClusterPermissionsInner
     */
    'cluster_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationCustomRoleClusterPermissionsInner
     */
    'cluster_name'?: string;
    /**
     * 
     * @type {OrganizationCustomRoleClusterPermission}
     * @memberof OrganizationCustomRoleClusterPermissionsInner
     */
    'permission'?: OrganizationCustomRoleClusterPermission;
}


/**
 * 
 * @export
 * @interface OrganizationCustomRoleCreateRequest
 */
export interface OrganizationCustomRoleCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof OrganizationCustomRoleCreateRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationCustomRoleCreateRequest
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface OrganizationCustomRoleList
 */
export interface OrganizationCustomRoleList {
    /**
     * 
     * @type {Array<OrganizationCustomRole>}
     * @memberof OrganizationCustomRoleList
     */
    'results'?: Array<OrganizationCustomRole>;
}
/**
 * Indicates the permission for a target project and a given environment type, from the lowest to the highest: - `NO_ACCESS` user has no access - `VIEWER` user can access the environment (and applications / containers / databases / variables) - `DEPLOYER` user can deploy the environment (dependent on the required cluster permission `ENV_CREATOR`) - `MANAGER` user can create an environment (and applications / containers / databases / variables) 
 * @export
 * @enum {string}
 */

export const OrganizationCustomRoleProjectPermission = {
    NO_ACCESS: 'NO_ACCESS',
    VIEWER: 'VIEWER',
    DEPLOYER: 'DEPLOYER',
    MANAGER: 'MANAGER'
} as const;

export type OrganizationCustomRoleProjectPermission = typeof OrganizationCustomRoleProjectPermission[keyof typeof OrganizationCustomRoleProjectPermission];


/**
 * 
 * @export
 * @interface OrganizationCustomRoleProjectPermissionsInner
 */
export interface OrganizationCustomRoleProjectPermissionsInner {
    /**
     * 
     * @type {string}
     * @memberof OrganizationCustomRoleProjectPermissionsInner
     */
    'project_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationCustomRoleProjectPermissionsInner
     */
    'project_name'?: string;
    /**
     * If `is_admin` is `true`, the user is: - automatically `MANAGER` for each environment type - allowed to manage project deployment rules - able to delete the project    Note that `permissions` can then be ignored for this project 
     * @type {boolean}
     * @memberof OrganizationCustomRoleProjectPermissionsInner
     */
    'is_admin'?: boolean;
    /**
     * 
     * @type {Array<OrganizationCustomRoleUpdateRequestProjectPermissionsInnerPermissionsInner>}
     * @memberof OrganizationCustomRoleProjectPermissionsInner
     */
    'permissions'?: Array<OrganizationCustomRoleUpdateRequestProjectPermissionsInnerPermissionsInner>;
}
/**
 * 
 * @export
 * @interface OrganizationCustomRoleUpdateRequest
 */
export interface OrganizationCustomRoleUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof OrganizationCustomRoleUpdateRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationCustomRoleUpdateRequest
     */
    'description'?: string;
    /**
     * Should contain an entry for every existing cluster
     * @type {Array<OrganizationCustomRoleUpdateRequestClusterPermissionsInner>}
     * @memberof OrganizationCustomRoleUpdateRequest
     */
    'cluster_permissions': Array<OrganizationCustomRoleUpdateRequestClusterPermissionsInner>;
    /**
     * Should contain an entry for every existing project
     * @type {Array<OrganizationCustomRoleUpdateRequestProjectPermissionsInner>}
     * @memberof OrganizationCustomRoleUpdateRequest
     */
    'project_permissions': Array<OrganizationCustomRoleUpdateRequestProjectPermissionsInner>;
}
/**
 * 
 * @export
 * @interface OrganizationCustomRoleUpdateRequestClusterPermissionsInner
 */
export interface OrganizationCustomRoleUpdateRequestClusterPermissionsInner {
    /**
     * 
     * @type {string}
     * @memberof OrganizationCustomRoleUpdateRequestClusterPermissionsInner
     */
    'cluster_id'?: string;
    /**
     * 
     * @type {OrganizationCustomRoleClusterPermission}
     * @memberof OrganizationCustomRoleUpdateRequestClusterPermissionsInner
     */
    'permission'?: OrganizationCustomRoleClusterPermission;
}


/**
 * 
 * @export
 * @interface OrganizationCustomRoleUpdateRequestProjectPermissionsInner
 */
export interface OrganizationCustomRoleUpdateRequestProjectPermissionsInner {
    /**
     * 
     * @type {string}
     * @memberof OrganizationCustomRoleUpdateRequestProjectPermissionsInner
     */
    'project_id'?: string;
    /**
     * If `is_admin` is `true`, the user is: - automatically `MANAGER` for each environment type - allowed to manage project deployment rules - able to delete the project    Note that `permissions` can then be ignored for this project 
     * @type {boolean}
     * @memberof OrganizationCustomRoleUpdateRequestProjectPermissionsInner
     */
    'is_admin'?: boolean;
    /**
     * Mandatory if `is_admin` is `false`   Should contain an entry for every environment type: - `DEVELOPMENT` - `PREVIEW` - `STAGING` - `PRODUCTION` 
     * @type {Array<OrganizationCustomRoleUpdateRequestProjectPermissionsInnerPermissionsInner>}
     * @memberof OrganizationCustomRoleUpdateRequestProjectPermissionsInner
     */
    'permissions'?: Array<OrganizationCustomRoleUpdateRequestProjectPermissionsInnerPermissionsInner>;
}
/**
 * 
 * @export
 * @interface OrganizationCustomRoleUpdateRequestProjectPermissionsInnerPermissionsInner
 */
export interface OrganizationCustomRoleUpdateRequestProjectPermissionsInnerPermissionsInner {
    /**
     * 
     * @type {EnvironmentModeEnum}
     * @memberof OrganizationCustomRoleUpdateRequestProjectPermissionsInnerPermissionsInner
     */
    'environment_type'?: EnvironmentModeEnum;
    /**
     * 
     * @type {OrganizationCustomRoleProjectPermission}
     * @memberof OrganizationCustomRoleUpdateRequestProjectPermissionsInnerPermissionsInner
     */
    'permission'?: OrganizationCustomRoleProjectPermission;
}


/**
 * 
 * @export
 * @interface OrganizationEditRequest
 */
export interface OrganizationEditRequest {
    /**
     * name is case insensitive
     * @type {string}
     * @memberof OrganizationEditRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationEditRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationEditRequest
     */
    'website_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationEditRequest
     */
    'repository'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationEditRequest
     */
    'logo_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationEditRequest
     */
    'icon_url'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof OrganizationEditRequest
     */
    'admin_emails'?: Array<string> | null;
}
/**
 * Origin of the organization event
 * @export
 * @enum {string}
 */

export const OrganizationEventOrigin = {
    API: 'API',
    CLI: 'CLI',
    CONSOLE: 'CONSOLE',
    GIT: 'GIT',
    QOVERY_INTERNAL: 'QOVERY_INTERNAL',
    TERRAFORM_PROVIDER: 'TERRAFORM_PROVIDER'
} as const;

export type OrganizationEventOrigin = typeof OrganizationEventOrigin[keyof typeof OrganizationEventOrigin];


/**
 * 
 * @export
 * @interface OrganizationEventResponse
 */
export interface OrganizationEventResponse {
    /**
     * 
     * @type {string}
     * @memberof OrganizationEventResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationEventResponse
     */
    'timestamp'?: string;
    /**
     * 
     * @type {OrganizationEventType}
     * @memberof OrganizationEventResponse
     */
    'event_type'?: OrganizationEventType;
    /**
     * 
     * @type {string}
     * @memberof OrganizationEventResponse
     */
    'target_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationEventResponse
     */
    'target_name'?: string;
    /**
     * 
     * @type {OrganizationEventTargetType}
     * @memberof OrganizationEventResponse
     */
    'target_type'?: OrganizationEventTargetType;
    /**
     * 
     * @type {OrganizationEventSubTargetType}
     * @memberof OrganizationEventResponse
     */
    'sub_target_type'?: OrganizationEventSubTargetType | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationEventResponse
     */
    'change'?: string;
    /**
     * 
     * @type {OrganizationEventOrigin}
     * @memberof OrganizationEventResponse
     */
    'origin'?: OrganizationEventOrigin;
    /**
     * 
     * @type {string}
     * @memberof OrganizationEventResponse
     */
    'triggered_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationEventResponse
     */
    'project_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationEventResponse
     */
    'project_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationEventResponse
     */
    'environment_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationEventResponse
     */
    'environment_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationEventResponse
     */
    'user_agent'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationEventResponse
     */
    'original_change'?: string | null;
}


/**
 * 
 * @export
 * @interface OrganizationEventResponseList
 */
export interface OrganizationEventResponseList {
    /**
     * 
     * @type {OrganizationEventResponseListLinks}
     * @memberof OrganizationEventResponseList
     */
    'links'?: OrganizationEventResponseListLinks;
    /**
     * Indicates if you cannot see previous logs according to your organization max limit
     * @type {boolean}
     * @memberof OrganizationEventResponseList
     */
    'organization_max_limit_reached'?: boolean;
    /**
     * 
     * @type {Array<OrganizationEventResponse>}
     * @memberof OrganizationEventResponseList
     */
    'events'?: Array<OrganizationEventResponse>;
}
/**
 * 
 * @export
 * @interface OrganizationEventResponseListLinks
 */
export interface OrganizationEventResponseListLinks {
    /**
     * 
     * @type {string}
     * @memberof OrganizationEventResponseListLinks
     */
    'previous'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationEventResponseListLinks
     */
    'next'?: string;
}
/**
 * Type of the organization event
 * @export
 * @enum {string}
 */

export const OrganizationEventSubTargetType = {
    ADVANCED_SETTINGS: 'ADVANCED_SETTINGS',
    ALERT_RULE: 'ALERT_RULE',
    ANNOTATIONS_GROUP: 'ANNOTATIONS_GROUP',
    API_TOKEN: 'API_TOKEN',
    BILLING_INFO: 'BILLING_INFO',
    BILLING_USAGE_REPORT: 'BILLING_USAGE_REPORT',
    CLOUD_PROVIDER_CREDENTIALS: 'CLOUD_PROVIDER_CREDENTIALS',
    CLUSTER_CREDENTIALS: 'CLUSTER_CREDENTIALS',
    CLUSTER_ROUTING_TABLE: 'CLUSTER_ROUTING_TABLE',
    CONFIG: 'CONFIG',
    CREDIT_CARD: 'CREDIT_CARD',
    CREDIT_CODE: 'CREDIT_CODE',
    CUSTOM_DOMAIN: 'CUSTOM_DOMAIN',
    CUSTOM_ROLE: 'CUSTOM_ROLE',
    DEPLOYMENT_RULE: 'DEPLOYMENT_RULE',
    DEPLOYMENT_STAGE: 'DEPLOYMENT_STAGE',
    GITHUB_APP: 'GITHUB_APP',
    GIT_REPOSITORY: 'GIT_REPOSITORY',
    GIT_TOKEN: 'GIT_TOKEN',
    INVITATION: 'INVITATION',
    KUBERNETES_CONFIGURATION: 'KUBERNETES_CONFIGURATION',
    KUBERNETES_CREDENTIALS: 'KUBERNETES_CREDENTIALS',
    LABELS_GROUP: 'LABELS_GROUP',
    MEMBER_ROLE: 'MEMBER_ROLE',
    PLAN: 'PLAN',
    REMOTE_ACCESS: 'REMOTE_ACCESS',
    SECRET: 'SECRET',
    SSO: 'SSO',
    TERRAFORM: 'TERRAFORM',
    TRANSFER_OWNERSHIP: 'TRANSFER_OWNERSHIP',
    VARIABLE: 'VARIABLE'
} as const;

export type OrganizationEventSubTargetType = typeof OrganizationEventSubTargetType[keyof typeof OrganizationEventSubTargetType];


/**
 * The target level to fetch
 * @export
 * @enum {string}
 */

export const OrganizationEventTargetLevel = {
    PROJECT: 'PROJECT',
    ENVIRONMENT: 'ENVIRONMENT'
} as const;

export type OrganizationEventTargetLevel = typeof OrganizationEventTargetLevel[keyof typeof OrganizationEventTargetLevel];


/**
 * 
 * @export
 * @interface OrganizationEventTargetResponseList
 */
export interface OrganizationEventTargetResponseList {
    /**
     * 
     * @type {Array<ClusterCloudProviderInfoCredentials>}
     * @memberof OrganizationEventTargetResponseList
     */
    'targets'?: Array<ClusterCloudProviderInfoCredentials>;
}
/**
 * Type of the organization event
 * @export
 * @enum {string}
 */

export const OrganizationEventTargetType = {
    APPLICATION: 'APPLICATION',
    CLUSTER: 'CLUSTER',
    CONTAINER: 'CONTAINER',
    CONTAINER_REGISTRY: 'CONTAINER_REGISTRY',
    DATABASE: 'DATABASE',
    ENTERPRISE_CONNECTION: 'ENTERPRISE_CONNECTION',
    ENVIRONMENT: 'ENVIRONMENT',
    JOB: 'JOB',
    HELM: 'HELM',
    HELM_REPOSITORY: 'HELM_REPOSITORY',
    MEMBERS_AND_ROLES: 'MEMBERS_AND_ROLES',
    ORGANIZATION: 'ORGANIZATION',
    PROJECT: 'PROJECT',
    WEBHOOK: 'WEBHOOK',
    TERRAFORM: 'TERRAFORM'
} as const;

export type OrganizationEventTargetType = typeof OrganizationEventTargetType[keyof typeof OrganizationEventTargetType];


/**
 * Type of the organization event
 * @export
 * @enum {string}
 */

export const OrganizationEventType = {
    CREATE: 'CREATE',
    UPDATE: 'UPDATE',
    DELETE: 'DELETE',
    ACCEPT: 'ACCEPT',
    EXPORT: 'EXPORT',
    CLONE: 'CLONE',
    DEPLOY_QUEUED: 'DEPLOY_QUEUED',
    STOP_QUEUED: 'STOP_QUEUED',
    RESTART_QUEUED: 'RESTART_QUEUED',
    DELETE_QUEUED: 'DELETE_QUEUED',
    UNINSTALL_QUEUED: 'UNINSTALL_QUEUED',
    MAINTENANCE: 'MAINTENANCE',
    DRY_RUN: 'DRY_RUN',
    TRIGGER_REDEPLOY: 'TRIGGER_REDEPLOY',
    TRIGGER_CANCEL: 'TRIGGER_CANCEL',
    FORCE_RUN_QUEUED: 'FORCE_RUN_QUEUED',
    FORCE_RUN_QUEUED_DEPLOY: 'FORCE_RUN_QUEUED_DEPLOY',
    FORCE_RUN_QUEUED_STOP: 'FORCE_RUN_QUEUED_STOP',
    FORCE_RUN_QUEUED_DELETE: 'FORCE_RUN_QUEUED_DELETE',
    TRIGGER_DEPLOY: 'TRIGGER_DEPLOY',
    TRIGGER_STOP: 'TRIGGER_STOP',
    TRIGGER_RESTART: 'TRIGGER_RESTART',
    TRIGGER_DELETE: 'TRIGGER_DELETE',
    TRIGGER_UNINSTALL: 'TRIGGER_UNINSTALL',
    TRIGGER_DEPLOY_DRY_RUN: 'TRIGGER_DEPLOY_DRY_RUN',
    TRIGGER_TERRAFORM_FORCE_UNLOCK: 'TRIGGER_TERRAFORM_FORCE_UNLOCK',
    TRIGGER_TERRAFORM_MIGRATE_STATE: 'TRIGGER_TERRAFORM_MIGRATE_STATE',
    TRIGGER_FORCE_RUN: 'TRIGGER_FORCE_RUN',
    TRIGGER_FORCE_RUN_DEPLOY: 'TRIGGER_FORCE_RUN_DEPLOY',
    TRIGGER_FORCE_RUN_STOP: 'TRIGGER_FORCE_RUN_STOP',
    TRIGGER_FORCE_RUN_DELETE: 'TRIGGER_FORCE_RUN_DELETE',
    DEPLOYED: 'DEPLOYED',
    STOPPED: 'STOPPED',
    DELETED: 'DELETED',
    UNINSTALLED: 'UNINSTALLED',
    RESTARTED: 'RESTARTED',
    DEPLOYED_DRY_RUN: 'DEPLOYED_DRY_RUN',
    FORCE_RUN_SUCCEEDED: 'FORCE_RUN_SUCCEEDED',
    TERRAFORM_FORCE_UNLOCK_SUCCEEDED: 'TERRAFORM_FORCE_UNLOCK_SUCCEEDED',
    TERRAFORM_MIGRATE_STATE_SUCCEEDED: 'TERRAFORM_MIGRATE_STATE_SUCCEEDED',
    DEPLOY_FAILED: 'DEPLOY_FAILED',
    STOP_FAILED: 'STOP_FAILED',
    DELETE_FAILED: 'DELETE_FAILED',
    UNINSTALL_FAILED: 'UNINSTALL_FAILED',
    RESTART_FAILED: 'RESTART_FAILED',
    DEPLOYED_DRY_RUN_FAILED: 'DEPLOYED_DRY_RUN_FAILED',
    FORCE_RUN_FAILED: 'FORCE_RUN_FAILED',
    TERRAFORM_FORCE_UNLOCK_FAILED: 'TERRAFORM_FORCE_UNLOCK_FAILED',
    TERRAFORM_MIGRATE_STATE_FAILED: 'TERRAFORM_MIGRATE_STATE_FAILED',
    SHELL: 'SHELL',
    SSO: 'SSO',
    PORT_FORWARD: 'PORT_FORWARD',
    REMOTE_DEBUG: 'REMOTE_DEBUG',
    IMPORT: 'IMPORT',
    LOCK: 'LOCK',
    UNLOCK: 'UNLOCK'
} as const;

export type OrganizationEventType = typeof OrganizationEventType[keyof typeof OrganizationEventType];


/**
 * 
 * @export
 * @interface OrganizationGithubAppConnectRequest
 */
export interface OrganizationGithubAppConnectRequest {
    /**
     * 
     * @type {string}
     * @memberof OrganizationGithubAppConnectRequest
     */
    'installation_id': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationGithubAppConnectRequest
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface OrganizationJobAutoDeployRequest
 */
export interface OrganizationJobAutoDeployRequest {
    /**
     * the job image name to deploy
     * @type {string}
     * @memberof OrganizationJobAutoDeployRequest
     */
    'image_name'?: string;
    /**
     * the new tag to deploy
     * @type {string}
     * @memberof OrganizationJobAutoDeployRequest
     */
    'tag'?: string;
}
/**
 * 
 * @export
 * @interface OrganizationLabelsGroupAssociatedItemsResponseList
 */
export interface OrganizationLabelsGroupAssociatedItemsResponseList {
    /**
     * 
     * @type {Array<OrganizationLabelsGroupAssociatedItemsResponseListResultsInner>}
     * @memberof OrganizationLabelsGroupAssociatedItemsResponseList
     */
    'results'?: Array<OrganizationLabelsGroupAssociatedItemsResponseListResultsInner>;
}
/**
 * 
 * @export
 * @interface OrganizationLabelsGroupAssociatedItemsResponseListResultsInner
 */
export interface OrganizationLabelsGroupAssociatedItemsResponseListResultsInner {
    /**
     * 
     * @type {string}
     * @memberof OrganizationLabelsGroupAssociatedItemsResponseListResultsInner
     */
    'cluster_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationLabelsGroupAssociatedItemsResponseListResultsInner
     */
    'cluster_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationLabelsGroupAssociatedItemsResponseListResultsInner
     */
    'project_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationLabelsGroupAssociatedItemsResponseListResultsInner
     */
    'project_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationLabelsGroupAssociatedItemsResponseListResultsInner
     */
    'environment_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationLabelsGroupAssociatedItemsResponseListResultsInner
     */
    'environment_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationLabelsGroupAssociatedItemsResponseListResultsInner
     */
    'item_id': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationLabelsGroupAssociatedItemsResponseListResultsInner
     */
    'item_name': string;
    /**
     * 
     * @type {LabelsGroupAssociatedItemType}
     * @memberof OrganizationLabelsGroupAssociatedItemsResponseListResultsInner
     */
    'item_type': LabelsGroupAssociatedItemType;
}


/**
 * 
 * @export
 * @interface OrganizationLabelsGroupCreateRequest
 */
export interface OrganizationLabelsGroupCreateRequest {
    /**
     * name of the labels group
     * @type {string}
     * @memberof OrganizationLabelsGroupCreateRequest
     */
    'name': string;
    /**
     * 
     * @type {Array<Label>}
     * @memberof OrganizationLabelsGroupCreateRequest
     */
    'labels': Array<Label>;
}
/**
 * 
 * @export
 * @interface OrganizationLabelsGroupEnrichedResponse
 */
export interface OrganizationLabelsGroupEnrichedResponse {
    /**
     * 
     * @type {string}
     * @memberof OrganizationLabelsGroupEnrichedResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationLabelsGroupEnrichedResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationLabelsGroupEnrichedResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationLabelsGroupEnrichedResponse
     */
    'name': string;
    /**
     * 
     * @type {Array<Label>}
     * @memberof OrganizationLabelsGroupEnrichedResponse
     */
    'labels': Array<Label>;
    /**
     * 
     * @type {number}
     * @memberof OrganizationLabelsGroupEnrichedResponse
     */
    'associated_items_count'?: number;
}
/**
 * 
 * @export
 * @interface OrganizationLabelsGroupResponse
 */
export interface OrganizationLabelsGroupResponse {
    /**
     * 
     * @type {string}
     * @memberof OrganizationLabelsGroupResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationLabelsGroupResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationLabelsGroupResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationLabelsGroupResponse
     */
    'name': string;
    /**
     * 
     * @type {Array<Label>}
     * @memberof OrganizationLabelsGroupResponse
     */
    'labels': Array<Label>;
}
/**
 * 
 * @export
 * @interface OrganizationRequest
 */
export interface OrganizationRequest {
    /**
     * name is case insensitive
     * @type {string}
     * @memberof OrganizationRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {PlanEnum}
     * @memberof OrganizationRequest
     */
    'plan': PlanEnum;
    /**
     * 
     * @type {string}
     * @memberof OrganizationRequest
     */
    'website_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationRequest
     */
    'repository'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationRequest
     */
    'logo_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationRequest
     */
    'icon_url'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof OrganizationRequest
     */
    'admin_emails'?: Array<string> | null;
}


/**
 * 
 * @export
 * @interface OrganizationResponseList
 */
export interface OrganizationResponseList {
    /**
     * 
     * @type {Array<Organization>}
     * @memberof OrganizationResponseList
     */
    'results'?: Array<Organization>;
}
/**
 * 
 * @export
 * @interface OrganizationWebhookCreateRequest
 */
export interface OrganizationWebhookCreateRequest {
    /**
     * 
     * @type {OrganizationWebhookKindEnum}
     * @memberof OrganizationWebhookCreateRequest
     */
    'kind': OrganizationWebhookKindEnum;
    /**
     * Set the public HTTP or HTTPS endpoint that will receive the specified events. The target URL must starts with `http://` or `https://` 
     * @type {string}
     * @memberof OrganizationWebhookCreateRequest
     */
    'target_url': string;
    /**
     * Make sure you receive a payload to sign the Qovery request with your secret. Qovery will add a HTTP header `Qovery-Signature: <Your Secret>` to every webhook requests sent to your target URL. 
     * @type {string}
     * @memberof OrganizationWebhookCreateRequest
     */
    'target_secret'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationWebhookCreateRequest
     */
    'description'?: string;
    /**
     * Turn on or off your endpoint.
     * @type {boolean}
     * @memberof OrganizationWebhookCreateRequest
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {Array<OrganizationWebhookEventEnum>}
     * @memberof OrganizationWebhookCreateRequest
     */
    'events': Array<OrganizationWebhookEventEnum>;
    /**
     * Specify the project names you want to filter to.  This webhook will be triggered only if the event is coming from the specified Project IDs. Notes: 1. Wildcard is accepted E.g. `product*`. 2. Name is case insensitive. 
     * @type {Array<string>}
     * @memberof OrganizationWebhookCreateRequest
     */
    'project_names_filter'?: Array<string>;
    /**
     * Specify the environment modes you want to filter to. This webhook will be triggered only if the event is coming from an environment with the specified mode. 
     * @type {Array<EnvironmentModeEnum>}
     * @memberof OrganizationWebhookCreateRequest
     */
    'environment_types_filter'?: Array<EnvironmentModeEnum>;
}


/**
 * 
 * @export
 * @interface OrganizationWebhookCreateResponse
 */
export interface OrganizationWebhookCreateResponse {
    /**
     * 
     * @type {string}
     * @memberof OrganizationWebhookCreateResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationWebhookCreateResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationWebhookCreateResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {OrganizationWebhookKindEnum}
     * @memberof OrganizationWebhookCreateResponse
     */
    'kind'?: OrganizationWebhookKindEnum;
    /**
     * Set the public HTTP or HTTPS endpoint that will receive the specified events. The target URL must starts with `http://` or `https://` 
     * @type {string}
     * @memberof OrganizationWebhookCreateResponse
     */
    'target_url'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationWebhookCreateResponse
     */
    'target_secret_set'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OrganizationWebhookCreateResponse
     */
    'description'?: string;
    /**
     * Turn on or off your endpoint.
     * @type {boolean}
     * @memberof OrganizationWebhookCreateResponse
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {Array<OrganizationWebhookEventEnum>}
     * @memberof OrganizationWebhookCreateResponse
     */
    'events'?: Array<OrganizationWebhookEventEnum>;
    /**
     * Specify the project names you want to filter to.  This webhook will be triggered only if the event is coming from the specified Project IDs. Notes: 1. Wildcard is accepted E.g. `product*`. 2. Name is case insensitive. 
     * @type {Array<string>}
     * @memberof OrganizationWebhookCreateResponse
     */
    'project_names_filter'?: Array<string>;
    /**
     * Specify the environment modes you want to filter to. This webhook will be triggered only if the event is coming from an environment with the specified mode. 
     * @type {Array<EnvironmentModeEnum>}
     * @memberof OrganizationWebhookCreateResponse
     */
    'environment_types_filter'?: Array<EnvironmentModeEnum>;
}


/**
 * Events to subscribe to and send to the `target_url`. - `DEPLOYMENT_STARTED` send an event when a deployment is started and going to be executed - `DEPLOYMENT_CANCELLED` send an event when a deployment is cancelled - `DEPLOYMENT_FAILURE` send an event when a deployment failed - `DEPLOYMENT_SUCCESSFUL` send an event when a deployment is successful 
 * @export
 * @enum {string}
 */

export const OrganizationWebhookEventEnum = {
    STARTED: 'DEPLOYMENT_STARTED',
    CANCELLED: 'DEPLOYMENT_CANCELLED',
    FAILURE: 'DEPLOYMENT_FAILURE',
    SUCCESSFUL: 'DEPLOYMENT_SUCCESSFUL'
} as const;

export type OrganizationWebhookEventEnum = typeof OrganizationWebhookEventEnum[keyof typeof OrganizationWebhookEventEnum];


/**
 * Define the type of the webhook. `SLACK` is a special webhook type to push notifications directly to slack. The `target_url` must be a Slack compatible endpoint.
 * @export
 * @enum {string}
 */

export const OrganizationWebhookKindEnum = {
    STANDARD: 'STANDARD',
    SLACK: 'SLACK'
} as const;

export type OrganizationWebhookKindEnum = typeof OrganizationWebhookKindEnum[keyof typeof OrganizationWebhookKindEnum];


/**
 * 
 * @export
 * @interface OrganizationWebhookResponse
 */
export interface OrganizationWebhookResponse {
    /**
     * 
     * @type {string}
     * @memberof OrganizationWebhookResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationWebhookResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationWebhookResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {OrganizationWebhookKindEnum}
     * @memberof OrganizationWebhookResponse
     */
    'kind'?: OrganizationWebhookKindEnum;
    /**
     * Set the public HTTP or HTTPS endpoint that will receive the specified events. The target URL must starts with `http://` or `https://` 
     * @type {string}
     * @memberof OrganizationWebhookResponse
     */
    'target_url'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationWebhookResponse
     */
    'target_secret_set'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OrganizationWebhookResponse
     */
    'description'?: string;
    /**
     * Turn on or off your endpoint.
     * @type {boolean}
     * @memberof OrganizationWebhookResponse
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {Array<OrganizationWebhookEventEnum>}
     * @memberof OrganizationWebhookResponse
     */
    'events'?: Array<OrganizationWebhookEventEnum>;
    /**
     * Specify the project names you want to filter to.  This webhook will be triggered only if the event is coming from the specified Project IDs. Notes: 1. Wildcard is accepted E.g. `product*`. 2. Name is case insensitive. 
     * @type {Array<string>}
     * @memberof OrganizationWebhookResponse
     */
    'project_names_filter'?: Array<string>;
    /**
     * Specify the environment modes you want to filter to. This webhook will be triggered only if the event is coming from an environment with the specified mode. 
     * @type {Array<EnvironmentModeEnum>}
     * @memberof OrganizationWebhookResponse
     */
    'environment_types_filter'?: Array<EnvironmentModeEnum>;
}


/**
 * 
 * @export
 * @interface OrganizationWebhookResponseList
 */
export interface OrganizationWebhookResponseList {
    /**
     * 
     * @type {Array<OrganizationWebhookResponse>}
     * @memberof OrganizationWebhookResponseList
     */
    'results'?: Array<OrganizationWebhookResponse>;
}
/**
 * 
 * @export
 * @interface PaginationData
 */
export interface PaginationData {
    /**
     * 
     * @type {number}
     * @memberof PaginationData
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof PaginationData
     */
    'page_size': number;
}
/**
 * 
 * @export
 * @interface ParseTerraformVariablesFromGitRepo200Response
 */
export interface ParseTerraformVariablesFromGitRepo200Response {
    /**
     * 
     * @type {Array<TerraformVariableDefinition>}
     * @memberof ParseTerraformVariablesFromGitRepo200Response
     */
    'results'?: Array<TerraformVariableDefinition>;
}
/**
 * FREE, BUSINESS & PROFESSIONAL are deprecated. 2025 plans are the new plans available.
 * @export
 * @enum {string}
 */

export const PlanEnum = {
    FREE: 'FREE',
    TEAM: 'TEAM',
    TEAM_YEARLY: 'TEAM_YEARLY',
    ENTERPRISE: 'ENTERPRISE',
    ENTERPRISE_YEARLY: 'ENTERPRISE_YEARLY',
    PROFESSIONAL: 'PROFESSIONAL',
    BUSINESS: 'BUSINESS',
    USER_2025: 'USER_2025',
    TEAM_2025: 'TEAM_2025',
    BUSINESS_2025: 'BUSINESS_2025',
    ENTERPRISE_2025: 'ENTERPRISE_2025'
} as const;

export type PlanEnum = typeof PlanEnum[keyof typeof PlanEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const PortProtocolEnum = {
    HTTP: 'HTTP',
    GRPC: 'GRPC',
    TCP: 'TCP',
    UDP: 'UDP'
} as const;

export type PortProtocolEnum = typeof PortProtocolEnum[keyof typeof PortProtocolEnum];


/**
 * 
 * @export
 * @interface Probe
 */
export interface Probe {
    /**
     * 
     * @type {ProbeType}
     * @memberof Probe
     */
    'type'?: ProbeType;
    /**
     * 
     * @type {number}
     * @memberof Probe
     */
    'initial_delay_seconds'?: number;
    /**
     * 
     * @type {number}
     * @memberof Probe
     */
    'period_seconds'?: number;
    /**
     * 
     * @type {number}
     * @memberof Probe
     */
    'timeout_seconds'?: number;
    /**
     * 
     * @type {number}
     * @memberof Probe
     */
    'success_threshold'?: number;
    /**
     * 
     * @type {number}
     * @memberof Probe
     */
    'failure_threshold'?: number;
}
/**
 * 
 * @export
 * @interface ProbeType
 */
export interface ProbeType {
    /**
     * 
     * @type {ProbeTypeTcp}
     * @memberof ProbeType
     */
    'tcp'?: ProbeTypeTcp | null;
    /**
     * 
     * @type {ProbeTypeHttp}
     * @memberof ProbeType
     */
    'http'?: ProbeTypeHttp | null;
    /**
     * 
     * @type {ProbeTypeExec}
     * @memberof ProbeType
     */
    'exec'?: ProbeTypeExec | null;
    /**
     * 
     * @type {ProbeTypeGrpc}
     * @memberof ProbeType
     */
    'grpc'?: ProbeTypeGrpc | null;
}
/**
 * 
 * @export
 * @interface ProbeTypeExec
 */
export interface ProbeTypeExec {
    /**
     * 
     * @type {Array<string>}
     * @memberof ProbeTypeExec
     */
    'command'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ProbeTypeGrpc
 */
export interface ProbeTypeGrpc {
    /**
     * 
     * @type {string}
     * @memberof ProbeTypeGrpc
     */
    'service'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ProbeTypeGrpc
     */
    'port'?: number;
}
/**
 * 
 * @export
 * @interface ProbeTypeHttp
 */
export interface ProbeTypeHttp {
    /**
     * 
     * @type {string}
     * @memberof ProbeTypeHttp
     */
    'path'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProbeTypeHttp
     */
    'scheme'?: string;
    /**
     * 
     * @type {number}
     * @memberof ProbeTypeHttp
     */
    'port'?: number;
}
/**
 * 
 * @export
 * @interface ProbeTypeTcp
 */
export interface ProbeTypeTcp {
    /**
     * 
     * @type {number}
     * @memberof ProbeTypeTcp
     */
    'port'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProbeTypeTcp
     */
    'host'?: string | null;
}
/**
 * 
 * @export
 * @interface Project
 */
export interface Project {
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    'associated_environments_count': number;
    /**
     * 
     * @type {ReferenceObject}
     * @memberof Project
     */
    'organization': ReferenceObject;
}
/**
 * 
 * @export
 * @interface ProjectCurrentCost
 */
export interface ProjectCurrentCost {
    /**
     * 
     * @type {string}
     * @memberof ProjectCurrentCost
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectCurrentCost
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof ProjectCurrentCost
     */
    'consumed_time_in_seconds': number;
    /**
     * 
     * @type {Cost}
     * @memberof ProjectCurrentCost
     */
    'cost': Cost;
    /**
     * 
     * @type {Array<GenericObjectCurrentCost>}
     * @memberof ProjectCurrentCost
     */
    'environments'?: Array<GenericObjectCurrentCost>;
}
/**
 * 
 * @export
 * @interface ProjectCurrentCostResponseList
 */
export interface ProjectCurrentCostResponseList {
    /**
     * 
     * @type {Array<ProjectCurrentCost>}
     * @memberof ProjectCurrentCostResponseList
     */
    'projects'?: Array<ProjectCurrentCost>;
}
/**
 * 
 * @export
 * @interface ProjectDeploymentRule
 */
export interface ProjectDeploymentRule {
    /**
     * 
     * @type {string}
     * @memberof ProjectDeploymentRule
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectDeploymentRule
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectDeploymentRule
     */
    'updated_at'?: string;
    /**
     * name is case insensitive
     * @type {string}
     * @memberof ProjectDeploymentRule
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectDeploymentRule
     */
    'description'?: string | null;
    /**
     * 
     * @type {EnvironmentModeEnum}
     * @memberof ProjectDeploymentRule
     */
    'mode': EnvironmentModeEnum;
    /**
     * 
     * @type {string}
     * @memberof ProjectDeploymentRule
     */
    'cluster_id': string;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectDeploymentRule
     */
    'auto_stop'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ProjectDeploymentRule
     */
    'timezone': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectDeploymentRule
     */
    'start_time': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectDeploymentRule
     */
    'stop_time': string;
    /**
     * 
     * @type {Array<WeekdayEnum>}
     * @memberof ProjectDeploymentRule
     */
    'weekdays': Array<WeekdayEnum>;
    /**
     * wildcard pattern composed of \'?\' and/or \'*\' used to target new created environments
     * @type {string}
     * @memberof ProjectDeploymentRule
     */
    'wildcard': string;
    /**
     * used to select the first deployment rule to match new created environments
     * @type {number}
     * @memberof ProjectDeploymentRule
     */
    'priority_index'?: number;
}


/**
 * 
 * @export
 * @interface ProjectDeploymentRuleRequest
 */
export interface ProjectDeploymentRuleRequest {
    /**
     * name is case insensitive
     * @type {string}
     * @memberof ProjectDeploymentRuleRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectDeploymentRuleRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {EnvironmentModeEnum}
     * @memberof ProjectDeploymentRuleRequest
     */
    'mode': EnvironmentModeEnum;
    /**
     * 
     * @type {string}
     * @memberof ProjectDeploymentRuleRequest
     */
    'cluster_id': string;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectDeploymentRuleRequest
     */
    'auto_stop'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ProjectDeploymentRuleRequest
     */
    'timezone': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectDeploymentRuleRequest
     */
    'start_time': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectDeploymentRuleRequest
     */
    'stop_time': string;
    /**
     * 
     * @type {Array<WeekdayEnum>}
     * @memberof ProjectDeploymentRuleRequest
     */
    'weekdays': Array<WeekdayEnum>;
    /**
     * wildcard pattern composed of \'?\' and/or \'*\' used to target new created environments
     * @type {string}
     * @memberof ProjectDeploymentRuleRequest
     */
    'wildcard': string;
}


/**
 * 
 * @export
 * @interface ProjectDeploymentRuleResponseList
 */
export interface ProjectDeploymentRuleResponseList {
    /**
     * 
     * @type {Array<ProjectDeploymentRule>}
     * @memberof ProjectDeploymentRuleResponseList
     */
    'results'?: Array<ProjectDeploymentRule>;
}
/**
 * 
 * @export
 * @interface ProjectDeploymentRulesPriorityOrderRequest
 */
export interface ProjectDeploymentRulesPriorityOrderRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof ProjectDeploymentRulesPriorityOrderRequest
     */
    'project_deployment_rule_ids_in_order'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ProjectRequest
 */
export interface ProjectRequest {
    /**
     * name is case insensitive
     * @type {string}
     * @memberof ProjectRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectRequest
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface ProjectResponseList
 */
export interface ProjectResponseList {
    /**
     * 
     * @type {Array<Project>}
     * @memberof ProjectResponseList
     */
    'results'?: Array<Project>;
}
/**
 * 
 * @export
 * @interface ProjectStats
 */
export interface ProjectStats {
    /**
     * 
     * @type {string}
     * @memberof ProjectStats
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof ProjectStats
     */
    'service_total_number'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProjectStats
     */
    'environment_total_number'?: number;
}
/**
 * 
 * @export
 * @interface ProjectStatsResponseList
 */
export interface ProjectStatsResponseList {
    /**
     * 
     * @type {Array<ProjectStats>}
     * @memberof ProjectStatsResponseList
     */
    'results'?: Array<ProjectStats>;
}
/**
 * 
 * @export
 * @interface QueuedDeploymentRequestForService
 */
export interface QueuedDeploymentRequestForService {
    /**
     * 
     * @type {QueuedDeploymentRequestForServiceIdentifier}
     * @memberof QueuedDeploymentRequestForService
     */
    'identifier': QueuedDeploymentRequestForServiceIdentifier;
    /**
     * 
     * @type {QueuedDeploymentRequestForServiceAuditingData}
     * @memberof QueuedDeploymentRequestForService
     */
    'auditing_data': QueuedDeploymentRequestForServiceAuditingData;
    /**
     * 
     * @type {StatusDetails}
     * @memberof QueuedDeploymentRequestForService
     */
    'status_details': StatusDetails;
    /**
     * 
     * @type {string}
     * @memberof QueuedDeploymentRequestForService
     */
    'icon_uri': string;
}
/**
 * 
 * @export
 * @interface QueuedDeploymentRequestForServiceAuditingData
 */
export interface QueuedDeploymentRequestForServiceAuditingData {
    /**
     * 
     * @type {string}
     * @memberof QueuedDeploymentRequestForServiceAuditingData
     */
    'triggered_by': string;
    /**
     * 
     * @type {OrganizationEventOrigin}
     * @memberof QueuedDeploymentRequestForServiceAuditingData
     */
    'origin'?: OrganizationEventOrigin;
}


/**
 * 
 * @export
 * @interface QueuedDeploymentRequestForServiceIdentifier
 */
export interface QueuedDeploymentRequestForServiceIdentifier {
    /**
     * 
     * @type {string}
     * @memberof QueuedDeploymentRequestForServiceIdentifier
     */
    'deployment_request_id': string;
    /**
     * 
     * @type {string}
     * @memberof QueuedDeploymentRequestForServiceIdentifier
     */
    'service_id': string;
    /**
     * 
     * @type {ServiceTypeEnum}
     * @memberof QueuedDeploymentRequestForServiceIdentifier
     */
    'service_type': ServiceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof QueuedDeploymentRequestForServiceIdentifier
     */
    'name': string;
}


/**
 * 
 * @export
 * @interface QueuedDeploymentRequestWithStages
 */
export interface QueuedDeploymentRequestWithStages {
    /**
     * 
     * @type {QueuedDeploymentRequestWithStagesIdentifier}
     * @memberof QueuedDeploymentRequestWithStages
     */
    'identifier': QueuedDeploymentRequestWithStagesIdentifier;
    /**
     * 
     * @type {QueuedDeploymentRequestWithStagesAuditingData}
     * @memberof QueuedDeploymentRequestWithStages
     */
    'auditing_data': QueuedDeploymentRequestWithStagesAuditingData;
    /**
     * 
     * @type {DeploymentHistoryTriggerAction}
     * @memberof QueuedDeploymentRequestWithStages
     */
    'trigger_action': DeploymentHistoryTriggerAction;
    /**
     * 
     * @type {Array<QueuedDeploymentRequestWithStagesStagesInner>}
     * @memberof QueuedDeploymentRequestWithStages
     */
    'stages': Array<QueuedDeploymentRequestWithStagesStagesInner>;
}


/**
 * 
 * @export
 * @interface QueuedDeploymentRequestWithStagesAuditingData
 */
export interface QueuedDeploymentRequestWithStagesAuditingData {
    /**
     * 
     * @type {string}
     * @memberof QueuedDeploymentRequestWithStagesAuditingData
     */
    'triggered_by': string;
    /**
     * 
     * @type {OrganizationEventOrigin}
     * @memberof QueuedDeploymentRequestWithStagesAuditingData
     */
    'origin'?: OrganizationEventOrigin;
}


/**
 * 
 * @export
 * @interface QueuedDeploymentRequestWithStagesIdentifier
 */
export interface QueuedDeploymentRequestWithStagesIdentifier {
    /**
     * 
     * @type {string}
     * @memberof QueuedDeploymentRequestWithStagesIdentifier
     */
    'deployment_request_id': string;
    /**
     * 
     * @type {string}
     * @memberof QueuedDeploymentRequestWithStagesIdentifier
     */
    'environment_id': string;
}
/**
 * 
 * @export
 * @interface QueuedDeploymentRequestWithStagesStagesInner
 */
export interface QueuedDeploymentRequestWithStagesStagesInner {
    /**
     * 
     * @type {string}
     * @memberof QueuedDeploymentRequestWithStagesStagesInner
     */
    'name': string;
    /**
     * 
     * @type {StageStatusEnum}
     * @memberof QueuedDeploymentRequestWithStagesStagesInner
     */
    'status': StageStatusEnum;
    /**
     * 
     * @type {Array<QueuedDeploymentRequestWithStagesStagesInnerServicesInner>}
     * @memberof QueuedDeploymentRequestWithStagesStagesInner
     */
    'services': Array<QueuedDeploymentRequestWithStagesStagesInnerServicesInner>;
}


/**
 * 
 * @export
 * @interface QueuedDeploymentRequestWithStagesStagesInnerServicesInner
 */
export interface QueuedDeploymentRequestWithStagesStagesInnerServicesInner {
    /**
     * 
     * @type {QueuedDeploymentRequestWithStagesStagesInnerServicesInnerIdentifier}
     * @memberof QueuedDeploymentRequestWithStagesStagesInnerServicesInner
     */
    'identifier': QueuedDeploymentRequestWithStagesStagesInnerServicesInnerIdentifier;
    /**
     * 
     * @type {StageStatusEnum}
     * @memberof QueuedDeploymentRequestWithStagesStagesInnerServicesInner
     */
    'status': StageStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof QueuedDeploymentRequestWithStagesStagesInnerServicesInner
     */
    'icon_uri'?: string;
    /**
     * 
     * @type {QueuedDeploymentRequestWithStagesStagesInnerServicesInnerDetails}
     * @memberof QueuedDeploymentRequestWithStagesStagesInnerServicesInner
     */
    'details'?: QueuedDeploymentRequestWithStagesStagesInnerServicesInnerDetails;
}


/**
 * @type QueuedDeploymentRequestWithStagesStagesInnerServicesInnerDetails
 * @export
 */
export type QueuedDeploymentRequestWithStagesStagesInnerServicesInnerDetails = QueuedDeploymentRequestWithStagesStagesInnerServicesInnerDetailsOneOf;

/**
 * JobDetails
 * @export
 * @interface QueuedDeploymentRequestWithStagesStagesInnerServicesInnerDetailsOneOf
 */
export interface QueuedDeploymentRequestWithStagesStagesInnerServicesInnerDetailsOneOf {
    /**
     * 
     * @type {string}
     * @memberof QueuedDeploymentRequestWithStagesStagesInnerServicesInnerDetailsOneOf
     */
    'job_type': QueuedDeploymentRequestWithStagesStagesInnerServicesInnerDetailsOneOfJobTypeEnum;
}

export const QueuedDeploymentRequestWithStagesStagesInnerServicesInnerDetailsOneOfJobTypeEnum = {
    CRON: 'CRON',
    LIFECYCLE: 'LIFECYCLE'
} as const;

export type QueuedDeploymentRequestWithStagesStagesInnerServicesInnerDetailsOneOfJobTypeEnum = typeof QueuedDeploymentRequestWithStagesStagesInnerServicesInnerDetailsOneOfJobTypeEnum[keyof typeof QueuedDeploymentRequestWithStagesStagesInnerServicesInnerDetailsOneOfJobTypeEnum];

/**
 * 
 * @export
 * @interface QueuedDeploymentRequestWithStagesStagesInnerServicesInnerIdentifier
 */
export interface QueuedDeploymentRequestWithStagesStagesInnerServicesInnerIdentifier {
    /**
     * 
     * @type {string}
     * @memberof QueuedDeploymentRequestWithStagesStagesInnerServicesInnerIdentifier
     */
    'service_id': string;
    /**
     * 
     * @type {ServiceTypeEnum}
     * @memberof QueuedDeploymentRequestWithStagesStagesInnerServicesInnerIdentifier
     */
    'service_type': ServiceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof QueuedDeploymentRequestWithStagesStagesInnerServicesInnerIdentifier
     */
    'name': string;
}


/**
 * 
 * @export
 * @interface RebootServicesRequest
 */
export interface RebootServicesRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof RebootServicesRequest
     */
    'application_ids'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof RebootServicesRequest
     */
    'database_ids'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof RebootServicesRequest
     */
    'container_ids'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ReferenceObject
 */
export interface ReferenceObject {
    /**
     * 
     * @type {string}
     * @memberof ReferenceObject
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface ReferenceObjectStatus
 */
export interface ReferenceObjectStatus {
    /**
     * 
     * @type {string}
     * @memberof ReferenceObjectStatus
     */
    'id': string;
    /**
     * 
     * @type {StateEnum}
     * @memberof ReferenceObjectStatus
     */
    'state': StateEnum;
    /**
     * 
     * @type {ServiceDeploymentStatusEnum}
     * @memberof ReferenceObjectStatus
     */
    'service_deployment_status': ServiceDeploymentStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ReferenceObjectStatus
     */
    'last_deployment_date'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ReferenceObjectStatus
     */
    'is_part_last_deployment': boolean;
    /**
     * 
     * @type {ServiceStepMetrics}
     * @memberof ReferenceObjectStatus
     */
    'steps'?: ServiceStepMetrics;
    /**
     * 
     * @type {string}
     * @memberof ReferenceObjectStatus
     */
    'execution_id'?: string;
    /**
     * 
     * @type {StatusDetails}
     * @memberof ReferenceObjectStatus
     */
    'status_details': StatusDetails;
    /**
     * 
     * @type {string}
     * @memberof ReferenceObjectStatus
     */
    'deployment_request_id': string | null;
    /**
     * 
     * @type {number}
     * @memberof ReferenceObjectStatus
     */
    'deployment_requests_count': number;
}


/**
 * 
 * @export
 * @interface ReferenceObjectStatusResponseList
 */
export interface ReferenceObjectStatusResponseList {
    /**
     * 
     * @type {Array<ReferenceObjectStatus>}
     * @memberof ReferenceObjectStatusResponseList
     */
    'results'?: Array<ReferenceObjectStatus>;
}
/**
 * 
 * @export
 * @interface Referral
 */
export interface Referral {
    /**
     * 
     * @type {number}
     * @memberof Referral
     */
    'total_invited'?: number;
    /**
     * 
     * @type {string}
     * @memberof Referral
     */
    'invitation_link'?: string;
}
/**
 * Mirroring mode when deploying a service from a container registry - Cluster: This is not available on Scaleway. Images within the mirroring registry are organized by \"Qovery cluster\", meaning that the application deployed on the same cluster are all mirrored on the same repository. - Service: Images within the mirroring registry are organized by \"Qovery service\", each service has its own repository 
 * @export
 * @enum {string}
 */

export const RegistryMirroringModeEnum = {
    CLUSTER: 'Cluster',
    SERVICE: 'Service'
} as const;

export type RegistryMirroringModeEnum = typeof RegistryMirroringModeEnum[keyof typeof RegistryMirroringModeEnum];


/**
 * 
 * @export
 * @interface RewardClaim
 */
export interface RewardClaim {
    /**
     * 
     * @type {string}
     * @memberof RewardClaim
     */
    'type'?: RewardClaimTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof RewardClaim
     */
    'code'?: string;
}

export const RewardClaimTypeEnum = {
    INVITATION: 'INVITATION'
} as const;

export type RewardClaimTypeEnum = typeof RewardClaimTypeEnum[keyof typeof RewardClaimTypeEnum];

/**
 * 
 * @export
 * @interface ScalewayClusterCredentials
 */
export interface ScalewayClusterCredentials {
    /**
     * 
     * @type {string}
     * @memberof ScalewayClusterCredentials
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ScalewayClusterCredentials
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ScalewayClusterCredentials
     */
    'scaleway_access_key': string;
    /**
     * 
     * @type {string}
     * @memberof ScalewayClusterCredentials
     */
    'object_type': ScalewayClusterCredentialsObjectTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ScalewayClusterCredentials
     */
    'scaleway_project_id': string;
    /**
     * 
     * @type {string}
     * @memberof ScalewayClusterCredentials
     */
    'scaleway_organization_id': string;
}

export const ScalewayClusterCredentialsObjectTypeEnum = {
    SCW: 'SCW'
} as const;

export type ScalewayClusterCredentialsObjectTypeEnum = typeof ScalewayClusterCredentialsObjectTypeEnum[keyof typeof ScalewayClusterCredentialsObjectTypeEnum];

/**
 * 
 * @export
 * @interface ScalewayCredentialsRequest
 */
export interface ScalewayCredentialsRequest {
    /**
     * 
     * @type {string}
     * @memberof ScalewayCredentialsRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ScalewayCredentialsRequest
     */
    'scaleway_access_key': string;
    /**
     * 
     * @type {string}
     * @memberof ScalewayCredentialsRequest
     */
    'scaleway_secret_key': string;
    /**
     * 
     * @type {string}
     * @memberof ScalewayCredentialsRequest
     */
    'scaleway_project_id': string;
    /**
     * 
     * @type {string}
     * @memberof ScalewayCredentialsRequest
     */
    'scaleway_organization_id': string;
}
/**
 * 
 * @export
 * @interface Secret
 */
export interface Secret {
    /**
     * 
     * @type {string}
     * @memberof Secret
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Secret
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Secret
     */
    'updated_at'?: string;
    /**
     * key is case sensitive
     * @type {string}
     * @memberof Secret
     */
    'key': string;
    /**
     * 
     * @type {SecretOverride}
     * @memberof Secret
     */
    'overridden_secret'?: SecretOverride;
    /**
     * 
     * @type {SecretAlias}
     * @memberof Secret
     */
    'aliased_secret'?: SecretAlias;
    /**
     * 
     * @type {APIVariableScopeEnum}
     * @memberof Secret
     */
    'scope': APIVariableScopeEnum;
    /**
     * 
     * @type {APIVariableTypeEnum}
     * @memberof Secret
     */
    'variable_type'?: APIVariableTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Secret
     */
    'service_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Secret
     */
    'service_name'?: string;
    /**
     * 
     * @type {LinkedServiceTypeEnum}
     * @memberof Secret
     */
    'service_type'?: LinkedServiceTypeEnum;
    /**
     * Entity that created/own the variable (i.e: Qovery, Doppler)
     * @type {string}
     * @memberof Secret
     */
    'owned_by'?: string;
    /**
     * optional variable description (255 characters maximum)
     * @type {string}
     * @memberof Secret
     */
    'description'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Secret
     */
    'enable_interpolation_in_file'?: boolean | null;
}


/**
 * 
 * @export
 * @interface SecretAlias
 */
export interface SecretAlias {
    /**
     * 
     * @type {string}
     * @memberof SecretAlias
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SecretAlias
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof SecretAlias
     */
    'mount_path': string;
    /**
     * 
     * @type {APIVariableScopeEnum}
     * @memberof SecretAlias
     */
    'scope': APIVariableScopeEnum;
    /**
     * 
     * @type {APIVariableTypeEnum}
     * @memberof SecretAlias
     */
    'variable_type': APIVariableTypeEnum;
    /**
     * optional variable description (255 characters maximum)
     * @type {string}
     * @memberof SecretAlias
     */
    'description'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof SecretAlias
     */
    'enable_interpolation_in_file'?: boolean | null;
}


/**
 * 
 * @export
 * @interface SecretEditRequest
 */
export interface SecretEditRequest {
    /**
     * 
     * @type {string}
     * @memberof SecretEditRequest
     */
    'value'?: string;
    /**
     * 
     * @type {string}
     * @memberof SecretEditRequest
     */
    'key': string;
    /**
     * optional variable description (255 characters maximum)
     * @type {string}
     * @memberof SecretEditRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof SecretEditRequest
     */
    'enable_interpolation_in_file'?: boolean | null;
}
/**
 * 
 * @export
 * @interface SecretOverride
 */
export interface SecretOverride {
    /**
     * 
     * @type {string}
     * @memberof SecretOverride
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SecretOverride
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof SecretOverride
     */
    'mount_path': string;
    /**
     * 
     * @type {APIVariableScopeEnum}
     * @memberof SecretOverride
     */
    'scope': APIVariableScopeEnum;
    /**
     * 
     * @type {APIVariableTypeEnum}
     * @memberof SecretOverride
     */
    'variable_type': APIVariableTypeEnum;
    /**
     * optional variable description (255 characters maximum)
     * @type {string}
     * @memberof SecretOverride
     */
    'description'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof SecretOverride
     */
    'enable_interpolation_in_file'?: boolean | null;
}


/**
 * 
 * @export
 * @interface SecretRequest
 */
export interface SecretRequest {
    /**
     * key is case sensitive
     * @type {string}
     * @memberof SecretRequest
     */
    'key': string;
    /**
     * value of the secret. Clear value will never be returned
     * @type {string}
     * @memberof SecretRequest
     */
    'value'?: string;
    /**
     * should be set for file only. variable mount path make secret a file (where file should be mounted).
     * @type {string}
     * @memberof SecretRequest
     */
    'mount_path'?: string | null;
    /**
     * optional variable description (255 character maximum)
     * @type {string}
     * @memberof SecretRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof SecretRequest
     */
    'enable_interpolation_in_file'?: boolean | null;
}
/**
 * 
 * @export
 * @interface SecretResponseList
 */
export interface SecretResponseList {
    /**
     * 
     * @type {Array<Secret>}
     * @memberof SecretResponseList
     */
    'results'?: Array<Secret>;
}
/**
 * 
 * @export
 * @interface Service
 */
export interface Service {
    /**
     * uuid of the associated service (application, database, job, gateway...)
     * @type {string}
     * @memberof Service
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Service
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Service
     */
    'updated_at'?: string;
    /**
     * 
     * @type {ServiceTypeEnum}
     * @memberof Service
     */
    'type'?: ServiceTypeEnum;
    /**
     * name of the service
     * @type {string}
     * @memberof Service
     */
    'name'?: string;
    /**
     * Git commit ID corresponding to the deployed version of the application
     * @type {string}
     * @memberof Service
     */
    'deployed_commit_id'?: string;
    /**
     * uuid of the user that made the last update
     * @type {string}
     * @memberof Service
     */
    'last_updated_by'?: string;
    /**
     * global overview of resources consumption of the service
     * @type {number}
     * @memberof Service
     */
    'consumed_resources_in_percent'?: number;
    /**
     * describes the typology of service (container, postgresl, redis...)
     * @type {string}
     * @memberof Service
     */
    'service_typology'?: string;
    /**
     * for databases this field exposes the database version
     * @type {string}
     * @memberof Service
     */
    'service_version'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Service
     */
    'to_update'?: boolean;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ServiceActionEnum = {
    DEPLOY: 'DEPLOY',
    DELETE: 'DELETE',
    RESTART: 'RESTART',
    STOP: 'STOP',
    UNKNOWN: 'UNKNOWN'
} as const;

export type ServiceActionEnum = typeof ServiceActionEnum[keyof typeof ServiceActionEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const ServiceActionStatusEnum = {
    QUEUED: 'QUEUED',
    ONGOING: 'ONGOING',
    SUCCESS: 'SUCCESS',
    ERROR: 'ERROR',
    EXECUTING: 'EXECUTING',
    CANCELED: 'CANCELED',
    CANCELING: 'CANCELING',
    NEVER: 'NEVER'
} as const;

export type ServiceActionStatusEnum = typeof ServiceActionStatusEnum[keyof typeof ServiceActionStatusEnum];


/**
 * 
 * @export
 * @interface ServiceAnnotationRequest
 */
export interface ServiceAnnotationRequest {
    /**
     * 
     * @type {string}
     * @memberof ServiceAnnotationRequest
     */
    'id': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ServiceDeploymentStatusEnum = {
    NEVER_DEPLOYED: 'NEVER_DEPLOYED',
    OUT_OF_DATE: 'OUT_OF_DATE',
    UP_TO_DATE: 'UP_TO_DATE'
} as const;

export type ServiceDeploymentStatusEnum = typeof ServiceDeploymentStatusEnum[keyof typeof ServiceDeploymentStatusEnum];


/**
 * 
 * @export
 * @interface ServiceLabelRequest
 */
export interface ServiceLabelRequest {
    /**
     * 
     * @type {string}
     * @memberof ServiceLabelRequest
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface ServiceLightResponse
 */
export interface ServiceLightResponse {
    /**
     * 
     * @type {string}
     * @memberof ServiceLightResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceLightResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceLightResponse
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceLightResponse
     */
    'icon_uri': string;
    /**
     * 
     * @type {ServiceTypeEnum}
     * @memberof ServiceLightResponse
     */
    'service_type': ServiceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ServiceLightResponse
     */
    'project_id': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceLightResponse
     */
    'project_name': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceLightResponse
     */
    'environment_id': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceLightResponse
     */
    'environment_name': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceLightResponse
     */
    'cluster_id': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceLightResponse
     */
    'job_type'?: ServiceLightResponseJobTypeEnum;
}

export const ServiceLightResponseJobTypeEnum = {
    CRON: 'CRON',
    LIFECYCLE: 'LIFECYCLE'
} as const;

export type ServiceLightResponseJobTypeEnum = typeof ServiceLightResponseJobTypeEnum[keyof typeof ServiceLightResponseJobTypeEnum];

/**
 * 
 * @export
 * @interface ServicePort
 */
export interface ServicePort {
    /**
     * 
     * @type {string}
     * @memberof ServicePort
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ServicePort
     */
    'name'?: string;
    /**
     * The listening port of your service.
     * @type {number}
     * @memberof ServicePort
     */
    'internal_port': number;
    /**
     * The exposed port for your service. This is optional. If not set a default port will be used.
     * @type {number}
     * @memberof ServicePort
     */
    'external_port'?: number;
    /**
     * Expose the port to the world
     * @type {boolean}
     * @memberof ServicePort
     */
    'publicly_accessible': boolean;
    /**
     * is the default port to use for domain
     * @type {boolean}
     * @memberof ServicePort
     */
    'is_default'?: boolean;
    /**
     * 
     * @type {PortProtocolEnum}
     * @memberof ServicePort
     */
    'protocol': PortProtocolEnum;
    /**
     * Indicate the path or regex that must match for traffic to be accepted on your service i.e: /api/ will only accept http calls that start with /api/  Only valid for publicly_accessible HTTP or GRPC ports.
     * @type {string}
     * @memberof ServicePort
     */
    'public_path'?: string;
    /**
     * Indicate the new path that will be used to reach your service after replacement i.e: public_path -> /(.*)  public_path_rewrite -> /api/$1 will append /api/ on all externaly requested url when reaching the service  external/use url -> example.com/foobar  -> url seen by the service -> example.com/api/foobar Only valid for publicly_accessible HTTP or GRPC ports.
     * @type {string}
     * @memberof ServicePort
     */
    'public_path_rewrite'?: string;
}


/**
 * 
 * @export
 * @interface ServicePortRequest
 */
export interface ServicePortRequest {
    /**
     * 
     * @type {Array<ServicePortRequestPortsInner>}
     * @memberof ServicePortRequest
     */
    'ports'?: Array<ServicePortRequestPortsInner>;
}
/**
 * 
 * @export
 * @interface ServicePortRequestPortsInner
 */
export interface ServicePortRequestPortsInner {
    /**
     * 
     * @type {string}
     * @memberof ServicePortRequestPortsInner
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServicePortRequestPortsInner
     */
    'name'?: string;
    /**
     * The listening port of your service.
     * @type {number}
     * @memberof ServicePortRequestPortsInner
     */
    'internal_port': number;
    /**
     * The exposed port for your service. This is optional. If not set a default port will be used.
     * @type {number}
     * @memberof ServicePortRequestPortsInner
     */
    'external_port'?: number;
    /**
     * Expose the port to the world
     * @type {boolean}
     * @memberof ServicePortRequestPortsInner
     */
    'publicly_accessible': boolean;
    /**
     * is the default port to use for domain
     * @type {boolean}
     * @memberof ServicePortRequestPortsInner
     */
    'is_default'?: boolean;
    /**
     * 
     * @type {PortProtocolEnum}
     * @memberof ServicePortRequestPortsInner
     */
    'protocol'?: PortProtocolEnum;
    /**
     * Indicate the path or regex that must match for traffic to be accepted on your service i.e: /api/ will only accept http calls that start with /api/  Only valid for publicly_accessible HTTP or GRPC ports.
     * @type {string}
     * @memberof ServicePortRequestPortsInner
     */
    'public_path'?: string;
    /**
     * Indicate the new path that will be used to reach your service after replacement i.e: public_path -> /(.*)  public_path_rewrite -> /api/$1 will append /api/ on all externaly requested url when reaching the service  external/use url -> example.com/foobar  -> url seen by the service -> example.com/api/foobar Only valid for publicly_accessible HTTP or GRPC ports.
     * @type {string}
     * @memberof ServicePortRequestPortsInner
     */
    'public_path_rewrite'?: string;
}


/**
 * 
 * @export
 * @interface ServiceStepMetric
 */
export interface ServiceStepMetric {
    /**
     * 
     * @type {ServiceStepMetricNameEnum}
     * @memberof ServiceStepMetric
     */
    'step_name'?: ServiceStepMetricNameEnum;
    /**
     * 
     * @type {StepMetricStatusEnum}
     * @memberof ServiceStepMetric
     */
    'status'?: StepMetricStatusEnum;
    /**
     * The duration of the step in seconds.
     * @type {number}
     * @memberof ServiceStepMetric
     */
    'duration_sec'?: number;
}


/**
 * The name of the deployment step at the service level: - REGISTRY_CREATE_REPOSITORY: The step to create the repository in the registry. - GIT_CLONE: The step to clone the source code repository.  - BUILD_QUEUEING: The queuing time preceding the actual building step. - BUILD: The step to build the source code. - DEPLOYMENT_QUEUEING: The queuing time preceding the actual deployment step. - DEPLOYMENT: The step to deploy the service.  - ROUTER_DEPLOYMENT: The step to deploy the router.  - MIRROR_IMAGE: The step to mirror the image to the private registry. - EXECUTING: The step to execute a job or terraform apply. 
 * @export
 * @enum {string}
 */

export const ServiceStepMetricNameEnum = {
    REGISTRY_CREATE_REPOSITORY: 'REGISTRY_CREATE_REPOSITORY',
    GIT_CLONE: 'GIT_CLONE',
    BUILD_QUEUEING: 'BUILD_QUEUEING',
    BUILD: 'BUILD',
    DEPLOYMENT_QUEUEING: 'DEPLOYMENT_QUEUEING',
    DEPLOYMENT: 'DEPLOYMENT',
    ROUTER_DEPLOYMENT: 'ROUTER_DEPLOYMENT',
    MIRROR_IMAGE: 'MIRROR_IMAGE',
    EXECUTING: 'EXECUTING'
} as const;

export type ServiceStepMetricNameEnum = typeof ServiceStepMetricNameEnum[keyof typeof ServiceStepMetricNameEnum];


/**
 * 
 * @export
 * @interface ServiceStepMetrics
 */
export interface ServiceStepMetrics {
    /**
     * The total duration in seconds of the service deployment or null if the deployment is not completed.
     * @type {number}
     * @memberof ServiceStepMetrics
     */
    'total_duration_sec': number | null;
    /**
     * The total duration in seconds of the service deployment without queuing steps.
     * @type {number}
     * @memberof ServiceStepMetrics
     */
    'total_computing_duration_sec': number;
    /**
     * A list of metrics for deployment steps of the service.
     * @type {Array<ServiceStepMetric>}
     * @memberof ServiceStepMetrics
     */
    'details': Array<ServiceStepMetric>;
}
/**
 * 
 * @export
 * @interface ServiceStorage
 */
export interface ServiceStorage {
    /**
     * 
     * @type {Array<ServiceStorageStorageInner>}
     * @memberof ServiceStorage
     */
    'storage'?: Array<ServiceStorageStorageInner>;
}
/**
 * 
 * @export
 * @interface ServiceStorageRequest
 */
export interface ServiceStorageRequest {
    /**
     * 
     * @type {Array<ServiceStorageRequestStorageInner>}
     * @memberof ServiceStorageRequest
     */
    'storage'?: Array<ServiceStorageRequestStorageInner>;
}
/**
 * 
 * @export
 * @interface ServiceStorageRequestStorageInner
 */
export interface ServiceStorageRequestStorageInner {
    /**
     * 
     * @type {string}
     * @memberof ServiceStorageRequestStorageInner
     */
    'id'?: string;
    /**
     * 
     * @type {StorageTypeEnum}
     * @memberof ServiceStorageRequestStorageInner
     */
    'type': StorageTypeEnum;
    /**
     * unit is GB Minimum size is 4 GB 
     * @type {number}
     * @memberof ServiceStorageRequestStorageInner
     */
    'size': number;
    /**
     * 
     * @type {string}
     * @memberof ServiceStorageRequestStorageInner
     */
    'mount_point': string;
}


/**
 * 
 * @export
 * @interface ServiceStorageStorageInner
 */
export interface ServiceStorageStorageInner {
    /**
     * 
     * @type {string}
     * @memberof ServiceStorageStorageInner
     */
    'id': string;
    /**
     * 
     * @type {StorageTypeEnum}
     * @memberof ServiceStorageStorageInner
     */
    'type': StorageTypeEnum;
    /**
     * unit is GB
     * @type {number}
     * @memberof ServiceStorageStorageInner
     */
    'size': number;
    /**
     * 
     * @type {string}
     * @memberof ServiceStorageStorageInner
     */
    'mount_point': string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ServiceSubActionEnum = {
    NONE: 'NONE',
    TERRAFORM_PLAN_ONLY: 'TERRAFORM_PLAN_ONLY',
    TERRAFORM_PLAN_AND_APPLY: 'TERRAFORM_PLAN_AND_APPLY',
    TERRAFORM_DESTROY: 'TERRAFORM_DESTROY',
    TERRAFORM_FORCE_UNLOCK_STATE: 'TERRAFORM_FORCE_UNLOCK_STATE',
    TERRAFORM_MIGRATE_STATE: 'TERRAFORM_MIGRATE_STATE'
} as const;

export type ServiceSubActionEnum = typeof ServiceSubActionEnum[keyof typeof ServiceSubActionEnum];


/**
 * 
 * @export
 * @interface ServiceTotalNumber
 */
export interface ServiceTotalNumber {
    /**
     * 
     * @type {number}
     * @memberof ServiceTotalNumber
     */
    'service_total_number'?: number;
}
/**
 * type of the service (application, database, job, ...)
 * @export
 * @enum {string}
 */

export const ServiceTypeEnum = {
    APPLICATION: 'APPLICATION',
    DATABASE: 'DATABASE',
    CONTAINER: 'CONTAINER',
    JOB: 'JOB',
    HELM: 'HELM',
    TERRAFORM: 'TERRAFORM'
} as const;

export type ServiceTypeEnum = typeof ServiceTypeEnum[keyof typeof ServiceTypeEnum];


/**
 * type of the service
 * @export
 * @enum {string}
 */

export const ServiceTypeForVariableEnum = {
    APPLICATION: 'APPLICATION',
    CONTAINER: 'CONTAINER',
    JOB: 'JOB',
    HELM: 'HELM',
    TERRAFORM: 'TERRAFORM'
} as const;

export type ServiceTypeForVariableEnum = typeof ServiceTypeForVariableEnum[keyof typeof ServiceTypeForVariableEnum];


/**
 * 
 * @export
 * @interface SignUp
 */
export interface SignUp {
    /**
     * 
     * @type {string}
     * @memberof SignUp
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SignUp
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof SignUp
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignUp
     */
    'first_name': string;
    /**
     * 
     * @type {string}
     * @memberof SignUp
     */
    'last_name': string;
    /**
     * 
     * @type {string}
     * @memberof SignUp
     */
    'user_email': string;
    /**
     * 
     * @type {TypeOfUseEnum}
     * @memberof SignUp
     */
    'type_of_use': TypeOfUseEnum;
    /**
     * 
     * @type {string}
     * @memberof SignUp
     */
    'qovery_usage': string;
    /**
     * 
     * @type {string}
     * @memberof SignUp
     */
    'company_name'?: string | null;
    /**
     * 
     * @type {CompanySizeEnum}
     * @memberof SignUp
     */
    'company_size'?: CompanySizeEnum;
    /**
     * 
     * @type {string}
     * @memberof SignUp
     */
    'user_role'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SignUp
     */
    'qovery_usage_other'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SignUp
     */
    'user_questions'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SignUp
     */
    'current_step'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof SignUp
     */
    'dx_auth'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof SignUp
     */
    'infrastructure_hosting'?: string | null;
}


/**
 * 
 * @export
 * @interface SignUpRequest
 */
export interface SignUpRequest {
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    'first_name': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    'last_name': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    'user_email': string;
    /**
     * 
     * @type {TypeOfUseEnum}
     * @memberof SignUpRequest
     */
    'type_of_use': TypeOfUseEnum;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    'qovery_usage': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    'company_name'?: string | null;
    /**
     * 
     * @type {CompanySizeEnum}
     * @memberof SignUpRequest
     */
    'company_size'?: CompanySizeEnum;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    'user_role'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    'qovery_usage_other'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    'user_questions'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    'current_step'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof SignUpRequest
     */
    'dx_auth'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    'infrastructure_hosting'?: string | null;
}


/**
 * 
 * @export
 * @interface SlackAlertReceiverCreationRequest
 */
export interface SlackAlertReceiverCreationRequest extends AlertReceiverCreationRequest {
    /**
     * 
     * @type {string}
     * @memberof SlackAlertReceiverCreationRequest
     */
    'webhook_url': string;
}


/**
 * 
 * @export
 * @interface SlackAlertReceiverEditRequest
 */
export interface SlackAlertReceiverEditRequest extends AlertReceiverEditRequest {
    /**
     * 
     * @type {string}
     * @memberof SlackAlertReceiverEditRequest
     */
    'webhook_url'?: string | null;
}


/**
 * 
 * @export
 * @interface Stage
 */
export interface Stage {
    /**
     * 
     * @type {string}
     * @memberof Stage
     */
    'id': string;
    /**
     * stage name
     * @type {string}
     * @memberof Stage
     */
    'name': string;
    /**
     * 
     * @type {StageStepMetrics}
     * @memberof Stage
     */
    'steps'?: StageStepMetrics;
    /**
     * 
     * @type {string}
     * @memberof Stage
     */
    'description': string;
    /**
     * 
     * @type {StageStatusEnum}
     * @memberof Stage
     */
    'status'?: StageStatusEnum;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const StageStatusEnum = {
    QUEUED: 'QUEUED',
    ONGOING: 'ONGOING',
    DONE: 'DONE',
    ERROR: 'ERROR',
    SKIPPED: 'SKIPPED',
    CANCELED: 'CANCELED'
} as const;

export type StageStatusEnum = typeof StageStatusEnum[keyof typeof StageStatusEnum];


/**
 * 
 * @export
 * @interface StageStepMetric
 */
export interface StageStepMetric {
    /**
     * 
     * @type {StageStepMetricNameEnum}
     * @memberof StageStepMetric
     */
    'step_name'?: StageStepMetricNameEnum;
    /**
     * 
     * @type {StepMetricStatusEnum}
     * @memberof StageStepMetric
     */
    'status'?: StepMetricStatusEnum;
    /**
     * The duration of the step in seconds.
     * @type {number}
     * @memberof StageStepMetric
     */
    'duration_sec'?: number;
}


/**
 * The name of the deployment step at the stage level: - QUEUEING: The step preceding the actual stage deployment step. - PROVISION_BUILDER: The step to provision builders before the actual build. 
 * @export
 * @enum {string}
 */

export const StageStepMetricNameEnum = {
    QUEUEING: 'QUEUEING',
    PROVISION_BUILDER: 'PROVISION_BUILDER'
} as const;

export type StageStepMetricNameEnum = typeof StageStepMetricNameEnum[keyof typeof StageStepMetricNameEnum];


/**
 * 
 * @export
 * @interface StageStepMetrics
 */
export interface StageStepMetrics {
    /**
     * The total duration in seconds of the stage deployment or null if the deployment is not completed
     * @type {number}
     * @memberof StageStepMetrics
     */
    'total_duration_sec'?: number | null;
    /**
     * A list of metrics for deployment steps of the stage.
     * @type {Array<StageStepMetric>}
     * @memberof StageStepMetrics
     */
    'details'?: Array<StageStepMetric>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const StateEnum = {
    BUILDING: 'BUILDING',
    BUILD_ERROR: 'BUILD_ERROR',
    CANCELED: 'CANCELED',
    CANCELING: 'CANCELING',
    DELETED: 'DELETED',
    DELETE_ERROR: 'DELETE_ERROR',
    DELETE_QUEUED: 'DELETE_QUEUED',
    DELETING: 'DELETING',
    DEPLOYED: 'DEPLOYED',
    DEPLOYING: 'DEPLOYING',
    DEPLOYMENT_ERROR: 'DEPLOYMENT_ERROR',
    DEPLOYMENT_QUEUED: 'DEPLOYMENT_QUEUED',
    EXECUTING: 'EXECUTING',
    QUEUED: 'QUEUED',
    READY: 'READY',
    RECAP: 'RECAP',
    RESTARTED: 'RESTARTED',
    RESTARTING: 'RESTARTING',
    RESTART_ERROR: 'RESTART_ERROR',
    RESTART_QUEUED: 'RESTART_QUEUED',
    STOPPED: 'STOPPED',
    STOPPING: 'STOPPING',
    STOP_ERROR: 'STOP_ERROR',
    STOP_QUEUED: 'STOP_QUEUED',
    WAITING_DELETING: 'WAITING_DELETING',
    WAITING_RESTARTING: 'WAITING_RESTARTING',
    WAITING_RUNNING: 'WAITING_RUNNING',
    WAITING_STOPPING: 'WAITING_STOPPING'
} as const;

export type StateEnum = typeof StateEnum[keyof typeof StateEnum];


/**
 * 
 * @export
 * @interface Status
 */
export interface Status {
    /**
     * 
     * @type {string}
     * @memberof Status
     */
    'id': string;
    /**
     * 
     * @type {StateEnum}
     * @memberof Status
     */
    'state': StateEnum;
    /**
     * 
     * @type {ServiceDeploymentStatusEnum}
     * @memberof Status
     */
    'service_deployment_status': ServiceDeploymentStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Status
     */
    'last_deployment_date'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Status
     */
    'is_part_last_deployment': boolean;
    /**
     * 
     * @type {ServiceStepMetrics}
     * @memberof Status
     */
    'steps'?: ServiceStepMetrics;
    /**
     * 
     * @type {string}
     * @memberof Status
     */
    'execution_id'?: string;
    /**
     * 
     * @type {StatusDetails}
     * @memberof Status
     */
    'status_details': StatusDetails;
    /**
     * 
     * @type {string}
     * @memberof Status
     */
    'deployment_request_id': string | null;
    /**
     * 
     * @type {number}
     * @memberof Status
     */
    'deployment_requests_count': number;
}


/**
 * 
 * @export
 * @interface StatusDetails
 */
export interface StatusDetails {
    /**
     * 
     * @type {ServiceActionEnum}
     * @memberof StatusDetails
     */
    'action': ServiceActionEnum;
    /**
     * 
     * @type {ServiceActionStatusEnum}
     * @memberof StatusDetails
     */
    'status': ServiceActionStatusEnum;
    /**
     * 
     * @type {ServiceSubActionEnum}
     * @memberof StatusDetails
     */
    'sub_action': ServiceSubActionEnum;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const StatusKindEnum = {
    CANCELED: 'CANCELED',
    CANCELING: 'CANCELING',
    DELETED: 'DELETED',
    DELETE_ERROR: 'DELETE_ERROR',
    DELETE_IN_PROGRESS: 'DELETE_IN_PROGRESS',
    DEPLOYED: 'DEPLOYED',
    DEPLOYMENT_ERROR: 'DEPLOYMENT_ERROR',
    DEPLOYMENT_IN_PROGRESS: 'DEPLOYMENT_IN_PROGRESS',
    ERROR: 'ERROR',
    PAUSED: 'PAUSED',
    PAUSE_ERROR: 'PAUSE_ERROR',
    PAUSE_IN_PROGRESS: 'PAUSE_IN_PROGRESS',
    WAITING: 'WAITING'
} as const;

export type StatusKindEnum = typeof StatusKindEnum[keyof typeof StatusKindEnum];


/**
 * The status of completion for the step: - SUCCESS: The step completed successfully. - ERROR: The step completed with an error. - CANCEL: The step was canceled. - SKIP: The step was skipped because it was not necessary. 
 * @export
 * @enum {string}
 */

export const StepMetricStatusEnum = {
    SUCCESS: 'SUCCESS',
    ERROR: 'ERROR',
    CANCEL: 'CANCEL',
    SKIP: 'SKIP'
} as const;

export type StepMetricStatusEnum = typeof StepMetricStatusEnum[keyof typeof StepMetricStatusEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const StorageTypeEnum = {
    FAST_SSD: 'FAST_SSD'
} as const;

export type StorageTypeEnum = typeof StorageTypeEnum[keyof typeof StorageTypeEnum];


/**
 * 
 * @export
 * @interface TerraformAdvancedSettings
 */
export interface TerraformAdvancedSettings {
    /**
     * define the max timeout for the build
     * @type {number}
     * @memberof TerraformAdvancedSettings
     */
    'build.timeout_max_sec'?: number;
    /**
     * define the max cpu resources (in milli)
     * @type {number}
     * @memberof TerraformAdvancedSettings
     */
    'build.cpu_max_in_milli'?: number;
    /**
     * define the max ram resources (in gib)
     * @type {number}
     * @memberof TerraformAdvancedSettings
     */
    'build.ram_max_in_gib'?: number;
    /**
     * 
     * @type {number}
     * @memberof TerraformAdvancedSettings
     */
    'build.ephemeral_storage_in_gib'?: number;
    /**
     * define how long in seconds an application is supposed to be stopped gracefully
     * @type {number}
     * @memberof TerraformAdvancedSettings
     */
    'deployment.termination_grace_period_seconds'?: number;
    /**
     * Set pod placement on specific Kubernetes nodes labels
     * @type {{ [key: string]: string; }}
     * @memberof TerraformAdvancedSettings
     */
    'deployment.affinity.node.required'?: { [key: string]: string; };
    /**
     * Allows you to set an existing Kubernetes service account name 
     * @type {string}
     * @memberof TerraformAdvancedSettings
     */
    'security.service_account_name'?: string;
    /**
     * Mounts the container\'s root filesystem as read-only 
     * @type {boolean}
     * @memberof TerraformAdvancedSettings
     */
    'security.read_only_root_filesystem'?: boolean;
}
/**
 * @type TerraformBackend
 * Configuration for Terraform backend - exactly one backend type must be specified
 * @export
 */
export type TerraformBackend = TerraformBackendOneOf | TerraformBackendOneOf1;

/**
 * 
 * @export
 * @interface TerraformBackendOneOf
 */
export interface TerraformBackendOneOf {
    /**
     * Kubernetes-specific backend configuration
     * @type {object}
     * @memberof TerraformBackendOneOf
     */
    'kubernetes': object;
}
/**
 * 
 * @export
 * @interface TerraformBackendOneOf1
 */
export interface TerraformBackendOneOf1 {
    /**
     * User-provided backend configuration
     * @type {object}
     * @memberof TerraformBackendOneOf1
     */
    'user_provided': object;
}
/**
 * 
 * @export
 * @interface TerraformDeployRequest
 */
export interface TerraformDeployRequest {
    /**
     * Terraform service identifier
     * @type {string}
     * @memberof TerraformDeployRequest
     */
    'id'?: string | null;
    /**
     * Commit to deploy for chart source.
     * @type {string}
     * @memberof TerraformDeployRequest
     */
    'git_commit_id'?: string;
    /**
     * Terraform action to execute.
     * @type {string}
     * @memberof TerraformDeployRequest
     */
    'action'?: TerraformDeployRequestActionEnum | null;
}

export const TerraformDeployRequestActionEnum = {
    PLAN: 'PLAN',
    FORCE_UNLOCK: 'FORCE_UNLOCK',
    MIGRATE_STATE: 'MIGRATE_STATE'
} as const;

export type TerraformDeployRequestActionEnum = typeof TerraformDeployRequestActionEnum[keyof typeof TerraformDeployRequestActionEnum];

/**
 * 
 * @export
 * @interface TerraformDeploymentRestrictionRequest
 */
export interface TerraformDeploymentRestrictionRequest {
    /**
     * 
     * @type {DeploymentRestrictionModeEnum}
     * @memberof TerraformDeploymentRestrictionRequest
     */
    'mode': DeploymentRestrictionModeEnum;
    /**
     * 
     * @type {DeploymentRestrictionTypeEnum}
     * @memberof TerraformDeploymentRestrictionRequest
     */
    'type': DeploymentRestrictionTypeEnum;
    /**
     * ‘For `PATH` restrictions, the value must not start with `/`’
     * @type {string}
     * @memberof TerraformDeploymentRestrictionRequest
     */
    'value': string;
}


/**
 * 
 * @export
 * @interface TerraformDeploymentRestrictionResponse
 */
export interface TerraformDeploymentRestrictionResponse {
    /**
     * 
     * @type {string}
     * @memberof TerraformDeploymentRestrictionResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TerraformDeploymentRestrictionResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof TerraformDeploymentRestrictionResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {DeploymentRestrictionModeEnum}
     * @memberof TerraformDeploymentRestrictionResponse
     */
    'mode': DeploymentRestrictionModeEnum;
    /**
     * 
     * @type {DeploymentRestrictionTypeEnum}
     * @memberof TerraformDeploymentRestrictionResponse
     */
    'type': DeploymentRestrictionTypeEnum;
    /**
     * ‘For `PATH` restrictions, the value must not start with `/`’
     * @type {string}
     * @memberof TerraformDeploymentRestrictionResponse
     */
    'value': string;
}


/**
 * 
 * @export
 * @interface TerraformDeploymentRestrictionResponseList
 */
export interface TerraformDeploymentRestrictionResponseList {
    /**
     * 
     * @type {Array<TerraformDeploymentRestrictionResponse>}
     * @memberof TerraformDeploymentRestrictionResponseList
     */
    'results'?: Array<TerraformDeploymentRestrictionResponse>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TerraformEngineEnum = {
    TERRAFORM: 'TERRAFORM',
    OPEN_TOFU: 'OPEN_TOFU'
} as const;

export type TerraformEngineEnum = typeof TerraformEngineEnum[keyof typeof TerraformEngineEnum];


/**
 * 
 * @export
 * @interface TerraformFilesSource
 */
export interface TerraformFilesSource {
    /**
     * 
     * @type {TerraformFilesSourceGit}
     * @memberof TerraformFilesSource
     */
    'git'?: TerraformFilesSourceGit;
}
/**
 * 
 * @export
 * @interface TerraformFilesSourceGit
 */
export interface TerraformFilesSourceGit {
    /**
     * 
     * @type {ApplicationGitRepository}
     * @memberof TerraformFilesSourceGit
     */
    'git_repository'?: ApplicationGitRepository;
}
/**
 * 
 * @export
 * @interface TerraformFilesSourceRequest
 */
export interface TerraformFilesSourceRequest {
    /**
     * 
     * @type {string}
     * @memberof TerraformFilesSourceRequest
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface TerraformGitRepositoryRequest
 */
export interface TerraformGitRepositoryRequest {
    /**
     * 
     * @type {string}
     * @memberof TerraformGitRepositoryRequest
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof TerraformGitRepositoryRequest
     */
    'branch'?: string;
    /**
     * 
     * @type {string}
     * @memberof TerraformGitRepositoryRequest
     */
    'root_path'?: string;
    /**
     * 
     * @type {string}
     * @memberof TerraformGitRepositoryRequest
     */
    'git_token_id'?: string;
}
/**
 * 
 * @export
 * @interface TerraformJobResourcesResponse
 */
export interface TerraformJobResourcesResponse {
    /**
     * 
     * @type {number}
     * @memberof TerraformJobResourcesResponse
     */
    'cpu_milli': number;
    /**
     * 
     * @type {number}
     * @memberof TerraformJobResourcesResponse
     */
    'ram_mib': number;
    /**
     * 
     * @type {number}
     * @memberof TerraformJobResourcesResponse
     */
    'gpu': number;
    /**
     * 
     * @type {number}
     * @memberof TerraformJobResourcesResponse
     */
    'storage_gib': number;
}
/**
 * 
 * @export
 * @interface TerraformProviderVersion
 */
export interface TerraformProviderVersion {
    /**
     * 
     * @type {boolean}
     * @memberof TerraformProviderVersion
     */
    'read_from_terraform_block'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TerraformProviderVersion
     */
    'explicit_version': string;
}
/**
 * 
 * @export
 * @interface TerraformRequest
 */
export interface TerraformRequest {
    /**
     * 
     * @type {string}
     * @memberof TerraformRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TerraformRequest
     */
    'description': string;
    /**
     * 
     * @type {boolean}
     * @memberof TerraformRequest
     */
    'auto_deploy': boolean;
    /**
     * 
     * @type {TerraformRequestTerraformFilesSource}
     * @memberof TerraformRequest
     */
    'terraform_files_source': TerraformRequestTerraformFilesSource;
    /**
     * 
     * @type {TerraformVariablesSourceRequest}
     * @memberof TerraformRequest
     */
    'terraform_variables_source': TerraformVariablesSourceRequest;
    /**
     * 
     * @type {TerraformBackend}
     * @memberof TerraformRequest
     */
    'backend': TerraformBackend;
    /**
     * 
     * @type {TerraformEngineEnum}
     * @memberof TerraformRequest
     */
    'engine': TerraformEngineEnum;
    /**
     * 
     * @type {TerraformProviderVersion}
     * @memberof TerraformRequest
     */
    'provider_version': TerraformProviderVersion;
    /**
     * 
     * @type {number}
     * @memberof TerraformRequest
     */
    'timeout_sec'?: number;
    /**
     * 
     * @type {string}
     * @memberof TerraformRequest
     */
    'icon_uri'?: string;
    /**
     * 
     * @type {TerraformRequestJobResources}
     * @memberof TerraformRequest
     */
    'job_resources': TerraformRequestJobResources;
    /**
     * 
     * @type {boolean}
     * @memberof TerraformRequest
     */
    'use_cluster_credentials'?: boolean;
    /**
     * The key represent the action command name i.e: \"plan\" The value represent the extra arguments to pass to this command  i.e: {\"apply\", [\"-lock=false\"]} is going to prepend `-lock=false` to terraform apply commands
     * @type {{ [key: string]: Array<string>; }}
     * @memberof TerraformRequest
     */
    'action_extra_arguments'?: { [key: string]: Array<string>; };
    /**
     * 
     * @type {TerraformRequestDockerfileFragment}
     * @memberof TerraformRequest
     */
    'dockerfile_fragment'?: TerraformRequestDockerfileFragment | null;
}


/**
 * @type TerraformRequestDockerfileFragment
 * Custom Dockerfile fragment to inject during build. Optional field. When null, no custom fragment is injected. 
 * @export
 */
export type TerraformRequestDockerfileFragment = { type: 'file' } & DockerfileFragmentFile | { type: 'inline' } & DockerfileFragmentInline;

/**
 * 
 * @export
 * @interface TerraformRequestJobResources
 */
export interface TerraformRequestJobResources {
    /**
     * 
     * @type {number}
     * @memberof TerraformRequestJobResources
     */
    'cpu_milli': number;
    /**
     * 
     * @type {number}
     * @memberof TerraformRequestJobResources
     */
    'ram_mib': number;
    /**
     * 
     * @type {number}
     * @memberof TerraformRequestJobResources
     */
    'gpu': number;
    /**
     * 
     * @type {number}
     * @memberof TerraformRequestJobResources
     */
    'storage_gib': number;
}
/**
 * @type TerraformRequestTerraformFilesSource
 * @export
 */
export type TerraformRequestTerraformFilesSource = TerraformRequestTerraformFilesSourceOneOf;

/**
 * 
 * @export
 * @interface TerraformRequestTerraformFilesSourceOneOf
 */
export interface TerraformRequestTerraformFilesSourceOneOf {
    /**
     * 
     * @type {TerraformGitRepositoryRequest}
     * @memberof TerraformRequestTerraformFilesSourceOneOf
     */
    'git_repository'?: TerraformGitRepositoryRequest;
}
/**
 * A Terraform service
 * @export
 * @interface TerraformResponse
 */
export interface TerraformResponse {
    /**
     * 
     * @type {string}
     * @memberof TerraformResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TerraformResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof TerraformResponse
     */
    'updated_at'?: string;
    /**
     * name is case insensitive
     * @type {string}
     * @memberof TerraformResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TerraformResponse
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof TerraformResponse
     */
    'timeout_sec': number;
    /**
     * 
     * @type {boolean}
     * @memberof TerraformResponse
     */
    'auto_deploy': boolean;
    /**
     * 
     * @type {TerraformResponseAllOfTerraformFilesSource}
     * @memberof TerraformResponse
     */
    'terraform_files_source'?: TerraformResponseAllOfTerraformFilesSource;
    /**
     * Icon URI representing the terraform service.
     * @type {string}
     * @memberof TerraformResponse
     */
    'icon_uri': string;
    /**
     * 
     * @type {ServiceTypeEnum}
     * @memberof TerraformResponse
     */
    'service_type': ServiceTypeEnum;
    /**
     * 
     * @type {TerraformVariablesSourceResponse}
     * @memberof TerraformResponse
     */
    'terraform_variables_source': TerraformVariablesSourceResponse;
    /**
     * 
     * @type {TerraformEngineEnum}
     * @memberof TerraformResponse
     */
    'engine': TerraformEngineEnum;
    /**
     * 
     * @type {TerraformBackend}
     * @memberof TerraformResponse
     */
    'backend': TerraformBackend;
    /**
     * 
     * @type {TerraformProviderVersion}
     * @memberof TerraformResponse
     */
    'provider_version': TerraformProviderVersion;
    /**
     * 
     * @type {TerraformJobResourcesResponse}
     * @memberof TerraformResponse
     */
    'job_resources': TerraformJobResourcesResponse;
    /**
     * 
     * @type {ReferenceObject}
     * @memberof TerraformResponse
     */
    'environment': ReferenceObject;
    /**
     * 
     * @type {boolean}
     * @memberof TerraformResponse
     */
    'use_cluster_credentials': boolean;
    /**
     * The key represent the action command name i.e: \"plan\" The value represent the extra arguments to pass to this command  i.e: {\"apply\", [\"-lock=false\"]} is going to prepend `-lock=false` to terraform apply commands
     * @type {{ [key: string]: Array<string>; }}
     * @memberof TerraformResponse
     */
    'action_extra_arguments': { [key: string]: Array<string>; };
    /**
     * 
     * @type {TerraformResponseAllOfDockerfileFragment}
     * @memberof TerraformResponse
     */
    'dockerfile_fragment'?: TerraformResponseAllOfDockerfileFragment | null;
}


/**
 * @type TerraformResponseAllOfDockerfileFragment
 * Custom Dockerfile fragment to inject during build. When null, no custom fragment is injected. 
 * @export
 */
export type TerraformResponseAllOfDockerfileFragment = { type: 'file' } & DockerfileFragmentFile | { type: 'inline' } & DockerfileFragmentInline;

/**
 * @type TerraformResponseAllOfTerraformFilesSource
 * @export
 */
export type TerraformResponseAllOfTerraformFilesSource = TerraformFilesSource;

/**
 * 
 * @export
 * @interface TerraformResponseList
 */
export interface TerraformResponseList {
    /**
     * 
     * @type {Array<TerraformResponse>}
     * @memberof TerraformResponseList
     */
    'results'?: Array<TerraformResponse>;
}
/**
 * A Terraform input variable
 * @export
 * @interface TerraformVarKeyValue
 */
export interface TerraformVarKeyValue {
    /**
     * 
     * @type {string}
     * @memberof TerraformVarKeyValue
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof TerraformVarKeyValue
     */
    'value'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TerraformVarKeyValue
     */
    'secret'?: boolean;
}
/**
 * Represents a Terraform variable definition extracted from a Terraform file.
 * @export
 * @interface TerraformVariableDefinition
 */
export interface TerraformVariableDefinition {
    /**
     * The name of the variable
     * @type {string}
     * @memberof TerraformVariableDefinition
     */
    'key': string;
    /**
     * Whether the variable is marked as sensitive
     * @type {boolean}
     * @memberof TerraformVariableDefinition
     */
    'sensitive': boolean;
    /**
     * Whether the variable accepts null values. If false, the variable is required.
     * @type {boolean}
     * @memberof TerraformVariableDefinition
     */
    'nullable'?: boolean;
    /**
     * The default value of the variable, or null if no default is provided
     * @type {string}
     * @memberof TerraformVariableDefinition
     */
    'default'?: string | null;
    /**
     * The path inside your git repository where the variable is defined
     * @type {string}
     * @memberof TerraformVariableDefinition
     */
    'source': string;
    /**
     * The description of the variable, or null if no description is provided
     * @type {string}
     * @memberof TerraformVariableDefinition
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface TerraformVariableParsingRequest
 */
export interface TerraformVariableParsingRequest {
    /**
     * 
     * @type {ApplicationGitRepositoryRequest}
     * @memberof TerraformVariableParsingRequest
     */
    'git_repository': ApplicationGitRepositoryRequest;
}
/**
 * 
 * @export
 * @interface TerraformVariablesSourceRequest
 */
export interface TerraformVariablesSourceRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof TerraformVariablesSourceRequest
     */
    'tf_var_file_paths': Array<string>;
    /**
     * 
     * @type {Array<TerraformVarKeyValue>}
     * @memberof TerraformVariablesSourceRequest
     */
    'tf_vars': Array<TerraformVarKeyValue>;
}
/**
 * 
 * @export
 * @interface TerraformVariablesSourceResponse
 */
export interface TerraformVariablesSourceResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof TerraformVariablesSourceResponse
     */
    'tf_var_file_paths': Array<string>;
    /**
     * 
     * @type {Array<TerraformVarKeyValue>}
     * @memberof TerraformVariablesSourceResponse
     */
    'tf_vars': Array<TerraformVarKeyValue>;
}
/**
 * 
 * @export
 * @interface TerraformVersionResponse
 */
export interface TerraformVersionResponse {
    /**
     * 
     * @type {TerraformEngineEnum}
     * @memberof TerraformVersionResponse
     */
    'engine': TerraformEngineEnum;
    /**
     * Terraform version string
     * @type {string}
     * @memberof TerraformVersionResponse
     */
    'version': string;
}


/**
 * 
 * @export
 * @interface TerraformVersionResponseList
 */
export interface TerraformVersionResponseList {
    /**
     * 
     * @type {Array<TerraformVersionResponse>}
     * @memberof TerraformVersionResponseList
     */
    'results'?: Array<TerraformVersionResponse>;
}
/**
 * @type TfVarsDiscoveryMode
 * Discovery mode for Terraform tfvars files - either auto-discover or specify paths
 * @export
 */
export type TfVarsDiscoveryMode = { type: 'AutoDiscover' } & TfVarsDiscoveryModeAutoDiscover | { type: 'SpecificPaths' } & TfVarsDiscoveryModeSpecificPaths;

/**
 * Automatically discover all tfvars files in the repository
 * @export
 * @interface TfVarsDiscoveryModeAutoDiscover
 */
export interface TfVarsDiscoveryModeAutoDiscover {
    /**
     * Discriminator for auto-discovery mode
     * @type {string}
     * @memberof TfVarsDiscoveryModeAutoDiscover
     */
    'type': TfVarsDiscoveryModeAutoDiscoverTypeEnum;
}

export const TfVarsDiscoveryModeAutoDiscoverTypeEnum = {
    AUTO_DISCOVER: 'AutoDiscover'
} as const;

export type TfVarsDiscoveryModeAutoDiscoverTypeEnum = typeof TfVarsDiscoveryModeAutoDiscoverTypeEnum[keyof typeof TfVarsDiscoveryModeAutoDiscoverTypeEnum];

/**
 * Discover tfvars files at specific paths only
 * @export
 * @interface TfVarsDiscoveryModeSpecificPaths
 */
export interface TfVarsDiscoveryModeSpecificPaths {
    /**
     * Discriminator for specific paths mode
     * @type {string}
     * @memberof TfVarsDiscoveryModeSpecificPaths
     */
    'type': TfVarsDiscoveryModeSpecificPathsTypeEnum;
    /**
     * List of specific paths to tfvars files
     * @type {Array<string>}
     * @memberof TfVarsDiscoveryModeSpecificPaths
     */
    'paths': Array<string>;
}

export const TfVarsDiscoveryModeSpecificPathsTypeEnum = {
    SPECIFIC_PATHS: 'SpecificPaths'
} as const;

export type TfVarsDiscoveryModeSpecificPathsTypeEnum = typeof TfVarsDiscoveryModeSpecificPathsTypeEnum[keyof typeof TfVarsDiscoveryModeSpecificPathsTypeEnum];

/**
 * Represents a Terraform tfvars file with its variables
 * @export
 * @interface TfVarsFileResponse
 */
export interface TfVarsFileResponse {
    /**
     * The path to the tfvars file within the Git repository
     * @type {string}
     * @memberof TfVarsFileResponse
     */
    'source': string;
    /**
     * Map of variable names to their values from the tfvars file
     * @type {{ [key: string]: string; }}
     * @memberof TfVarsFileResponse
     */
    'variables': { [key: string]: string; };
}
/**
 * Request to list Terraform tfvars files from a Git repository
 * @export
 * @interface TfVarsListRequest
 */
export interface TfVarsListRequest {
    /**
     * 
     * @type {ApplicationGitRepositoryRequest}
     * @memberof TfVarsListRequest
     */
    'git_repository': ApplicationGitRepositoryRequest;
    /**
     * 
     * @type {TfVarsDiscoveryMode}
     * @memberof TfVarsListRequest
     */
    'mode': TfVarsDiscoveryMode;
}
/**
 * 
 * @export
 * @interface TransferOwnershipRequest
 */
export interface TransferOwnershipRequest {
    /**
     * 
     * @type {string}
     * @memberof TransferOwnershipRequest
     */
    'user_id': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TypeOfUseEnum = {
    PERSONAL: 'PERSONAL',
    SCHOOL: 'SCHOOL',
    WORK: 'WORK'
} as const;

export type TypeOfUseEnum = typeof TypeOfUseEnum[keyof typeof TypeOfUseEnum];


/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'profile_picture_url'?: string;
}
/**
 * 
 * @export
 * @interface UserResponseList
 */
export interface UserResponseList {
    /**
     * 
     * @type {Array<User>}
     * @memberof UserResponseList
     */
    'results'?: Array<User>;
}
/**
 * 
 * @export
 * @interface Value
 */
export interface Value {
    /**
     * 
     * @type {string}
     * @memberof Value
     */
    'value'?: string;
    /**
     * optional variable description (255 characters maximum)
     * @type {string}
     * @memberof Value
     */
    'description'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Value
     */
    'enable_interpolation_in_file'?: boolean | null;
}
/**
 * 
 * @export
 * @interface VariableAlias
 */
export interface VariableAlias {
    /**
     * 
     * @type {string}
     * @memberof VariableAlias
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof VariableAlias
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof VariableAlias
     */
    'value'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VariableAlias
     */
    'mount_path': string;
    /**
     * 
     * @type {APIVariableScopeEnum}
     * @memberof VariableAlias
     */
    'scope': APIVariableScopeEnum;
    /**
     * 
     * @type {APIVariableTypeEnum}
     * @memberof VariableAlias
     */
    'variable_type': APIVariableTypeEnum;
}


/**
 * 
 * @export
 * @interface VariableAliasRequest
 */
export interface VariableAliasRequest {
    /**
     * the value to be used as Alias of the targeted environment variable.
     * @type {string}
     * @memberof VariableAliasRequest
     */
    'key': string;
    /**
     * 
     * @type {APIVariableScopeEnum}
     * @memberof VariableAliasRequest
     */
    'alias_scope': APIVariableScopeEnum;
    /**
     * the id of the variable that is aliased.
     * @type {string}
     * @memberof VariableAliasRequest
     */
    'alias_parent_id': string;
    /**
     * optional variable description (255 characters maximum)
     * @type {string}
     * @memberof VariableAliasRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof VariableAliasRequest
     */
    'enable_interpolation_in_file'?: boolean | null;
}


/**
 * 
 * @export
 * @interface VariableEditRequest
 */
export interface VariableEditRequest {
    /**
     * the key of the environment variable
     * @type {string}
     * @memberof VariableEditRequest
     */
    'key': string;
    /**
     * the value of the environment variable
     * @type {string}
     * @memberof VariableEditRequest
     */
    'value'?: string | null;
    /**
     * optional variable description (255 characters maximum)
     * @type {string}
     * @memberof VariableEditRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof VariableEditRequest
     */
    'enable_interpolation_in_file'?: boolean | null;
}
/**
 * 
 * @export
 * @interface VariableImport
 */
export interface VariableImport {
    /**
     * 
     * @type {number}
     * @memberof VariableImport
     */
    'total_variables_to_import': number;
    /**
     * 
     * @type {Array<VariableImportSuccessfulImportedVariablesInner>}
     * @memberof VariableImport
     */
    'successful_imported_variables': Array<VariableImportSuccessfulImportedVariablesInner>;
}
/**
 * 
 * @export
 * @interface VariableImportRequest
 */
export interface VariableImportRequest {
    /**
     * 
     * @type {boolean}
     * @memberof VariableImportRequest
     */
    'overwrite': boolean;
    /**
     * 
     * @type {Array<VariableImportRequestVarsInner>}
     * @memberof VariableImportRequest
     */
    'vars': Array<VariableImportRequestVarsInner>;
}
/**
 * 
 * @export
 * @interface VariableImportRequestVarsInner
 */
export interface VariableImportRequestVarsInner {
    /**
     * 
     * @type {string}
     * @memberof VariableImportRequestVarsInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof VariableImportRequestVarsInner
     */
    'value': string;
    /**
     * 
     * @type {APIVariableScopeEnum}
     * @memberof VariableImportRequestVarsInner
     */
    'scope': APIVariableScopeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof VariableImportRequestVarsInner
     */
    'is_secret': boolean;
}


/**
 * 
 * @export
 * @interface VariableImportSuccessfulImportedVariablesInner
 */
export interface VariableImportSuccessfulImportedVariablesInner {
    /**
     * 
     * @type {string}
     * @memberof VariableImportSuccessfulImportedVariablesInner
     */
    'name': string;
    /**
     * Optional if the variable is secret
     * @type {string}
     * @memberof VariableImportSuccessfulImportedVariablesInner
     */
    'value'?: string;
    /**
     * 
     * @type {APIVariableScopeEnum}
     * @memberof VariableImportSuccessfulImportedVariablesInner
     */
    'scope': APIVariableScopeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof VariableImportSuccessfulImportedVariablesInner
     */
    'is_secret': boolean;
}


/**
 * 
 * @export
 * @interface VariableOverride
 */
export interface VariableOverride {
    /**
     * The id of the overriden variable
     * @type {string}
     * @memberof VariableOverride
     */
    'id': string;
    /**
     * The key of the overriden variable
     * @type {string}
     * @memberof VariableOverride
     */
    'key': string;
    /**
     * The value of the overriden variable
     * @type {string}
     * @memberof VariableOverride
     */
    'value'?: string | null;
    /**
     * The mounth path of the overriden variable (only if environment variable type is \'file\')
     * @type {string}
     * @memberof VariableOverride
     */
    'mount_path': string;
    /**
     * 
     * @type {APIVariableScopeEnum}
     * @memberof VariableOverride
     */
    'scope': APIVariableScopeEnum;
    /**
     * 
     * @type {APIVariableTypeEnum}
     * @memberof VariableOverride
     */
    'variable_type': APIVariableTypeEnum;
}


/**
 * 
 * @export
 * @interface VariableOverrideRequest
 */
export interface VariableOverrideRequest {
    /**
     * the value to be used as Override of the targeted environment variable.
     * @type {string}
     * @memberof VariableOverrideRequest
     */
    'value': string;
    /**
     * 
     * @type {APIVariableScopeEnum}
     * @memberof VariableOverrideRequest
     */
    'override_scope': APIVariableScopeEnum;
    /**
     * the id of the variable that is aliased.
     * @type {string}
     * @memberof VariableOverrideRequest
     */
    'override_parent_id': string;
    /**
     * optional variable description (255 characters maximum)
     * @type {string}
     * @memberof VariableOverrideRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof VariableOverrideRequest
     */
    'enable_interpolation_in_file'?: boolean | null;
}


/**
 * 
 * @export
 * @interface VariableRequest
 */
export interface VariableRequest {
    /**
     * the key of the environment variable
     * @type {string}
     * @memberof VariableRequest
     */
    'key': string;
    /**
     * the value of the environment variable
     * @type {string}
     * @memberof VariableRequest
     */
    'value': string;
    /**
     * the path where the file will be mounted (only if type =file)
     * @type {string}
     * @memberof VariableRequest
     */
    'mount_path'?: string | null;
    /**
     * if true, the variable will be considered as a secret and will not be accessible after its creation. Only your applications will be able to access its value at build and run time.
     * @type {boolean}
     * @memberof VariableRequest
     */
    'is_secret': boolean;
    /**
     * 
     * @type {APIVariableScopeEnum}
     * @memberof VariableRequest
     */
    'variable_scope': APIVariableScopeEnum;
    /**
     * based on the selected scope, it contains the ID of the service, environment or project where the variable is attached
     * @type {string}
     * @memberof VariableRequest
     */
    'variable_parent_id': string;
    /**
     * optional variable description (255 characters maximum)
     * @type {string}
     * @memberof VariableRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof VariableRequest
     */
    'enable_interpolation_in_file'?: boolean | null;
}


/**
 * 
 * @export
 * @interface VariableResponse
 */
export interface VariableResponse {
    /**
     * 
     * @type {string}
     * @memberof VariableResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof VariableResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof VariableResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof VariableResponse
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof VariableResponse
     */
    'value': string | null;
    /**
     * 
     * @type {string}
     * @memberof VariableResponse
     */
    'mount_path'?: string | null;
    /**
     * 
     * @type {VariableOverride}
     * @memberof VariableResponse
     */
    'overridden_variable'?: VariableOverride;
    /**
     * 
     * @type {VariableAlias}
     * @memberof VariableResponse
     */
    'aliased_variable'?: VariableAlias;
    /**
     * 
     * @type {APIVariableScopeEnum}
     * @memberof VariableResponse
     */
    'scope': APIVariableScopeEnum;
    /**
     * 
     * @type {APIVariableTypeEnum}
     * @memberof VariableResponse
     */
    'variable_type': APIVariableTypeEnum;
    /**
     * The id of the service referenced by this variable.
     * @type {string}
     * @memberof VariableResponse
     */
    'service_id'?: string;
    /**
     * The name of the service referenced by this variable.
     * @type {string}
     * @memberof VariableResponse
     */
    'service_name'?: string;
    /**
     * 
     * @type {LinkedServiceTypeEnum}
     * @memberof VariableResponse
     */
    'service_type'?: LinkedServiceTypeEnum;
    /**
     * Entity that created/own the variable (i.e: Qovery, Doppler)
     * @type {string}
     * @memberof VariableResponse
     */
    'owned_by'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof VariableResponse
     */
    'is_secret': boolean;
    /**
     * 
     * @type {string}
     * @memberof VariableResponse
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof VariableResponse
     */
    'enable_interpolation_in_file'?: boolean;
}


/**
 * 
 * @export
 * @interface VariableResponseList
 */
export interface VariableResponseList {
    /**
     * 
     * @type {Array<VariableResponse>}
     * @memberof VariableResponseList
     */
    'results'?: Array<VariableResponse>;
}
/**
 * 
 * @export
 * @interface Version
 */
export interface Version {
    /**
     * 
     * @type {string}
     * @memberof Version
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface VersionResponseList
 */
export interface VersionResponseList {
    /**
     * 
     * @type {Array<Version>}
     * @memberof VersionResponseList
     */
    'results'?: Array<Version>;
}
/**
 * 
 * @export
 * @interface WebhookEventResponse
 */
export interface WebhookEventResponse {
    /**
     * Unique identifier
     * @type {string}
     * @memberof WebhookEventResponse
     */
    'id': string;
    /**
     * Timestamp when the webhook event was created
     * @type {string}
     * @memberof WebhookEventResponse
     */
    'created_at': string;
    /**
     * 
     * @type {OrganizationWebhookKindEnum}
     * @memberof WebhookEventResponse
     */
    'kind': OrganizationWebhookKindEnum;
    /**
     * 
     * @type {OrganizationWebhookEventEnum}
     * @memberof WebhookEventResponse
     */
    'matched_event': OrganizationWebhookEventEnum;
    /**
     * The webhook target URL that was invoked
     * @type {string}
     * @memberof WebhookEventResponse
     */
    'target_url_used': string;
    /**
     * The request payload sent to the webhook
     * @type {{ [key: string]: any; }}
     * @memberof WebhookEventResponse
     */
    'request': { [key: string]: any; };
    /**
     * HTTP status code returned by the webhook target
     * @type {number}
     * @memberof WebhookEventResponse
     */
    'target_response_status_code': number;
    /**
     * Response body from the webhook target
     * @type {string}
     * @memberof WebhookEventResponse
     */
    'target_response_body'?: string | null;
}


/**
 * 
 * @export
 * @interface WebhookEventResponseList
 */
export interface WebhookEventResponseList {
    /**
     * 
     * @type {Array<WebhookEventResponse>}
     * @memberof WebhookEventResponseList
     */
    'results'?: Array<WebhookEventResponse>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const WeekdayEnum = {
    MONDAY: 'MONDAY',
    TUESDAY: 'TUESDAY',
    WEDNESDAY: 'WEDNESDAY',
    THURSDAY: 'THURSDAY',
    FRIDAY: 'FRIDAY',
    SATURDAY: 'SATURDAY',
    SUNDAY: 'SUNDAY'
} as const;

export type WeekdayEnum = typeof WeekdayEnum[keyof typeof WeekdayEnum];



/**
 * AccountInfoApi - axios parameter creator
 * @export
 */
export const AccountInfoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Edit account information
         * @param {AccountInfoEditRequest} [accountInfoEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editAccountInformation: async (accountInfoEditRequest?: AccountInfoEditRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountInfoEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Account information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountInformation: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountInfoApi - functional programming interface
 * @export
 */
export const AccountInfoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountInfoApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Edit account information
         * @param {AccountInfoEditRequest} [accountInfoEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editAccountInformation(accountInfoEditRequest?: AccountInfoEditRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editAccountInformation(accountInfoEditRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountInfoApi.editAccountInformation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Account information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountInformation(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountInformation(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountInfoApi.getAccountInformation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccountInfoApi - factory interface
 * @export
 */
export const AccountInfoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountInfoApiFp(configuration)
    return {
        /**
         * 
         * @summary Edit account information
         * @param {AccountInfoEditRequest} [accountInfoEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editAccountInformation(accountInfoEditRequest?: AccountInfoEditRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccountInfo> {
            return localVarFp.editAccountInformation(accountInfoEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Account information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountInformation(options?: RawAxiosRequestConfig): AxiosPromise<AccountInfo> {
            return localVarFp.getAccountInformation(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountInfoApi - object-oriented interface
 * @export
 * @class AccountInfoApi
 * @extends {BaseAPI}
 */
export class AccountInfoApi extends BaseAPI {
    /**
     * 
     * @summary Edit account information
     * @param {AccountInfoEditRequest} [accountInfoEditRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountInfoApi
     */
    public editAccountInformation(accountInfoEditRequest?: AccountInfoEditRequest, options?: RawAxiosRequestConfig) {
        return AccountInfoApiFp(this.configuration).editAccountInformation(accountInfoEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Account information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountInfoApi
     */
    public getAccountInformation(options?: RawAxiosRequestConfig) {
        return AccountInfoApiFp(this.configuration).getAccountInformation(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AlertReceiversApi - axios parameter creator
 * @export
 */
export const AlertReceiversApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new alert receiver
         * @summary Create alert receiver
         * @param {AlertReceiverCreationRequest} [alertReceiverCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlertReceiver: async (alertReceiverCreationRequest?: AlertReceiverCreationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/alert-receivers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(alertReceiverCreationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an alert receiver
         * @summary Delete alert receiver
         * @param {string} alertReceiverId Alert Receiver ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlertReceiver: async (alertReceiverId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'alertReceiverId' is not null or undefined
            assertParamExists('deleteAlertReceiver', 'alertReceiverId', alertReceiverId)
            const localVarPath = `/alert-receivers/{alertReceiverId}`
                .replace(`{${"alertReceiverId"}}`, encodeURIComponent(String(alertReceiverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing alert receiver
         * @summary Update alert receiver
         * @param {string} alertReceiverId Alert Receiver ID
         * @param {AlertReceiverEditRequest} [alertReceiverEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editAlertReceiver: async (alertReceiverId: string, alertReceiverEditRequest?: AlertReceiverEditRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'alertReceiverId' is not null or undefined
            assertParamExists('editAlertReceiver', 'alertReceiverId', alertReceiverId)
            const localVarPath = `/alert-receivers/{alertReceiverId}`
                .replace(`{${"alertReceiverId"}}`, encodeURIComponent(String(alertReceiverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(alertReceiverEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific alert receiver by its ID
         * @summary Get alert receiver
         * @param {string} alertReceiverId Alert Receiver ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlertReceiver: async (alertReceiverId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'alertReceiverId' is not null or undefined
            assertParamExists('getAlertReceiver', 'alertReceiverId', alertReceiverId)
            const localVarPath = `/alert-receivers/{alertReceiverId}`
                .replace(`{${"alertReceiverId"}}`, encodeURIComponent(String(alertReceiverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all alert receivers for a specific organization
         * @summary List alert receivers
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlertReceivers: async (organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getAlertReceivers', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/alert-receivers`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validate an existing alert receiver by sending a test message for example.
         * @summary Validate Existing Alert Receiver
         * @param {string} alertReceiverId Alert Receiver ID
         * @param {AlertReceiverValidationRequest} [alertReceiverValidationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateExistingAlertReceiver: async (alertReceiverId: string, alertReceiverValidationRequest?: AlertReceiverValidationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'alertReceiverId' is not null or undefined
            assertParamExists('validateExistingAlertReceiver', 'alertReceiverId', alertReceiverId)
            const localVarPath = `/alert-receivers/{alertReceiverId}/validate`
                .replace(`{${"alertReceiverId"}}`, encodeURIComponent(String(alertReceiverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(alertReceiverValidationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validate a future alert receiver by sending a test message.
         * @summary Validate New Alert Receiver
         * @param {AlertReceiverCreationValidationRequest} [alertReceiverCreationValidationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateNewAlertReceiver: async (alertReceiverCreationValidationRequest?: AlertReceiverCreationValidationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/alert-receivers/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(alertReceiverCreationValidationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AlertReceiversApi - functional programming interface
 * @export
 */
export const AlertReceiversApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AlertReceiversApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new alert receiver
         * @summary Create alert receiver
         * @param {AlertReceiverCreationRequest} [alertReceiverCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAlertReceiver(alertReceiverCreationRequest?: AlertReceiverCreationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertReceiverResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAlertReceiver(alertReceiverCreationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlertReceiversApi.createAlertReceiver']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an alert receiver
         * @summary Delete alert receiver
         * @param {string} alertReceiverId Alert Receiver ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAlertReceiver(alertReceiverId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAlertReceiver(alertReceiverId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlertReceiversApi.deleteAlertReceiver']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing alert receiver
         * @summary Update alert receiver
         * @param {string} alertReceiverId Alert Receiver ID
         * @param {AlertReceiverEditRequest} [alertReceiverEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editAlertReceiver(alertReceiverId: string, alertReceiverEditRequest?: AlertReceiverEditRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertReceiverResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editAlertReceiver(alertReceiverId, alertReceiverEditRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlertReceiversApi.editAlertReceiver']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific alert receiver by its ID
         * @summary Get alert receiver
         * @param {string} alertReceiverId Alert Receiver ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAlertReceiver(alertReceiverId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertReceiverResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAlertReceiver(alertReceiverId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlertReceiversApi.getAlertReceiver']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all alert receivers for a specific organization
         * @summary List alert receivers
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAlertReceivers(organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertReceiverList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAlertReceivers(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlertReceiversApi.getAlertReceivers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Validate an existing alert receiver by sending a test message for example.
         * @summary Validate Existing Alert Receiver
         * @param {string} alertReceiverId Alert Receiver ID
         * @param {AlertReceiverValidationRequest} [alertReceiverValidationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateExistingAlertReceiver(alertReceiverId: string, alertReceiverValidationRequest?: AlertReceiverValidationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateExistingAlertReceiver(alertReceiverId, alertReceiverValidationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlertReceiversApi.validateExistingAlertReceiver']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Validate a future alert receiver by sending a test message.
         * @summary Validate New Alert Receiver
         * @param {AlertReceiverCreationValidationRequest} [alertReceiverCreationValidationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateNewAlertReceiver(alertReceiverCreationValidationRequest?: AlertReceiverCreationValidationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateNewAlertReceiver(alertReceiverCreationValidationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlertReceiversApi.validateNewAlertReceiver']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AlertReceiversApi - factory interface
 * @export
 */
export const AlertReceiversApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AlertReceiversApiFp(configuration)
    return {
        /**
         * Create a new alert receiver
         * @summary Create alert receiver
         * @param {AlertReceiverCreationRequest} [alertReceiverCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlertReceiver(alertReceiverCreationRequest?: AlertReceiverCreationRequest, options?: RawAxiosRequestConfig): AxiosPromise<AlertReceiverResponse> {
            return localVarFp.createAlertReceiver(alertReceiverCreationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an alert receiver
         * @summary Delete alert receiver
         * @param {string} alertReceiverId Alert Receiver ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlertReceiver(alertReceiverId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteAlertReceiver(alertReceiverId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing alert receiver
         * @summary Update alert receiver
         * @param {string} alertReceiverId Alert Receiver ID
         * @param {AlertReceiverEditRequest} [alertReceiverEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editAlertReceiver(alertReceiverId: string, alertReceiverEditRequest?: AlertReceiverEditRequest, options?: RawAxiosRequestConfig): AxiosPromise<AlertReceiverResponse> {
            return localVarFp.editAlertReceiver(alertReceiverId, alertReceiverEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific alert receiver by its ID
         * @summary Get alert receiver
         * @param {string} alertReceiverId Alert Receiver ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlertReceiver(alertReceiverId: string, options?: RawAxiosRequestConfig): AxiosPromise<AlertReceiverResponse> {
            return localVarFp.getAlertReceiver(alertReceiverId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all alert receivers for a specific organization
         * @summary List alert receivers
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlertReceivers(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise<AlertReceiverList> {
            return localVarFp.getAlertReceivers(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Validate an existing alert receiver by sending a test message for example.
         * @summary Validate Existing Alert Receiver
         * @param {string} alertReceiverId Alert Receiver ID
         * @param {AlertReceiverValidationRequest} [alertReceiverValidationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateExistingAlertReceiver(alertReceiverId: string, alertReceiverValidationRequest?: AlertReceiverValidationRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.validateExistingAlertReceiver(alertReceiverId, alertReceiverValidationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Validate a future alert receiver by sending a test message.
         * @summary Validate New Alert Receiver
         * @param {AlertReceiverCreationValidationRequest} [alertReceiverCreationValidationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateNewAlertReceiver(alertReceiverCreationValidationRequest?: AlertReceiverCreationValidationRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.validateNewAlertReceiver(alertReceiverCreationValidationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AlertReceiversApi - object-oriented interface
 * @export
 * @class AlertReceiversApi
 * @extends {BaseAPI}
 */
export class AlertReceiversApi extends BaseAPI {
    /**
     * Create a new alert receiver
     * @summary Create alert receiver
     * @param {AlertReceiverCreationRequest} [alertReceiverCreationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertReceiversApi
     */
    public createAlertReceiver(alertReceiverCreationRequest?: AlertReceiverCreationRequest, options?: RawAxiosRequestConfig) {
        return AlertReceiversApiFp(this.configuration).createAlertReceiver(alertReceiverCreationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an alert receiver
     * @summary Delete alert receiver
     * @param {string} alertReceiverId Alert Receiver ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertReceiversApi
     */
    public deleteAlertReceiver(alertReceiverId: string, options?: RawAxiosRequestConfig) {
        return AlertReceiversApiFp(this.configuration).deleteAlertReceiver(alertReceiverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing alert receiver
     * @summary Update alert receiver
     * @param {string} alertReceiverId Alert Receiver ID
     * @param {AlertReceiverEditRequest} [alertReceiverEditRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertReceiversApi
     */
    public editAlertReceiver(alertReceiverId: string, alertReceiverEditRequest?: AlertReceiverEditRequest, options?: RawAxiosRequestConfig) {
        return AlertReceiversApiFp(this.configuration).editAlertReceiver(alertReceiverId, alertReceiverEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific alert receiver by its ID
     * @summary Get alert receiver
     * @param {string} alertReceiverId Alert Receiver ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertReceiversApi
     */
    public getAlertReceiver(alertReceiverId: string, options?: RawAxiosRequestConfig) {
        return AlertReceiversApiFp(this.configuration).getAlertReceiver(alertReceiverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all alert receivers for a specific organization
     * @summary List alert receivers
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertReceiversApi
     */
    public getAlertReceivers(organizationId: string, options?: RawAxiosRequestConfig) {
        return AlertReceiversApiFp(this.configuration).getAlertReceivers(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validate an existing alert receiver by sending a test message for example.
     * @summary Validate Existing Alert Receiver
     * @param {string} alertReceiverId Alert Receiver ID
     * @param {AlertReceiverValidationRequest} [alertReceiverValidationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertReceiversApi
     */
    public validateExistingAlertReceiver(alertReceiverId: string, alertReceiverValidationRequest?: AlertReceiverValidationRequest, options?: RawAxiosRequestConfig) {
        return AlertReceiversApiFp(this.configuration).validateExistingAlertReceiver(alertReceiverId, alertReceiverValidationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validate a future alert receiver by sending a test message.
     * @summary Validate New Alert Receiver
     * @param {AlertReceiverCreationValidationRequest} [alertReceiverCreationValidationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertReceiversApi
     */
    public validateNewAlertReceiver(alertReceiverCreationValidationRequest?: AlertReceiverCreationValidationRequest, options?: RawAxiosRequestConfig) {
        return AlertReceiversApiFp(this.configuration).validateNewAlertReceiver(alertReceiverCreationValidationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AlertRulesApi - axios parameter creator
 * @export
 */
export const AlertRulesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new alert rule with PromQL expression
         * @summary Create alert rule
         * @param {AlertRuleCreationRequest} [alertRuleCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlertRule: async (alertRuleCreationRequest?: AlertRuleCreationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/alert-rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(alertRuleCreationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an alert rule
         * @summary Delete alert rule
         * @param {string} alertRuleId Alert Rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlertRule: async (alertRuleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'alertRuleId' is not null or undefined
            assertParamExists('deleteAlertRule', 'alertRuleId', alertRuleId)
            const localVarPath = `/alert-rules/{alertRuleId}`
                .replace(`{${"alertRuleId"}}`, encodeURIComponent(String(alertRuleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing alert rule
         * @summary Update alert rule
         * @param {string} alertRuleId Alert Rule ID
         * @param {AlertRuleEditRequest} [alertRuleEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editAlertRule: async (alertRuleId: string, alertRuleEditRequest?: AlertRuleEditRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'alertRuleId' is not null or undefined
            assertParamExists('editAlertRule', 'alertRuleId', alertRuleId)
            const localVarPath = `/alert-rules/{alertRuleId}`
                .replace(`{${"alertRuleId"}}`, encodeURIComponent(String(alertRuleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(alertRuleEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific alert rule by its ID
         * @summary Get alert rule
         * @param {string} alertRuleId Alert Rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlertRule: async (alertRuleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'alertRuleId' is not null or undefined
            assertParamExists('getAlertRule', 'alertRuleId', alertRuleId)
            const localVarPath = `/alert-rules/{alertRuleId}`
                .replace(`{${"alertRuleId"}}`, encodeURIComponent(String(alertRuleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all alert rules for a specific organization
         * @summary List alert rules
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlertRules: async (organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getAlertRules', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/alert-rules`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AlertRulesApi - functional programming interface
 * @export
 */
export const AlertRulesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AlertRulesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new alert rule with PromQL expression
         * @summary Create alert rule
         * @param {AlertRuleCreationRequest} [alertRuleCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAlertRule(alertRuleCreationRequest?: AlertRuleCreationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertRuleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAlertRule(alertRuleCreationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlertRulesApi.createAlertRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an alert rule
         * @summary Delete alert rule
         * @param {string} alertRuleId Alert Rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAlertRule(alertRuleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAlertRule(alertRuleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlertRulesApi.deleteAlertRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing alert rule
         * @summary Update alert rule
         * @param {string} alertRuleId Alert Rule ID
         * @param {AlertRuleEditRequest} [alertRuleEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editAlertRule(alertRuleId: string, alertRuleEditRequest?: AlertRuleEditRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertRuleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editAlertRule(alertRuleId, alertRuleEditRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlertRulesApi.editAlertRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific alert rule by its ID
         * @summary Get alert rule
         * @param {string} alertRuleId Alert Rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAlertRule(alertRuleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertRuleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAlertRule(alertRuleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlertRulesApi.getAlertRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all alert rules for a specific organization
         * @summary List alert rules
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAlertRules(organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertRuleList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAlertRules(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlertRulesApi.getAlertRules']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AlertRulesApi - factory interface
 * @export
 */
export const AlertRulesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AlertRulesApiFp(configuration)
    return {
        /**
         * Create a new alert rule with PromQL expression
         * @summary Create alert rule
         * @param {AlertRuleCreationRequest} [alertRuleCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlertRule(alertRuleCreationRequest?: AlertRuleCreationRequest, options?: RawAxiosRequestConfig): AxiosPromise<AlertRuleResponse> {
            return localVarFp.createAlertRule(alertRuleCreationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an alert rule
         * @summary Delete alert rule
         * @param {string} alertRuleId Alert Rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlertRule(alertRuleId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteAlertRule(alertRuleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing alert rule
         * @summary Update alert rule
         * @param {string} alertRuleId Alert Rule ID
         * @param {AlertRuleEditRequest} [alertRuleEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editAlertRule(alertRuleId: string, alertRuleEditRequest?: AlertRuleEditRequest, options?: RawAxiosRequestConfig): AxiosPromise<AlertRuleResponse> {
            return localVarFp.editAlertRule(alertRuleId, alertRuleEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific alert rule by its ID
         * @summary Get alert rule
         * @param {string} alertRuleId Alert Rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlertRule(alertRuleId: string, options?: RawAxiosRequestConfig): AxiosPromise<AlertRuleResponse> {
            return localVarFp.getAlertRule(alertRuleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all alert rules for a specific organization
         * @summary List alert rules
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlertRules(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise<AlertRuleList> {
            return localVarFp.getAlertRules(organizationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AlertRulesApi - object-oriented interface
 * @export
 * @class AlertRulesApi
 * @extends {BaseAPI}
 */
export class AlertRulesApi extends BaseAPI {
    /**
     * Create a new alert rule with PromQL expression
     * @summary Create alert rule
     * @param {AlertRuleCreationRequest} [alertRuleCreationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertRulesApi
     */
    public createAlertRule(alertRuleCreationRequest?: AlertRuleCreationRequest, options?: RawAxiosRequestConfig) {
        return AlertRulesApiFp(this.configuration).createAlertRule(alertRuleCreationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an alert rule
     * @summary Delete alert rule
     * @param {string} alertRuleId Alert Rule ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertRulesApi
     */
    public deleteAlertRule(alertRuleId: string, options?: RawAxiosRequestConfig) {
        return AlertRulesApiFp(this.configuration).deleteAlertRule(alertRuleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing alert rule
     * @summary Update alert rule
     * @param {string} alertRuleId Alert Rule ID
     * @param {AlertRuleEditRequest} [alertRuleEditRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertRulesApi
     */
    public editAlertRule(alertRuleId: string, alertRuleEditRequest?: AlertRuleEditRequest, options?: RawAxiosRequestConfig) {
        return AlertRulesApiFp(this.configuration).editAlertRule(alertRuleId, alertRuleEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific alert rule by its ID
     * @summary Get alert rule
     * @param {string} alertRuleId Alert Rule ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertRulesApi
     */
    public getAlertRule(alertRuleId: string, options?: RawAxiosRequestConfig) {
        return AlertRulesApiFp(this.configuration).getAlertRule(alertRuleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all alert rules for a specific organization
     * @summary List alert rules
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertRulesApi
     */
    public getAlertRules(organizationId: string, options?: RawAxiosRequestConfig) {
        return AlertRulesApiFp(this.configuration).getAlertRules(organizationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ApplicationActionsApi - axios parameter creator
 * @export
 */
export const ApplicationActionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * You must provide a git commit id
         * @summary Deploy application
         * @param {string} applicationId Application ID
         * @param {DeployRequest} [deployRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployApplication: async (applicationId: string, deployRequest?: DeployRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('deployApplication', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/deploy`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deployRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reboot application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rebootApplication: async (applicationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('rebootApplication', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/restart-service`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Redeploy application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeployApplication: async (applicationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('redeployApplication', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/redeploy`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopApplication: async (applicationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('stopApplication', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/stop`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the resources of an application but keep the Qovery config. 
         * @summary Uninstall application
         * @param {string} applicationId Application ID
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uninstallApplication: async (applicationId: string, body?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('uninstallApplication', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/uninstall`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationActionsApi - functional programming interface
 * @export
 */
export const ApplicationActionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationActionsApiAxiosParamCreator(configuration)
    return {
        /**
         * You must provide a git commit id
         * @summary Deploy application
         * @param {string} applicationId Application ID
         * @param {DeployRequest} [deployRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployApplication(applicationId: string, deployRequest?: DeployRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployApplication(applicationId, deployRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationActionsApi.deployApplication']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Reboot application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rebootApplication(applicationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rebootApplication(applicationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationActionsApi.rebootApplication']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Redeploy application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async redeployApplication(applicationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.redeployApplication(applicationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationActionsApi.redeployApplication']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Stop application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopApplication(applicationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopApplication(applicationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationActionsApi.stopApplication']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete the resources of an application but keep the Qovery config. 
         * @summary Uninstall application
         * @param {string} applicationId Application ID
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uninstallApplication(applicationId: string, body?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uninstallApplication(applicationId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationActionsApi.uninstallApplication']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ApplicationActionsApi - factory interface
 * @export
 */
export const ApplicationActionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationActionsApiFp(configuration)
    return {
        /**
         * You must provide a git commit id
         * @summary Deploy application
         * @param {string} applicationId Application ID
         * @param {DeployRequest} [deployRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployApplication(applicationId: string, deployRequest?: DeployRequest, options?: RawAxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.deployApplication(applicationId, deployRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reboot application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rebootApplication(applicationId: string, options?: RawAxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.rebootApplication(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Redeploy application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeployApplication(applicationId: string, options?: RawAxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.redeployApplication(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Stop application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopApplication(applicationId: string, options?: RawAxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.stopApplication(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete the resources of an application but keep the Qovery config. 
         * @summary Uninstall application
         * @param {string} applicationId Application ID
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uninstallApplication(applicationId: string, body?: object, options?: RawAxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.uninstallApplication(applicationId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationActionsApi - object-oriented interface
 * @export
 * @class ApplicationActionsApi
 * @extends {BaseAPI}
 */
export class ApplicationActionsApi extends BaseAPI {
    /**
     * You must provide a git commit id
     * @summary Deploy application
     * @param {string} applicationId Application ID
     * @param {DeployRequest} [deployRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationActionsApi
     */
    public deployApplication(applicationId: string, deployRequest?: DeployRequest, options?: RawAxiosRequestConfig) {
        return ApplicationActionsApiFp(this.configuration).deployApplication(applicationId, deployRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reboot application
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationActionsApi
     */
    public rebootApplication(applicationId: string, options?: RawAxiosRequestConfig) {
        return ApplicationActionsApiFp(this.configuration).rebootApplication(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Redeploy application
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationActionsApi
     */
    public redeployApplication(applicationId: string, options?: RawAxiosRequestConfig) {
        return ApplicationActionsApiFp(this.configuration).redeployApplication(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Stop application
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationActionsApi
     */
    public stopApplication(applicationId: string, options?: RawAxiosRequestConfig) {
        return ApplicationActionsApiFp(this.configuration).stopApplication(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete the resources of an application but keep the Qovery config. 
     * @summary Uninstall application
     * @param {string} applicationId Application ID
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationActionsApi
     */
    public uninstallApplication(applicationId: string, body?: object, options?: RawAxiosRequestConfig) {
        return ApplicationActionsApiFp(this.configuration).uninstallApplication(applicationId, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ApplicationConfigurationApi - axios parameter creator
 * @export
 */
export const ApplicationConfigurationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Edit advanced settings by returning table of advanced settings.
         * @summary Edit advanced settings
         * @param {string} applicationId Application ID
         * @param {ApplicationAdvancedSettings} [applicationAdvancedSettings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editAdvancedSettings: async (applicationId: string, applicationAdvancedSettings?: ApplicationAdvancedSettings, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('editAdvancedSettings', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/advancedSettings`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(applicationAdvancedSettings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit the Network settings of the application.
         * @summary Edit Application Network
         * @param {string} applicationId Application ID
         * @param {ApplicationNetworkRequest} [applicationNetworkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editApplicationNetwork: async (applicationId: string, applicationNetworkRequest?: ApplicationNetworkRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('editApplicationNetwork', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/network`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(applicationNetworkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list and values of the advanced settings of the application. Default values for each setting are available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/advanced-settings/) 
         * @summary Get advanced settings
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdvancedSettings: async (applicationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getAdvancedSettings', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/advancedSettings`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get status of the application network settings.
         * @summary Get Application Network information
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationNetwork: async (applicationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getApplicationNetwork', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/network`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationConfigurationApi - functional programming interface
 * @export
 */
export const ApplicationConfigurationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationConfigurationApiAxiosParamCreator(configuration)
    return {
        /**
         * Edit advanced settings by returning table of advanced settings.
         * @summary Edit advanced settings
         * @param {string} applicationId Application ID
         * @param {ApplicationAdvancedSettings} [applicationAdvancedSettings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editAdvancedSettings(applicationId: string, applicationAdvancedSettings?: ApplicationAdvancedSettings, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationAdvancedSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editAdvancedSettings(applicationId, applicationAdvancedSettings, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationConfigurationApi.editAdvancedSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Edit the Network settings of the application.
         * @summary Edit Application Network
         * @param {string} applicationId Application ID
         * @param {ApplicationNetworkRequest} [applicationNetworkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editApplicationNetwork(applicationId: string, applicationNetworkRequest?: ApplicationNetworkRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationNetwork>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editApplicationNetwork(applicationId, applicationNetworkRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationConfigurationApi.editApplicationNetwork']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get list and values of the advanced settings of the application. Default values for each setting are available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/advanced-settings/) 
         * @summary Get advanced settings
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAdvancedSettings(applicationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationAdvancedSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAdvancedSettings(applicationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationConfigurationApi.getAdvancedSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get status of the application network settings.
         * @summary Get Application Network information
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationNetwork(applicationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationNetwork>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationNetwork(applicationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationConfigurationApi.getApplicationNetwork']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ApplicationConfigurationApi - factory interface
 * @export
 */
export const ApplicationConfigurationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationConfigurationApiFp(configuration)
    return {
        /**
         * Edit advanced settings by returning table of advanced settings.
         * @summary Edit advanced settings
         * @param {string} applicationId Application ID
         * @param {ApplicationAdvancedSettings} [applicationAdvancedSettings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editAdvancedSettings(applicationId: string, applicationAdvancedSettings?: ApplicationAdvancedSettings, options?: RawAxiosRequestConfig): AxiosPromise<ApplicationAdvancedSettings> {
            return localVarFp.editAdvancedSettings(applicationId, applicationAdvancedSettings, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit the Network settings of the application.
         * @summary Edit Application Network
         * @param {string} applicationId Application ID
         * @param {ApplicationNetworkRequest} [applicationNetworkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editApplicationNetwork(applicationId: string, applicationNetworkRequest?: ApplicationNetworkRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApplicationNetwork> {
            return localVarFp.editApplicationNetwork(applicationId, applicationNetworkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get list and values of the advanced settings of the application. Default values for each setting are available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/advanced-settings/) 
         * @summary Get advanced settings
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdvancedSettings(applicationId: string, options?: RawAxiosRequestConfig): AxiosPromise<ApplicationAdvancedSettings> {
            return localVarFp.getAdvancedSettings(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get status of the application network settings.
         * @summary Get Application Network information
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationNetwork(applicationId: string, options?: RawAxiosRequestConfig): AxiosPromise<ApplicationNetwork> {
            return localVarFp.getApplicationNetwork(applicationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationConfigurationApi - object-oriented interface
 * @export
 * @class ApplicationConfigurationApi
 * @extends {BaseAPI}
 */
export class ApplicationConfigurationApi extends BaseAPI {
    /**
     * Edit advanced settings by returning table of advanced settings.
     * @summary Edit advanced settings
     * @param {string} applicationId Application ID
     * @param {ApplicationAdvancedSettings} [applicationAdvancedSettings] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationConfigurationApi
     */
    public editAdvancedSettings(applicationId: string, applicationAdvancedSettings?: ApplicationAdvancedSettings, options?: RawAxiosRequestConfig) {
        return ApplicationConfigurationApiFp(this.configuration).editAdvancedSettings(applicationId, applicationAdvancedSettings, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit the Network settings of the application.
     * @summary Edit Application Network
     * @param {string} applicationId Application ID
     * @param {ApplicationNetworkRequest} [applicationNetworkRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationConfigurationApi
     */
    public editApplicationNetwork(applicationId: string, applicationNetworkRequest?: ApplicationNetworkRequest, options?: RawAxiosRequestConfig) {
        return ApplicationConfigurationApiFp(this.configuration).editApplicationNetwork(applicationId, applicationNetworkRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list and values of the advanced settings of the application. Default values for each setting are available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/advanced-settings/) 
     * @summary Get advanced settings
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationConfigurationApi
     */
    public getAdvancedSettings(applicationId: string, options?: RawAxiosRequestConfig) {
        return ApplicationConfigurationApiFp(this.configuration).getAdvancedSettings(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get status of the application network settings.
     * @summary Get Application Network information
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationConfigurationApi
     */
    public getApplicationNetwork(applicationId: string, options?: RawAxiosRequestConfig) {
        return ApplicationConfigurationApiFp(this.configuration).getApplicationNetwork(applicationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ApplicationCustomDomainApi - axios parameter creator
 * @export
 */
export const ApplicationCustomDomainApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Check Application Custom Domain
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkApplicationCustomDomain: async (applicationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('checkApplicationCustomDomain', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/checkCustomDomain`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a custom domain to this application in order not to use qovery autogenerated domain
         * @summary Add custom domain to the application.
         * @param {string} applicationId Application ID
         * @param {CustomDomainRequest} [customDomainRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationCustomDomain: async (applicationId: string, customDomainRequest?: CustomDomainRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('createApplicationCustomDomain', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/customDomain`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customDomainRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To delete an CustomDomain you must have the project user permission
         * @summary Delete a Custom Domain
         * @param {string} applicationId Application ID
         * @param {string} customDomainId Custom Domain ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomDomain: async (applicationId: string, customDomainId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('deleteCustomDomain', 'applicationId', applicationId)
            // verify required parameter 'customDomainId' is not null or undefined
            assertParamExists('deleteCustomDomain', 'customDomainId', customDomainId)
            const localVarPath = `/application/{applicationId}/customDomain/{customDomainId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"customDomainId"}}`, encodeURIComponent(String(customDomainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To edit a Custom Domain you must have the project user permission
         * @summary Edit a Custom Domain
         * @param {string} applicationId Application ID
         * @param {string} customDomainId Custom Domain ID
         * @param {CustomDomainRequest} [customDomainRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editCustomDomain: async (applicationId: string, customDomainId: string, customDomainRequest?: CustomDomainRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('editCustomDomain', 'applicationId', applicationId)
            // verify required parameter 'customDomainId' is not null or undefined
            assertParamExists('editCustomDomain', 'customDomainId', customDomainId)
            const localVarPath = `/application/{applicationId}/customDomain/{customDomainId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"customDomainId"}}`, encodeURIComponent(String(customDomainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customDomainRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Custom Domain status
         * @param {string} applicationId Application ID
         * @param {string} customDomainId Custom Domain ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomDomainStatus: async (applicationId: string, customDomainId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getCustomDomainStatus', 'applicationId', applicationId)
            // verify required parameter 'customDomainId' is not null or undefined
            assertParamExists('getCustomDomainStatus', 'customDomainId', customDomainId)
            const localVarPath = `/application/{applicationId}/customDomain/{customDomainId}/status`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"customDomainId"}}`, encodeURIComponent(String(customDomainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List application custom domains
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationCustomDomain: async (applicationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('listApplicationCustomDomain', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/customDomain`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationCustomDomainApi - functional programming interface
 * @export
 */
export const ApplicationCustomDomainApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationCustomDomainApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Check Application Custom Domain
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkApplicationCustomDomain(applicationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckedCustomDomainsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkApplicationCustomDomain(applicationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationCustomDomainApi.checkApplicationCustomDomain']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add a custom domain to this application in order not to use qovery autogenerated domain
         * @summary Add custom domain to the application.
         * @param {string} applicationId Application ID
         * @param {CustomDomainRequest} [customDomainRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplicationCustomDomain(applicationId: string, customDomainRequest?: CustomDomainRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomDomain>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplicationCustomDomain(applicationId, customDomainRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationCustomDomainApi.createApplicationCustomDomain']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * To delete an CustomDomain you must have the project user permission
         * @summary Delete a Custom Domain
         * @param {string} applicationId Application ID
         * @param {string} customDomainId Custom Domain ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCustomDomain(applicationId: string, customDomainId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCustomDomain(applicationId, customDomainId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationCustomDomainApi.deleteCustomDomain']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * To edit a Custom Domain you must have the project user permission
         * @summary Edit a Custom Domain
         * @param {string} applicationId Application ID
         * @param {string} customDomainId Custom Domain ID
         * @param {CustomDomainRequest} [customDomainRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editCustomDomain(applicationId: string, customDomainId: string, customDomainRequest?: CustomDomainRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomDomain>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editCustomDomain(applicationId, customDomainId, customDomainRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationCustomDomainApi.editCustomDomain']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Custom Domain status
         * @param {string} applicationId Application ID
         * @param {string} customDomainId Custom Domain ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomDomainStatus(applicationId: string, customDomainId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomDomain>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomDomainStatus(applicationId, customDomainId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationCustomDomainApi.getCustomDomainStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List application custom domains
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplicationCustomDomain(applicationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomDomainResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplicationCustomDomain(applicationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationCustomDomainApi.listApplicationCustomDomain']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ApplicationCustomDomainApi - factory interface
 * @export
 */
export const ApplicationCustomDomainApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationCustomDomainApiFp(configuration)
    return {
        /**
         * 
         * @summary Check Application Custom Domain
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkApplicationCustomDomain(applicationId: string, options?: RawAxiosRequestConfig): AxiosPromise<CheckedCustomDomainsResponse> {
            return localVarFp.checkApplicationCustomDomain(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a custom domain to this application in order not to use qovery autogenerated domain
         * @summary Add custom domain to the application.
         * @param {string} applicationId Application ID
         * @param {CustomDomainRequest} [customDomainRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationCustomDomain(applicationId: string, customDomainRequest?: CustomDomainRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomDomain> {
            return localVarFp.createApplicationCustomDomain(applicationId, customDomainRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * To delete an CustomDomain you must have the project user permission
         * @summary Delete a Custom Domain
         * @param {string} applicationId Application ID
         * @param {string} customDomainId Custom Domain ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomDomain(applicationId: string, customDomainId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteCustomDomain(applicationId, customDomainId, options).then((request) => request(axios, basePath));
        },
        /**
         * To edit a Custom Domain you must have the project user permission
         * @summary Edit a Custom Domain
         * @param {string} applicationId Application ID
         * @param {string} customDomainId Custom Domain ID
         * @param {CustomDomainRequest} [customDomainRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editCustomDomain(applicationId: string, customDomainId: string, customDomainRequest?: CustomDomainRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomDomain> {
            return localVarFp.editCustomDomain(applicationId, customDomainId, customDomainRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Custom Domain status
         * @param {string} applicationId Application ID
         * @param {string} customDomainId Custom Domain ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomDomainStatus(applicationId: string, customDomainId: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomDomain> {
            return localVarFp.getCustomDomainStatus(applicationId, customDomainId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List application custom domains
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationCustomDomain(applicationId: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomDomainResponseList> {
            return localVarFp.listApplicationCustomDomain(applicationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationCustomDomainApi - object-oriented interface
 * @export
 * @class ApplicationCustomDomainApi
 * @extends {BaseAPI}
 */
export class ApplicationCustomDomainApi extends BaseAPI {
    /**
     * 
     * @summary Check Application Custom Domain
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationCustomDomainApi
     */
    public checkApplicationCustomDomain(applicationId: string, options?: RawAxiosRequestConfig) {
        return ApplicationCustomDomainApiFp(this.configuration).checkApplicationCustomDomain(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a custom domain to this application in order not to use qovery autogenerated domain
     * @summary Add custom domain to the application.
     * @param {string} applicationId Application ID
     * @param {CustomDomainRequest} [customDomainRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationCustomDomainApi
     */
    public createApplicationCustomDomain(applicationId: string, customDomainRequest?: CustomDomainRequest, options?: RawAxiosRequestConfig) {
        return ApplicationCustomDomainApiFp(this.configuration).createApplicationCustomDomain(applicationId, customDomainRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To delete an CustomDomain you must have the project user permission
     * @summary Delete a Custom Domain
     * @param {string} applicationId Application ID
     * @param {string} customDomainId Custom Domain ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationCustomDomainApi
     */
    public deleteCustomDomain(applicationId: string, customDomainId: string, options?: RawAxiosRequestConfig) {
        return ApplicationCustomDomainApiFp(this.configuration).deleteCustomDomain(applicationId, customDomainId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To edit a Custom Domain you must have the project user permission
     * @summary Edit a Custom Domain
     * @param {string} applicationId Application ID
     * @param {string} customDomainId Custom Domain ID
     * @param {CustomDomainRequest} [customDomainRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationCustomDomainApi
     */
    public editCustomDomain(applicationId: string, customDomainId: string, customDomainRequest?: CustomDomainRequest, options?: RawAxiosRequestConfig) {
        return ApplicationCustomDomainApiFp(this.configuration).editCustomDomain(applicationId, customDomainId, customDomainRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Custom Domain status
     * @param {string} applicationId Application ID
     * @param {string} customDomainId Custom Domain ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationCustomDomainApi
     */
    public getCustomDomainStatus(applicationId: string, customDomainId: string, options?: RawAxiosRequestConfig) {
        return ApplicationCustomDomainApiFp(this.configuration).getCustomDomainStatus(applicationId, customDomainId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List application custom domains
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationCustomDomainApi
     */
    public listApplicationCustomDomain(applicationId: string, options?: RawAxiosRequestConfig) {
        return ApplicationCustomDomainApiFp(this.configuration).listApplicationCustomDomain(applicationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ApplicationDeploymentHistoryApi - axios parameter creator
 * @export
 */
export const ApplicationDeploymentHistoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter. You can also filter by status (FAILED or SUCCESS), and git_commit_id
         * @summary List application deploys
         * @param {string} applicationId Application ID
         * @param {string} [startId] Starting point after which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationDeploymentHistory: async (applicationId: string, startId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('listApplicationDeploymentHistory', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/deploymentHistory`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (startId !== undefined) {
                localVarQueryParameter['startId'] = startId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter. You can also filter by status (FAILED or SUCCESS), and git_commit_id
         * @summary List application deploys
         * @param {string} applicationId 
         * @param {number | null} [pageSize] The number of deployments to return in the current page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationDeploymentHistoryV2: async (applicationId: string, pageSize?: number | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('listApplicationDeploymentHistoryV2', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/deploymentHistoryV2`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationDeploymentHistoryApi - functional programming interface
 * @export
 */
export const ApplicationDeploymentHistoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationDeploymentHistoryApiAxiosParamCreator(configuration)
    return {
        /**
         * By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter. You can also filter by status (FAILED or SUCCESS), and git_commit_id
         * @summary List application deploys
         * @param {string} applicationId Application ID
         * @param {string} [startId] Starting point after which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplicationDeploymentHistory(applicationId: string, startId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentHistoryPaginatedResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplicationDeploymentHistory(applicationId, startId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationDeploymentHistoryApi.listApplicationDeploymentHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter. You can also filter by status (FAILED or SUCCESS), and git_commit_id
         * @summary List application deploys
         * @param {string} applicationId 
         * @param {number | null} [pageSize] The number of deployments to return in the current page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplicationDeploymentHistoryV2(applicationId: string, pageSize?: number | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentHistoryServicePaginatedResponseListV2>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplicationDeploymentHistoryV2(applicationId, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationDeploymentHistoryApi.listApplicationDeploymentHistoryV2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ApplicationDeploymentHistoryApi - factory interface
 * @export
 */
export const ApplicationDeploymentHistoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationDeploymentHistoryApiFp(configuration)
    return {
        /**
         * By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter. You can also filter by status (FAILED or SUCCESS), and git_commit_id
         * @summary List application deploys
         * @param {string} applicationId Application ID
         * @param {string} [startId] Starting point after which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationDeploymentHistory(applicationId: string, startId?: string, options?: RawAxiosRequestConfig): AxiosPromise<DeploymentHistoryPaginatedResponseList> {
            return localVarFp.listApplicationDeploymentHistory(applicationId, startId, options).then((request) => request(axios, basePath));
        },
        /**
         * By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter. You can also filter by status (FAILED or SUCCESS), and git_commit_id
         * @summary List application deploys
         * @param {string} applicationId 
         * @param {number | null} [pageSize] The number of deployments to return in the current page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationDeploymentHistoryV2(applicationId: string, pageSize?: number | null, options?: RawAxiosRequestConfig): AxiosPromise<DeploymentHistoryServicePaginatedResponseListV2> {
            return localVarFp.listApplicationDeploymentHistoryV2(applicationId, pageSize, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationDeploymentHistoryApi - object-oriented interface
 * @export
 * @class ApplicationDeploymentHistoryApi
 * @extends {BaseAPI}
 */
export class ApplicationDeploymentHistoryApi extends BaseAPI {
    /**
     * By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter. You can also filter by status (FAILED or SUCCESS), and git_commit_id
     * @summary List application deploys
     * @param {string} applicationId Application ID
     * @param {string} [startId] Starting point after which to return results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentHistoryApi
     */
    public listApplicationDeploymentHistory(applicationId: string, startId?: string, options?: RawAxiosRequestConfig) {
        return ApplicationDeploymentHistoryApiFp(this.configuration).listApplicationDeploymentHistory(applicationId, startId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter. You can also filter by status (FAILED or SUCCESS), and git_commit_id
     * @summary List application deploys
     * @param {string} applicationId 
     * @param {number | null} [pageSize] The number of deployments to return in the current page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentHistoryApi
     */
    public listApplicationDeploymentHistoryV2(applicationId: string, pageSize?: number | null, options?: RawAxiosRequestConfig) {
        return ApplicationDeploymentHistoryApiFp(this.configuration).listApplicationDeploymentHistoryV2(applicationId, pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ApplicationDeploymentRestrictionApi - axios parameter creator
 * @export
 */
export const ApplicationDeploymentRestrictionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an application deployment restriction
         * @summary Create an application deployment restriction
         * @param {string} applicationId Application ID
         * @param {ApplicationDeploymentRestrictionRequest} [applicationDeploymentRestrictionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationDeploymentRestriction: async (applicationId: string, applicationDeploymentRestrictionRequest?: ApplicationDeploymentRestrictionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('createApplicationDeploymentRestriction', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/deploymentRestriction`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(applicationDeploymentRestrictionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an application deployment restriction
         * @summary Delete an application deployment restriction
         * @param {string} applicationId Application ID
         * @param {string} deploymentRestrictionId Deployment Restriction ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationDeploymentRestriction: async (applicationId: string, deploymentRestrictionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('deleteApplicationDeploymentRestriction', 'applicationId', applicationId)
            // verify required parameter 'deploymentRestrictionId' is not null or undefined
            assertParamExists('deleteApplicationDeploymentRestriction', 'deploymentRestrictionId', deploymentRestrictionId)
            const localVarPath = `/application/{applicationId}/deploymentRestriction/{deploymentRestrictionId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"deploymentRestrictionId"}}`, encodeURIComponent(String(deploymentRestrictionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit an application deployment restriction
         * @summary Edit an application deployment restriction
         * @param {string} applicationId Application ID
         * @param {string} deploymentRestrictionId Deployment Restriction ID
         * @param {ApplicationDeploymentRestrictionRequest} [applicationDeploymentRestrictionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editApplicationDeploymentRestriction: async (applicationId: string, deploymentRestrictionId: string, applicationDeploymentRestrictionRequest?: ApplicationDeploymentRestrictionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('editApplicationDeploymentRestriction', 'applicationId', applicationId)
            // verify required parameter 'deploymentRestrictionId' is not null or undefined
            assertParamExists('editApplicationDeploymentRestriction', 'deploymentRestrictionId', deploymentRestrictionId)
            const localVarPath = `/application/{applicationId}/deploymentRestriction/{deploymentRestrictionId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"deploymentRestrictionId"}}`, encodeURIComponent(String(deploymentRestrictionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(applicationDeploymentRestrictionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get application deployment restrictions
         * @summary Get application deployment restrictions
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationDeploymentRestrictions: async (applicationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getApplicationDeploymentRestrictions', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/deploymentRestriction`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationDeploymentRestrictionApi - functional programming interface
 * @export
 */
export const ApplicationDeploymentRestrictionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationDeploymentRestrictionApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an application deployment restriction
         * @summary Create an application deployment restriction
         * @param {string} applicationId Application ID
         * @param {ApplicationDeploymentRestrictionRequest} [applicationDeploymentRestrictionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplicationDeploymentRestriction(applicationId: string, applicationDeploymentRestrictionRequest?: ApplicationDeploymentRestrictionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationDeploymentRestriction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplicationDeploymentRestriction(applicationId, applicationDeploymentRestrictionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationDeploymentRestrictionApi.createApplicationDeploymentRestriction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an application deployment restriction
         * @summary Delete an application deployment restriction
         * @param {string} applicationId Application ID
         * @param {string} deploymentRestrictionId Deployment Restriction ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApplicationDeploymentRestriction(applicationId: string, deploymentRestrictionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApplicationDeploymentRestriction(applicationId, deploymentRestrictionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationDeploymentRestrictionApi.deleteApplicationDeploymentRestriction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Edit an application deployment restriction
         * @summary Edit an application deployment restriction
         * @param {string} applicationId Application ID
         * @param {string} deploymentRestrictionId Deployment Restriction ID
         * @param {ApplicationDeploymentRestrictionRequest} [applicationDeploymentRestrictionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editApplicationDeploymentRestriction(applicationId: string, deploymentRestrictionId: string, applicationDeploymentRestrictionRequest?: ApplicationDeploymentRestrictionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationDeploymentRestriction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editApplicationDeploymentRestriction(applicationId, deploymentRestrictionId, applicationDeploymentRestrictionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationDeploymentRestrictionApi.editApplicationDeploymentRestriction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get application deployment restrictions
         * @summary Get application deployment restrictions
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationDeploymentRestrictions(applicationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationDeploymentRestrictionResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationDeploymentRestrictions(applicationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationDeploymentRestrictionApi.getApplicationDeploymentRestrictions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ApplicationDeploymentRestrictionApi - factory interface
 * @export
 */
export const ApplicationDeploymentRestrictionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationDeploymentRestrictionApiFp(configuration)
    return {
        /**
         * Create an application deployment restriction
         * @summary Create an application deployment restriction
         * @param {string} applicationId Application ID
         * @param {ApplicationDeploymentRestrictionRequest} [applicationDeploymentRestrictionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationDeploymentRestriction(applicationId: string, applicationDeploymentRestrictionRequest?: ApplicationDeploymentRestrictionRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApplicationDeploymentRestriction> {
            return localVarFp.createApplicationDeploymentRestriction(applicationId, applicationDeploymentRestrictionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an application deployment restriction
         * @summary Delete an application deployment restriction
         * @param {string} applicationId Application ID
         * @param {string} deploymentRestrictionId Deployment Restriction ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationDeploymentRestriction(applicationId: string, deploymentRestrictionId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteApplicationDeploymentRestriction(applicationId, deploymentRestrictionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit an application deployment restriction
         * @summary Edit an application deployment restriction
         * @param {string} applicationId Application ID
         * @param {string} deploymentRestrictionId Deployment Restriction ID
         * @param {ApplicationDeploymentRestrictionRequest} [applicationDeploymentRestrictionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editApplicationDeploymentRestriction(applicationId: string, deploymentRestrictionId: string, applicationDeploymentRestrictionRequest?: ApplicationDeploymentRestrictionRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApplicationDeploymentRestriction> {
            return localVarFp.editApplicationDeploymentRestriction(applicationId, deploymentRestrictionId, applicationDeploymentRestrictionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get application deployment restrictions
         * @summary Get application deployment restrictions
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationDeploymentRestrictions(applicationId: string, options?: RawAxiosRequestConfig): AxiosPromise<ApplicationDeploymentRestrictionResponseList> {
            return localVarFp.getApplicationDeploymentRestrictions(applicationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationDeploymentRestrictionApi - object-oriented interface
 * @export
 * @class ApplicationDeploymentRestrictionApi
 * @extends {BaseAPI}
 */
export class ApplicationDeploymentRestrictionApi extends BaseAPI {
    /**
     * Create an application deployment restriction
     * @summary Create an application deployment restriction
     * @param {string} applicationId Application ID
     * @param {ApplicationDeploymentRestrictionRequest} [applicationDeploymentRestrictionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentRestrictionApi
     */
    public createApplicationDeploymentRestriction(applicationId: string, applicationDeploymentRestrictionRequest?: ApplicationDeploymentRestrictionRequest, options?: RawAxiosRequestConfig) {
        return ApplicationDeploymentRestrictionApiFp(this.configuration).createApplicationDeploymentRestriction(applicationId, applicationDeploymentRestrictionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an application deployment restriction
     * @summary Delete an application deployment restriction
     * @param {string} applicationId Application ID
     * @param {string} deploymentRestrictionId Deployment Restriction ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentRestrictionApi
     */
    public deleteApplicationDeploymentRestriction(applicationId: string, deploymentRestrictionId: string, options?: RawAxiosRequestConfig) {
        return ApplicationDeploymentRestrictionApiFp(this.configuration).deleteApplicationDeploymentRestriction(applicationId, deploymentRestrictionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit an application deployment restriction
     * @summary Edit an application deployment restriction
     * @param {string} applicationId Application ID
     * @param {string} deploymentRestrictionId Deployment Restriction ID
     * @param {ApplicationDeploymentRestrictionRequest} [applicationDeploymentRestrictionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentRestrictionApi
     */
    public editApplicationDeploymentRestriction(applicationId: string, deploymentRestrictionId: string, applicationDeploymentRestrictionRequest?: ApplicationDeploymentRestrictionRequest, options?: RawAxiosRequestConfig) {
        return ApplicationDeploymentRestrictionApiFp(this.configuration).editApplicationDeploymentRestriction(applicationId, deploymentRestrictionId, applicationDeploymentRestrictionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get application deployment restrictions
     * @summary Get application deployment restrictions
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentRestrictionApi
     */
    public getApplicationDeploymentRestrictions(applicationId: string, options?: RawAxiosRequestConfig) {
        return ApplicationDeploymentRestrictionApiFp(this.configuration).getApplicationDeploymentRestrictions(applicationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ApplicationEnvironmentVariableApi - axios parameter creator
 * @export
 */
export const ApplicationEnvironmentVariableApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * - Add an environment variable to the application. 
         * @summary Add an environment variable to the application
         * @param {string} applicationId Application ID
         * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationEnvironmentVariable: async (applicationId: string, environmentVariableRequest?: EnvironmentVariableRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('createApplicationEnvironmentVariable', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/environmentVariable`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentVariableRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to add an alias at application level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at application level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - You can\'t create an alias on an alias 
         * @summary Create an environment variable alias at the application level
         * @param {string} applicationId Application ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationEnvironmentVariableAlias: async (applicationId: string, environmentVariableId: string, key?: Key, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('createApplicationEnvironmentVariableAlias', 'applicationId', applicationId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('createApplicationEnvironmentVariableAlias', 'environmentVariableId', environmentVariableId)
            const localVarPath = `/application/{applicationId}/environmentVariable/{environmentVariableId}/alias`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(key, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to override at application level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at application level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
         * @summary Create an environment variable override at the application level
         * @param {string} applicationId Application ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationEnvironmentVariableOverride: async (applicationId: string, environmentVariableId: string, value?: Value, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('createApplicationEnvironmentVariableOverride', 'applicationId', applicationId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('createApplicationEnvironmentVariableOverride', 'environmentVariableId', environmentVariableId)
            const localVarPath = `/application/{applicationId}/environmentVariable/{environmentVariableId}/override`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(value, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - To delete an environment variable from an application you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete an environment variable from an application
         * @param {string} applicationId Application ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationEnvironmentVariable: async (applicationId: string, environmentVariableId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('deleteApplicationEnvironmentVariable', 'applicationId', applicationId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('deleteApplicationEnvironmentVariable', 'environmentVariableId', environmentVariableId)
            const localVarPath = `/application/{applicationId}/environmentVariable/{environmentVariableId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit an environment variable belonging to the application
         * @param {string} applicationId Application ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editApplicationEnvironmentVariable: async (applicationId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('editApplicationEnvironmentVariable', 'applicationId', applicationId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('editApplicationEnvironmentVariable', 'environmentVariableId', environmentVariableId)
            // verify required parameter 'environmentVariableEditRequest' is not null or undefined
            assertParamExists('editApplicationEnvironmentVariable', 'environmentVariableEditRequest', environmentVariableEditRequest)
            const localVarPath = `/application/{applicationId}/environmentVariable/{environmentVariableId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentVariableEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Import environment variables in a defined scope, with a defined visibility.
         * @summary Import variables
         * @param {string} applicationId Application ID
         * @param {VariableImportRequest} [variableImportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importEnvironmentVariable: async (applicationId: string, variableImportRequest?: VariableImportRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('importEnvironmentVariable', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/environmentVariable/import`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(variableImportRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List environment variables
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationEnvironmentVariable: async (applicationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('listApplicationEnvironmentVariable', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/environmentVariable`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationEnvironmentVariableApi - functional programming interface
 * @export
 */
export const ApplicationEnvironmentVariableApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationEnvironmentVariableApiAxiosParamCreator(configuration)
    return {
        /**
         * - Add an environment variable to the application. 
         * @summary Add an environment variable to the application
         * @param {string} applicationId Application ID
         * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplicationEnvironmentVariable(applicationId: string, environmentVariableRequest?: EnvironmentVariableRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplicationEnvironmentVariable(applicationId, environmentVariableRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationEnvironmentVariableApi.createApplicationEnvironmentVariable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - Allows you to add an alias at application level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at application level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - You can\'t create an alias on an alias 
         * @summary Create an environment variable alias at the application level
         * @param {string} applicationId Application ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplicationEnvironmentVariableAlias(applicationId: string, environmentVariableId: string, key?: Key, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplicationEnvironmentVariableAlias(applicationId, environmentVariableId, key, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationEnvironmentVariableApi.createApplicationEnvironmentVariableAlias']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - Allows you to override at application level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at application level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
         * @summary Create an environment variable override at the application level
         * @param {string} applicationId Application ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplicationEnvironmentVariableOverride(applicationId: string, environmentVariableId: string, value?: Value, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplicationEnvironmentVariableOverride(applicationId, environmentVariableId, value, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationEnvironmentVariableApi.createApplicationEnvironmentVariableOverride']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - To delete an environment variable from an application you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete an environment variable from an application
         * @param {string} applicationId Application ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApplicationEnvironmentVariable(applicationId: string, environmentVariableId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApplicationEnvironmentVariable(applicationId, environmentVariableId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationEnvironmentVariableApi.deleteApplicationEnvironmentVariable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit an environment variable belonging to the application
         * @param {string} applicationId Application ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editApplicationEnvironmentVariable(applicationId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editApplicationEnvironmentVariable(applicationId, environmentVariableId, environmentVariableEditRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationEnvironmentVariableApi.editApplicationEnvironmentVariable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Import environment variables in a defined scope, with a defined visibility.
         * @summary Import variables
         * @param {string} applicationId Application ID
         * @param {VariableImportRequest} [variableImportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importEnvironmentVariable(applicationId: string, variableImportRequest?: VariableImportRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariableImport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importEnvironmentVariable(applicationId, variableImportRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationEnvironmentVariableApi.importEnvironmentVariable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List environment variables
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplicationEnvironmentVariable(applicationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariableResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplicationEnvironmentVariable(applicationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationEnvironmentVariableApi.listApplicationEnvironmentVariable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ApplicationEnvironmentVariableApi - factory interface
 * @export
 */
export const ApplicationEnvironmentVariableApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationEnvironmentVariableApiFp(configuration)
    return {
        /**
         * - Add an environment variable to the application. 
         * @summary Add an environment variable to the application
         * @param {string} applicationId Application ID
         * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationEnvironmentVariable(applicationId: string, environmentVariableRequest?: EnvironmentVariableRequest, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentVariable> {
            return localVarFp.createApplicationEnvironmentVariable(applicationId, environmentVariableRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to add an alias at application level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at application level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - You can\'t create an alias on an alias 
         * @summary Create an environment variable alias at the application level
         * @param {string} applicationId Application ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationEnvironmentVariableAlias(applicationId: string, environmentVariableId: string, key?: Key, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentVariable> {
            return localVarFp.createApplicationEnvironmentVariableAlias(applicationId, environmentVariableId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to override at application level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at application level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
         * @summary Create an environment variable override at the application level
         * @param {string} applicationId Application ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationEnvironmentVariableOverride(applicationId: string, environmentVariableId: string, value?: Value, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentVariable> {
            return localVarFp.createApplicationEnvironmentVariableOverride(applicationId, environmentVariableId, value, options).then((request) => request(axios, basePath));
        },
        /**
         * - To delete an environment variable from an application you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete an environment variable from an application
         * @param {string} applicationId Application ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationEnvironmentVariable(applicationId: string, environmentVariableId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteApplicationEnvironmentVariable(applicationId, environmentVariableId, options).then((request) => request(axios, basePath));
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit an environment variable belonging to the application
         * @param {string} applicationId Application ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editApplicationEnvironmentVariable(applicationId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentVariable> {
            return localVarFp.editApplicationEnvironmentVariable(applicationId, environmentVariableId, environmentVariableEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Import environment variables in a defined scope, with a defined visibility.
         * @summary Import variables
         * @param {string} applicationId Application ID
         * @param {VariableImportRequest} [variableImportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importEnvironmentVariable(applicationId: string, variableImportRequest?: VariableImportRequest, options?: RawAxiosRequestConfig): AxiosPromise<VariableImport> {
            return localVarFp.importEnvironmentVariable(applicationId, variableImportRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List environment variables
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationEnvironmentVariable(applicationId: string, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentVariableResponseList> {
            return localVarFp.listApplicationEnvironmentVariable(applicationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationEnvironmentVariableApi - object-oriented interface
 * @export
 * @class ApplicationEnvironmentVariableApi
 * @extends {BaseAPI}
 */
export class ApplicationEnvironmentVariableApi extends BaseAPI {
    /**
     * - Add an environment variable to the application. 
     * @summary Add an environment variable to the application
     * @param {string} applicationId Application ID
     * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationEnvironmentVariableApi
     */
    public createApplicationEnvironmentVariable(applicationId: string, environmentVariableRequest?: EnvironmentVariableRequest, options?: RawAxiosRequestConfig) {
        return ApplicationEnvironmentVariableApiFp(this.configuration).createApplicationEnvironmentVariable(applicationId, environmentVariableRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to add an alias at application level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at application level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - You can\'t create an alias on an alias 
     * @summary Create an environment variable alias at the application level
     * @param {string} applicationId Application ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {Key} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationEnvironmentVariableApi
     */
    public createApplicationEnvironmentVariableAlias(applicationId: string, environmentVariableId: string, key?: Key, options?: RawAxiosRequestConfig) {
        return ApplicationEnvironmentVariableApiFp(this.configuration).createApplicationEnvironmentVariableAlias(applicationId, environmentVariableId, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to override at application level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at application level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
     * @summary Create an environment variable override at the application level
     * @param {string} applicationId Application ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {Value} [value] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationEnvironmentVariableApi
     */
    public createApplicationEnvironmentVariableOverride(applicationId: string, environmentVariableId: string, value?: Value, options?: RawAxiosRequestConfig) {
        return ApplicationEnvironmentVariableApiFp(this.configuration).createApplicationEnvironmentVariableOverride(applicationId, environmentVariableId, value, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - To delete an environment variable from an application you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
     * @summary Delete an environment variable from an application
     * @param {string} applicationId Application ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationEnvironmentVariableApi
     */
    public deleteApplicationEnvironmentVariable(applicationId: string, environmentVariableId: string, options?: RawAxiosRequestConfig) {
        return ApplicationEnvironmentVariableApiFp(this.configuration).deleteApplicationEnvironmentVariable(applicationId, environmentVariableId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
     * @summary Edit an environment variable belonging to the application
     * @param {string} applicationId Application ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationEnvironmentVariableApi
     */
    public editApplicationEnvironmentVariable(applicationId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options?: RawAxiosRequestConfig) {
        return ApplicationEnvironmentVariableApiFp(this.configuration).editApplicationEnvironmentVariable(applicationId, environmentVariableId, environmentVariableEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Import environment variables in a defined scope, with a defined visibility.
     * @summary Import variables
     * @param {string} applicationId Application ID
     * @param {VariableImportRequest} [variableImportRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationEnvironmentVariableApi
     */
    public importEnvironmentVariable(applicationId: string, variableImportRequest?: VariableImportRequest, options?: RawAxiosRequestConfig) {
        return ApplicationEnvironmentVariableApiFp(this.configuration).importEnvironmentVariable(applicationId, variableImportRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List environment variables
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationEnvironmentVariableApi
     */
    public listApplicationEnvironmentVariable(applicationId: string, options?: RawAxiosRequestConfig) {
        return ApplicationEnvironmentVariableApiFp(this.configuration).listApplicationEnvironmentVariable(applicationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ApplicationLogsApi - axios parameter creator
 * @export
 */
export const ApplicationLogsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This will list the last 1000 logs of the application
         * @summary List logs
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationLog: async (applicationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('listApplicationLog', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/log`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationLogsApi - functional programming interface
 * @export
 */
export const ApplicationLogsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationLogsApiAxiosParamCreator(configuration)
    return {
        /**
         * This will list the last 1000 logs of the application
         * @summary List logs
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplicationLog(applicationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplicationLog(applicationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationLogsApi.listApplicationLog']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ApplicationLogsApi - factory interface
 * @export
 */
export const ApplicationLogsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationLogsApiFp(configuration)
    return {
        /**
         * This will list the last 1000 logs of the application
         * @summary List logs
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationLog(applicationId: string, options?: RawAxiosRequestConfig): AxiosPromise<LogResponseList> {
            return localVarFp.listApplicationLog(applicationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationLogsApi - object-oriented interface
 * @export
 * @class ApplicationLogsApi
 * @extends {BaseAPI}
 */
export class ApplicationLogsApi extends BaseAPI {
    /**
     * This will list the last 1000 logs of the application
     * @summary List logs
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationLogsApi
     */
    public listApplicationLog(applicationId: string, options?: RawAxiosRequestConfig) {
        return ApplicationLogsApiFp(this.configuration).listApplicationLog(applicationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ApplicationMainCallsApi - axios parameter creator
 * @export
 */
export const ApplicationMainCallsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * To delete the application you must have the admin permission
         * @summary Delete application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplication: async (applicationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('deleteApplication', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - To edit the application you must have the admin permission. - For port edition, if you provide a port id, we will update the corresponding port. If you don\'t we will create a new one. If you remove a port from the payload, we will delete it. - For storage edition, if you provide a storage id, we will update the corresponding storage. If you don\'t we will create a new one. If you remove a storage from the payload, we will delete it. 
         * @summary Edit application
         * @param {string} applicationId Application ID
         * @param {ApplicationEditRequest} [applicationEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editApplication: async (applicationId: string, applicationEditRequest?: ApplicationEditRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('editApplication', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(applicationEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get application by ID
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplication: async (applicationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getApplication', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get application status
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationStatus: async (applicationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getApplicationStatus', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/status`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns list of the last 100 commits made on the repository linked to the application
         * @summary List last commits
         * @param {string} applicationId Application ID
         * @param {string} [startId] Starting point after which to return results
         * @param {string} [gitCommitId] Git Commit ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationCommit: async (applicationId: string, startId?: string, gitCommitId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('listApplicationCommit', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/commit`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (startId !== undefined) {
                localVarQueryParameter['startId'] = startId;
            }

            if (gitCommitId !== undefined) {
                localVarQueryParameter['gitCommitId'] = gitCommitId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List contributors
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationContributor: async (applicationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('listApplicationContributor', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/contributor`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This will return all the custom domains and Qovery autogenerated domain for the given application
         * @summary List all URLs of the application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationLinks: async (applicationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('listApplicationLinks', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/link`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationMainCallsApi - functional programming interface
 * @export
 */
export const ApplicationMainCallsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationMainCallsApiAxiosParamCreator(configuration)
    return {
        /**
         * To delete the application you must have the admin permission
         * @summary Delete application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApplication(applicationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApplication(applicationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationMainCallsApi.deleteApplication']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - To edit the application you must have the admin permission. - For port edition, if you provide a port id, we will update the corresponding port. If you don\'t we will create a new one. If you remove a port from the payload, we will delete it. - For storage edition, if you provide a storage id, we will update the corresponding storage. If you don\'t we will create a new one. If you remove a storage from the payload, we will delete it. 
         * @summary Edit application
         * @param {string} applicationId Application ID
         * @param {ApplicationEditRequest} [applicationEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editApplication(applicationId: string, applicationEditRequest?: ApplicationEditRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Application>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editApplication(applicationId, applicationEditRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationMainCallsApi.editApplication']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get application by ID
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplication(applicationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Application>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplication(applicationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationMainCallsApi.getApplication']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get application status
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationStatus(applicationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationStatus(applicationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationMainCallsApi.getApplicationStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns list of the last 100 commits made on the repository linked to the application
         * @summary List last commits
         * @param {string} applicationId Application ID
         * @param {string} [startId] Starting point after which to return results
         * @param {string} [gitCommitId] Git Commit ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplicationCommit(applicationId: string, startId?: string, gitCommitId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommitResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplicationCommit(applicationId, startId, gitCommitId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationMainCallsApi.listApplicationCommit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List contributors
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplicationContributor(applicationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplicationContributor(applicationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationMainCallsApi.listApplicationContributor']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This will return all the custom domains and Qovery autogenerated domain for the given application
         * @summary List all URLs of the application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplicationLinks(applicationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplicationLinks(applicationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationMainCallsApi.listApplicationLinks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ApplicationMainCallsApi - factory interface
 * @export
 */
export const ApplicationMainCallsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationMainCallsApiFp(configuration)
    return {
        /**
         * To delete the application you must have the admin permission
         * @summary Delete application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplication(applicationId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteApplication(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * - To edit the application you must have the admin permission. - For port edition, if you provide a port id, we will update the corresponding port. If you don\'t we will create a new one. If you remove a port from the payload, we will delete it. - For storage edition, if you provide a storage id, we will update the corresponding storage. If you don\'t we will create a new one. If you remove a storage from the payload, we will delete it. 
         * @summary Edit application
         * @param {string} applicationId Application ID
         * @param {ApplicationEditRequest} [applicationEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editApplication(applicationId: string, applicationEditRequest?: ApplicationEditRequest, options?: RawAxiosRequestConfig): AxiosPromise<Application> {
            return localVarFp.editApplication(applicationId, applicationEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get application by ID
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplication(applicationId: string, options?: RawAxiosRequestConfig): AxiosPromise<Application> {
            return localVarFp.getApplication(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get application status
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationStatus(applicationId: string, options?: RawAxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.getApplicationStatus(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns list of the last 100 commits made on the repository linked to the application
         * @summary List last commits
         * @param {string} applicationId Application ID
         * @param {string} [startId] Starting point after which to return results
         * @param {string} [gitCommitId] Git Commit ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationCommit(applicationId: string, startId?: string, gitCommitId?: string, options?: RawAxiosRequestConfig): AxiosPromise<CommitResponseList> {
            return localVarFp.listApplicationCommit(applicationId, startId, gitCommitId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List contributors
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationContributor(applicationId: string, options?: RawAxiosRequestConfig): AxiosPromise<UserResponseList> {
            return localVarFp.listApplicationContributor(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * This will return all the custom domains and Qovery autogenerated domain for the given application
         * @summary List all URLs of the application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationLinks(applicationId: string, options?: RawAxiosRequestConfig): AxiosPromise<LinkResponseList> {
            return localVarFp.listApplicationLinks(applicationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationMainCallsApi - object-oriented interface
 * @export
 * @class ApplicationMainCallsApi
 * @extends {BaseAPI}
 */
export class ApplicationMainCallsApi extends BaseAPI {
    /**
     * To delete the application you must have the admin permission
     * @summary Delete application
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationMainCallsApi
     */
    public deleteApplication(applicationId: string, options?: RawAxiosRequestConfig) {
        return ApplicationMainCallsApiFp(this.configuration).deleteApplication(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - To edit the application you must have the admin permission. - For port edition, if you provide a port id, we will update the corresponding port. If you don\'t we will create a new one. If you remove a port from the payload, we will delete it. - For storage edition, if you provide a storage id, we will update the corresponding storage. If you don\'t we will create a new one. If you remove a storage from the payload, we will delete it. 
     * @summary Edit application
     * @param {string} applicationId Application ID
     * @param {ApplicationEditRequest} [applicationEditRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationMainCallsApi
     */
    public editApplication(applicationId: string, applicationEditRequest?: ApplicationEditRequest, options?: RawAxiosRequestConfig) {
        return ApplicationMainCallsApiFp(this.configuration).editApplication(applicationId, applicationEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get application by ID
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationMainCallsApi
     */
    public getApplication(applicationId: string, options?: RawAxiosRequestConfig) {
        return ApplicationMainCallsApiFp(this.configuration).getApplication(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get application status
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationMainCallsApi
     */
    public getApplicationStatus(applicationId: string, options?: RawAxiosRequestConfig) {
        return ApplicationMainCallsApiFp(this.configuration).getApplicationStatus(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns list of the last 100 commits made on the repository linked to the application
     * @summary List last commits
     * @param {string} applicationId Application ID
     * @param {string} [startId] Starting point after which to return results
     * @param {string} [gitCommitId] Git Commit ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationMainCallsApi
     */
    public listApplicationCommit(applicationId: string, startId?: string, gitCommitId?: string, options?: RawAxiosRequestConfig) {
        return ApplicationMainCallsApiFp(this.configuration).listApplicationCommit(applicationId, startId, gitCommitId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List contributors
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationMainCallsApi
     */
    public listApplicationContributor(applicationId: string, options?: RawAxiosRequestConfig) {
        return ApplicationMainCallsApiFp(this.configuration).listApplicationContributor(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will return all the custom domains and Qovery autogenerated domain for the given application
     * @summary List all URLs of the application
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationMainCallsApi
     */
    public listApplicationLinks(applicationId: string, options?: RawAxiosRequestConfig) {
        return ApplicationMainCallsApiFp(this.configuration).listApplicationLinks(applicationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ApplicationSecretApi - axios parameter creator
 * @export
 */
export const ApplicationSecretApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * - Add a secret to the application. 
         * @summary Add a secret to the application
         * @param {string} applicationId Application ID
         * @param {SecretRequest} [secretRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationSecret: async (applicationId: string, secretRequest?: SecretRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('createApplicationSecret', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/secret`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(secretRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to add an alias at application level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at application level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - You can\'t create an alias on an alias 
         * @summary Create a secret alias at the application level
         * @param {string} applicationId Application ID
         * @param {string} secretId Secret ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationSecretAlias: async (applicationId: string, secretId: string, key?: Key, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('createApplicationSecretAlias', 'applicationId', applicationId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('createApplicationSecretAlias', 'secretId', secretId)
            const localVarPath = `/application/{applicationId}/secret/{secretId}/alias`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(key, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to override at application level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at application level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
         * @summary Create a secret override at the application level
         * @param {string} applicationId Application ID
         * @param {string} secretId Secret ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationSecretOverride: async (applicationId: string, secretId: string, value?: Value, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('createApplicationSecretOverride', 'applicationId', applicationId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('createApplicationSecretOverride', 'secretId', secretId)
            const localVarPath = `/application/{applicationId}/secret/{secretId}/override`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(value, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete a secret from an application
         * @param {string} applicationId Application ID
         * @param {string} secretId Secret ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationSecret: async (applicationId: string, secretId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('deleteApplicationSecret', 'applicationId', applicationId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('deleteApplicationSecret', 'secretId', secretId)
            const localVarPath = `/application/{applicationId}/secret/{secretId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit a secret belonging to the application
         * @param {string} applicationId Application ID
         * @param {string} secretId Secret ID
         * @param {SecretEditRequest} secretEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editApplicationSecret: async (applicationId: string, secretId: string, secretEditRequest: SecretEditRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('editApplicationSecret', 'applicationId', applicationId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('editApplicationSecret', 'secretId', secretId)
            // verify required parameter 'secretEditRequest' is not null or undefined
            assertParamExists('editApplicationSecret', 'secretEditRequest', secretEditRequest)
            const localVarPath = `/application/{applicationId}/secret/{secretId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(secretEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Secrets are like environment variables, but they are secured and can\'t be revealed.
         * @summary List application secrets
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationSecrets: async (applicationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('listApplicationSecrets', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/secret`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationSecretApi - functional programming interface
 * @export
 */
export const ApplicationSecretApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationSecretApiAxiosParamCreator(configuration)
    return {
        /**
         * - Add a secret to the application. 
         * @summary Add a secret to the application
         * @param {string} applicationId Application ID
         * @param {SecretRequest} [secretRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplicationSecret(applicationId: string, secretRequest?: SecretRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplicationSecret(applicationId, secretRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationSecretApi.createApplicationSecret']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - Allows you to add an alias at application level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at application level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - You can\'t create an alias on an alias 
         * @summary Create a secret alias at the application level
         * @param {string} applicationId Application ID
         * @param {string} secretId Secret ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplicationSecretAlias(applicationId: string, secretId: string, key?: Key, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplicationSecretAlias(applicationId, secretId, key, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationSecretApi.createApplicationSecretAlias']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - Allows you to override at application level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at application level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
         * @summary Create a secret override at the application level
         * @param {string} applicationId Application ID
         * @param {string} secretId Secret ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplicationSecretOverride(applicationId: string, secretId: string, value?: Value, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplicationSecretOverride(applicationId, secretId, value, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationSecretApi.createApplicationSecretOverride']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete a secret from an application
         * @param {string} applicationId Application ID
         * @param {string} secretId Secret ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApplicationSecret(applicationId: string, secretId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApplicationSecret(applicationId, secretId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationSecretApi.deleteApplicationSecret']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit a secret belonging to the application
         * @param {string} applicationId Application ID
         * @param {string} secretId Secret ID
         * @param {SecretEditRequest} secretEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editApplicationSecret(applicationId: string, secretId: string, secretEditRequest: SecretEditRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editApplicationSecret(applicationId, secretId, secretEditRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationSecretApi.editApplicationSecret']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Secrets are like environment variables, but they are secured and can\'t be revealed.
         * @summary List application secrets
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplicationSecrets(applicationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecretResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplicationSecrets(applicationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationSecretApi.listApplicationSecrets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ApplicationSecretApi - factory interface
 * @export
 */
export const ApplicationSecretApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationSecretApiFp(configuration)
    return {
        /**
         * - Add a secret to the application. 
         * @summary Add a secret to the application
         * @param {string} applicationId Application ID
         * @param {SecretRequest} [secretRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationSecret(applicationId: string, secretRequest?: SecretRequest, options?: RawAxiosRequestConfig): AxiosPromise<Secret> {
            return localVarFp.createApplicationSecret(applicationId, secretRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to add an alias at application level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at application level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - You can\'t create an alias on an alias 
         * @summary Create a secret alias at the application level
         * @param {string} applicationId Application ID
         * @param {string} secretId Secret ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationSecretAlias(applicationId: string, secretId: string, key?: Key, options?: RawAxiosRequestConfig): AxiosPromise<Secret> {
            return localVarFp.createApplicationSecretAlias(applicationId, secretId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to override at application level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at application level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
         * @summary Create a secret override at the application level
         * @param {string} applicationId Application ID
         * @param {string} secretId Secret ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationSecretOverride(applicationId: string, secretId: string, value?: Value, options?: RawAxiosRequestConfig): AxiosPromise<Secret> {
            return localVarFp.createApplicationSecretOverride(applicationId, secretId, value, options).then((request) => request(axios, basePath));
        },
        /**
         * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete a secret from an application
         * @param {string} applicationId Application ID
         * @param {string} secretId Secret ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationSecret(applicationId: string, secretId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteApplicationSecret(applicationId, secretId, options).then((request) => request(axios, basePath));
        },
        /**
         * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit a secret belonging to the application
         * @param {string} applicationId Application ID
         * @param {string} secretId Secret ID
         * @param {SecretEditRequest} secretEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editApplicationSecret(applicationId: string, secretId: string, secretEditRequest: SecretEditRequest, options?: RawAxiosRequestConfig): AxiosPromise<Secret> {
            return localVarFp.editApplicationSecret(applicationId, secretId, secretEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Secrets are like environment variables, but they are secured and can\'t be revealed.
         * @summary List application secrets
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationSecrets(applicationId: string, options?: RawAxiosRequestConfig): AxiosPromise<SecretResponseList> {
            return localVarFp.listApplicationSecrets(applicationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationSecretApi - object-oriented interface
 * @export
 * @class ApplicationSecretApi
 * @extends {BaseAPI}
 */
export class ApplicationSecretApi extends BaseAPI {
    /**
     * - Add a secret to the application. 
     * @summary Add a secret to the application
     * @param {string} applicationId Application ID
     * @param {SecretRequest} [secretRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationSecretApi
     */
    public createApplicationSecret(applicationId: string, secretRequest?: SecretRequest, options?: RawAxiosRequestConfig) {
        return ApplicationSecretApiFp(this.configuration).createApplicationSecret(applicationId, secretRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to add an alias at application level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at application level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - You can\'t create an alias on an alias 
     * @summary Create a secret alias at the application level
     * @param {string} applicationId Application ID
     * @param {string} secretId Secret ID
     * @param {Key} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationSecretApi
     */
    public createApplicationSecretAlias(applicationId: string, secretId: string, key?: Key, options?: RawAxiosRequestConfig) {
        return ApplicationSecretApiFp(this.configuration).createApplicationSecretAlias(applicationId, secretId, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to override at application level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at application level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
     * @summary Create a secret override at the application level
     * @param {string} applicationId Application ID
     * @param {string} secretId Secret ID
     * @param {Value} [value] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationSecretApi
     */
    public createApplicationSecretOverride(applicationId: string, secretId: string, value?: Value, options?: RawAxiosRequestConfig) {
        return ApplicationSecretApiFp(this.configuration).createApplicationSecretOverride(applicationId, secretId, value, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well 
     * @summary Delete a secret from an application
     * @param {string} applicationId Application ID
     * @param {string} secretId Secret ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationSecretApi
     */
    public deleteApplicationSecret(applicationId: string, secretId: string, options?: RawAxiosRequestConfig) {
        return ApplicationSecretApiFp(this.configuration).deleteApplicationSecret(applicationId, secretId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
     * @summary Edit a secret belonging to the application
     * @param {string} applicationId Application ID
     * @param {string} secretId Secret ID
     * @param {SecretEditRequest} secretEditRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationSecretApi
     */
    public editApplicationSecret(applicationId: string, secretId: string, secretEditRequest: SecretEditRequest, options?: RawAxiosRequestConfig) {
        return ApplicationSecretApiFp(this.configuration).editApplicationSecret(applicationId, secretId, secretEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Secrets are like environment variables, but they are secured and can\'t be revealed.
     * @summary List application secrets
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationSecretApi
     */
    public listApplicationSecrets(applicationId: string, options?: RawAxiosRequestConfig) {
        return ApplicationSecretApiFp(this.configuration).listApplicationSecrets(applicationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ApplicationsApi - axios parameter creator
 * @export
 */
export const ApplicationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This will create a new application with the same configuration on the targeted environment Id.
         * @summary Clone application
         * @param {string} applicationId Application ID
         * @param {CloneServiceRequest} [cloneServiceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneApplication: async (applicationId: string, cloneServiceRequest?: CloneServiceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('cloneApplication', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/clone`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloneServiceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an application
         * @param {string} environmentId Environment ID
         * @param {ApplicationRequest} [applicationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplication: async (environmentId: string, applicationRequest?: ApplicationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('createApplication', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/application`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(applicationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Default values for each setting are available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/advanced-settings/)
         * @summary List default application advanced settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultApplicationAdvancedSettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/defaultApplicationAdvancedSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of applications with only their id and status.
         * @summary List all environment applications statuses
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentApplicationStatus: async (environmentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('getEnvironmentApplicationStatus', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/application/status`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List applications
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplication: async (environmentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('listApplication', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/application`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationsApi - functional programming interface
 * @export
 */
export const ApplicationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationsApiAxiosParamCreator(configuration)
    return {
        /**
         * This will create a new application with the same configuration on the targeted environment Id.
         * @summary Clone application
         * @param {string} applicationId Application ID
         * @param {CloneServiceRequest} [cloneServiceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloneApplication(applicationId: string, cloneServiceRequest?: CloneServiceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Application>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cloneApplication(applicationId, cloneServiceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.cloneApplication']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create an application
         * @param {string} environmentId Environment ID
         * @param {ApplicationRequest} [applicationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplication(environmentId: string, applicationRequest?: ApplicationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Application>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplication(environmentId, applicationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.createApplication']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Default values for each setting are available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/advanced-settings/)
         * @summary List default application advanced settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDefaultApplicationAdvancedSettings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationAdvancedSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDefaultApplicationAdvancedSettings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.getDefaultApplicationAdvancedSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of applications with only their id and status.
         * @summary List all environment applications statuses
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironmentApplicationStatus(environmentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReferenceObjectStatusResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironmentApplicationStatus(environmentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.getEnvironmentApplicationStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List applications
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplication(environmentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplication(environmentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.listApplication']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ApplicationsApi - factory interface
 * @export
 */
export const ApplicationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationsApiFp(configuration)
    return {
        /**
         * This will create a new application with the same configuration on the targeted environment Id.
         * @summary Clone application
         * @param {string} applicationId Application ID
         * @param {CloneServiceRequest} [cloneServiceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneApplication(applicationId: string, cloneServiceRequest?: CloneServiceRequest, options?: RawAxiosRequestConfig): AxiosPromise<Application> {
            return localVarFp.cloneApplication(applicationId, cloneServiceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create an application
         * @param {string} environmentId Environment ID
         * @param {ApplicationRequest} [applicationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplication(environmentId: string, applicationRequest?: ApplicationRequest, options?: RawAxiosRequestConfig): AxiosPromise<Application> {
            return localVarFp.createApplication(environmentId, applicationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Default values for each setting are available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/advanced-settings/)
         * @summary List default application advanced settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultApplicationAdvancedSettings(options?: RawAxiosRequestConfig): AxiosPromise<ApplicationAdvancedSettings> {
            return localVarFp.getDefaultApplicationAdvancedSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of applications with only their id and status.
         * @summary List all environment applications statuses
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentApplicationStatus(environmentId: string, options?: RawAxiosRequestConfig): AxiosPromise<ReferenceObjectStatusResponseList> {
            return localVarFp.getEnvironmentApplicationStatus(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List applications
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplication(environmentId: string, options?: RawAxiosRequestConfig): AxiosPromise<ApplicationResponseList> {
            return localVarFp.listApplication(environmentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationsApi - object-oriented interface
 * @export
 * @class ApplicationsApi
 * @extends {BaseAPI}
 */
export class ApplicationsApi extends BaseAPI {
    /**
     * This will create a new application with the same configuration on the targeted environment Id.
     * @summary Clone application
     * @param {string} applicationId Application ID
     * @param {CloneServiceRequest} [cloneServiceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public cloneApplication(applicationId: string, cloneServiceRequest?: CloneServiceRequest, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).cloneApplication(applicationId, cloneServiceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create an application
     * @param {string} environmentId Environment ID
     * @param {ApplicationRequest} [applicationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public createApplication(environmentId: string, applicationRequest?: ApplicationRequest, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).createApplication(environmentId, applicationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Default values for each setting are available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/advanced-settings/)
     * @summary List default application advanced settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public getDefaultApplicationAdvancedSettings(options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).getDefaultApplicationAdvancedSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of applications with only their id and status.
     * @summary List all environment applications statuses
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public getEnvironmentApplicationStatus(environmentId: string, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).getEnvironmentApplicationStatus(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List applications
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public listApplication(environmentId: string, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).listApplication(environmentId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AutoscalingPolicyApi - axios parameter creator
 * @export
 */
export const AutoscalingPolicyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createOrUpdateServiceAutoscaling
         * @param {string} serviceId Service ID of an application/job/container/database
         * @param {AutoscalingPolicyRequest} [autoscalingPolicyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateServiceAutoscaling: async (serviceId: string, autoscalingPolicyRequest?: AutoscalingPolicyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('createOrUpdateServiceAutoscaling', 'serviceId', serviceId)
            const localVarPath = `/service/{serviceId}/autoscalingPolicy`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(autoscalingPolicyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteServiceAutoscaling
         * @param {string} serviceId Service ID of an application/job/container/database
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteServiceAutoscaling: async (serviceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('deleteServiceAutoscaling', 'serviceId', serviceId)
            const localVarPath = `/service/{serviceId}/autoscalingPolicy`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getServiceAutoscaling
         * @param {string} serviceId Service ID of an application/job/container/database
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceAutoscaling: async (serviceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('getServiceAutoscaling', 'serviceId', serviceId)
            const localVarPath = `/service/{serviceId}/autoscalingPolicy`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AutoscalingPolicyApi - functional programming interface
 * @export
 */
export const AutoscalingPolicyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AutoscalingPolicyApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary createOrUpdateServiceAutoscaling
         * @param {string} serviceId Service ID of an application/job/container/database
         * @param {AutoscalingPolicyRequest} [autoscalingPolicyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrUpdateServiceAutoscaling(serviceId: string, autoscalingPolicyRequest?: AutoscalingPolicyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutoscalingPolicyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrUpdateServiceAutoscaling(serviceId, autoscalingPolicyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AutoscalingPolicyApi.createOrUpdateServiceAutoscaling']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary deleteServiceAutoscaling
         * @param {string} serviceId Service ID of an application/job/container/database
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteServiceAutoscaling(serviceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteServiceAutoscaling(serviceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AutoscalingPolicyApi.deleteServiceAutoscaling']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getServiceAutoscaling
         * @param {string} serviceId Service ID of an application/job/container/database
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceAutoscaling(serviceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutoscalingPolicyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceAutoscaling(serviceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AutoscalingPolicyApi.getServiceAutoscaling']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AutoscalingPolicyApi - factory interface
 * @export
 */
export const AutoscalingPolicyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AutoscalingPolicyApiFp(configuration)
    return {
        /**
         * 
         * @summary createOrUpdateServiceAutoscaling
         * @param {string} serviceId Service ID of an application/job/container/database
         * @param {AutoscalingPolicyRequest} [autoscalingPolicyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateServiceAutoscaling(serviceId: string, autoscalingPolicyRequest?: AutoscalingPolicyRequest, options?: RawAxiosRequestConfig): AxiosPromise<AutoscalingPolicyResponse> {
            return localVarFp.createOrUpdateServiceAutoscaling(serviceId, autoscalingPolicyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deleteServiceAutoscaling
         * @param {string} serviceId Service ID of an application/job/container/database
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteServiceAutoscaling(serviceId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteServiceAutoscaling(serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getServiceAutoscaling
         * @param {string} serviceId Service ID of an application/job/container/database
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceAutoscaling(serviceId: string, options?: RawAxiosRequestConfig): AxiosPromise<AutoscalingPolicyResponse> {
            return localVarFp.getServiceAutoscaling(serviceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AutoscalingPolicyApi - object-oriented interface
 * @export
 * @class AutoscalingPolicyApi
 * @extends {BaseAPI}
 */
export class AutoscalingPolicyApi extends BaseAPI {
    /**
     * 
     * @summary createOrUpdateServiceAutoscaling
     * @param {string} serviceId Service ID of an application/job/container/database
     * @param {AutoscalingPolicyRequest} [autoscalingPolicyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoscalingPolicyApi
     */
    public createOrUpdateServiceAutoscaling(serviceId: string, autoscalingPolicyRequest?: AutoscalingPolicyRequest, options?: RawAxiosRequestConfig) {
        return AutoscalingPolicyApiFp(this.configuration).createOrUpdateServiceAutoscaling(serviceId, autoscalingPolicyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deleteServiceAutoscaling
     * @param {string} serviceId Service ID of an application/job/container/database
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoscalingPolicyApi
     */
    public deleteServiceAutoscaling(serviceId: string, options?: RawAxiosRequestConfig) {
        return AutoscalingPolicyApiFp(this.configuration).deleteServiceAutoscaling(serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getServiceAutoscaling
     * @param {string} serviceId Service ID of an application/job/container/database
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoscalingPolicyApi
     */
    public getServiceAutoscaling(serviceId: string, options?: RawAxiosRequestConfig) {
        return AutoscalingPolicyApiFp(this.configuration).getServiceAutoscaling(serviceId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BackupsApi - axios parameter creator
 * @export
 */
export const BackupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a backup to the Database 
         * @param {string} databaseId Database ID
         * @param {BackupRequest} [backupRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addBackupDatabase: async (databaseId: string, backupRequest?: BackupRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('addBackupDatabase', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}/backup`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(backupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter
         * @summary List database  backups
         * @param {string} databaseId Database ID
         * @param {string} [startId] Starting point after which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseBackup: async (databaseId: string, startId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('listDatabaseBackup', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}/backup`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (startId !== undefined) {
                localVarQueryParameter['startId'] = startId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove database  backup
         * @param {string} databaseId Database ID
         * @param {string} backupId Database Backup ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDatabaseBackup: async (databaseId: string, backupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('removeDatabaseBackup', 'databaseId', databaseId)
            // verify required parameter 'backupId' is not null or undefined
            assertParamExists('removeDatabaseBackup', 'backupId', backupId)
            const localVarPath = `/database/{databaseId}/backup/{backupId}`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)))
                .replace(`{${"backupId"}}`, encodeURIComponent(String(backupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BackupsApi - functional programming interface
 * @export
 */
export const BackupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BackupsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a backup to the Database 
         * @param {string} databaseId Database ID
         * @param {BackupRequest} [backupRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addBackupDatabase(databaseId: string, backupRequest?: BackupRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Backup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addBackupDatabase(databaseId, backupRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BackupsApi.addBackupDatabase']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter
         * @summary List database  backups
         * @param {string} databaseId Database ID
         * @param {string} [startId] Starting point after which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDatabaseBackup(databaseId: string, startId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BackupPaginatedResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDatabaseBackup(databaseId, startId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BackupsApi.listDatabaseBackup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove database  backup
         * @param {string} databaseId Database ID
         * @param {string} backupId Database Backup ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeDatabaseBackup(databaseId: string, backupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeDatabaseBackup(databaseId, backupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BackupsApi.removeDatabaseBackup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BackupsApi - factory interface
 * @export
 */
export const BackupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BackupsApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a backup to the Database 
         * @param {string} databaseId Database ID
         * @param {BackupRequest} [backupRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addBackupDatabase(databaseId: string, backupRequest?: BackupRequest, options?: RawAxiosRequestConfig): AxiosPromise<Backup> {
            return localVarFp.addBackupDatabase(databaseId, backupRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter
         * @summary List database  backups
         * @param {string} databaseId Database ID
         * @param {string} [startId] Starting point after which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseBackup(databaseId: string, startId?: string, options?: RawAxiosRequestConfig): AxiosPromise<BackupPaginatedResponseList> {
            return localVarFp.listDatabaseBackup(databaseId, startId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove database  backup
         * @param {string} databaseId Database ID
         * @param {string} backupId Database Backup ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDatabaseBackup(databaseId: string, backupId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.removeDatabaseBackup(databaseId, backupId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BackupsApi - object-oriented interface
 * @export
 * @class BackupsApi
 * @extends {BaseAPI}
 */
export class BackupsApi extends BaseAPI {
    /**
     * 
     * @summary Add a backup to the Database 
     * @param {string} databaseId Database ID
     * @param {BackupRequest} [backupRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackupsApi
     */
    public addBackupDatabase(databaseId: string, backupRequest?: BackupRequest, options?: RawAxiosRequestConfig) {
        return BackupsApiFp(this.configuration).addBackupDatabase(databaseId, backupRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter
     * @summary List database  backups
     * @param {string} databaseId Database ID
     * @param {string} [startId] Starting point after which to return results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackupsApi
     */
    public listDatabaseBackup(databaseId: string, startId?: string, options?: RawAxiosRequestConfig) {
        return BackupsApiFp(this.configuration).listDatabaseBackup(databaseId, startId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove database  backup
     * @param {string} databaseId Database ID
     * @param {string} backupId Database Backup ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackupsApi
     */
    public removeDatabaseBackup(databaseId: string, backupId: string, options?: RawAxiosRequestConfig) {
        return BackupsApiFp(this.configuration).removeDatabaseBackup(databaseId, backupId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BillingApi - axios parameter creator
 * @export
 */
export const BillingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add credit card
         * @param {string} organizationId Organization ID
         * @param {CreditCardRequest} [creditCardRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCreditCard: async (organizationId: string, creditCardRequest?: CreditCardRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('addCreditCard', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/creditCard`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(creditCardRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add credit code
         * @param {string} organizationId Organization ID
         * @param {OrganizationCreditCodeRequest} [organizationCreditCodeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCreditCode: async (organizationId: string, organizationCreditCodeRequest?: OrganizationCreditCodeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('addCreditCode', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/creditCode`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationCreditCodeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Change organization plan
         * @param {string} organizationId Organization ID
         * @param {OrganizationChangePlanRequest} [organizationChangePlanRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePlan: async (organizationId: string, organizationChangePlanRequest?: OrganizationChangePlanRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('changePlan', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/changePlan`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationChangePlanRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete credit card
         * @param {string} organizationId Organization ID
         * @param {string} creditCardId Credit Card ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCreditCard: async (organizationId: string, creditCardId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteCreditCard', 'organizationId', organizationId)
            // verify required parameter 'creditCardId' is not null or undefined
            assertParamExists('deleteCreditCard', 'creditCardId', creditCardId)
            const localVarPath = `/organization/{organizationId}/creditCard/{creditCardId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"creditCardId"}}`, encodeURIComponent(String(creditCardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit Organization Billing Info
         * @param {string} organizationId Organization ID
         * @param {BillingInfoRequest} [billingInfoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editOrganizationBillingInfo: async (organizationId: string, billingInfoRequest?: BillingInfoRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('editOrganizationBillingInfo', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/billingInfo`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(billingInfoRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generate organization billing usage report
         * @param {string} organizationId Organization ID
         * @param {OrganizationBillingUsageReportRequest} [organizationBillingUsageReportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateBillingUsageReport: async (organizationId: string, organizationBillingUsageReportRequest?: OrganizationBillingUsageReportRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('generateBillingUsageReport', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/billingUsageReport`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationBillingUsageReportRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get your cluster cost range. We are unable to give a precise cost of your infrastructure at the moment. But Qovery guarantees that the cost of your cluster will not exceed the max range. 
         * @summary Get cluster current cost
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterCurrentCost: async (organizationId: string, clusterId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getClusterCurrentCost', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('getClusterCurrentCost', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}/currentCost`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns the external ID of the organization\'s billing account 
         * @summary Get organization billing external ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationBillingExternalId: async (organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationBillingExternalId', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/billingExternalId`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get organization billing info
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationBillingInfo: async (organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationBillingInfo', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/billingInfo`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns a \"is_valid\" boolean field reflecting the billing status of the organization: - If true, the organization billing is valid - For Startup organization, it returns false if there is at least 1 invoice unpaid since 1 week - For Community organization, it returns false if there is no credit left 
         * @summary Get organization billing status
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationBillingStatus: async (organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationBillingStatus', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/billingStatus`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get organization current cost
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationCurrentCost: async (organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationCurrentCost', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/currentCost`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get organization invoice
         * @param {string} organizationId Organization ID
         * @param {string} invoiceId Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationInvoice: async (organizationId: string, invoiceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationInvoice', 'organizationId', organizationId)
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('getOrganizationInvoice', 'invoiceId', invoiceId)
            const localVarPath = `/organization/{organizationId}/invoice/{invoiceId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This will return URL of the invoice PDF
         * @summary Get invoice link
         * @param {string} organizationId Organization ID
         * @param {string} invoiceId Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationInvoicePDF: async (organizationId: string, invoiceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationInvoicePDF', 'organizationId', organizationId)
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('getOrganizationInvoicePDF', 'invoiceId', invoiceId)
            const localVarPath = `/organization/{organizationId}/invoice/{invoiceId}/download`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List organization credit cards
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationCreditCards: async (organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listOrganizationCreditCards', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/creditCard`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List organization invoices
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationInvoice: async (organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listOrganizationInvoice', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/invoice`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download all invoices
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationDownloadAllInvoices: async (organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('organizationDownloadAllInvoices', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/downloadInvoices`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BillingApi - functional programming interface
 * @export
 */
export const BillingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BillingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add credit card
         * @param {string} organizationId Organization ID
         * @param {CreditCardRequest} [creditCardRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addCreditCard(organizationId: string, creditCardRequest?: CreditCardRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditCard>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addCreditCard(organizationId, creditCardRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.addCreditCard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add credit code
         * @param {string} organizationId Organization ID
         * @param {OrganizationCreditCodeRequest} [organizationCreditCodeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addCreditCode(organizationId: string, organizationCreditCodeRequest?: OrganizationCreditCodeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addCreditCode(organizationId, organizationCreditCodeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.addCreditCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Change organization plan
         * @param {string} organizationId Organization ID
         * @param {OrganizationChangePlanRequest} [organizationChangePlanRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changePlan(organizationId: string, organizationChangePlanRequest?: OrganizationChangePlanRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changePlan(organizationId, organizationChangePlanRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.changePlan']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete credit card
         * @param {string} organizationId Organization ID
         * @param {string} creditCardId Credit Card ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCreditCard(organizationId: string, creditCardId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCreditCard(organizationId, creditCardId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.deleteCreditCard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Edit Organization Billing Info
         * @param {string} organizationId Organization ID
         * @param {BillingInfoRequest} [billingInfoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editOrganizationBillingInfo(organizationId: string, billingInfoRequest?: BillingInfoRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BillingInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editOrganizationBillingInfo(organizationId, billingInfoRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.editOrganizationBillingInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Generate organization billing usage report
         * @param {string} organizationId Organization ID
         * @param {OrganizationBillingUsageReportRequest} [organizationBillingUsageReportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateBillingUsageReport(organizationId: string, organizationBillingUsageReportRequest?: OrganizationBillingUsageReportRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationBillingUsageReportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateBillingUsageReport(organizationId, organizationBillingUsageReportRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.generateBillingUsageReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get your cluster cost range. We are unable to give a precise cost of your infrastructure at the moment. But Qovery guarantees that the cost of your cluster will not exceed the max range. 
         * @summary Get cluster current cost
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClusterCurrentCost(organizationId: string, clusterId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CostRange>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClusterCurrentCost(organizationId, clusterId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.getClusterCurrentCost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint returns the external ID of the organization\'s billing account 
         * @summary Get organization billing external ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationBillingExternalId(organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BillingExternalId>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationBillingExternalId(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.getOrganizationBillingExternalId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get organization billing info
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationBillingInfo(organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BillingInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationBillingInfo(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.getOrganizationBillingInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint returns a \"is_valid\" boolean field reflecting the billing status of the organization: - If true, the organization billing is valid - For Startup organization, it returns false if there is at least 1 invoice unpaid since 1 week - For Community organization, it returns false if there is no credit left 
         * @summary Get organization billing status
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationBillingStatus(organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BillingStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationBillingStatus(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.getOrganizationBillingStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get organization current cost
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationCurrentCost(organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationCurrentCost>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationCurrentCost(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.getOrganizationCurrentCost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get organization invoice
         * @param {string} organizationId Organization ID
         * @param {string} invoiceId Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationInvoice(organizationId: string, invoiceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invoice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationInvoice(organizationId, invoiceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.getOrganizationInvoice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This will return URL of the invoice PDF
         * @summary Get invoice link
         * @param {string} organizationId Organization ID
         * @param {string} invoiceId Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationInvoicePDF(organizationId: string, invoiceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Link>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationInvoicePDF(organizationId, invoiceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.getOrganizationInvoicePDF']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List organization credit cards
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizationCreditCards(organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditCardResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationCreditCards(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.listOrganizationCreditCards']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List organization invoices
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizationInvoice(organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationInvoice(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.listOrganizationInvoice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Download all invoices
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationDownloadAllInvoices(organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationDownloadAllInvoices(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.organizationDownloadAllInvoices']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BillingApi - factory interface
 * @export
 */
export const BillingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BillingApiFp(configuration)
    return {
        /**
         * 
         * @summary Add credit card
         * @param {string} organizationId Organization ID
         * @param {CreditCardRequest} [creditCardRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCreditCard(organizationId: string, creditCardRequest?: CreditCardRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreditCard> {
            return localVarFp.addCreditCard(organizationId, creditCardRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add credit code
         * @param {string} organizationId Organization ID
         * @param {OrganizationCreditCodeRequest} [organizationCreditCodeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCreditCode(organizationId: string, organizationCreditCodeRequest?: OrganizationCreditCodeRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addCreditCode(organizationId, organizationCreditCodeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Change organization plan
         * @param {string} organizationId Organization ID
         * @param {OrganizationChangePlanRequest} [organizationChangePlanRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePlan(organizationId: string, organizationChangePlanRequest?: OrganizationChangePlanRequest, options?: RawAxiosRequestConfig): AxiosPromise<Organization> {
            return localVarFp.changePlan(organizationId, organizationChangePlanRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete credit card
         * @param {string} organizationId Organization ID
         * @param {string} creditCardId Credit Card ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCreditCard(organizationId: string, creditCardId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteCreditCard(organizationId, creditCardId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit Organization Billing Info
         * @param {string} organizationId Organization ID
         * @param {BillingInfoRequest} [billingInfoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editOrganizationBillingInfo(organizationId: string, billingInfoRequest?: BillingInfoRequest, options?: RawAxiosRequestConfig): AxiosPromise<BillingInfo> {
            return localVarFp.editOrganizationBillingInfo(organizationId, billingInfoRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Generate organization billing usage report
         * @param {string} organizationId Organization ID
         * @param {OrganizationBillingUsageReportRequest} [organizationBillingUsageReportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateBillingUsageReport(organizationId: string, organizationBillingUsageReportRequest?: OrganizationBillingUsageReportRequest, options?: RawAxiosRequestConfig): AxiosPromise<OrganizationBillingUsageReportResponse> {
            return localVarFp.generateBillingUsageReport(organizationId, organizationBillingUsageReportRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get your cluster cost range. We are unable to give a precise cost of your infrastructure at the moment. But Qovery guarantees that the cost of your cluster will not exceed the max range. 
         * @summary Get cluster current cost
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterCurrentCost(organizationId: string, clusterId: string, options?: RawAxiosRequestConfig): AxiosPromise<CostRange> {
            return localVarFp.getClusterCurrentCost(organizationId, clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns the external ID of the organization\'s billing account 
         * @summary Get organization billing external ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationBillingExternalId(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise<BillingExternalId> {
            return localVarFp.getOrganizationBillingExternalId(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get organization billing info
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationBillingInfo(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise<BillingInfo> {
            return localVarFp.getOrganizationBillingInfo(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a \"is_valid\" boolean field reflecting the billing status of the organization: - If true, the organization billing is valid - For Startup organization, it returns false if there is at least 1 invoice unpaid since 1 week - For Community organization, it returns false if there is no credit left 
         * @summary Get organization billing status
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationBillingStatus(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise<BillingStatus> {
            return localVarFp.getOrganizationBillingStatus(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get organization current cost
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationCurrentCost(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise<OrganizationCurrentCost> {
            return localVarFp.getOrganizationCurrentCost(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get organization invoice
         * @param {string} organizationId Organization ID
         * @param {string} invoiceId Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationInvoice(organizationId: string, invoiceId: string, options?: RawAxiosRequestConfig): AxiosPromise<Invoice> {
            return localVarFp.getOrganizationInvoice(organizationId, invoiceId, options).then((request) => request(axios, basePath));
        },
        /**
         * This will return URL of the invoice PDF
         * @summary Get invoice link
         * @param {string} organizationId Organization ID
         * @param {string} invoiceId Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationInvoicePDF(organizationId: string, invoiceId: string, options?: RawAxiosRequestConfig): AxiosPromise<Link> {
            return localVarFp.getOrganizationInvoicePDF(organizationId, invoiceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List organization credit cards
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationCreditCards(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise<CreditCardResponseList> {
            return localVarFp.listOrganizationCreditCards(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List organization invoices
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationInvoice(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise<InvoiceResponseList> {
            return localVarFp.listOrganizationInvoice(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download all invoices
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationDownloadAllInvoices(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.organizationDownloadAllInvoices(organizationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BillingApi - object-oriented interface
 * @export
 * @class BillingApi
 * @extends {BaseAPI}
 */
export class BillingApi extends BaseAPI {
    /**
     * 
     * @summary Add credit card
     * @param {string} organizationId Organization ID
     * @param {CreditCardRequest} [creditCardRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public addCreditCard(organizationId: string, creditCardRequest?: CreditCardRequest, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).addCreditCard(organizationId, creditCardRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add credit code
     * @param {string} organizationId Organization ID
     * @param {OrganizationCreditCodeRequest} [organizationCreditCodeRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public addCreditCode(organizationId: string, organizationCreditCodeRequest?: OrganizationCreditCodeRequest, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).addCreditCode(organizationId, organizationCreditCodeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Change organization plan
     * @param {string} organizationId Organization ID
     * @param {OrganizationChangePlanRequest} [organizationChangePlanRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public changePlan(organizationId: string, organizationChangePlanRequest?: OrganizationChangePlanRequest, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).changePlan(organizationId, organizationChangePlanRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete credit card
     * @param {string} organizationId Organization ID
     * @param {string} creditCardId Credit Card ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public deleteCreditCard(organizationId: string, creditCardId: string, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).deleteCreditCard(organizationId, creditCardId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit Organization Billing Info
     * @param {string} organizationId Organization ID
     * @param {BillingInfoRequest} [billingInfoRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public editOrganizationBillingInfo(organizationId: string, billingInfoRequest?: BillingInfoRequest, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).editOrganizationBillingInfo(organizationId, billingInfoRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Generate organization billing usage report
     * @param {string} organizationId Organization ID
     * @param {OrganizationBillingUsageReportRequest} [organizationBillingUsageReportRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public generateBillingUsageReport(organizationId: string, organizationBillingUsageReportRequest?: OrganizationBillingUsageReportRequest, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).generateBillingUsageReport(organizationId, organizationBillingUsageReportRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get your cluster cost range. We are unable to give a precise cost of your infrastructure at the moment. But Qovery guarantees that the cost of your cluster will not exceed the max range. 
     * @summary Get cluster current cost
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getClusterCurrentCost(organizationId: string, clusterId: string, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).getClusterCurrentCost(organizationId, clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns the external ID of the organization\'s billing account 
     * @summary Get organization billing external ID
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getOrganizationBillingExternalId(organizationId: string, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).getOrganizationBillingExternalId(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get organization billing info
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getOrganizationBillingInfo(organizationId: string, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).getOrganizationBillingInfo(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns a \"is_valid\" boolean field reflecting the billing status of the organization: - If true, the organization billing is valid - For Startup organization, it returns false if there is at least 1 invoice unpaid since 1 week - For Community organization, it returns false if there is no credit left 
     * @summary Get organization billing status
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getOrganizationBillingStatus(organizationId: string, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).getOrganizationBillingStatus(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get organization current cost
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getOrganizationCurrentCost(organizationId: string, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).getOrganizationCurrentCost(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get organization invoice
     * @param {string} organizationId Organization ID
     * @param {string} invoiceId Invoice ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getOrganizationInvoice(organizationId: string, invoiceId: string, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).getOrganizationInvoice(organizationId, invoiceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will return URL of the invoice PDF
     * @summary Get invoice link
     * @param {string} organizationId Organization ID
     * @param {string} invoiceId Invoice ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getOrganizationInvoicePDF(organizationId: string, invoiceId: string, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).getOrganizationInvoicePDF(organizationId, invoiceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List organization credit cards
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public listOrganizationCreditCards(organizationId: string, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).listOrganizationCreditCards(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List organization invoices
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public listOrganizationInvoice(organizationId: string, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).listOrganizationInvoice(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download all invoices
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public organizationDownloadAllInvoices(organizationId: string, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).organizationDownloadAllInvoices(organizationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CloudProviderApi - axios parameter creator
 * @export
 */
export const CloudProviderApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List AWS EKS available instance types
         * @param {string} region region name
         * @param {boolean} [onlyMeetsResourceReqs] 
         * @param {boolean} [withGpu] deprecated field, use &#x60;gpu&#x60; instead
         * @param {ListAWSEKSInstanceTypeGpuEnum} [gpu] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAWSEKSInstanceType: async (region: string, onlyMeetsResourceReqs?: boolean, withGpu?: boolean, gpu?: ListAWSEKSInstanceTypeGpuEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'region' is not null or undefined
            assertParamExists('listAWSEKSInstanceType', 'region', region)
            const localVarPath = `/aws/eks/instanceType/{region}`
                .replace(`{${"region"}}`, encodeURIComponent(String(region)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (onlyMeetsResourceReqs !== undefined) {
                localVarQueryParameter['only_meets_resource_reqs'] = onlyMeetsResourceReqs;
            }

            if (withGpu !== undefined) {
                localVarQueryParameter['with_gpu'] = withGpu;
            }

            if (gpu !== undefined) {
                localVarQueryParameter['gpu'] = gpu;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List AWS features available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAWSFeatures: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/aws/clusterFeature`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List AWS available instance types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAWSInstanceType: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/aws/instanceType`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List AWS available managed database instance types
         * @param {string} region region name
         * @param {string} databaseType Database type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAWSManagedDatabaseInstanceType: async (region: string, databaseType: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'region' is not null or undefined
            assertParamExists('listAWSManagedDatabaseInstanceType', 'region', region)
            // verify required parameter 'databaseType' is not null or undefined
            assertParamExists('listAWSManagedDatabaseInstanceType', 'databaseType', databaseType)
            const localVarPath = `/aws/managedDatabase/instanceType/{region}/{databaseType}`
                .replace(`{${"region"}}`, encodeURIComponent(String(region)))
                .replace(`{${"databaseType"}}`, encodeURIComponent(String(databaseType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List AWS available managed database types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAWSManagedDatabaseType: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/aws/managedDatabase/type`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List AWS regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAWSRegions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/aws/region`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Azure AKS available instance types
         * @param {string} region region name
         * @param {boolean} [onlyMeetsResourceReqs] 
         * @param {boolean} [withGpu] deprecated field, use &#x60;gpu&#x60; instead
         * @param {ListAzureAKSInstanceTypeGpuEnum} [gpu] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAzureAKSInstanceType: async (region: string, onlyMeetsResourceReqs?: boolean, withGpu?: boolean, gpu?: ListAzureAKSInstanceTypeGpuEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'region' is not null or undefined
            assertParamExists('listAzureAKSInstanceType', 'region', region)
            const localVarPath = `/azure/aks/instanceType/{region}`
                .replace(`{${"region"}}`, encodeURIComponent(String(region)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (onlyMeetsResourceReqs !== undefined) {
                localVarQueryParameter['only_meets_resource_reqs'] = onlyMeetsResourceReqs;
            }

            if (withGpu !== undefined) {
                localVarQueryParameter['with_gpu'] = withGpu;
            }

            if (gpu !== undefined) {
                localVarQueryParameter['gpu'] = gpu;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Azure features available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAzureFeatures: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/azure/clusterFeature`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Azure regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAzureRegions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/azure/region`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Cloud providers available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCloudProvider: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cloudProvider`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List GCP features available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGcpFeatures: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/gcp/clusterFeature`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List GCP GKE available instance types
         * @param {string} region region name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGcpGkeInstanceType: async (region: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'region' is not null or undefined
            assertParamExists('listGcpGkeInstanceType', 'region', region)
            const localVarPath = `/gcp/instanceType/{region}`
                .replace(`{${"region"}}`, encodeURIComponent(String(region)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List GCP regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGcpRegions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/gcp/region`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Scaleway available managed database types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSCWManagedDatabaseType: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/scaleway/managedDatabase/type`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Scaleway features available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScalewayFeatures: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/scaleway/clusterFeature`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Scaleway available instance types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScalewayInstanceType: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/scaleway/instanceType`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Scaleway Kapsule available instance types
         * @param {string} zone zone name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScalewayKapsuleInstanceType: async (zone: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zone' is not null or undefined
            assertParamExists('listScalewayKapsuleInstanceType', 'zone', zone)
            const localVarPath = `/scaleway/instanceType/{zone}`
                .replace(`{${"zone"}}`, encodeURIComponent(String(zone)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Scaleway regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScalewayRegions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/scaleway/region`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CloudProviderApi - functional programming interface
 * @export
 */
export const CloudProviderApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CloudProviderApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List AWS EKS available instance types
         * @param {string} region region name
         * @param {boolean} [onlyMeetsResourceReqs] 
         * @param {boolean} [withGpu] deprecated field, use &#x60;gpu&#x60; instead
         * @param {ListAWSEKSInstanceTypeGpuEnum} [gpu] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAWSEKSInstanceType(region: string, onlyMeetsResourceReqs?: boolean, withGpu?: boolean, gpu?: ListAWSEKSInstanceTypeGpuEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterInstanceTypeResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAWSEKSInstanceType(region, onlyMeetsResourceReqs, withGpu, gpu, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudProviderApi.listAWSEKSInstanceType']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List AWS features available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAWSFeatures(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterFeatureResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAWSFeatures(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudProviderApi.listAWSFeatures']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List AWS available instance types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAWSInstanceType(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterInstanceTypeResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAWSInstanceType(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudProviderApi.listAWSInstanceType']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List AWS available managed database instance types
         * @param {string} region region name
         * @param {string} databaseType Database type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAWSManagedDatabaseInstanceType(region: string, databaseType: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManagedDatabaseInstanceTypeResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAWSManagedDatabaseInstanceType(region, databaseType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudProviderApi.listAWSManagedDatabaseInstanceType']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List AWS available managed database types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAWSManagedDatabaseType(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManagedDatabaseTypeResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAWSManagedDatabaseType(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudProviderApi.listAWSManagedDatabaseType']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List AWS regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAWSRegions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterRegionResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAWSRegions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudProviderApi.listAWSRegions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Azure AKS available instance types
         * @param {string} region region name
         * @param {boolean} [onlyMeetsResourceReqs] 
         * @param {boolean} [withGpu] deprecated field, use &#x60;gpu&#x60; instead
         * @param {ListAzureAKSInstanceTypeGpuEnum} [gpu] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAzureAKSInstanceType(region: string, onlyMeetsResourceReqs?: boolean, withGpu?: boolean, gpu?: ListAzureAKSInstanceTypeGpuEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterInstanceTypeResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAzureAKSInstanceType(region, onlyMeetsResourceReqs, withGpu, gpu, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudProviderApi.listAzureAKSInstanceType']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Azure features available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAzureFeatures(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterFeatureResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAzureFeatures(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudProviderApi.listAzureFeatures']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Azure regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAzureRegions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterRegionResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAzureRegions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudProviderApi.listAzureRegions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Cloud providers available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCloudProvider(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudProviderResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCloudProvider(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudProviderApi.listCloudProvider']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List GCP features available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGcpFeatures(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterFeatureResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGcpFeatures(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudProviderApi.listGcpFeatures']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List GCP GKE available instance types
         * @param {string} region region name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGcpGkeInstanceType(region: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterInstanceTypeResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGcpGkeInstanceType(region, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudProviderApi.listGcpGkeInstanceType']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List GCP regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGcpRegions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterRegionResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGcpRegions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudProviderApi.listGcpRegions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Scaleway available managed database types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSCWManagedDatabaseType(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManagedDatabaseTypeResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSCWManagedDatabaseType(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudProviderApi.listSCWManagedDatabaseType']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Scaleway features available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listScalewayFeatures(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterFeatureResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listScalewayFeatures(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudProviderApi.listScalewayFeatures']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Scaleway available instance types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listScalewayInstanceType(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterInstanceTypeResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listScalewayInstanceType(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudProviderApi.listScalewayInstanceType']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Scaleway Kapsule available instance types
         * @param {string} zone zone name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listScalewayKapsuleInstanceType(zone: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterInstanceTypeResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listScalewayKapsuleInstanceType(zone, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudProviderApi.listScalewayKapsuleInstanceType']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Scaleway regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listScalewayRegions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterRegionResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listScalewayRegions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudProviderApi.listScalewayRegions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CloudProviderApi - factory interface
 * @export
 */
export const CloudProviderApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CloudProviderApiFp(configuration)
    return {
        /**
         * 
         * @summary List AWS EKS available instance types
         * @param {string} region region name
         * @param {boolean} [onlyMeetsResourceReqs] 
         * @param {boolean} [withGpu] deprecated field, use &#x60;gpu&#x60; instead
         * @param {ListAWSEKSInstanceTypeGpuEnum} [gpu] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAWSEKSInstanceType(region: string, onlyMeetsResourceReqs?: boolean, withGpu?: boolean, gpu?: ListAWSEKSInstanceTypeGpuEnum, options?: RawAxiosRequestConfig): AxiosPromise<ClusterInstanceTypeResponseList> {
            return localVarFp.listAWSEKSInstanceType(region, onlyMeetsResourceReqs, withGpu, gpu, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List AWS features available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAWSFeatures(options?: RawAxiosRequestConfig): AxiosPromise<ClusterFeatureResponseList> {
            return localVarFp.listAWSFeatures(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List AWS available instance types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAWSInstanceType(options?: RawAxiosRequestConfig): AxiosPromise<ClusterInstanceTypeResponseList> {
            return localVarFp.listAWSInstanceType(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List AWS available managed database instance types
         * @param {string} region region name
         * @param {string} databaseType Database type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAWSManagedDatabaseInstanceType(region: string, databaseType: string, options?: RawAxiosRequestConfig): AxiosPromise<ManagedDatabaseInstanceTypeResponseList> {
            return localVarFp.listAWSManagedDatabaseInstanceType(region, databaseType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List AWS available managed database types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAWSManagedDatabaseType(options?: RawAxiosRequestConfig): AxiosPromise<ManagedDatabaseTypeResponseList> {
            return localVarFp.listAWSManagedDatabaseType(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List AWS regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAWSRegions(options?: RawAxiosRequestConfig): AxiosPromise<ClusterRegionResponseList> {
            return localVarFp.listAWSRegions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Azure AKS available instance types
         * @param {string} region region name
         * @param {boolean} [onlyMeetsResourceReqs] 
         * @param {boolean} [withGpu] deprecated field, use &#x60;gpu&#x60; instead
         * @param {ListAzureAKSInstanceTypeGpuEnum} [gpu] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAzureAKSInstanceType(region: string, onlyMeetsResourceReqs?: boolean, withGpu?: boolean, gpu?: ListAzureAKSInstanceTypeGpuEnum, options?: RawAxiosRequestConfig): AxiosPromise<ClusterInstanceTypeResponseList> {
            return localVarFp.listAzureAKSInstanceType(region, onlyMeetsResourceReqs, withGpu, gpu, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Azure features available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAzureFeatures(options?: RawAxiosRequestConfig): AxiosPromise<ClusterFeatureResponseList> {
            return localVarFp.listAzureFeatures(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Azure regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAzureRegions(options?: RawAxiosRequestConfig): AxiosPromise<ClusterRegionResponseList> {
            return localVarFp.listAzureRegions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Cloud providers available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCloudProvider(options?: RawAxiosRequestConfig): AxiosPromise<CloudProviderResponseList> {
            return localVarFp.listCloudProvider(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List GCP features available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGcpFeatures(options?: RawAxiosRequestConfig): AxiosPromise<ClusterFeatureResponseList> {
            return localVarFp.listGcpFeatures(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List GCP GKE available instance types
         * @param {string} region region name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGcpGkeInstanceType(region: string, options?: RawAxiosRequestConfig): AxiosPromise<ClusterInstanceTypeResponseList> {
            return localVarFp.listGcpGkeInstanceType(region, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List GCP regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGcpRegions(options?: RawAxiosRequestConfig): AxiosPromise<ClusterRegionResponseList> {
            return localVarFp.listGcpRegions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Scaleway available managed database types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSCWManagedDatabaseType(options?: RawAxiosRequestConfig): AxiosPromise<ManagedDatabaseTypeResponseList> {
            return localVarFp.listSCWManagedDatabaseType(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Scaleway features available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScalewayFeatures(options?: RawAxiosRequestConfig): AxiosPromise<ClusterFeatureResponseList> {
            return localVarFp.listScalewayFeatures(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Scaleway available instance types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScalewayInstanceType(options?: RawAxiosRequestConfig): AxiosPromise<ClusterInstanceTypeResponseList> {
            return localVarFp.listScalewayInstanceType(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Scaleway Kapsule available instance types
         * @param {string} zone zone name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScalewayKapsuleInstanceType(zone: string, options?: RawAxiosRequestConfig): AxiosPromise<ClusterInstanceTypeResponseList> {
            return localVarFp.listScalewayKapsuleInstanceType(zone, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Scaleway regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScalewayRegions(options?: RawAxiosRequestConfig): AxiosPromise<ClusterRegionResponseList> {
            return localVarFp.listScalewayRegions(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CloudProviderApi - object-oriented interface
 * @export
 * @class CloudProviderApi
 * @extends {BaseAPI}
 */
export class CloudProviderApi extends BaseAPI {
    /**
     * 
     * @summary List AWS EKS available instance types
     * @param {string} region region name
     * @param {boolean} [onlyMeetsResourceReqs] 
     * @param {boolean} [withGpu] deprecated field, use &#x60;gpu&#x60; instead
     * @param {ListAWSEKSInstanceTypeGpuEnum} [gpu] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listAWSEKSInstanceType(region: string, onlyMeetsResourceReqs?: boolean, withGpu?: boolean, gpu?: ListAWSEKSInstanceTypeGpuEnum, options?: RawAxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listAWSEKSInstanceType(region, onlyMeetsResourceReqs, withGpu, gpu, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List AWS features available
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listAWSFeatures(options?: RawAxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listAWSFeatures(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List AWS available instance types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listAWSInstanceType(options?: RawAxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listAWSInstanceType(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List AWS available managed database instance types
     * @param {string} region region name
     * @param {string} databaseType Database type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listAWSManagedDatabaseInstanceType(region: string, databaseType: string, options?: RawAxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listAWSManagedDatabaseInstanceType(region, databaseType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List AWS available managed database types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listAWSManagedDatabaseType(options?: RawAxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listAWSManagedDatabaseType(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List AWS regions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listAWSRegions(options?: RawAxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listAWSRegions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Azure AKS available instance types
     * @param {string} region region name
     * @param {boolean} [onlyMeetsResourceReqs] 
     * @param {boolean} [withGpu] deprecated field, use &#x60;gpu&#x60; instead
     * @param {ListAzureAKSInstanceTypeGpuEnum} [gpu] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listAzureAKSInstanceType(region: string, onlyMeetsResourceReqs?: boolean, withGpu?: boolean, gpu?: ListAzureAKSInstanceTypeGpuEnum, options?: RawAxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listAzureAKSInstanceType(region, onlyMeetsResourceReqs, withGpu, gpu, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Azure features available
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listAzureFeatures(options?: RawAxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listAzureFeatures(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Azure regions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listAzureRegions(options?: RawAxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listAzureRegions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Cloud providers available
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listCloudProvider(options?: RawAxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listCloudProvider(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List GCP features available
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listGcpFeatures(options?: RawAxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listGcpFeatures(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List GCP GKE available instance types
     * @param {string} region region name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listGcpGkeInstanceType(region: string, options?: RawAxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listGcpGkeInstanceType(region, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List GCP regions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listGcpRegions(options?: RawAxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listGcpRegions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Scaleway available managed database types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listSCWManagedDatabaseType(options?: RawAxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listSCWManagedDatabaseType(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Scaleway features available
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listScalewayFeatures(options?: RawAxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listScalewayFeatures(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Scaleway available instance types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listScalewayInstanceType(options?: RawAxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listScalewayInstanceType(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Scaleway Kapsule available instance types
     * @param {string} zone zone name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listScalewayKapsuleInstanceType(zone: string, options?: RawAxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listScalewayKapsuleInstanceType(zone, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Scaleway regions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listScalewayRegions(options?: RawAxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listScalewayRegions(options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ListAWSEKSInstanceTypeGpuEnum = {
    INCLUDE: 'INCLUDE',
    EXCLUDE: 'EXCLUDE',
    ONLY: 'ONLY'
} as const;
export type ListAWSEKSInstanceTypeGpuEnum = typeof ListAWSEKSInstanceTypeGpuEnum[keyof typeof ListAWSEKSInstanceTypeGpuEnum];
/**
 * @export
 */
export const ListAzureAKSInstanceTypeGpuEnum = {
    ONLY: 'ONLY',
    INCLUDE: 'INCLUDE',
    EXCLUDE: 'EXCLUDE'
} as const;
export type ListAzureAKSInstanceTypeGpuEnum = typeof ListAzureAKSInstanceTypeGpuEnum[keyof typeof ListAzureAKSInstanceTypeGpuEnum];


/**
 * CloudProviderCredentialsApi - axios parameter creator
 * @export
 */
export const CloudProviderCredentialsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create AWS credentials set
         * @param {string} organizationId Organization ID
         * @param {AwsCredentialsRequest} [awsCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAWSCredentials: async (organizationId: string, awsCredentialsRequest?: AwsCredentialsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createAWSCredentials', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/aws/credentials`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(awsCredentialsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Azure credentials set
         * @param {string} organizationId Organization ID
         * @param {AzureCredentialsRequest} [azureCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAzureCredentials: async (organizationId: string, azureCredentialsRequest?: AzureCredentialsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createAzureCredentials', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/azure/credentials`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(azureCredentialsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create GCP credentials set
         * @param {string} organizationId Organization ID
         * @param {GcpCredentialsRequest} [gcpCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGcpCredentials: async (organizationId: string, gcpCredentialsRequest?: GcpCredentialsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createGcpCredentials', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/gcp/credentials`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gcpCredentialsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create OnPremise credentials set
         * @param {string} organizationId Organization ID
         * @param {OnPremiseCredentialsRequest} [onPremiseCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOnPremiseCredentials: async (organizationId: string, onPremiseCredentialsRequest?: OnPremiseCredentialsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createOnPremiseCredentials', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/onPremise/credentials`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(onPremiseCredentialsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Scaleway credentials set
         * @param {string} organizationId Organization ID
         * @param {ScalewayCredentialsRequest} [scalewayCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScalewayCredentials: async (organizationId: string, scalewayCredentialsRequest?: ScalewayCredentialsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createScalewayCredentials', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/scaleway/credentials`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scalewayCredentialsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a set of AWS credentials
         * @param {string} credentialsId Credentials ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAWSCredentials: async (credentialsId: string, organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'credentialsId' is not null or undefined
            assertParamExists('deleteAWSCredentials', 'credentialsId', credentialsId)
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteAWSCredentials', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/aws/credentials/{credentialsId}`
                .replace(`{${"credentialsId"}}`, encodeURIComponent(String(credentialsId)))
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a set of Azure credentials
         * @param {string} organizationId 
         * @param {string} credentialsId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAzureCredentials: async (organizationId: string, credentialsId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteAzureCredentials', 'organizationId', organizationId)
            // verify required parameter 'credentialsId' is not null or undefined
            assertParamExists('deleteAzureCredentials', 'credentialsId', credentialsId)
            const localVarPath = `/organization/{organizationId}/azure/credentials/{credentialsId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"credentialsId"}}`, encodeURIComponent(String(credentialsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a set of GCP credentials
         * @param {string} credentialsId Credentials ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGcpCredentials: async (credentialsId: string, organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'credentialsId' is not null or undefined
            assertParamExists('deleteGcpCredentials', 'credentialsId', credentialsId)
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteGcpCredentials', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/gcp/credentials/{credentialsId}`
                .replace(`{${"credentialsId"}}`, encodeURIComponent(String(credentialsId)))
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a set of OnPremise credentials
         * @param {string} credentialsId Credentials ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOnPremiseCredentials: async (credentialsId: string, organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'credentialsId' is not null or undefined
            assertParamExists('deleteOnPremiseCredentials', 'credentialsId', credentialsId)
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteOnPremiseCredentials', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/onPremise/credentials/{credentialsId}`
                .replace(`{${"credentialsId"}}`, encodeURIComponent(String(credentialsId)))
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a set of Scaleway credentials
         * @param {string} credentialsId Credentials ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScalewayCredentials: async (credentialsId: string, organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'credentialsId' is not null or undefined
            assertParamExists('deleteScalewayCredentials', 'credentialsId', credentialsId)
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteScalewayCredentials', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/scaleway/credentials/{credentialsId}`
                .replace(`{${"credentialsId"}}`, encodeURIComponent(String(credentialsId)))
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a set of AWS credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {AwsCredentialsRequest} [awsCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editAWSCredentials: async (organizationId: string, credentialsId: string, awsCredentialsRequest?: AwsCredentialsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('editAWSCredentials', 'organizationId', organizationId)
            // verify required parameter 'credentialsId' is not null or undefined
            assertParamExists('editAWSCredentials', 'credentialsId', credentialsId)
            const localVarPath = `/organization/{organizationId}/aws/credentials/{credentialsId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"credentialsId"}}`, encodeURIComponent(String(credentialsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(awsCredentialsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a set of Azure credentials
         * @param {string} organizationId 
         * @param {string} credentialsId 
         * @param {AzureCredentialsRequest} [azureCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editAzureCredentials: async (organizationId: string, credentialsId: string, azureCredentialsRequest?: AzureCredentialsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('editAzureCredentials', 'organizationId', organizationId)
            // verify required parameter 'credentialsId' is not null or undefined
            assertParamExists('editAzureCredentials', 'credentialsId', credentialsId)
            const localVarPath = `/organization/{organizationId}/azure/credentials/{credentialsId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"credentialsId"}}`, encodeURIComponent(String(credentialsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(azureCredentialsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a set of GCP credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {GcpCredentialsRequest} [gcpCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editGcpCredentials: async (organizationId: string, credentialsId: string, gcpCredentialsRequest?: GcpCredentialsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('editGcpCredentials', 'organizationId', organizationId)
            // verify required parameter 'credentialsId' is not null or undefined
            assertParamExists('editGcpCredentials', 'credentialsId', credentialsId)
            const localVarPath = `/organization/{organizationId}/gcp/credentials/{credentialsId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"credentialsId"}}`, encodeURIComponent(String(credentialsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gcpCredentialsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a set of OnPremise credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {OnPremiseCredentialsRequest} [onPremiseCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editOnPremiseCredentials: async (organizationId: string, credentialsId: string, onPremiseCredentialsRequest?: OnPremiseCredentialsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('editOnPremiseCredentials', 'organizationId', organizationId)
            // verify required parameter 'credentialsId' is not null or undefined
            assertParamExists('editOnPremiseCredentials', 'credentialsId', credentialsId)
            const localVarPath = `/organization/{organizationId}/onPremise/credentials/{credentialsId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"credentialsId"}}`, encodeURIComponent(String(credentialsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(onPremiseCredentialsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a set of Scaleway credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {ScalewayCredentialsRequest} [scalewayCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editScalewayCredentials: async (organizationId: string, credentialsId: string, scalewayCredentialsRequest?: ScalewayCredentialsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('editScalewayCredentials', 'organizationId', organizationId)
            // verify required parameter 'credentialsId' is not null or undefined
            assertParamExists('editScalewayCredentials', 'credentialsId', credentialsId)
            const localVarPath = `/organization/{organizationId}/scaleway/credentials/{credentialsId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"credentialsId"}}`, encodeURIComponent(String(credentialsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scalewayCredentialsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a set of AWS credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAWSCredentials: async (organizationId: string, credentialsId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getAWSCredentials', 'organizationId', organizationId)
            // verify required parameter 'credentialsId' is not null or undefined
            assertParamExists('getAWSCredentials', 'credentialsId', credentialsId)
            const localVarPath = `/organization/{organizationId}/aws/credentials/{credentialsId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"credentialsId"}}`, encodeURIComponent(String(credentialsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a set of Azure credentials
         * @param {string} organizationId 
         * @param {string} credentialsId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAzureCredentials: async (organizationId: string, credentialsId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getAzureCredentials', 'organizationId', organizationId)
            // verify required parameter 'credentialsId' is not null or undefined
            assertParamExists('getAzureCredentials', 'credentialsId', credentialsId)
            const localVarPath = `/organization/{organizationId}/azure/credentials/{credentialsId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"credentialsId"}}`, encodeURIComponent(String(credentialsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a set of GCP credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGcpCredentials: async (organizationId: string, credentialsId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getGcpCredentials', 'organizationId', organizationId)
            // verify required parameter 'credentialsId' is not null or undefined
            assertParamExists('getGcpCredentials', 'credentialsId', credentialsId)
            const localVarPath = `/organization/{organizationId}/gcp/credentials/{credentialsId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"credentialsId"}}`, encodeURIComponent(String(credentialsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a set of OnPremise credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOnPremiseCredentials: async (organizationId: string, credentialsId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOnPremiseCredentials', 'organizationId', organizationId)
            // verify required parameter 'credentialsId' is not null or undefined
            assertParamExists('getOnPremiseCredentials', 'credentialsId', credentialsId)
            const localVarPath = `/organization/{organizationId}/onPremise/credentials/{credentialsId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"credentialsId"}}`, encodeURIComponent(String(credentialsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a set of Scaleway credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScalewayCredentials: async (organizationId: string, credentialsId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getScalewayCredentials', 'organizationId', organizationId)
            // verify required parameter 'credentialsId' is not null or undefined
            assertParamExists('getScalewayCredentials', 'credentialsId', credentialsId)
            const localVarPath = `/organization/{organizationId}/scaleway/credentials/{credentialsId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"credentialsId"}}`, encodeURIComponent(String(credentialsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List AWS credentials
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAWSCredentials: async (organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listAWSCredentials', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/aws/credentials`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Azure credentials
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAzureCredentials: async (organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listAzureCredentials', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/azure/credentials`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List GCP credentials
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGcpCredentials: async (organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listGcpCredentials', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/gcp/credentials`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List OnPremise credentials
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOnPremiseCredentials: async (organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listOnPremiseCredentials', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/onPremise/credentials`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Scaleway credentials
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScalewayCredentials: async (organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listScalewayCredentials', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/scaleway/credentials`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CloudProviderCredentialsApi - functional programming interface
 * @export
 */
export const CloudProviderCredentialsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CloudProviderCredentialsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create AWS credentials set
         * @param {string} organizationId Organization ID
         * @param {AwsCredentialsRequest} [awsCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAWSCredentials(organizationId: string, awsCredentialsRequest?: AwsCredentialsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentials>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAWSCredentials(organizationId, awsCredentialsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudProviderCredentialsApi.createAWSCredentials']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Azure credentials set
         * @param {string} organizationId Organization ID
         * @param {AzureCredentialsRequest} [azureCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAzureCredentials(organizationId: string, azureCredentialsRequest?: AzureCredentialsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentials>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAzureCredentials(organizationId, azureCredentialsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudProviderCredentialsApi.createAzureCredentials']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create GCP credentials set
         * @param {string} organizationId Organization ID
         * @param {GcpCredentialsRequest} [gcpCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGcpCredentials(organizationId: string, gcpCredentialsRequest?: GcpCredentialsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentials>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGcpCredentials(organizationId, gcpCredentialsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudProviderCredentialsApi.createGcpCredentials']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create OnPremise credentials set
         * @param {string} organizationId Organization ID
         * @param {OnPremiseCredentialsRequest} [onPremiseCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOnPremiseCredentials(organizationId: string, onPremiseCredentialsRequest?: OnPremiseCredentialsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentials>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOnPremiseCredentials(organizationId, onPremiseCredentialsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudProviderCredentialsApi.createOnPremiseCredentials']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Scaleway credentials set
         * @param {string} organizationId Organization ID
         * @param {ScalewayCredentialsRequest} [scalewayCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createScalewayCredentials(organizationId: string, scalewayCredentialsRequest?: ScalewayCredentialsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentials>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createScalewayCredentials(organizationId, scalewayCredentialsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudProviderCredentialsApi.createScalewayCredentials']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a set of AWS credentials
         * @param {string} credentialsId Credentials ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAWSCredentials(credentialsId: string, organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAWSCredentials(credentialsId, organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudProviderCredentialsApi.deleteAWSCredentials']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a set of Azure credentials
         * @param {string} organizationId 
         * @param {string} credentialsId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAzureCredentials(organizationId: string, credentialsId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAzureCredentials(organizationId, credentialsId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudProviderCredentialsApi.deleteAzureCredentials']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a set of GCP credentials
         * @param {string} credentialsId Credentials ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGcpCredentials(credentialsId: string, organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGcpCredentials(credentialsId, organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudProviderCredentialsApi.deleteGcpCredentials']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a set of OnPremise credentials
         * @param {string} credentialsId Credentials ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOnPremiseCredentials(credentialsId: string, organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOnPremiseCredentials(credentialsId, organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudProviderCredentialsApi.deleteOnPremiseCredentials']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a set of Scaleway credentials
         * @param {string} credentialsId Credentials ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteScalewayCredentials(credentialsId: string, organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteScalewayCredentials(credentialsId, organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudProviderCredentialsApi.deleteScalewayCredentials']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Edit a set of AWS credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {AwsCredentialsRequest} [awsCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editAWSCredentials(organizationId: string, credentialsId: string, awsCredentialsRequest?: AwsCredentialsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentials>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editAWSCredentials(organizationId, credentialsId, awsCredentialsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudProviderCredentialsApi.editAWSCredentials']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Edit a set of Azure credentials
         * @param {string} organizationId 
         * @param {string} credentialsId 
         * @param {AzureCredentialsRequest} [azureCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editAzureCredentials(organizationId: string, credentialsId: string, azureCredentialsRequest?: AzureCredentialsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentials>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editAzureCredentials(organizationId, credentialsId, azureCredentialsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudProviderCredentialsApi.editAzureCredentials']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Edit a set of GCP credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {GcpCredentialsRequest} [gcpCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editGcpCredentials(organizationId: string, credentialsId: string, gcpCredentialsRequest?: GcpCredentialsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentials>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editGcpCredentials(organizationId, credentialsId, gcpCredentialsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudProviderCredentialsApi.editGcpCredentials']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Edit a set of OnPremise credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {OnPremiseCredentialsRequest} [onPremiseCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editOnPremiseCredentials(organizationId: string, credentialsId: string, onPremiseCredentialsRequest?: OnPremiseCredentialsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentials>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editOnPremiseCredentials(organizationId, credentialsId, onPremiseCredentialsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudProviderCredentialsApi.editOnPremiseCredentials']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Edit a set of Scaleway credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {ScalewayCredentialsRequest} [scalewayCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editScalewayCredentials(organizationId: string, credentialsId: string, scalewayCredentialsRequest?: ScalewayCredentialsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentials>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editScalewayCredentials(organizationId, credentialsId, scalewayCredentialsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudProviderCredentialsApi.editScalewayCredentials']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a set of AWS credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAWSCredentials(organizationId: string, credentialsId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentials>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAWSCredentials(organizationId, credentialsId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudProviderCredentialsApi.getAWSCredentials']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a set of Azure credentials
         * @param {string} organizationId 
         * @param {string} credentialsId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAzureCredentials(organizationId: string, credentialsId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentials>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAzureCredentials(organizationId, credentialsId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudProviderCredentialsApi.getAzureCredentials']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a set of GCP credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGcpCredentials(organizationId: string, credentialsId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentials>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGcpCredentials(organizationId, credentialsId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudProviderCredentialsApi.getGcpCredentials']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a set of OnPremise credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOnPremiseCredentials(organizationId: string, credentialsId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentials>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOnPremiseCredentials(organizationId, credentialsId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudProviderCredentialsApi.getOnPremiseCredentials']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a set of Scaleway credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScalewayCredentials(organizationId: string, credentialsId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentials>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScalewayCredentials(organizationId, credentialsId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudProviderCredentialsApi.getScalewayCredentials']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List AWS credentials
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAWSCredentials(organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentialsResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAWSCredentials(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudProviderCredentialsApi.listAWSCredentials']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Azure credentials
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAzureCredentials(organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentialsResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAzureCredentials(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudProviderCredentialsApi.listAzureCredentials']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List GCP credentials
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGcpCredentials(organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentialsResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGcpCredentials(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudProviderCredentialsApi.listGcpCredentials']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List OnPremise credentials
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOnPremiseCredentials(organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentialsResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOnPremiseCredentials(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudProviderCredentialsApi.listOnPremiseCredentials']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Scaleway credentials
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listScalewayCredentials(organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentialsResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listScalewayCredentials(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudProviderCredentialsApi.listScalewayCredentials']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CloudProviderCredentialsApi - factory interface
 * @export
 */
export const CloudProviderCredentialsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CloudProviderCredentialsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create AWS credentials set
         * @param {string} organizationId Organization ID
         * @param {AwsCredentialsRequest} [awsCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAWSCredentials(organizationId: string, awsCredentialsRequest?: AwsCredentialsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ClusterCredentials> {
            return localVarFp.createAWSCredentials(organizationId, awsCredentialsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Azure credentials set
         * @param {string} organizationId Organization ID
         * @param {AzureCredentialsRequest} [azureCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAzureCredentials(organizationId: string, azureCredentialsRequest?: AzureCredentialsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ClusterCredentials> {
            return localVarFp.createAzureCredentials(organizationId, azureCredentialsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create GCP credentials set
         * @param {string} organizationId Organization ID
         * @param {GcpCredentialsRequest} [gcpCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGcpCredentials(organizationId: string, gcpCredentialsRequest?: GcpCredentialsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ClusterCredentials> {
            return localVarFp.createGcpCredentials(organizationId, gcpCredentialsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create OnPremise credentials set
         * @param {string} organizationId Organization ID
         * @param {OnPremiseCredentialsRequest} [onPremiseCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOnPremiseCredentials(organizationId: string, onPremiseCredentialsRequest?: OnPremiseCredentialsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ClusterCredentials> {
            return localVarFp.createOnPremiseCredentials(organizationId, onPremiseCredentialsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Scaleway credentials set
         * @param {string} organizationId Organization ID
         * @param {ScalewayCredentialsRequest} [scalewayCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScalewayCredentials(organizationId: string, scalewayCredentialsRequest?: ScalewayCredentialsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ClusterCredentials> {
            return localVarFp.createScalewayCredentials(organizationId, scalewayCredentialsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a set of AWS credentials
         * @param {string} credentialsId Credentials ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAWSCredentials(credentialsId: string, organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteAWSCredentials(credentialsId, organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a set of Azure credentials
         * @param {string} organizationId 
         * @param {string} credentialsId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAzureCredentials(organizationId: string, credentialsId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteAzureCredentials(organizationId, credentialsId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a set of GCP credentials
         * @param {string} credentialsId Credentials ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGcpCredentials(credentialsId: string, organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteGcpCredentials(credentialsId, organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a set of OnPremise credentials
         * @param {string} credentialsId Credentials ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOnPremiseCredentials(credentialsId: string, organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteOnPremiseCredentials(credentialsId, organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a set of Scaleway credentials
         * @param {string} credentialsId Credentials ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScalewayCredentials(credentialsId: string, organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteScalewayCredentials(credentialsId, organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a set of AWS credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {AwsCredentialsRequest} [awsCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editAWSCredentials(organizationId: string, credentialsId: string, awsCredentialsRequest?: AwsCredentialsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ClusterCredentials> {
            return localVarFp.editAWSCredentials(organizationId, credentialsId, awsCredentialsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a set of Azure credentials
         * @param {string} organizationId 
         * @param {string} credentialsId 
         * @param {AzureCredentialsRequest} [azureCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editAzureCredentials(organizationId: string, credentialsId: string, azureCredentialsRequest?: AzureCredentialsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ClusterCredentials> {
            return localVarFp.editAzureCredentials(organizationId, credentialsId, azureCredentialsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a set of GCP credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {GcpCredentialsRequest} [gcpCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editGcpCredentials(organizationId: string, credentialsId: string, gcpCredentialsRequest?: GcpCredentialsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ClusterCredentials> {
            return localVarFp.editGcpCredentials(organizationId, credentialsId, gcpCredentialsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a set of OnPremise credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {OnPremiseCredentialsRequest} [onPremiseCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editOnPremiseCredentials(organizationId: string, credentialsId: string, onPremiseCredentialsRequest?: OnPremiseCredentialsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ClusterCredentials> {
            return localVarFp.editOnPremiseCredentials(organizationId, credentialsId, onPremiseCredentialsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a set of Scaleway credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {ScalewayCredentialsRequest} [scalewayCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editScalewayCredentials(organizationId: string, credentialsId: string, scalewayCredentialsRequest?: ScalewayCredentialsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ClusterCredentials> {
            return localVarFp.editScalewayCredentials(organizationId, credentialsId, scalewayCredentialsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a set of AWS credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAWSCredentials(organizationId: string, credentialsId: string, options?: RawAxiosRequestConfig): AxiosPromise<ClusterCredentials> {
            return localVarFp.getAWSCredentials(organizationId, credentialsId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a set of Azure credentials
         * @param {string} organizationId 
         * @param {string} credentialsId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAzureCredentials(organizationId: string, credentialsId: string, options?: RawAxiosRequestConfig): AxiosPromise<ClusterCredentials> {
            return localVarFp.getAzureCredentials(organizationId, credentialsId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a set of GCP credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGcpCredentials(organizationId: string, credentialsId: string, options?: RawAxiosRequestConfig): AxiosPromise<ClusterCredentials> {
            return localVarFp.getGcpCredentials(organizationId, credentialsId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a set of OnPremise credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOnPremiseCredentials(organizationId: string, credentialsId: string, options?: RawAxiosRequestConfig): AxiosPromise<ClusterCredentials> {
            return localVarFp.getOnPremiseCredentials(organizationId, credentialsId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a set of Scaleway credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScalewayCredentials(organizationId: string, credentialsId: string, options?: RawAxiosRequestConfig): AxiosPromise<ClusterCredentials> {
            return localVarFp.getScalewayCredentials(organizationId, credentialsId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List AWS credentials
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAWSCredentials(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise<ClusterCredentialsResponseList> {
            return localVarFp.listAWSCredentials(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Azure credentials
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAzureCredentials(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise<ClusterCredentialsResponseList> {
            return localVarFp.listAzureCredentials(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List GCP credentials
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGcpCredentials(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise<ClusterCredentialsResponseList> {
            return localVarFp.listGcpCredentials(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List OnPremise credentials
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOnPremiseCredentials(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise<ClusterCredentialsResponseList> {
            return localVarFp.listOnPremiseCredentials(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Scaleway credentials
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScalewayCredentials(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise<ClusterCredentialsResponseList> {
            return localVarFp.listScalewayCredentials(organizationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CloudProviderCredentialsApi - object-oriented interface
 * @export
 * @class CloudProviderCredentialsApi
 * @extends {BaseAPI}
 */
export class CloudProviderCredentialsApi extends BaseAPI {
    /**
     * 
     * @summary Create AWS credentials set
     * @param {string} organizationId Organization ID
     * @param {AwsCredentialsRequest} [awsCredentialsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public createAWSCredentials(organizationId: string, awsCredentialsRequest?: AwsCredentialsRequest, options?: RawAxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).createAWSCredentials(organizationId, awsCredentialsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Azure credentials set
     * @param {string} organizationId Organization ID
     * @param {AzureCredentialsRequest} [azureCredentialsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public createAzureCredentials(organizationId: string, azureCredentialsRequest?: AzureCredentialsRequest, options?: RawAxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).createAzureCredentials(organizationId, azureCredentialsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create GCP credentials set
     * @param {string} organizationId Organization ID
     * @param {GcpCredentialsRequest} [gcpCredentialsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public createGcpCredentials(organizationId: string, gcpCredentialsRequest?: GcpCredentialsRequest, options?: RawAxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).createGcpCredentials(organizationId, gcpCredentialsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create OnPremise credentials set
     * @param {string} organizationId Organization ID
     * @param {OnPremiseCredentialsRequest} [onPremiseCredentialsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public createOnPremiseCredentials(organizationId: string, onPremiseCredentialsRequest?: OnPremiseCredentialsRequest, options?: RawAxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).createOnPremiseCredentials(organizationId, onPremiseCredentialsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Scaleway credentials set
     * @param {string} organizationId Organization ID
     * @param {ScalewayCredentialsRequest} [scalewayCredentialsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public createScalewayCredentials(organizationId: string, scalewayCredentialsRequest?: ScalewayCredentialsRequest, options?: RawAxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).createScalewayCredentials(organizationId, scalewayCredentialsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a set of AWS credentials
     * @param {string} credentialsId Credentials ID
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public deleteAWSCredentials(credentialsId: string, organizationId: string, options?: RawAxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).deleteAWSCredentials(credentialsId, organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a set of Azure credentials
     * @param {string} organizationId 
     * @param {string} credentialsId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public deleteAzureCredentials(organizationId: string, credentialsId: string, options?: RawAxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).deleteAzureCredentials(organizationId, credentialsId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a set of GCP credentials
     * @param {string} credentialsId Credentials ID
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public deleteGcpCredentials(credentialsId: string, organizationId: string, options?: RawAxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).deleteGcpCredentials(credentialsId, organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a set of OnPremise credentials
     * @param {string} credentialsId Credentials ID
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public deleteOnPremiseCredentials(credentialsId: string, organizationId: string, options?: RawAxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).deleteOnPremiseCredentials(credentialsId, organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a set of Scaleway credentials
     * @param {string} credentialsId Credentials ID
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public deleteScalewayCredentials(credentialsId: string, organizationId: string, options?: RawAxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).deleteScalewayCredentials(credentialsId, organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a set of AWS credentials
     * @param {string} organizationId Organization ID
     * @param {string} credentialsId Credentials ID
     * @param {AwsCredentialsRequest} [awsCredentialsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public editAWSCredentials(organizationId: string, credentialsId: string, awsCredentialsRequest?: AwsCredentialsRequest, options?: RawAxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).editAWSCredentials(organizationId, credentialsId, awsCredentialsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a set of Azure credentials
     * @param {string} organizationId 
     * @param {string} credentialsId 
     * @param {AzureCredentialsRequest} [azureCredentialsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public editAzureCredentials(organizationId: string, credentialsId: string, azureCredentialsRequest?: AzureCredentialsRequest, options?: RawAxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).editAzureCredentials(organizationId, credentialsId, azureCredentialsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a set of GCP credentials
     * @param {string} organizationId Organization ID
     * @param {string} credentialsId Credentials ID
     * @param {GcpCredentialsRequest} [gcpCredentialsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public editGcpCredentials(organizationId: string, credentialsId: string, gcpCredentialsRequest?: GcpCredentialsRequest, options?: RawAxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).editGcpCredentials(organizationId, credentialsId, gcpCredentialsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a set of OnPremise credentials
     * @param {string} organizationId Organization ID
     * @param {string} credentialsId Credentials ID
     * @param {OnPremiseCredentialsRequest} [onPremiseCredentialsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public editOnPremiseCredentials(organizationId: string, credentialsId: string, onPremiseCredentialsRequest?: OnPremiseCredentialsRequest, options?: RawAxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).editOnPremiseCredentials(organizationId, credentialsId, onPremiseCredentialsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a set of Scaleway credentials
     * @param {string} organizationId Organization ID
     * @param {string} credentialsId Credentials ID
     * @param {ScalewayCredentialsRequest} [scalewayCredentialsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public editScalewayCredentials(organizationId: string, credentialsId: string, scalewayCredentialsRequest?: ScalewayCredentialsRequest, options?: RawAxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).editScalewayCredentials(organizationId, credentialsId, scalewayCredentialsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a set of AWS credentials
     * @param {string} organizationId Organization ID
     * @param {string} credentialsId Credentials ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public getAWSCredentials(organizationId: string, credentialsId: string, options?: RawAxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).getAWSCredentials(organizationId, credentialsId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a set of Azure credentials
     * @param {string} organizationId 
     * @param {string} credentialsId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public getAzureCredentials(organizationId: string, credentialsId: string, options?: RawAxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).getAzureCredentials(organizationId, credentialsId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a set of GCP credentials
     * @param {string} organizationId Organization ID
     * @param {string} credentialsId Credentials ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public getGcpCredentials(organizationId: string, credentialsId: string, options?: RawAxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).getGcpCredentials(organizationId, credentialsId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a set of OnPremise credentials
     * @param {string} organizationId Organization ID
     * @param {string} credentialsId Credentials ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public getOnPremiseCredentials(organizationId: string, credentialsId: string, options?: RawAxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).getOnPremiseCredentials(organizationId, credentialsId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a set of Scaleway credentials
     * @param {string} organizationId Organization ID
     * @param {string} credentialsId Credentials ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public getScalewayCredentials(organizationId: string, credentialsId: string, options?: RawAxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).getScalewayCredentials(organizationId, credentialsId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List AWS credentials
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public listAWSCredentials(organizationId: string, options?: RawAxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).listAWSCredentials(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Azure credentials
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public listAzureCredentials(organizationId: string, options?: RawAxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).listAzureCredentials(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List GCP credentials
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public listGcpCredentials(organizationId: string, options?: RawAxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).listGcpCredentials(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List OnPremise credentials
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public listOnPremiseCredentials(organizationId: string, options?: RawAxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).listOnPremiseCredentials(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Scaleway credentials
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public listScalewayCredentials(organizationId: string, options?: RawAxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).listScalewayCredentials(organizationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ClustersApi - axios parameter creator
 * @export
 */
export const ClustersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a cluster
         * @param {string} organizationId Organization ID
         * @param {ClusterRequest} [clusterRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCluster: async (organizationId: string, clusterRequest?: ClusterRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createCluster', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/cluster`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clusterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a cluster
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {ClusterDeleteMode} [deleteMode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCluster: async (organizationId: string, clusterId: string, deleteMode?: ClusterDeleteMode, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteCluster', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('deleteCluster', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (deleteMode !== undefined) {
                localVarQueryParameter['deleteMode'] = deleteMode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * allows to deploy a cluster
         * @summary Deploy a cluster
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {boolean} [dryRun] default: false. Decide if the deployment of the cluster should be done in dry_run mode. Avoiding any changes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployCluster: async (organizationId: string, clusterId: string, dryRun?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deployCluster', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('deployCluster', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}/deploy`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (dryRun !== undefined) {
                localVarQueryParameter['dry_run'] = dryRun;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a cluster
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {ClusterRequest} [clusterRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editCluster: async (organizationId: string, clusterId: string, clusterRequest?: ClusterRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('editCluster', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('editCluster', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clusterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit advanced settings by returning table of advanced settings.
         * @summary Edit advanced settings
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {ClusterAdvancedSettings} [clusterAdvancedSettings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editClusterAdvancedSettings: async (organizationId: string, clusterId: string, clusterAdvancedSettings?: ClusterAdvancedSettings, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('editClusterAdvancedSettings', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('editClusterAdvancedSettings', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}/advancedSettings`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clusterAdvancedSettings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit cluster kubeconfig
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editClusterKubeconfig: async (organizationId: string, clusterId: string, body?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('editClusterKubeconfig', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('editClusterKubeconfig', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}/kubeconfig`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/x-yaml';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit routing table by returning updated table.
         * @summary Edit routing table
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {ClusterRoutingTableRequest} [clusterRoutingTableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editRoutingTable: async (organizationId: string, clusterId: string, clusterRoutingTableRequest?: ClusterRoutingTableRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('editRoutingTable', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('editRoutingTable', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}/routingTable`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clusterRoutingTableRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the list and values of the advanced settings of the cluster. Default values for each setting are available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/cluster-advanced-settings/) 
         * @summary Get advanced settings
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterAdvancedSettings: async (organizationId: string, clusterId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getClusterAdvancedSettings', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('getClusterAdvancedSettings', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}/advancedSettings`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get cluster kubeconfig
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {boolean} [withTokenFromCli] If true, the user auth part will have an exec command with qovery cli
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterKubeconfig: async (organizationId: string, clusterId: string, withTokenFromCli?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getClusterKubeconfig', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('getClusterKubeconfig', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}/kubeconfig`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (withTokenFromCli !== undefined) {
                localVarQueryParameter['with_token_from_cli'] = withTokenFromCli;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List Cluster Kubernetes Events
         * @summary List Cluster Kubernetes Events
         * @param {string} clusterId Cluster ID
         * @param {string} fromDateTime The start date time to fetch events from, following ISO-8601 format.   The &#x60;+&#x60; character must be escaped (&#x60;%2B&#x60;) 
         * @param {string} toDateTime The end date time to fetch events from, following ISO-8601 format.   The &#x60;+&#x60; character must be escaped (&#x60;%2B&#x60;) 
         * @param {string} [nodeName] The name of the node to fetch event from
         * @param {string} [podName] The name of the pod to fetch event from
         * @param {string} [reportingComponent] The name of the reporting component used to filter events.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterKubernetesEvents: async (clusterId: string, fromDateTime: string, toDateTime: string, nodeName?: string, podName?: string, reportingComponent?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('getClusterKubernetesEvents', 'clusterId', clusterId)
            // verify required parameter 'fromDateTime' is not null or undefined
            assertParamExists('getClusterKubernetesEvents', 'fromDateTime', fromDateTime)
            // verify required parameter 'toDateTime' is not null or undefined
            assertParamExists('getClusterKubernetesEvents', 'toDateTime', toDateTime)
            const localVarPath = `/cluster/{clusterId}/events`
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fromDateTime !== undefined) {
                localVarQueryParameter['from_date_time'] = fromDateTime;
            }

            if (toDateTime !== undefined) {
                localVarQueryParameter['to_date_time'] = toDateTime;
            }

            if (nodeName !== undefined) {
                localVarQueryParameter['node_name'] = nodeName;
            }

            if (podName !== undefined) {
                localVarQueryParameter['pod_name'] = podName;
            }

            if (reportingComponent !== undefined) {
                localVarQueryParameter['reporting_component'] = reportingComponent;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch cluster logs
         * @summary Fetch cluster logs
         * @param {string} clusterId 
         * @param {string} endpoint 
         * @param {string} query 
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {string} [limit] 
         * @param {string} [since] 
         * @param {string} [step] 
         * @param {string} [interval] 
         * @param {string} [direction] 
         * @param {string} [time] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterLogs: async (clusterId: string, endpoint: string, query: string, start?: string, end?: string, limit?: string, since?: string, step?: string, interval?: string, direction?: string, time?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('getClusterLogs', 'clusterId', clusterId)
            // verify required parameter 'endpoint' is not null or undefined
            assertParamExists('getClusterLogs', 'endpoint', endpoint)
            // verify required parameter 'query' is not null or undefined
            assertParamExists('getClusterLogs', 'query', query)
            const localVarPath = `/cluster/{clusterId}/logs`
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (endpoint !== undefined) {
                localVarQueryParameter['endpoint'] = endpoint;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = since;
            }

            if (step !== undefined) {
                localVarQueryParameter['step'] = step;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (time !== undefined) {
                localVarQueryParameter['time'] = time;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch cluster metrics.
         * @summary Fetch cluster metrics
         * @param {string} clusterId Cluster ID
         * @param {string} endpoint 
         * @param {string} query 
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {string} [step] 
         * @param {string} [time] 
         * @param {string} [timeout] 
         * @param {string} [dedup] 
         * @param {string} [partialResponse] 
         * @param {string} [maxSourceResolution] 
         * @param {string} [engine] 
         * @param {string} [analyze] 
         * @param {string} [boardShortName] 
         * @param {string} [metricShortName] 
         * @param {string} [traceId] 
         * @param {string} [range] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterMetrics: async (clusterId: string, endpoint: string, query: string, start?: string, end?: string, step?: string, time?: string, timeout?: string, dedup?: string, partialResponse?: string, maxSourceResolution?: string, engine?: string, analyze?: string, boardShortName?: string, metricShortName?: string, traceId?: string, range?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('getClusterMetrics', 'clusterId', clusterId)
            // verify required parameter 'endpoint' is not null or undefined
            assertParamExists('getClusterMetrics', 'endpoint', endpoint)
            // verify required parameter 'query' is not null or undefined
            assertParamExists('getClusterMetrics', 'query', query)
            const localVarPath = `/cluster/{clusterId}/metrics`
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (endpoint !== undefined) {
                localVarQueryParameter['endpoint'] = endpoint;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (step !== undefined) {
                localVarQueryParameter['step'] = step;
            }

            if (time !== undefined) {
                localVarQueryParameter['time'] = time;
            }

            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }

            if (dedup !== undefined) {
                localVarQueryParameter['dedup'] = dedup;
            }

            if (partialResponse !== undefined) {
                localVarQueryParameter['partial_response'] = partialResponse;
            }

            if (maxSourceResolution !== undefined) {
                localVarQueryParameter['max_source_resolution'] = maxSourceResolution;
            }

            if (engine !== undefined) {
                localVarQueryParameter['engine'] = engine;
            }

            if (analyze !== undefined) {
                localVarQueryParameter['analyze'] = analyze;
            }

            if (boardShortName !== undefined) {
                localVarQueryParameter['board_short_name'] = boardShortName;
            }

            if (metricShortName !== undefined) {
                localVarQueryParameter['metric_short_name'] = metricShortName;
            }

            if (traceId !== undefined) {
                localVarQueryParameter['trace_id'] = traceId;
            }

            if (range !== undefined) {
                localVarQueryParameter['range'] = range;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Know if a cluster is ready to be deployed or not
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterReadinessStatus: async (organizationId: string, clusterId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getClusterReadinessStatus', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('getClusterReadinessStatus', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}/isReady`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get cluster status
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterStatus: async (organizationId: string, clusterId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getClusterStatus', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('getClusterStatus', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}/status`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Default values for each setting are available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/cluster-advanced-settings/)
         * @summary List default cluster advanced settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultClusterAdvancedSettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/defaultClusterAdvancedSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get cluster helm values for self managed installation
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstallationHelmValues: async (organizationId: string, clusterId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getInstallationHelmValues', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('getInstallationHelmValues', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}/installationHelmValues`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get cluster cloud provider info and credentials
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationCloudProviderInfo: async (organizationId: string, clusterId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationCloudProviderInfo', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('getOrganizationCloudProviderInfo', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}/cloudProviderInfo`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of clusters with only their id and status.
         * @summary List all clusters statuses
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationClusterStatus: async (organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationClusterStatus', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/cluster/status`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve network routing table where each line corresponds to a route between a destination and a target.
         * @summary Get routing table
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutingTable: async (organizationId: string, clusterId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getRoutingTable', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('getRoutingTable', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}/routingTable`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List Cluster Logs
         * @summary List Cluster Logs
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listClusterLogs: async (organizationId: string, clusterId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listClusterLogs', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('listClusterLogs', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}/logs`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List organization clusters
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationCluster: async (organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listOrganizationCluster', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/cluster`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lock a Cluster
         * @summary Lock Cluster
         * @param {string} clusterId 
         * @param {ClusterLockRequest} [clusterLockRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lockCluster: async (clusterId: string, clusterLockRequest?: ClusterLockRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('lockCluster', 'clusterId', clusterId)
            const localVarPath = `/cluster/{clusterId}/lock`
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clusterLockRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Specify cluster cloud provider info and credentials
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {ClusterCloudProviderInfoRequest} [clusterCloudProviderInfoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifyClusterCloudProviderInfo: async (organizationId: string, clusterId: string, clusterCloudProviderInfoRequest?: ClusterCloudProviderInfoRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('specifyClusterCloudProviderInfo', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('specifyClusterCloudProviderInfo', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}/cloudProviderInfo`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clusterCloudProviderInfoRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cluster stop has been requester.
         * @summary Stop cluster
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopCluster: async (organizationId: string, clusterId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('stopCluster', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('stopCluster', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}/stop`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unlock a cluster
         * @summary Unlock Cluster
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlockCluster: async (clusterId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('unlockCluster', 'clusterId', clusterId)
            const localVarPath = `/cluster/{clusterId}/lock`
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update karpenter private fargate subnet ids
         * @summary Update karpenter private fargate subnet ids
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {ClusterKarpenterPrivateSubnetIdsPutRequest} [clusterKarpenterPrivateSubnetIdsPutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKarpenterPrivateFargateSubnetIds: async (organizationId: string, clusterId: string, clusterKarpenterPrivateSubnetIdsPutRequest?: ClusterKarpenterPrivateSubnetIdsPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateKarpenterPrivateFargateSubnetIds', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('updateKarpenterPrivateFargateSubnetIds', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}/karpenterPrivateSubnetIds`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clusterKarpenterPrivateSubnetIdsPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * allows to upgrade a cluster to next available kubernetes version
         * @summary Upgrade a cluster
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upgradeCluster: async (clusterId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('upgradeCluster', 'clusterId', clusterId)
            const localVarPath = `/cluster/{clusterId}/upgrade`
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClustersApi - functional programming interface
 * @export
 */
export const ClustersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClustersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a cluster
         * @param {string} organizationId Organization ID
         * @param {ClusterRequest} [clusterRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCluster(organizationId: string, clusterRequest?: ClusterRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cluster>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCluster(organizationId, clusterRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClustersApi.createCluster']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a cluster
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {ClusterDeleteMode} [deleteMode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCluster(organizationId: string, clusterId: string, deleteMode?: ClusterDeleteMode, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCluster(organizationId, clusterId, deleteMode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClustersApi.deleteCluster']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * allows to deploy a cluster
         * @summary Deploy a cluster
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {boolean} [dryRun] default: false. Decide if the deployment of the cluster should be done in dry_run mode. Avoiding any changes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployCluster(organizationId: string, clusterId: string, dryRun?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployCluster(organizationId, clusterId, dryRun, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClustersApi.deployCluster']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Edit a cluster
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {ClusterRequest} [clusterRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editCluster(organizationId: string, clusterId: string, clusterRequest?: ClusterRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cluster>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editCluster(organizationId, clusterId, clusterRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClustersApi.editCluster']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Edit advanced settings by returning table of advanced settings.
         * @summary Edit advanced settings
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {ClusterAdvancedSettings} [clusterAdvancedSettings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editClusterAdvancedSettings(organizationId: string, clusterId: string, clusterAdvancedSettings?: ClusterAdvancedSettings, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterAdvancedSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editClusterAdvancedSettings(organizationId, clusterId, clusterAdvancedSettings, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClustersApi.editClusterAdvancedSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Edit cluster kubeconfig
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editClusterKubeconfig(organizationId: string, clusterId: string, body?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editClusterKubeconfig(organizationId, clusterId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClustersApi.editClusterKubeconfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Edit routing table by returning updated table.
         * @summary Edit routing table
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {ClusterRoutingTableRequest} [clusterRoutingTableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editRoutingTable(organizationId: string, clusterId: string, clusterRoutingTableRequest?: ClusterRoutingTableRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterRoutingTable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editRoutingTable(organizationId, clusterId, clusterRoutingTableRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClustersApi.editRoutingTable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the list and values of the advanced settings of the cluster. Default values for each setting are available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/cluster-advanced-settings/) 
         * @summary Get advanced settings
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClusterAdvancedSettings(organizationId: string, clusterId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterAdvancedSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClusterAdvancedSettings(organizationId, clusterId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClustersApi.getClusterAdvancedSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get cluster kubeconfig
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {boolean} [withTokenFromCli] If true, the user auth part will have an exec command with qovery cli
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClusterKubeconfig(organizationId: string, clusterId: string, withTokenFromCli?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClusterKubeconfig(organizationId, clusterId, withTokenFromCli, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClustersApi.getClusterKubeconfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List Cluster Kubernetes Events
         * @summary List Cluster Kubernetes Events
         * @param {string} clusterId Cluster ID
         * @param {string} fromDateTime The start date time to fetch events from, following ISO-8601 format.   The &#x60;+&#x60; character must be escaped (&#x60;%2B&#x60;) 
         * @param {string} toDateTime The end date time to fetch events from, following ISO-8601 format.   The &#x60;+&#x60; character must be escaped (&#x60;%2B&#x60;) 
         * @param {string} [nodeName] The name of the node to fetch event from
         * @param {string} [podName] The name of the pod to fetch event from
         * @param {string} [reportingComponent] The name of the reporting component used to filter events.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClusterKubernetesEvents(clusterId: string, fromDateTime: string, toDateTime: string, nodeName?: string, podName?: string, reportingComponent?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetClusterKubernetesEvents200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClusterKubernetesEvents(clusterId, fromDateTime, toDateTime, nodeName, podName, reportingComponent, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClustersApi.getClusterKubernetesEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch cluster logs
         * @summary Fetch cluster logs
         * @param {string} clusterId 
         * @param {string} endpoint 
         * @param {string} query 
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {string} [limit] 
         * @param {string} [since] 
         * @param {string} [step] 
         * @param {string} [interval] 
         * @param {string} [direction] 
         * @param {string} [time] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClusterLogs(clusterId: string, endpoint: string, query: string, start?: string, end?: string, limit?: string, since?: string, step?: string, interval?: string, direction?: string, time?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterLogsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClusterLogs(clusterId, endpoint, query, start, end, limit, since, step, interval, direction, time, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClustersApi.getClusterLogs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch cluster metrics.
         * @summary Fetch cluster metrics
         * @param {string} clusterId Cluster ID
         * @param {string} endpoint 
         * @param {string} query 
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {string} [step] 
         * @param {string} [time] 
         * @param {string} [timeout] 
         * @param {string} [dedup] 
         * @param {string} [partialResponse] 
         * @param {string} [maxSourceResolution] 
         * @param {string} [engine] 
         * @param {string} [analyze] 
         * @param {string} [boardShortName] 
         * @param {string} [metricShortName] 
         * @param {string} [traceId] 
         * @param {string} [range] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClusterMetrics(clusterId: string, endpoint: string, query: string, start?: string, end?: string, step?: string, time?: string, timeout?: string, dedup?: string, partialResponse?: string, maxSourceResolution?: string, engine?: string, analyze?: string, boardShortName?: string, metricShortName?: string, traceId?: string, range?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterMetricsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClusterMetrics(clusterId, endpoint, query, start, end, step, time, timeout, dedup, partialResponse, maxSourceResolution, engine, analyze, boardShortName, metricShortName, traceId, range, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClustersApi.getClusterMetrics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Know if a cluster is ready to be deployed or not
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClusterReadinessStatus(organizationId: string, clusterId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterReadinessStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClusterReadinessStatus(organizationId, clusterId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClustersApi.getClusterReadinessStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get cluster status
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClusterStatus(organizationId: string, clusterId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClusterStatus(organizationId, clusterId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClustersApi.getClusterStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Default values for each setting are available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/cluster-advanced-settings/)
         * @summary List default cluster advanced settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDefaultClusterAdvancedSettings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterAdvancedSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDefaultClusterAdvancedSettings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClustersApi.getDefaultClusterAdvancedSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get cluster helm values for self managed installation
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInstallationHelmValues(organizationId: string, clusterId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInstallationHelmValues(organizationId, clusterId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClustersApi.getInstallationHelmValues']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get cluster cloud provider info and credentials
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationCloudProviderInfo(organizationId: string, clusterId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCloudProviderInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationCloudProviderInfo(organizationId, clusterId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClustersApi.getOrganizationCloudProviderInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of clusters with only their id and status.
         * @summary List all clusters statuses
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationClusterStatus(organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterStatusResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationClusterStatus(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClustersApi.getOrganizationClusterStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve network routing table where each line corresponds to a route between a destination and a target.
         * @summary Get routing table
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoutingTable(organizationId: string, clusterId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterRoutingTable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoutingTable(organizationId, clusterId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClustersApi.getRoutingTable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List Cluster Logs
         * @summary List Cluster Logs
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listClusterLogs(organizationId: string, clusterId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterLogsResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listClusterLogs(organizationId, clusterId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClustersApi.listClusterLogs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List organization clusters
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizationCluster(organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationCluster(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClustersApi.listOrganizationCluster']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lock a Cluster
         * @summary Lock Cluster
         * @param {string} clusterId 
         * @param {ClusterLockRequest} [clusterLockRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lockCluster(clusterId: string, clusterLockRequest?: ClusterLockRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterLock>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lockCluster(clusterId, clusterLockRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClustersApi.lockCluster']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Specify cluster cloud provider info and credentials
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {ClusterCloudProviderInfoRequest} [clusterCloudProviderInfoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async specifyClusterCloudProviderInfo(organizationId: string, clusterId: string, clusterCloudProviderInfoRequest?: ClusterCloudProviderInfoRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCloudProviderInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.specifyClusterCloudProviderInfo(organizationId, clusterId, clusterCloudProviderInfoRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClustersApi.specifyClusterCloudProviderInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cluster stop has been requester.
         * @summary Stop cluster
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopCluster(organizationId: string, clusterId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopCluster(organizationId, clusterId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClustersApi.stopCluster']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Unlock a cluster
         * @summary Unlock Cluster
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlockCluster(clusterId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlockCluster(clusterId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClustersApi.unlockCluster']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update karpenter private fargate subnet ids
         * @summary Update karpenter private fargate subnet ids
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {ClusterKarpenterPrivateSubnetIdsPutRequest} [clusterKarpenterPrivateSubnetIdsPutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateKarpenterPrivateFargateSubnetIds(organizationId: string, clusterId: string, clusterKarpenterPrivateSubnetIdsPutRequest?: ClusterKarpenterPrivateSubnetIdsPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateKarpenterPrivateFargateSubnetIds(organizationId, clusterId, clusterKarpenterPrivateSubnetIdsPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClustersApi.updateKarpenterPrivateFargateSubnetIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * allows to upgrade a cluster to next available kubernetes version
         * @summary Upgrade a cluster
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upgradeCluster(clusterId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.upgradeCluster(clusterId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClustersApi.upgradeCluster']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ClustersApi - factory interface
 * @export
 */
export const ClustersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClustersApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a cluster
         * @param {string} organizationId Organization ID
         * @param {ClusterRequest} [clusterRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCluster(organizationId: string, clusterRequest?: ClusterRequest, options?: RawAxiosRequestConfig): AxiosPromise<Cluster> {
            return localVarFp.createCluster(organizationId, clusterRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a cluster
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {ClusterDeleteMode} [deleteMode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCluster(organizationId: string, clusterId: string, deleteMode?: ClusterDeleteMode, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteCluster(organizationId, clusterId, deleteMode, options).then((request) => request(axios, basePath));
        },
        /**
         * allows to deploy a cluster
         * @summary Deploy a cluster
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {boolean} [dryRun] default: false. Decide if the deployment of the cluster should be done in dry_run mode. Avoiding any changes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployCluster(organizationId: string, clusterId: string, dryRun?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<ClusterStatus> {
            return localVarFp.deployCluster(organizationId, clusterId, dryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a cluster
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {ClusterRequest} [clusterRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editCluster(organizationId: string, clusterId: string, clusterRequest?: ClusterRequest, options?: RawAxiosRequestConfig): AxiosPromise<Cluster> {
            return localVarFp.editCluster(organizationId, clusterId, clusterRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit advanced settings by returning table of advanced settings.
         * @summary Edit advanced settings
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {ClusterAdvancedSettings} [clusterAdvancedSettings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editClusterAdvancedSettings(organizationId: string, clusterId: string, clusterAdvancedSettings?: ClusterAdvancedSettings, options?: RawAxiosRequestConfig): AxiosPromise<ClusterAdvancedSettings> {
            return localVarFp.editClusterAdvancedSettings(organizationId, clusterId, clusterAdvancedSettings, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit cluster kubeconfig
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editClusterKubeconfig(organizationId: string, clusterId: string, body?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.editClusterKubeconfig(organizationId, clusterId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit routing table by returning updated table.
         * @summary Edit routing table
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {ClusterRoutingTableRequest} [clusterRoutingTableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editRoutingTable(organizationId: string, clusterId: string, clusterRoutingTableRequest?: ClusterRoutingTableRequest, options?: RawAxiosRequestConfig): AxiosPromise<ClusterRoutingTable> {
            return localVarFp.editRoutingTable(organizationId, clusterId, clusterRoutingTableRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the list and values of the advanced settings of the cluster. Default values for each setting are available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/cluster-advanced-settings/) 
         * @summary Get advanced settings
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterAdvancedSettings(organizationId: string, clusterId: string, options?: RawAxiosRequestConfig): AxiosPromise<ClusterAdvancedSettings> {
            return localVarFp.getClusterAdvancedSettings(organizationId, clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get cluster kubeconfig
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {boolean} [withTokenFromCli] If true, the user auth part will have an exec command with qovery cli
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterKubeconfig(organizationId: string, clusterId: string, withTokenFromCli?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getClusterKubeconfig(organizationId, clusterId, withTokenFromCli, options).then((request) => request(axios, basePath));
        },
        /**
         * List Cluster Kubernetes Events
         * @summary List Cluster Kubernetes Events
         * @param {string} clusterId Cluster ID
         * @param {string} fromDateTime The start date time to fetch events from, following ISO-8601 format.   The &#x60;+&#x60; character must be escaped (&#x60;%2B&#x60;) 
         * @param {string} toDateTime The end date time to fetch events from, following ISO-8601 format.   The &#x60;+&#x60; character must be escaped (&#x60;%2B&#x60;) 
         * @param {string} [nodeName] The name of the node to fetch event from
         * @param {string} [podName] The name of the pod to fetch event from
         * @param {string} [reportingComponent] The name of the reporting component used to filter events.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterKubernetesEvents(clusterId: string, fromDateTime: string, toDateTime: string, nodeName?: string, podName?: string, reportingComponent?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetClusterKubernetesEvents200Response> {
            return localVarFp.getClusterKubernetesEvents(clusterId, fromDateTime, toDateTime, nodeName, podName, reportingComponent, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch cluster logs
         * @summary Fetch cluster logs
         * @param {string} clusterId 
         * @param {string} endpoint 
         * @param {string} query 
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {string} [limit] 
         * @param {string} [since] 
         * @param {string} [step] 
         * @param {string} [interval] 
         * @param {string} [direction] 
         * @param {string} [time] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterLogs(clusterId: string, endpoint: string, query: string, start?: string, end?: string, limit?: string, since?: string, step?: string, interval?: string, direction?: string, time?: string, options?: RawAxiosRequestConfig): AxiosPromise<ClusterLogsResponse> {
            return localVarFp.getClusterLogs(clusterId, endpoint, query, start, end, limit, since, step, interval, direction, time, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch cluster metrics.
         * @summary Fetch cluster metrics
         * @param {string} clusterId Cluster ID
         * @param {string} endpoint 
         * @param {string} query 
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {string} [step] 
         * @param {string} [time] 
         * @param {string} [timeout] 
         * @param {string} [dedup] 
         * @param {string} [partialResponse] 
         * @param {string} [maxSourceResolution] 
         * @param {string} [engine] 
         * @param {string} [analyze] 
         * @param {string} [boardShortName] 
         * @param {string} [metricShortName] 
         * @param {string} [traceId] 
         * @param {string} [range] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterMetrics(clusterId: string, endpoint: string, query: string, start?: string, end?: string, step?: string, time?: string, timeout?: string, dedup?: string, partialResponse?: string, maxSourceResolution?: string, engine?: string, analyze?: string, boardShortName?: string, metricShortName?: string, traceId?: string, range?: string, options?: RawAxiosRequestConfig): AxiosPromise<ClusterMetricsResponse> {
            return localVarFp.getClusterMetrics(clusterId, endpoint, query, start, end, step, time, timeout, dedup, partialResponse, maxSourceResolution, engine, analyze, boardShortName, metricShortName, traceId, range, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Know if a cluster is ready to be deployed or not
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterReadinessStatus(organizationId: string, clusterId: string, options?: RawAxiosRequestConfig): AxiosPromise<ClusterReadinessStatus> {
            return localVarFp.getClusterReadinessStatus(organizationId, clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get cluster status
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterStatus(organizationId: string, clusterId: string, options?: RawAxiosRequestConfig): AxiosPromise<ClusterStatus> {
            return localVarFp.getClusterStatus(organizationId, clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Default values for each setting are available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/cluster-advanced-settings/)
         * @summary List default cluster advanced settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultClusterAdvancedSettings(options?: RawAxiosRequestConfig): AxiosPromise<ClusterAdvancedSettings> {
            return localVarFp.getDefaultClusterAdvancedSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get cluster helm values for self managed installation
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstallationHelmValues(organizationId: string, clusterId: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getInstallationHelmValues(organizationId, clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get cluster cloud provider info and credentials
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationCloudProviderInfo(organizationId: string, clusterId: string, options?: RawAxiosRequestConfig): AxiosPromise<ClusterCloudProviderInfo> {
            return localVarFp.getOrganizationCloudProviderInfo(organizationId, clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of clusters with only their id and status.
         * @summary List all clusters statuses
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationClusterStatus(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise<ClusterStatusResponseList> {
            return localVarFp.getOrganizationClusterStatus(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve network routing table where each line corresponds to a route between a destination and a target.
         * @summary Get routing table
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutingTable(organizationId: string, clusterId: string, options?: RawAxiosRequestConfig): AxiosPromise<ClusterRoutingTable> {
            return localVarFp.getRoutingTable(organizationId, clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * List Cluster Logs
         * @summary List Cluster Logs
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listClusterLogs(organizationId: string, clusterId: string, options?: RawAxiosRequestConfig): AxiosPromise<ClusterLogsResponseList> {
            return localVarFp.listClusterLogs(organizationId, clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List organization clusters
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationCluster(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise<ClusterResponseList> {
            return localVarFp.listOrganizationCluster(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lock a Cluster
         * @summary Lock Cluster
         * @param {string} clusterId 
         * @param {ClusterLockRequest} [clusterLockRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lockCluster(clusterId: string, clusterLockRequest?: ClusterLockRequest, options?: RawAxiosRequestConfig): AxiosPromise<ClusterLock> {
            return localVarFp.lockCluster(clusterId, clusterLockRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Specify cluster cloud provider info and credentials
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {ClusterCloudProviderInfoRequest} [clusterCloudProviderInfoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifyClusterCloudProviderInfo(organizationId: string, clusterId: string, clusterCloudProviderInfoRequest?: ClusterCloudProviderInfoRequest, options?: RawAxiosRequestConfig): AxiosPromise<ClusterCloudProviderInfo> {
            return localVarFp.specifyClusterCloudProviderInfo(organizationId, clusterId, clusterCloudProviderInfoRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Cluster stop has been requester.
         * @summary Stop cluster
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopCluster(organizationId: string, clusterId: string, options?: RawAxiosRequestConfig): AxiosPromise<ClusterStatus> {
            return localVarFp.stopCluster(organizationId, clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Unlock a cluster
         * @summary Unlock Cluster
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlockCluster(clusterId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.unlockCluster(clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update karpenter private fargate subnet ids
         * @summary Update karpenter private fargate subnet ids
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {ClusterKarpenterPrivateSubnetIdsPutRequest} [clusterKarpenterPrivateSubnetIdsPutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKarpenterPrivateFargateSubnetIds(organizationId: string, clusterId: string, clusterKarpenterPrivateSubnetIdsPutRequest?: ClusterKarpenterPrivateSubnetIdsPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateKarpenterPrivateFargateSubnetIds(organizationId, clusterId, clusterKarpenterPrivateSubnetIdsPutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * allows to upgrade a cluster to next available kubernetes version
         * @summary Upgrade a cluster
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upgradeCluster(clusterId: string, options?: RawAxiosRequestConfig): AxiosPromise<ClusterStatus> {
            return localVarFp.upgradeCluster(clusterId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClustersApi - object-oriented interface
 * @export
 * @class ClustersApi
 * @extends {BaseAPI}
 */
export class ClustersApi extends BaseAPI {
    /**
     * 
     * @summary Create a cluster
     * @param {string} organizationId Organization ID
     * @param {ClusterRequest} [clusterRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public createCluster(organizationId: string, clusterRequest?: ClusterRequest, options?: RawAxiosRequestConfig) {
        return ClustersApiFp(this.configuration).createCluster(organizationId, clusterRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a cluster
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {ClusterDeleteMode} [deleteMode] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public deleteCluster(organizationId: string, clusterId: string, deleteMode?: ClusterDeleteMode, options?: RawAxiosRequestConfig) {
        return ClustersApiFp(this.configuration).deleteCluster(organizationId, clusterId, deleteMode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * allows to deploy a cluster
     * @summary Deploy a cluster
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {boolean} [dryRun] default: false. Decide if the deployment of the cluster should be done in dry_run mode. Avoiding any changes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public deployCluster(organizationId: string, clusterId: string, dryRun?: boolean, options?: RawAxiosRequestConfig) {
        return ClustersApiFp(this.configuration).deployCluster(organizationId, clusterId, dryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a cluster
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {ClusterRequest} [clusterRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public editCluster(organizationId: string, clusterId: string, clusterRequest?: ClusterRequest, options?: RawAxiosRequestConfig) {
        return ClustersApiFp(this.configuration).editCluster(organizationId, clusterId, clusterRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit advanced settings by returning table of advanced settings.
     * @summary Edit advanced settings
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {ClusterAdvancedSettings} [clusterAdvancedSettings] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public editClusterAdvancedSettings(organizationId: string, clusterId: string, clusterAdvancedSettings?: ClusterAdvancedSettings, options?: RawAxiosRequestConfig) {
        return ClustersApiFp(this.configuration).editClusterAdvancedSettings(organizationId, clusterId, clusterAdvancedSettings, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit cluster kubeconfig
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {string} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public editClusterKubeconfig(organizationId: string, clusterId: string, body?: string, options?: RawAxiosRequestConfig) {
        return ClustersApiFp(this.configuration).editClusterKubeconfig(organizationId, clusterId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit routing table by returning updated table.
     * @summary Edit routing table
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {ClusterRoutingTableRequest} [clusterRoutingTableRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public editRoutingTable(organizationId: string, clusterId: string, clusterRoutingTableRequest?: ClusterRoutingTableRequest, options?: RawAxiosRequestConfig) {
        return ClustersApiFp(this.configuration).editRoutingTable(organizationId, clusterId, clusterRoutingTableRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the list and values of the advanced settings of the cluster. Default values for each setting are available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/cluster-advanced-settings/) 
     * @summary Get advanced settings
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public getClusterAdvancedSettings(organizationId: string, clusterId: string, options?: RawAxiosRequestConfig) {
        return ClustersApiFp(this.configuration).getClusterAdvancedSettings(organizationId, clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get cluster kubeconfig
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {boolean} [withTokenFromCli] If true, the user auth part will have an exec command with qovery cli
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public getClusterKubeconfig(organizationId: string, clusterId: string, withTokenFromCli?: boolean, options?: RawAxiosRequestConfig) {
        return ClustersApiFp(this.configuration).getClusterKubeconfig(organizationId, clusterId, withTokenFromCli, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List Cluster Kubernetes Events
     * @summary List Cluster Kubernetes Events
     * @param {string} clusterId Cluster ID
     * @param {string} fromDateTime The start date time to fetch events from, following ISO-8601 format.   The &#x60;+&#x60; character must be escaped (&#x60;%2B&#x60;) 
     * @param {string} toDateTime The end date time to fetch events from, following ISO-8601 format.   The &#x60;+&#x60; character must be escaped (&#x60;%2B&#x60;) 
     * @param {string} [nodeName] The name of the node to fetch event from
     * @param {string} [podName] The name of the pod to fetch event from
     * @param {string} [reportingComponent] The name of the reporting component used to filter events.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public getClusterKubernetesEvents(clusterId: string, fromDateTime: string, toDateTime: string, nodeName?: string, podName?: string, reportingComponent?: string, options?: RawAxiosRequestConfig) {
        return ClustersApiFp(this.configuration).getClusterKubernetesEvents(clusterId, fromDateTime, toDateTime, nodeName, podName, reportingComponent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch cluster logs
     * @summary Fetch cluster logs
     * @param {string} clusterId 
     * @param {string} endpoint 
     * @param {string} query 
     * @param {string} [start] 
     * @param {string} [end] 
     * @param {string} [limit] 
     * @param {string} [since] 
     * @param {string} [step] 
     * @param {string} [interval] 
     * @param {string} [direction] 
     * @param {string} [time] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public getClusterLogs(clusterId: string, endpoint: string, query: string, start?: string, end?: string, limit?: string, since?: string, step?: string, interval?: string, direction?: string, time?: string, options?: RawAxiosRequestConfig) {
        return ClustersApiFp(this.configuration).getClusterLogs(clusterId, endpoint, query, start, end, limit, since, step, interval, direction, time, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch cluster metrics.
     * @summary Fetch cluster metrics
     * @param {string} clusterId Cluster ID
     * @param {string} endpoint 
     * @param {string} query 
     * @param {string} [start] 
     * @param {string} [end] 
     * @param {string} [step] 
     * @param {string} [time] 
     * @param {string} [timeout] 
     * @param {string} [dedup] 
     * @param {string} [partialResponse] 
     * @param {string} [maxSourceResolution] 
     * @param {string} [engine] 
     * @param {string} [analyze] 
     * @param {string} [boardShortName] 
     * @param {string} [metricShortName] 
     * @param {string} [traceId] 
     * @param {string} [range] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public getClusterMetrics(clusterId: string, endpoint: string, query: string, start?: string, end?: string, step?: string, time?: string, timeout?: string, dedup?: string, partialResponse?: string, maxSourceResolution?: string, engine?: string, analyze?: string, boardShortName?: string, metricShortName?: string, traceId?: string, range?: string, options?: RawAxiosRequestConfig) {
        return ClustersApiFp(this.configuration).getClusterMetrics(clusterId, endpoint, query, start, end, step, time, timeout, dedup, partialResponse, maxSourceResolution, engine, analyze, boardShortName, metricShortName, traceId, range, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Know if a cluster is ready to be deployed or not
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public getClusterReadinessStatus(organizationId: string, clusterId: string, options?: RawAxiosRequestConfig) {
        return ClustersApiFp(this.configuration).getClusterReadinessStatus(organizationId, clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get cluster status
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public getClusterStatus(organizationId: string, clusterId: string, options?: RawAxiosRequestConfig) {
        return ClustersApiFp(this.configuration).getClusterStatus(organizationId, clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Default values for each setting are available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/cluster-advanced-settings/)
     * @summary List default cluster advanced settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public getDefaultClusterAdvancedSettings(options?: RawAxiosRequestConfig) {
        return ClustersApiFp(this.configuration).getDefaultClusterAdvancedSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get cluster helm values for self managed installation
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public getInstallationHelmValues(organizationId: string, clusterId: string, options?: RawAxiosRequestConfig) {
        return ClustersApiFp(this.configuration).getInstallationHelmValues(organizationId, clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get cluster cloud provider info and credentials
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public getOrganizationCloudProviderInfo(organizationId: string, clusterId: string, options?: RawAxiosRequestConfig) {
        return ClustersApiFp(this.configuration).getOrganizationCloudProviderInfo(organizationId, clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of clusters with only their id and status.
     * @summary List all clusters statuses
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public getOrganizationClusterStatus(organizationId: string, options?: RawAxiosRequestConfig) {
        return ClustersApiFp(this.configuration).getOrganizationClusterStatus(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve network routing table where each line corresponds to a route between a destination and a target.
     * @summary Get routing table
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public getRoutingTable(organizationId: string, clusterId: string, options?: RawAxiosRequestConfig) {
        return ClustersApiFp(this.configuration).getRoutingTable(organizationId, clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List Cluster Logs
     * @summary List Cluster Logs
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public listClusterLogs(organizationId: string, clusterId: string, options?: RawAxiosRequestConfig) {
        return ClustersApiFp(this.configuration).listClusterLogs(organizationId, clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List organization clusters
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public listOrganizationCluster(organizationId: string, options?: RawAxiosRequestConfig) {
        return ClustersApiFp(this.configuration).listOrganizationCluster(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lock a Cluster
     * @summary Lock Cluster
     * @param {string} clusterId 
     * @param {ClusterLockRequest} [clusterLockRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public lockCluster(clusterId: string, clusterLockRequest?: ClusterLockRequest, options?: RawAxiosRequestConfig) {
        return ClustersApiFp(this.configuration).lockCluster(clusterId, clusterLockRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Specify cluster cloud provider info and credentials
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {ClusterCloudProviderInfoRequest} [clusterCloudProviderInfoRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public specifyClusterCloudProviderInfo(organizationId: string, clusterId: string, clusterCloudProviderInfoRequest?: ClusterCloudProviderInfoRequest, options?: RawAxiosRequestConfig) {
        return ClustersApiFp(this.configuration).specifyClusterCloudProviderInfo(organizationId, clusterId, clusterCloudProviderInfoRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cluster stop has been requester.
     * @summary Stop cluster
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public stopCluster(organizationId: string, clusterId: string, options?: RawAxiosRequestConfig) {
        return ClustersApiFp(this.configuration).stopCluster(organizationId, clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unlock a cluster
     * @summary Unlock Cluster
     * @param {string} clusterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public unlockCluster(clusterId: string, options?: RawAxiosRequestConfig) {
        return ClustersApiFp(this.configuration).unlockCluster(clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update karpenter private fargate subnet ids
     * @summary Update karpenter private fargate subnet ids
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {ClusterKarpenterPrivateSubnetIdsPutRequest} [clusterKarpenterPrivateSubnetIdsPutRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public updateKarpenterPrivateFargateSubnetIds(organizationId: string, clusterId: string, clusterKarpenterPrivateSubnetIdsPutRequest?: ClusterKarpenterPrivateSubnetIdsPutRequest, options?: RawAxiosRequestConfig) {
        return ClustersApiFp(this.configuration).updateKarpenterPrivateFargateSubnetIds(organizationId, clusterId, clusterKarpenterPrivateSubnetIdsPutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * allows to upgrade a cluster to next available kubernetes version
     * @summary Upgrade a cluster
     * @param {string} clusterId Cluster ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public upgradeCluster(clusterId: string, options?: RawAxiosRequestConfig) {
        return ClustersApiFp(this.configuration).upgradeCluster(clusterId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContainerActionsApi - axios parameter creator
 * @export
 */
export const ContainerActionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * You must provide a container image tag
         * @summary Deploy container
         * @param {string} containerId Container ID
         * @param {ContainerDeployRequest} [containerDeployRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployContainer: async (containerId: string, containerDeployRequest?: ContainerDeployRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('deployContainer', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/deploy`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(containerDeployRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reboot container
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rebootContainer: async (containerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('rebootContainer', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/restart-service`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Redeploy container
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeployContainer: async (containerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('redeployContainer', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/redeploy`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop container
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopContainer: async (containerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('stopContainer', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/stop`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the resources of the container but keep Qovery configuration
         * @summary Uninstall container
         * @param {string} containerId Container ID
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uninstallContainer: async (containerId: string, body?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('uninstallContainer', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/uninstall`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContainerActionsApi - functional programming interface
 * @export
 */
export const ContainerActionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContainerActionsApiAxiosParamCreator(configuration)
    return {
        /**
         * You must provide a container image tag
         * @summary Deploy container
         * @param {string} containerId Container ID
         * @param {ContainerDeployRequest} [containerDeployRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployContainer(containerId: string, containerDeployRequest?: ContainerDeployRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployContainer(containerId, containerDeployRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContainerActionsApi.deployContainer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Reboot container
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rebootContainer(containerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rebootContainer(containerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContainerActionsApi.rebootContainer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Redeploy container
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async redeployContainer(containerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.redeployContainer(containerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContainerActionsApi.redeployContainer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Stop container
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopContainer(containerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopContainer(containerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContainerActionsApi.stopContainer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete the resources of the container but keep Qovery configuration
         * @summary Uninstall container
         * @param {string} containerId Container ID
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uninstallContainer(containerId: string, body?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uninstallContainer(containerId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContainerActionsApi.uninstallContainer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContainerActionsApi - factory interface
 * @export
 */
export const ContainerActionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContainerActionsApiFp(configuration)
    return {
        /**
         * You must provide a container image tag
         * @summary Deploy container
         * @param {string} containerId Container ID
         * @param {ContainerDeployRequest} [containerDeployRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployContainer(containerId: string, containerDeployRequest?: ContainerDeployRequest, options?: RawAxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.deployContainer(containerId, containerDeployRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reboot container
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rebootContainer(containerId: string, options?: RawAxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.rebootContainer(containerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Redeploy container
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeployContainer(containerId: string, options?: RawAxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.redeployContainer(containerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Stop container
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopContainer(containerId: string, options?: RawAxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.stopContainer(containerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete the resources of the container but keep Qovery configuration
         * @summary Uninstall container
         * @param {string} containerId Container ID
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uninstallContainer(containerId: string, body?: object, options?: RawAxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.uninstallContainer(containerId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContainerActionsApi - object-oriented interface
 * @export
 * @class ContainerActionsApi
 * @extends {BaseAPI}
 */
export class ContainerActionsApi extends BaseAPI {
    /**
     * You must provide a container image tag
     * @summary Deploy container
     * @param {string} containerId Container ID
     * @param {ContainerDeployRequest} [containerDeployRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerActionsApi
     */
    public deployContainer(containerId: string, containerDeployRequest?: ContainerDeployRequest, options?: RawAxiosRequestConfig) {
        return ContainerActionsApiFp(this.configuration).deployContainer(containerId, containerDeployRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reboot container
     * @param {string} containerId Container ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerActionsApi
     */
    public rebootContainer(containerId: string, options?: RawAxiosRequestConfig) {
        return ContainerActionsApiFp(this.configuration).rebootContainer(containerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Redeploy container
     * @param {string} containerId Container ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerActionsApi
     */
    public redeployContainer(containerId: string, options?: RawAxiosRequestConfig) {
        return ContainerActionsApiFp(this.configuration).redeployContainer(containerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Stop container
     * @param {string} containerId Container ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerActionsApi
     */
    public stopContainer(containerId: string, options?: RawAxiosRequestConfig) {
        return ContainerActionsApiFp(this.configuration).stopContainer(containerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete the resources of the container but keep Qovery configuration
     * @summary Uninstall container
     * @param {string} containerId Container ID
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerActionsApi
     */
    public uninstallContainer(containerId: string, body?: object, options?: RawAxiosRequestConfig) {
        return ContainerActionsApiFp(this.configuration).uninstallContainer(containerId, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContainerConfigurationApi - axios parameter creator
 * @export
 */
export const ContainerConfigurationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Edit advanced settings by returning table of advanced settings.
         * @summary Edit advanced settings
         * @param {string} containerId Container ID
         * @param {ContainerAdvancedSettings} [containerAdvancedSettings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editContainerAdvancedSettings: async (containerId: string, containerAdvancedSettings?: ContainerAdvancedSettings, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('editContainerAdvancedSettings', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/advancedSettings`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(containerAdvancedSettings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit the Network settings of the container.
         * @summary Edit Container Network
         * @param {string} containerId Container ID
         * @param {ContainerNetworkRequest} [containerNetworkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editContainerNetwork: async (containerId: string, containerNetworkRequest?: ContainerNetworkRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('editContainerNetwork', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/network`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(containerNetworkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list and values of the advanced settings of the container. Default values for each setting are available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/advanced-settings/) 
         * @summary Get advanced settings
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainerAdvancedSettings: async (containerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('getContainerAdvancedSettings', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/advancedSettings`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get status of the container network settings.
         * @summary Get Container Network information
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainerNetwork: async (containerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('getContainerNetwork', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/network`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContainerConfigurationApi - functional programming interface
 * @export
 */
export const ContainerConfigurationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContainerConfigurationApiAxiosParamCreator(configuration)
    return {
        /**
         * Edit advanced settings by returning table of advanced settings.
         * @summary Edit advanced settings
         * @param {string} containerId Container ID
         * @param {ContainerAdvancedSettings} [containerAdvancedSettings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editContainerAdvancedSettings(containerId: string, containerAdvancedSettings?: ContainerAdvancedSettings, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerAdvancedSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editContainerAdvancedSettings(containerId, containerAdvancedSettings, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContainerConfigurationApi.editContainerAdvancedSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Edit the Network settings of the container.
         * @summary Edit Container Network
         * @param {string} containerId Container ID
         * @param {ContainerNetworkRequest} [containerNetworkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editContainerNetwork(containerId: string, containerNetworkRequest?: ContainerNetworkRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerNetwork>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editContainerNetwork(containerId, containerNetworkRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContainerConfigurationApi.editContainerNetwork']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get list and values of the advanced settings of the container. Default values for each setting are available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/advanced-settings/) 
         * @summary Get advanced settings
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContainerAdvancedSettings(containerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerAdvancedSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContainerAdvancedSettings(containerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContainerConfigurationApi.getContainerAdvancedSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get status of the container network settings.
         * @summary Get Container Network information
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContainerNetwork(containerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerNetwork>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContainerNetwork(containerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContainerConfigurationApi.getContainerNetwork']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContainerConfigurationApi - factory interface
 * @export
 */
export const ContainerConfigurationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContainerConfigurationApiFp(configuration)
    return {
        /**
         * Edit advanced settings by returning table of advanced settings.
         * @summary Edit advanced settings
         * @param {string} containerId Container ID
         * @param {ContainerAdvancedSettings} [containerAdvancedSettings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editContainerAdvancedSettings(containerId: string, containerAdvancedSettings?: ContainerAdvancedSettings, options?: RawAxiosRequestConfig): AxiosPromise<ContainerAdvancedSettings> {
            return localVarFp.editContainerAdvancedSettings(containerId, containerAdvancedSettings, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit the Network settings of the container.
         * @summary Edit Container Network
         * @param {string} containerId Container ID
         * @param {ContainerNetworkRequest} [containerNetworkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editContainerNetwork(containerId: string, containerNetworkRequest?: ContainerNetworkRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContainerNetwork> {
            return localVarFp.editContainerNetwork(containerId, containerNetworkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get list and values of the advanced settings of the container. Default values for each setting are available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/advanced-settings/) 
         * @summary Get advanced settings
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainerAdvancedSettings(containerId: string, options?: RawAxiosRequestConfig): AxiosPromise<ContainerAdvancedSettings> {
            return localVarFp.getContainerAdvancedSettings(containerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get status of the container network settings.
         * @summary Get Container Network information
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainerNetwork(containerId: string, options?: RawAxiosRequestConfig): AxiosPromise<ContainerNetwork> {
            return localVarFp.getContainerNetwork(containerId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContainerConfigurationApi - object-oriented interface
 * @export
 * @class ContainerConfigurationApi
 * @extends {BaseAPI}
 */
export class ContainerConfigurationApi extends BaseAPI {
    /**
     * Edit advanced settings by returning table of advanced settings.
     * @summary Edit advanced settings
     * @param {string} containerId Container ID
     * @param {ContainerAdvancedSettings} [containerAdvancedSettings] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerConfigurationApi
     */
    public editContainerAdvancedSettings(containerId: string, containerAdvancedSettings?: ContainerAdvancedSettings, options?: RawAxiosRequestConfig) {
        return ContainerConfigurationApiFp(this.configuration).editContainerAdvancedSettings(containerId, containerAdvancedSettings, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit the Network settings of the container.
     * @summary Edit Container Network
     * @param {string} containerId Container ID
     * @param {ContainerNetworkRequest} [containerNetworkRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerConfigurationApi
     */
    public editContainerNetwork(containerId: string, containerNetworkRequest?: ContainerNetworkRequest, options?: RawAxiosRequestConfig) {
        return ContainerConfigurationApiFp(this.configuration).editContainerNetwork(containerId, containerNetworkRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list and values of the advanced settings of the container. Default values for each setting are available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/advanced-settings/) 
     * @summary Get advanced settings
     * @param {string} containerId Container ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerConfigurationApi
     */
    public getContainerAdvancedSettings(containerId: string, options?: RawAxiosRequestConfig) {
        return ContainerConfigurationApiFp(this.configuration).getContainerAdvancedSettings(containerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get status of the container network settings.
     * @summary Get Container Network information
     * @param {string} containerId Container ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerConfigurationApi
     */
    public getContainerNetwork(containerId: string, options?: RawAxiosRequestConfig) {
        return ContainerConfigurationApiFp(this.configuration).getContainerNetwork(containerId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContainerCustomDomainApi - axios parameter creator
 * @export
 */
export const ContainerCustomDomainApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Check Container Custom Domain
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkContainerCustomDomain: async (containerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('checkContainerCustomDomain', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/checkCustomDomain`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a custom domain to this container in order not to use qovery autogenerated domain
         * @summary Add custom domain to the container.
         * @param {string} containerId Container ID
         * @param {CustomDomainRequest} [customDomainRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainerCustomDomain: async (containerId: string, customDomainRequest?: CustomDomainRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('createContainerCustomDomain', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/customDomain`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customDomainRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To delete an CustomDomain you must have the project user permission
         * @summary Delete a Custom Domain
         * @param {string} containerId Container ID
         * @param {string} customDomainId Custom Domain ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContainerCustomDomain: async (containerId: string, customDomainId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('deleteContainerCustomDomain', 'containerId', containerId)
            // verify required parameter 'customDomainId' is not null or undefined
            assertParamExists('deleteContainerCustomDomain', 'customDomainId', customDomainId)
            const localVarPath = `/container/{containerId}/customDomain/{customDomainId}`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"customDomainId"}}`, encodeURIComponent(String(customDomainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To edit a Custom Domain  you must have the project user permission
         * @summary Edit a Custom Domain
         * @param {string} containerId Container ID
         * @param {string} customDomainId Custom Domain ID
         * @param {CustomDomainRequest} [customDomainRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editContainerCustomDomain: async (containerId: string, customDomainId: string, customDomainRequest?: CustomDomainRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('editContainerCustomDomain', 'containerId', containerId)
            // verify required parameter 'customDomainId' is not null or undefined
            assertParamExists('editContainerCustomDomain', 'customDomainId', customDomainId)
            const localVarPath = `/container/{containerId}/customDomain/{customDomainId}`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"customDomainId"}}`, encodeURIComponent(String(customDomainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customDomainRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Custom Domain status
         * @param {string} containerId Container ID
         * @param {string} customDomainId Custom Domain ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainerCustomDomainStatus: async (containerId: string, customDomainId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('getContainerCustomDomainStatus', 'containerId', containerId)
            // verify required parameter 'customDomainId' is not null or undefined
            assertParamExists('getContainerCustomDomainStatus', 'customDomainId', customDomainId)
            const localVarPath = `/container/{containerId}/customDomain/{customDomainId}/status`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"customDomainId"}}`, encodeURIComponent(String(customDomainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List container custom domains
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerCustomDomain: async (containerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('listContainerCustomDomain', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/customDomain`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContainerCustomDomainApi - functional programming interface
 * @export
 */
export const ContainerCustomDomainApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContainerCustomDomainApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Check Container Custom Domain
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkContainerCustomDomain(containerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckedCustomDomainsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkContainerCustomDomain(containerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContainerCustomDomainApi.checkContainerCustomDomain']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add a custom domain to this container in order not to use qovery autogenerated domain
         * @summary Add custom domain to the container.
         * @param {string} containerId Container ID
         * @param {CustomDomainRequest} [customDomainRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContainerCustomDomain(containerId: string, customDomainRequest?: CustomDomainRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomDomain>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContainerCustomDomain(containerId, customDomainRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContainerCustomDomainApi.createContainerCustomDomain']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * To delete an CustomDomain you must have the project user permission
         * @summary Delete a Custom Domain
         * @param {string} containerId Container ID
         * @param {string} customDomainId Custom Domain ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteContainerCustomDomain(containerId: string, customDomainId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteContainerCustomDomain(containerId, customDomainId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContainerCustomDomainApi.deleteContainerCustomDomain']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * To edit a Custom Domain  you must have the project user permission
         * @summary Edit a Custom Domain
         * @param {string} containerId Container ID
         * @param {string} customDomainId Custom Domain ID
         * @param {CustomDomainRequest} [customDomainRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editContainerCustomDomain(containerId: string, customDomainId: string, customDomainRequest?: CustomDomainRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomDomain>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editContainerCustomDomain(containerId, customDomainId, customDomainRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContainerCustomDomainApi.editContainerCustomDomain']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Custom Domain status
         * @param {string} containerId Container ID
         * @param {string} customDomainId Custom Domain ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContainerCustomDomainStatus(containerId: string, customDomainId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomDomain>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContainerCustomDomainStatus(containerId, customDomainId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContainerCustomDomainApi.getContainerCustomDomainStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List container custom domains
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContainerCustomDomain(containerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomDomainResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listContainerCustomDomain(containerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContainerCustomDomainApi.listContainerCustomDomain']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContainerCustomDomainApi - factory interface
 * @export
 */
export const ContainerCustomDomainApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContainerCustomDomainApiFp(configuration)
    return {
        /**
         * 
         * @summary Check Container Custom Domain
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkContainerCustomDomain(containerId: string, options?: RawAxiosRequestConfig): AxiosPromise<CheckedCustomDomainsResponse> {
            return localVarFp.checkContainerCustomDomain(containerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a custom domain to this container in order not to use qovery autogenerated domain
         * @summary Add custom domain to the container.
         * @param {string} containerId Container ID
         * @param {CustomDomainRequest} [customDomainRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainerCustomDomain(containerId: string, customDomainRequest?: CustomDomainRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomDomain> {
            return localVarFp.createContainerCustomDomain(containerId, customDomainRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * To delete an CustomDomain you must have the project user permission
         * @summary Delete a Custom Domain
         * @param {string} containerId Container ID
         * @param {string} customDomainId Custom Domain ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContainerCustomDomain(containerId: string, customDomainId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteContainerCustomDomain(containerId, customDomainId, options).then((request) => request(axios, basePath));
        },
        /**
         * To edit a Custom Domain  you must have the project user permission
         * @summary Edit a Custom Domain
         * @param {string} containerId Container ID
         * @param {string} customDomainId Custom Domain ID
         * @param {CustomDomainRequest} [customDomainRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editContainerCustomDomain(containerId: string, customDomainId: string, customDomainRequest?: CustomDomainRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomDomain> {
            return localVarFp.editContainerCustomDomain(containerId, customDomainId, customDomainRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Custom Domain status
         * @param {string} containerId Container ID
         * @param {string} customDomainId Custom Domain ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainerCustomDomainStatus(containerId: string, customDomainId: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomDomain> {
            return localVarFp.getContainerCustomDomainStatus(containerId, customDomainId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List container custom domains
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerCustomDomain(containerId: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomDomainResponseList> {
            return localVarFp.listContainerCustomDomain(containerId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContainerCustomDomainApi - object-oriented interface
 * @export
 * @class ContainerCustomDomainApi
 * @extends {BaseAPI}
 */
export class ContainerCustomDomainApi extends BaseAPI {
    /**
     * 
     * @summary Check Container Custom Domain
     * @param {string} containerId Container ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerCustomDomainApi
     */
    public checkContainerCustomDomain(containerId: string, options?: RawAxiosRequestConfig) {
        return ContainerCustomDomainApiFp(this.configuration).checkContainerCustomDomain(containerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a custom domain to this container in order not to use qovery autogenerated domain
     * @summary Add custom domain to the container.
     * @param {string} containerId Container ID
     * @param {CustomDomainRequest} [customDomainRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerCustomDomainApi
     */
    public createContainerCustomDomain(containerId: string, customDomainRequest?: CustomDomainRequest, options?: RawAxiosRequestConfig) {
        return ContainerCustomDomainApiFp(this.configuration).createContainerCustomDomain(containerId, customDomainRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To delete an CustomDomain you must have the project user permission
     * @summary Delete a Custom Domain
     * @param {string} containerId Container ID
     * @param {string} customDomainId Custom Domain ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerCustomDomainApi
     */
    public deleteContainerCustomDomain(containerId: string, customDomainId: string, options?: RawAxiosRequestConfig) {
        return ContainerCustomDomainApiFp(this.configuration).deleteContainerCustomDomain(containerId, customDomainId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To edit a Custom Domain  you must have the project user permission
     * @summary Edit a Custom Domain
     * @param {string} containerId Container ID
     * @param {string} customDomainId Custom Domain ID
     * @param {CustomDomainRequest} [customDomainRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerCustomDomainApi
     */
    public editContainerCustomDomain(containerId: string, customDomainId: string, customDomainRequest?: CustomDomainRequest, options?: RawAxiosRequestConfig) {
        return ContainerCustomDomainApiFp(this.configuration).editContainerCustomDomain(containerId, customDomainId, customDomainRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Custom Domain status
     * @param {string} containerId Container ID
     * @param {string} customDomainId Custom Domain ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerCustomDomainApi
     */
    public getContainerCustomDomainStatus(containerId: string, customDomainId: string, options?: RawAxiosRequestConfig) {
        return ContainerCustomDomainApiFp(this.configuration).getContainerCustomDomainStatus(containerId, customDomainId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List container custom domains
     * @param {string} containerId Container ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerCustomDomainApi
     */
    public listContainerCustomDomain(containerId: string, options?: RawAxiosRequestConfig) {
        return ContainerCustomDomainApiFp(this.configuration).listContainerCustomDomain(containerId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContainerDeploymentHistoryApi - axios parameter creator
 * @export
 */
export const ContainerDeploymentHistoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the 20 last container deployments
         * @summary List container deployments
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerDeploymentHistory: async (containerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('listContainerDeploymentHistory', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/deploymentHistory`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the 20 last container deployments
         * @summary List container deployments
         * @param {string} containerId Container ID
         * @param {number | null} [pageSize] The number of deployments to return in the current page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerDeploymentHistoryV2: async (containerId: string, pageSize?: number | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('listContainerDeploymentHistoryV2', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/deploymentHistoryV2`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContainerDeploymentHistoryApi - functional programming interface
 * @export
 */
export const ContainerDeploymentHistoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContainerDeploymentHistoryApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the 20 last container deployments
         * @summary List container deployments
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContainerDeploymentHistory(containerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListContainerDeploymentHistory200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listContainerDeploymentHistory(containerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContainerDeploymentHistoryApi.listContainerDeploymentHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the 20 last container deployments
         * @summary List container deployments
         * @param {string} containerId Container ID
         * @param {number | null} [pageSize] The number of deployments to return in the current page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContainerDeploymentHistoryV2(containerId: string, pageSize?: number | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentHistoryServicePaginatedResponseListV2>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listContainerDeploymentHistoryV2(containerId, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContainerDeploymentHistoryApi.listContainerDeploymentHistoryV2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContainerDeploymentHistoryApi - factory interface
 * @export
 */
export const ContainerDeploymentHistoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContainerDeploymentHistoryApiFp(configuration)
    return {
        /**
         * Returns the 20 last container deployments
         * @summary List container deployments
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerDeploymentHistory(containerId: string, options?: RawAxiosRequestConfig): AxiosPromise<ListContainerDeploymentHistory200Response> {
            return localVarFp.listContainerDeploymentHistory(containerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the 20 last container deployments
         * @summary List container deployments
         * @param {string} containerId Container ID
         * @param {number | null} [pageSize] The number of deployments to return in the current page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerDeploymentHistoryV2(containerId: string, pageSize?: number | null, options?: RawAxiosRequestConfig): AxiosPromise<DeploymentHistoryServicePaginatedResponseListV2> {
            return localVarFp.listContainerDeploymentHistoryV2(containerId, pageSize, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContainerDeploymentHistoryApi - object-oriented interface
 * @export
 * @class ContainerDeploymentHistoryApi
 * @extends {BaseAPI}
 */
export class ContainerDeploymentHistoryApi extends BaseAPI {
    /**
     * Returns the 20 last container deployments
     * @summary List container deployments
     * @param {string} containerId Container ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerDeploymentHistoryApi
     */
    public listContainerDeploymentHistory(containerId: string, options?: RawAxiosRequestConfig) {
        return ContainerDeploymentHistoryApiFp(this.configuration).listContainerDeploymentHistory(containerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the 20 last container deployments
     * @summary List container deployments
     * @param {string} containerId Container ID
     * @param {number | null} [pageSize] The number of deployments to return in the current page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerDeploymentHistoryApi
     */
    public listContainerDeploymentHistoryV2(containerId: string, pageSize?: number | null, options?: RawAxiosRequestConfig) {
        return ContainerDeploymentHistoryApiFp(this.configuration).listContainerDeploymentHistoryV2(containerId, pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContainerEnvironmentVariableApi - axios parameter creator
 * @export
 */
export const ContainerEnvironmentVariableApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * - Add an environment variable to the container. 
         * @summary Add an environment variable to the container
         * @param {string} containerId Container ID
         * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainerEnvironmentVariable: async (containerId: string, environmentVariableRequest?: EnvironmentVariableRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('createContainerEnvironmentVariable', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/environmentVariable`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentVariableRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to add an alias at container level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at container level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - You can\'t create an alias on an alias 
         * @summary Create an environment variable alias at the container level
         * @param {string} containerId Container ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainerEnvironmentVariableAlias: async (containerId: string, environmentVariableId: string, key?: Key, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('createContainerEnvironmentVariableAlias', 'containerId', containerId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('createContainerEnvironmentVariableAlias', 'environmentVariableId', environmentVariableId)
            const localVarPath = `/container/{containerId}/environmentVariable/{environmentVariableId}/alias`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(key, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to override at container level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at container level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
         * @summary Create an environment variable override at the container level
         * @param {string} containerId Container ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainerEnvironmentVariableOverride: async (containerId: string, environmentVariableId: string, value?: Value, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('createContainerEnvironmentVariableOverride', 'containerId', containerId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('createContainerEnvironmentVariableOverride', 'environmentVariableId', environmentVariableId)
            const localVarPath = `/container/{containerId}/environmentVariable/{environmentVariableId}/override`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(value, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - To delete an environment variable from an container you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete an environment variable from a container
         * @param {string} containerId Container ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContainerEnvironmentVariable: async (containerId: string, environmentVariableId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('deleteContainerEnvironmentVariable', 'containerId', containerId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('deleteContainerEnvironmentVariable', 'environmentVariableId', environmentVariableId)
            const localVarPath = `/container/{containerId}/environmentVariable/{environmentVariableId}`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > CONTAINER) 
         * @summary Edit an environment variable belonging to the container
         * @param {string} containerId Container ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editContainerEnvironmentVariable: async (containerId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('editContainerEnvironmentVariable', 'containerId', containerId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('editContainerEnvironmentVariable', 'environmentVariableId', environmentVariableId)
            // verify required parameter 'environmentVariableEditRequest' is not null or undefined
            assertParamExists('editContainerEnvironmentVariable', 'environmentVariableEditRequest', environmentVariableEditRequest)
            const localVarPath = `/container/{containerId}/environmentVariable/{environmentVariableId}`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentVariableEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Import environment variables in a defined scope, with a defined visibility.
         * @summary Import variables
         * @param {string} containerId Container ID
         * @param {VariableImportRequest} [variableImportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importContainerEnvironmentVariable: async (containerId: string, variableImportRequest?: VariableImportRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('importContainerEnvironmentVariable', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/environmentVariable/import`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(variableImportRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List environment variables
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerEnvironmentVariable: async (containerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('listContainerEnvironmentVariable', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/environmentVariable`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContainerEnvironmentVariableApi - functional programming interface
 * @export
 */
export const ContainerEnvironmentVariableApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContainerEnvironmentVariableApiAxiosParamCreator(configuration)
    return {
        /**
         * - Add an environment variable to the container. 
         * @summary Add an environment variable to the container
         * @param {string} containerId Container ID
         * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContainerEnvironmentVariable(containerId: string, environmentVariableRequest?: EnvironmentVariableRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContainerEnvironmentVariable(containerId, environmentVariableRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContainerEnvironmentVariableApi.createContainerEnvironmentVariable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - Allows you to add an alias at container level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at container level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - You can\'t create an alias on an alias 
         * @summary Create an environment variable alias at the container level
         * @param {string} containerId Container ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContainerEnvironmentVariableAlias(containerId: string, environmentVariableId: string, key?: Key, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContainerEnvironmentVariableAlias(containerId, environmentVariableId, key, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContainerEnvironmentVariableApi.createContainerEnvironmentVariableAlias']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - Allows you to override at container level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at container level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
         * @summary Create an environment variable override at the container level
         * @param {string} containerId Container ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContainerEnvironmentVariableOverride(containerId: string, environmentVariableId: string, value?: Value, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContainerEnvironmentVariableOverride(containerId, environmentVariableId, value, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContainerEnvironmentVariableApi.createContainerEnvironmentVariableOverride']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - To delete an environment variable from an container you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete an environment variable from a container
         * @param {string} containerId Container ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteContainerEnvironmentVariable(containerId: string, environmentVariableId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteContainerEnvironmentVariable(containerId, environmentVariableId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContainerEnvironmentVariableApi.deleteContainerEnvironmentVariable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > CONTAINER) 
         * @summary Edit an environment variable belonging to the container
         * @param {string} containerId Container ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editContainerEnvironmentVariable(containerId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editContainerEnvironmentVariable(containerId, environmentVariableId, environmentVariableEditRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContainerEnvironmentVariableApi.editContainerEnvironmentVariable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Import environment variables in a defined scope, with a defined visibility.
         * @summary Import variables
         * @param {string} containerId Container ID
         * @param {VariableImportRequest} [variableImportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importContainerEnvironmentVariable(containerId: string, variableImportRequest?: VariableImportRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariableImport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importContainerEnvironmentVariable(containerId, variableImportRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContainerEnvironmentVariableApi.importContainerEnvironmentVariable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List environment variables
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContainerEnvironmentVariable(containerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariableResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listContainerEnvironmentVariable(containerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContainerEnvironmentVariableApi.listContainerEnvironmentVariable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContainerEnvironmentVariableApi - factory interface
 * @export
 */
export const ContainerEnvironmentVariableApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContainerEnvironmentVariableApiFp(configuration)
    return {
        /**
         * - Add an environment variable to the container. 
         * @summary Add an environment variable to the container
         * @param {string} containerId Container ID
         * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainerEnvironmentVariable(containerId: string, environmentVariableRequest?: EnvironmentVariableRequest, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentVariable> {
            return localVarFp.createContainerEnvironmentVariable(containerId, environmentVariableRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to add an alias at container level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at container level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - You can\'t create an alias on an alias 
         * @summary Create an environment variable alias at the container level
         * @param {string} containerId Container ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainerEnvironmentVariableAlias(containerId: string, environmentVariableId: string, key?: Key, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentVariable> {
            return localVarFp.createContainerEnvironmentVariableAlias(containerId, environmentVariableId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to override at container level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at container level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
         * @summary Create an environment variable override at the container level
         * @param {string} containerId Container ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainerEnvironmentVariableOverride(containerId: string, environmentVariableId: string, value?: Value, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentVariable> {
            return localVarFp.createContainerEnvironmentVariableOverride(containerId, environmentVariableId, value, options).then((request) => request(axios, basePath));
        },
        /**
         * - To delete an environment variable from an container you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete an environment variable from a container
         * @param {string} containerId Container ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContainerEnvironmentVariable(containerId: string, environmentVariableId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteContainerEnvironmentVariable(containerId, environmentVariableId, options).then((request) => request(axios, basePath));
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > CONTAINER) 
         * @summary Edit an environment variable belonging to the container
         * @param {string} containerId Container ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editContainerEnvironmentVariable(containerId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentVariable> {
            return localVarFp.editContainerEnvironmentVariable(containerId, environmentVariableId, environmentVariableEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Import environment variables in a defined scope, with a defined visibility.
         * @summary Import variables
         * @param {string} containerId Container ID
         * @param {VariableImportRequest} [variableImportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importContainerEnvironmentVariable(containerId: string, variableImportRequest?: VariableImportRequest, options?: RawAxiosRequestConfig): AxiosPromise<VariableImport> {
            return localVarFp.importContainerEnvironmentVariable(containerId, variableImportRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List environment variables
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerEnvironmentVariable(containerId: string, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentVariableResponseList> {
            return localVarFp.listContainerEnvironmentVariable(containerId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContainerEnvironmentVariableApi - object-oriented interface
 * @export
 * @class ContainerEnvironmentVariableApi
 * @extends {BaseAPI}
 */
export class ContainerEnvironmentVariableApi extends BaseAPI {
    /**
     * - Add an environment variable to the container. 
     * @summary Add an environment variable to the container
     * @param {string} containerId Container ID
     * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerEnvironmentVariableApi
     */
    public createContainerEnvironmentVariable(containerId: string, environmentVariableRequest?: EnvironmentVariableRequest, options?: RawAxiosRequestConfig) {
        return ContainerEnvironmentVariableApiFp(this.configuration).createContainerEnvironmentVariable(containerId, environmentVariableRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to add an alias at container level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at container level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - You can\'t create an alias on an alias 
     * @summary Create an environment variable alias at the container level
     * @param {string} containerId Container ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {Key} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerEnvironmentVariableApi
     */
    public createContainerEnvironmentVariableAlias(containerId: string, environmentVariableId: string, key?: Key, options?: RawAxiosRequestConfig) {
        return ContainerEnvironmentVariableApiFp(this.configuration).createContainerEnvironmentVariableAlias(containerId, environmentVariableId, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to override at container level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at container level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
     * @summary Create an environment variable override at the container level
     * @param {string} containerId Container ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {Value} [value] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerEnvironmentVariableApi
     */
    public createContainerEnvironmentVariableOverride(containerId: string, environmentVariableId: string, value?: Value, options?: RawAxiosRequestConfig) {
        return ContainerEnvironmentVariableApiFp(this.configuration).createContainerEnvironmentVariableOverride(containerId, environmentVariableId, value, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - To delete an environment variable from an container you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
     * @summary Delete an environment variable from a container
     * @param {string} containerId Container ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerEnvironmentVariableApi
     */
    public deleteContainerEnvironmentVariable(containerId: string, environmentVariableId: string, options?: RawAxiosRequestConfig) {
        return ContainerEnvironmentVariableApiFp(this.configuration).deleteContainerEnvironmentVariable(containerId, environmentVariableId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > CONTAINER) 
     * @summary Edit an environment variable belonging to the container
     * @param {string} containerId Container ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerEnvironmentVariableApi
     */
    public editContainerEnvironmentVariable(containerId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options?: RawAxiosRequestConfig) {
        return ContainerEnvironmentVariableApiFp(this.configuration).editContainerEnvironmentVariable(containerId, environmentVariableId, environmentVariableEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Import environment variables in a defined scope, with a defined visibility.
     * @summary Import variables
     * @param {string} containerId Container ID
     * @param {VariableImportRequest} [variableImportRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerEnvironmentVariableApi
     */
    public importContainerEnvironmentVariable(containerId: string, variableImportRequest?: VariableImportRequest, options?: RawAxiosRequestConfig) {
        return ContainerEnvironmentVariableApiFp(this.configuration).importContainerEnvironmentVariable(containerId, variableImportRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List environment variables
     * @param {string} containerId Container ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerEnvironmentVariableApi
     */
    public listContainerEnvironmentVariable(containerId: string, options?: RawAxiosRequestConfig) {
        return ContainerEnvironmentVariableApiFp(this.configuration).listContainerEnvironmentVariable(containerId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContainerLogsApi - axios parameter creator
 * @export
 */
export const ContainerLogsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This will list the last 1000 logs of the container
         * @summary List logs
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerLog: async (containerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('listContainerLog', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/log`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContainerLogsApi - functional programming interface
 * @export
 */
export const ContainerLogsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContainerLogsApiAxiosParamCreator(configuration)
    return {
        /**
         * This will list the last 1000 logs of the container
         * @summary List logs
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContainerLog(containerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listContainerLog(containerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContainerLogsApi.listContainerLog']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContainerLogsApi - factory interface
 * @export
 */
export const ContainerLogsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContainerLogsApiFp(configuration)
    return {
        /**
         * This will list the last 1000 logs of the container
         * @summary List logs
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerLog(containerId: string, options?: RawAxiosRequestConfig): AxiosPromise<LogResponseList> {
            return localVarFp.listContainerLog(containerId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContainerLogsApi - object-oriented interface
 * @export
 * @class ContainerLogsApi
 * @extends {BaseAPI}
 */
export class ContainerLogsApi extends BaseAPI {
    /**
     * This will list the last 1000 logs of the container
     * @summary List logs
     * @param {string} containerId Container ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerLogsApi
     */
    public listContainerLog(containerId: string, options?: RawAxiosRequestConfig) {
        return ContainerLogsApiFp(this.configuration).listContainerLog(containerId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContainerMainCallsApi - axios parameter creator
 * @export
 */
export const ContainerMainCallsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * To delete the container you must have the admin permission
         * @summary Delete container
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContainer: async (containerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('deleteContainer', 'containerId', containerId)
            const localVarPath = `/container/{containerId}`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - To edit the container you must have the admin permission. - For port edition, if you provide a port id, we will update the corresponding port. If you don\'t we will create a new one. If you remove a port from the payload, we will delete it. - For storage edition, if you provide a storage id, we will update the corresponding storage. If you don\'t we will create a new one. If you remove a storage from the payload, we will delete it. 
         * @summary Edit container
         * @param {string} containerId Container ID
         * @param {ContainerRequest} [containerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editContainer: async (containerId: string, containerRequest?: ContainerRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('editContainer', 'containerId', containerId)
            const localVarPath = `/container/{containerId}`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(containerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get container by ID
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainer: async (containerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('getContainer', 'containerId', containerId)
            const localVarPath = `/container/{containerId}`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get container status
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainerStatus: async (containerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('getContainerStatus', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/status`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This will return all the custom domains and Qovery autogenerated domain for the given container
         * @summary List all URLs of the container
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerLinks: async (containerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('listContainerLinks', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/link`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContainerMainCallsApi - functional programming interface
 * @export
 */
export const ContainerMainCallsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContainerMainCallsApiAxiosParamCreator(configuration)
    return {
        /**
         * To delete the container you must have the admin permission
         * @summary Delete container
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteContainer(containerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteContainer(containerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContainerMainCallsApi.deleteContainer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - To edit the container you must have the admin permission. - For port edition, if you provide a port id, we will update the corresponding port. If you don\'t we will create a new one. If you remove a port from the payload, we will delete it. - For storage edition, if you provide a storage id, we will update the corresponding storage. If you don\'t we will create a new one. If you remove a storage from the payload, we will delete it. 
         * @summary Edit container
         * @param {string} containerId Container ID
         * @param {ContainerRequest} [containerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editContainer(containerId: string, containerRequest?: ContainerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editContainer(containerId, containerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContainerMainCallsApi.editContainer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get container by ID
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContainer(containerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContainer(containerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContainerMainCallsApi.getContainer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get container status
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContainerStatus(containerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContainerStatus(containerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContainerMainCallsApi.getContainerStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This will return all the custom domains and Qovery autogenerated domain for the given container
         * @summary List all URLs of the container
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContainerLinks(containerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listContainerLinks(containerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContainerMainCallsApi.listContainerLinks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContainerMainCallsApi - factory interface
 * @export
 */
export const ContainerMainCallsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContainerMainCallsApiFp(configuration)
    return {
        /**
         * To delete the container you must have the admin permission
         * @summary Delete container
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContainer(containerId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteContainer(containerId, options).then((request) => request(axios, basePath));
        },
        /**
         * - To edit the container you must have the admin permission. - For port edition, if you provide a port id, we will update the corresponding port. If you don\'t we will create a new one. If you remove a port from the payload, we will delete it. - For storage edition, if you provide a storage id, we will update the corresponding storage. If you don\'t we will create a new one. If you remove a storage from the payload, we will delete it. 
         * @summary Edit container
         * @param {string} containerId Container ID
         * @param {ContainerRequest} [containerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editContainer(containerId: string, containerRequest?: ContainerRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContainerResponse> {
            return localVarFp.editContainer(containerId, containerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get container by ID
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainer(containerId: string, options?: RawAxiosRequestConfig): AxiosPromise<ContainerResponse> {
            return localVarFp.getContainer(containerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get container status
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainerStatus(containerId: string, options?: RawAxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.getContainerStatus(containerId, options).then((request) => request(axios, basePath));
        },
        /**
         * This will return all the custom domains and Qovery autogenerated domain for the given container
         * @summary List all URLs of the container
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerLinks(containerId: string, options?: RawAxiosRequestConfig): AxiosPromise<LinkResponseList> {
            return localVarFp.listContainerLinks(containerId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContainerMainCallsApi - object-oriented interface
 * @export
 * @class ContainerMainCallsApi
 * @extends {BaseAPI}
 */
export class ContainerMainCallsApi extends BaseAPI {
    /**
     * To delete the container you must have the admin permission
     * @summary Delete container
     * @param {string} containerId Container ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerMainCallsApi
     */
    public deleteContainer(containerId: string, options?: RawAxiosRequestConfig) {
        return ContainerMainCallsApiFp(this.configuration).deleteContainer(containerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - To edit the container you must have the admin permission. - For port edition, if you provide a port id, we will update the corresponding port. If you don\'t we will create a new one. If you remove a port from the payload, we will delete it. - For storage edition, if you provide a storage id, we will update the corresponding storage. If you don\'t we will create a new one. If you remove a storage from the payload, we will delete it. 
     * @summary Edit container
     * @param {string} containerId Container ID
     * @param {ContainerRequest} [containerRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerMainCallsApi
     */
    public editContainer(containerId: string, containerRequest?: ContainerRequest, options?: RawAxiosRequestConfig) {
        return ContainerMainCallsApiFp(this.configuration).editContainer(containerId, containerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get container by ID
     * @param {string} containerId Container ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerMainCallsApi
     */
    public getContainer(containerId: string, options?: RawAxiosRequestConfig) {
        return ContainerMainCallsApiFp(this.configuration).getContainer(containerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get container status
     * @param {string} containerId Container ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerMainCallsApi
     */
    public getContainerStatus(containerId: string, options?: RawAxiosRequestConfig) {
        return ContainerMainCallsApiFp(this.configuration).getContainerStatus(containerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will return all the custom domains and Qovery autogenerated domain for the given container
     * @summary List all URLs of the container
     * @param {string} containerId Container ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerMainCallsApi
     */
    public listContainerLinks(containerId: string, options?: RawAxiosRequestConfig) {
        return ContainerMainCallsApiFp(this.configuration).listContainerLinks(containerId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContainerRegistriesApi - axios parameter creator
 * @export
 */
export const ContainerRegistriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a container registry
         * @param {string} organizationId Organization ID
         * @param {ContainerRegistryRequest} [containerRegistryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainerRegistry: async (organizationId: string, containerRegistryRequest?: ContainerRegistryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createContainerRegistry', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/containerRegistry`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(containerRegistryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a container registry
         * @param {string} organizationId Organization ID
         * @param {string} containerRegistryId Container Registry ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContainerRegistry: async (organizationId: string, containerRegistryId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteContainerRegistry', 'organizationId', organizationId)
            // verify required parameter 'containerRegistryId' is not null or undefined
            assertParamExists('deleteContainerRegistry', 'containerRegistryId', containerRegistryId)
            const localVarPath = `/organization/{organizationId}/containerRegistry/{containerRegistryId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"containerRegistryId"}}`, encodeURIComponent(String(containerRegistryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a container registry
         * @param {string} organizationId Organization ID
         * @param {string} containerRegistryId Container Registry ID
         * @param {ContainerRegistryRequest} [containerRegistryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editContainerRegistry: async (organizationId: string, containerRegistryId: string, containerRegistryRequest?: ContainerRegistryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('editContainerRegistry', 'organizationId', organizationId)
            // verify required parameter 'containerRegistryId' is not null or undefined
            assertParamExists('editContainerRegistry', 'containerRegistryId', containerRegistryId)
            const localVarPath = `/organization/{organizationId}/containerRegistry/{containerRegistryId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"containerRegistryId"}}`, encodeURIComponent(String(containerRegistryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(containerRegistryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a container registry
         * @param {string} organizationId Organization ID
         * @param {string} containerRegistryId Container Registry ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainerRegistry: async (organizationId: string, containerRegistryId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getContainerRegistry', 'organizationId', organizationId)
            // verify required parameter 'containerRegistryId' is not null or undefined
            assertParamExists('getContainerRegistry', 'containerRegistryId', containerRegistryId)
            const localVarPath = `/organization/{organizationId}/containerRegistry/{containerRegistryId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"containerRegistryId"}}`, encodeURIComponent(String(containerRegistryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List image version for a container registry
         * @param {string} organizationId Organization ID
         * @param {string} containerRegistryId Container Registry ID
         * @param {string} [imageName] container image name
         * @param {string} [search] partial container image name to search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainerVersions: async (organizationId: string, containerRegistryId: string, imageName?: string, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getContainerVersions', 'organizationId', organizationId)
            // verify required parameter 'containerRegistryId' is not null or undefined
            assertParamExists('getContainerVersions', 'containerRegistryId', containerRegistryId)
            const localVarPath = `/organization/{organizationId}/containerRegistry/{containerRegistryId}/images`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"containerRegistryId"}}`, encodeURIComponent(String(containerRegistryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (imageName !== undefined) {
                localVarQueryParameter['imageName'] = imageName;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List supported container registries by Qovery and get the mandatory authentification configuration.
         * @summary List supported container registries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAvailableContainerRegistry: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/availableContainerRegistry`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List organization container registries
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerRegistry: async (organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listContainerRegistry', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/containerRegistry`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContainerRegistriesApi - functional programming interface
 * @export
 */
export const ContainerRegistriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContainerRegistriesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a container registry
         * @param {string} organizationId Organization ID
         * @param {ContainerRegistryRequest} [containerRegistryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContainerRegistry(organizationId: string, containerRegistryRequest?: ContainerRegistryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerRegistryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContainerRegistry(organizationId, containerRegistryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContainerRegistriesApi.createContainerRegistry']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a container registry
         * @param {string} organizationId Organization ID
         * @param {string} containerRegistryId Container Registry ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteContainerRegistry(organizationId: string, containerRegistryId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteContainerRegistry(organizationId, containerRegistryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContainerRegistriesApi.deleteContainerRegistry']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Edit a container registry
         * @param {string} organizationId Organization ID
         * @param {string} containerRegistryId Container Registry ID
         * @param {ContainerRegistryRequest} [containerRegistryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editContainerRegistry(organizationId: string, containerRegistryId: string, containerRegistryRequest?: ContainerRegistryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerRegistryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editContainerRegistry(organizationId, containerRegistryId, containerRegistryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContainerRegistriesApi.editContainerRegistry']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a container registry
         * @param {string} organizationId Organization ID
         * @param {string} containerRegistryId Container Registry ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContainerRegistry(organizationId: string, containerRegistryId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerRegistryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContainerRegistry(organizationId, containerRegistryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContainerRegistriesApi.getContainerRegistry']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List image version for a container registry
         * @param {string} organizationId Organization ID
         * @param {string} containerRegistryId Container Registry ID
         * @param {string} [imageName] container image name
         * @param {string} [search] partial container image name to search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContainerVersions(organizationId: string, containerRegistryId: string, imageName?: string, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerVersionResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContainerVersions(organizationId, containerRegistryId, imageName, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContainerRegistriesApi.getContainerVersions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List supported container registries by Qovery and get the mandatory authentification configuration.
         * @summary List supported container registries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAvailableContainerRegistry(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AvailableContainerRegistryResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAvailableContainerRegistry(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContainerRegistriesApi.listAvailableContainerRegistry']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List organization container registries
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContainerRegistry(organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerRegistryResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listContainerRegistry(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContainerRegistriesApi.listContainerRegistry']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContainerRegistriesApi - factory interface
 * @export
 */
export const ContainerRegistriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContainerRegistriesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a container registry
         * @param {string} organizationId Organization ID
         * @param {ContainerRegistryRequest} [containerRegistryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainerRegistry(organizationId: string, containerRegistryRequest?: ContainerRegistryRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContainerRegistryResponse> {
            return localVarFp.createContainerRegistry(organizationId, containerRegistryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a container registry
         * @param {string} organizationId Organization ID
         * @param {string} containerRegistryId Container Registry ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContainerRegistry(organizationId: string, containerRegistryId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteContainerRegistry(organizationId, containerRegistryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a container registry
         * @param {string} organizationId Organization ID
         * @param {string} containerRegistryId Container Registry ID
         * @param {ContainerRegistryRequest} [containerRegistryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editContainerRegistry(organizationId: string, containerRegistryId: string, containerRegistryRequest?: ContainerRegistryRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContainerRegistryResponse> {
            return localVarFp.editContainerRegistry(organizationId, containerRegistryId, containerRegistryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a container registry
         * @param {string} organizationId Organization ID
         * @param {string} containerRegistryId Container Registry ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainerRegistry(organizationId: string, containerRegistryId: string, options?: RawAxiosRequestConfig): AxiosPromise<ContainerRegistryResponse> {
            return localVarFp.getContainerRegistry(organizationId, containerRegistryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List image version for a container registry
         * @param {string} organizationId Organization ID
         * @param {string} containerRegistryId Container Registry ID
         * @param {string} [imageName] container image name
         * @param {string} [search] partial container image name to search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainerVersions(organizationId: string, containerRegistryId: string, imageName?: string, search?: string, options?: RawAxiosRequestConfig): AxiosPromise<ContainerVersionResponseList> {
            return localVarFp.getContainerVersions(organizationId, containerRegistryId, imageName, search, options).then((request) => request(axios, basePath));
        },
        /**
         * List supported container registries by Qovery and get the mandatory authentification configuration.
         * @summary List supported container registries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAvailableContainerRegistry(options?: RawAxiosRequestConfig): AxiosPromise<AvailableContainerRegistryResponseList> {
            return localVarFp.listAvailableContainerRegistry(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List organization container registries
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerRegistry(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise<ContainerRegistryResponseList> {
            return localVarFp.listContainerRegistry(organizationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContainerRegistriesApi - object-oriented interface
 * @export
 * @class ContainerRegistriesApi
 * @extends {BaseAPI}
 */
export class ContainerRegistriesApi extends BaseAPI {
    /**
     * 
     * @summary Create a container registry
     * @param {string} organizationId Organization ID
     * @param {ContainerRegistryRequest} [containerRegistryRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerRegistriesApi
     */
    public createContainerRegistry(organizationId: string, containerRegistryRequest?: ContainerRegistryRequest, options?: RawAxiosRequestConfig) {
        return ContainerRegistriesApiFp(this.configuration).createContainerRegistry(organizationId, containerRegistryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a container registry
     * @param {string} organizationId Organization ID
     * @param {string} containerRegistryId Container Registry ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerRegistriesApi
     */
    public deleteContainerRegistry(organizationId: string, containerRegistryId: string, options?: RawAxiosRequestConfig) {
        return ContainerRegistriesApiFp(this.configuration).deleteContainerRegistry(organizationId, containerRegistryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a container registry
     * @param {string} organizationId Organization ID
     * @param {string} containerRegistryId Container Registry ID
     * @param {ContainerRegistryRequest} [containerRegistryRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerRegistriesApi
     */
    public editContainerRegistry(organizationId: string, containerRegistryId: string, containerRegistryRequest?: ContainerRegistryRequest, options?: RawAxiosRequestConfig) {
        return ContainerRegistriesApiFp(this.configuration).editContainerRegistry(organizationId, containerRegistryId, containerRegistryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a container registry
     * @param {string} organizationId Organization ID
     * @param {string} containerRegistryId Container Registry ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerRegistriesApi
     */
    public getContainerRegistry(organizationId: string, containerRegistryId: string, options?: RawAxiosRequestConfig) {
        return ContainerRegistriesApiFp(this.configuration).getContainerRegistry(organizationId, containerRegistryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List image version for a container registry
     * @param {string} organizationId Organization ID
     * @param {string} containerRegistryId Container Registry ID
     * @param {string} [imageName] container image name
     * @param {string} [search] partial container image name to search
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerRegistriesApi
     */
    public getContainerVersions(organizationId: string, containerRegistryId: string, imageName?: string, search?: string, options?: RawAxiosRequestConfig) {
        return ContainerRegistriesApiFp(this.configuration).getContainerVersions(organizationId, containerRegistryId, imageName, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List supported container registries by Qovery and get the mandatory authentification configuration.
     * @summary List supported container registries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerRegistriesApi
     */
    public listAvailableContainerRegistry(options?: RawAxiosRequestConfig) {
        return ContainerRegistriesApiFp(this.configuration).listAvailableContainerRegistry(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List organization container registries
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerRegistriesApi
     */
    public listContainerRegistry(organizationId: string, options?: RawAxiosRequestConfig) {
        return ContainerRegistriesApiFp(this.configuration).listContainerRegistry(organizationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContainerSecretApi - axios parameter creator
 * @export
 */
export const ContainerSecretApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * - Add a secret to the container. 
         * @summary Add a secret to the container
         * @param {string} containerId Container ID
         * @param {SecretRequest} [secretRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainerSecret: async (containerId: string, secretRequest?: SecretRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('createContainerSecret', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/secret`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(secretRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to add an alias at container level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at container level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - You can\'t create an alias on an alias 
         * @summary Create a secret alias at the container level
         * @param {string} containerId Container ID
         * @param {string} secretId Secret ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainerSecretAlias: async (containerId: string, secretId: string, key?: Key, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('createContainerSecretAlias', 'containerId', containerId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('createContainerSecretAlias', 'secretId', secretId)
            const localVarPath = `/container/{containerId}/secret/{secretId}/alias`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(key, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to override at container level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at container level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
         * @summary Create a secret override at the container level
         * @param {string} containerId Container ID
         * @param {string} secretId Secret ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainerSecretOverride: async (containerId: string, secretId: string, value?: Value, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('createContainerSecretOverride', 'containerId', containerId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('createContainerSecretOverride', 'secretId', secretId)
            const localVarPath = `/container/{containerId}/secret/{secretId}/override`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(value, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete a secret from an container
         * @param {string} containerId Container ID
         * @param {string} secretId Secret ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContainerSecret: async (containerId: string, secretId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('deleteContainerSecret', 'containerId', containerId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('deleteContainerSecret', 'secretId', secretId)
            const localVarPath = `/container/{containerId}/secret/{secretId}`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > CONTAINER) 
         * @summary Edit a secret belonging to the container
         * @param {string} containerId Container ID
         * @param {string} secretId Secret ID
         * @param {SecretEditRequest} secretEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editContainerSecret: async (containerId: string, secretId: string, secretEditRequest: SecretEditRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('editContainerSecret', 'containerId', containerId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('editContainerSecret', 'secretId', secretId)
            // verify required parameter 'secretEditRequest' is not null or undefined
            assertParamExists('editContainerSecret', 'secretEditRequest', secretEditRequest)
            const localVarPath = `/container/{containerId}/secret/{secretId}`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(secretEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Secrets are like environment variables, but they are secured and can\'t be revealed.
         * @summary List container secrets
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerSecrets: async (containerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('listContainerSecrets', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/secret`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContainerSecretApi - functional programming interface
 * @export
 */
export const ContainerSecretApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContainerSecretApiAxiosParamCreator(configuration)
    return {
        /**
         * - Add a secret to the container. 
         * @summary Add a secret to the container
         * @param {string} containerId Container ID
         * @param {SecretRequest} [secretRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContainerSecret(containerId: string, secretRequest?: SecretRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContainerSecret(containerId, secretRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContainerSecretApi.createContainerSecret']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - Allows you to add an alias at container level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at container level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - You can\'t create an alias on an alias 
         * @summary Create a secret alias at the container level
         * @param {string} containerId Container ID
         * @param {string} secretId Secret ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContainerSecretAlias(containerId: string, secretId: string, key?: Key, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContainerSecretAlias(containerId, secretId, key, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContainerSecretApi.createContainerSecretAlias']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - Allows you to override at container level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at container level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
         * @summary Create a secret override at the container level
         * @param {string} containerId Container ID
         * @param {string} secretId Secret ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContainerSecretOverride(containerId: string, secretId: string, value?: Value, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContainerSecretOverride(containerId, secretId, value, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContainerSecretApi.createContainerSecretOverride']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete a secret from an container
         * @param {string} containerId Container ID
         * @param {string} secretId Secret ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteContainerSecret(containerId: string, secretId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteContainerSecret(containerId, secretId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContainerSecretApi.deleteContainerSecret']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > CONTAINER) 
         * @summary Edit a secret belonging to the container
         * @param {string} containerId Container ID
         * @param {string} secretId Secret ID
         * @param {SecretEditRequest} secretEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editContainerSecret(containerId: string, secretId: string, secretEditRequest: SecretEditRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editContainerSecret(containerId, secretId, secretEditRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContainerSecretApi.editContainerSecret']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Secrets are like environment variables, but they are secured and can\'t be revealed.
         * @summary List container secrets
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContainerSecrets(containerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecretResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listContainerSecrets(containerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContainerSecretApi.listContainerSecrets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContainerSecretApi - factory interface
 * @export
 */
export const ContainerSecretApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContainerSecretApiFp(configuration)
    return {
        /**
         * - Add a secret to the container. 
         * @summary Add a secret to the container
         * @param {string} containerId Container ID
         * @param {SecretRequest} [secretRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainerSecret(containerId: string, secretRequest?: SecretRequest, options?: RawAxiosRequestConfig): AxiosPromise<Secret> {
            return localVarFp.createContainerSecret(containerId, secretRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to add an alias at container level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at container level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - You can\'t create an alias on an alias 
         * @summary Create a secret alias at the container level
         * @param {string} containerId Container ID
         * @param {string} secretId Secret ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainerSecretAlias(containerId: string, secretId: string, key?: Key, options?: RawAxiosRequestConfig): AxiosPromise<Secret> {
            return localVarFp.createContainerSecretAlias(containerId, secretId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to override at container level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at container level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
         * @summary Create a secret override at the container level
         * @param {string} containerId Container ID
         * @param {string} secretId Secret ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainerSecretOverride(containerId: string, secretId: string, value?: Value, options?: RawAxiosRequestConfig): AxiosPromise<Secret> {
            return localVarFp.createContainerSecretOverride(containerId, secretId, value, options).then((request) => request(axios, basePath));
        },
        /**
         * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete a secret from an container
         * @param {string} containerId Container ID
         * @param {string} secretId Secret ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContainerSecret(containerId: string, secretId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteContainerSecret(containerId, secretId, options).then((request) => request(axios, basePath));
        },
        /**
         * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > CONTAINER) 
         * @summary Edit a secret belonging to the container
         * @param {string} containerId Container ID
         * @param {string} secretId Secret ID
         * @param {SecretEditRequest} secretEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editContainerSecret(containerId: string, secretId: string, secretEditRequest: SecretEditRequest, options?: RawAxiosRequestConfig): AxiosPromise<Secret> {
            return localVarFp.editContainerSecret(containerId, secretId, secretEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Secrets are like environment variables, but they are secured and can\'t be revealed.
         * @summary List container secrets
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerSecrets(containerId: string, options?: RawAxiosRequestConfig): AxiosPromise<SecretResponseList> {
            return localVarFp.listContainerSecrets(containerId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContainerSecretApi - object-oriented interface
 * @export
 * @class ContainerSecretApi
 * @extends {BaseAPI}
 */
export class ContainerSecretApi extends BaseAPI {
    /**
     * - Add a secret to the container. 
     * @summary Add a secret to the container
     * @param {string} containerId Container ID
     * @param {SecretRequest} [secretRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerSecretApi
     */
    public createContainerSecret(containerId: string, secretRequest?: SecretRequest, options?: RawAxiosRequestConfig) {
        return ContainerSecretApiFp(this.configuration).createContainerSecret(containerId, secretRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to add an alias at container level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at container level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - You can\'t create an alias on an alias 
     * @summary Create a secret alias at the container level
     * @param {string} containerId Container ID
     * @param {string} secretId Secret ID
     * @param {Key} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerSecretApi
     */
    public createContainerSecretAlias(containerId: string, secretId: string, key?: Key, options?: RawAxiosRequestConfig) {
        return ContainerSecretApiFp(this.configuration).createContainerSecretAlias(containerId, secretId, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to override at container level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at container level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
     * @summary Create a secret override at the container level
     * @param {string} containerId Container ID
     * @param {string} secretId Secret ID
     * @param {Value} [value] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerSecretApi
     */
    public createContainerSecretOverride(containerId: string, secretId: string, value?: Value, options?: RawAxiosRequestConfig) {
        return ContainerSecretApiFp(this.configuration).createContainerSecretOverride(containerId, secretId, value, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well 
     * @summary Delete a secret from an container
     * @param {string} containerId Container ID
     * @param {string} secretId Secret ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerSecretApi
     */
    public deleteContainerSecret(containerId: string, secretId: string, options?: RawAxiosRequestConfig) {
        return ContainerSecretApiFp(this.configuration).deleteContainerSecret(containerId, secretId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > CONTAINER) 
     * @summary Edit a secret belonging to the container
     * @param {string} containerId Container ID
     * @param {string} secretId Secret ID
     * @param {SecretEditRequest} secretEditRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerSecretApi
     */
    public editContainerSecret(containerId: string, secretId: string, secretEditRequest: SecretEditRequest, options?: RawAxiosRequestConfig) {
        return ContainerSecretApiFp(this.configuration).editContainerSecret(containerId, secretId, secretEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Secrets are like environment variables, but they are secured and can\'t be revealed.
     * @summary List container secrets
     * @param {string} containerId Container ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerSecretApi
     */
    public listContainerSecrets(containerId: string, options?: RawAxiosRequestConfig) {
        return ContainerSecretApiFp(this.configuration).listContainerSecrets(containerId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContainersApi - axios parameter creator
 * @export
 */
export const ContainersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Triggers a new container deploy in each environment matching the following conditions - environment should have the auto-deploy enabled - the container should have the same image name and a different tag 
         * @summary Auto deploy containers
         * @param {string} organizationId Organization ID
         * @param {OrganizationContainerAutoDeployRequest} [organizationContainerAutoDeployRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoDeployContainerEnvironments: async (organizationId: string, organizationContainerAutoDeployRequest?: OrganizationContainerAutoDeployRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('autoDeployContainerEnvironments', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/container/deploy`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationContainerAutoDeployRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This will create a new container with the same configuration on the targeted environment Id.
         * @summary Clone container
         * @param {string} containerId Container ID
         * @param {CloneServiceRequest} [cloneServiceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneContainer: async (containerId: string, cloneServiceRequest?: CloneServiceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('cloneContainer', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/clone`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloneServiceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a container
         * @param {string} environmentId Environment ID
         * @param {ContainerRequest} [containerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainer: async (environmentId: string, containerRequest?: ContainerRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('createContainer', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/container`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(containerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of containers with only their id and status.
         * @summary List all container registry container statuses
         * @param {string} organizationId Organization ID
         * @param {string} containerRegistryId Container Registry ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainerRegistryContainerStatus: async (organizationId: string, containerRegistryId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getContainerRegistryContainerStatus', 'organizationId', organizationId)
            // verify required parameter 'containerRegistryId' is not null or undefined
            assertParamExists('getContainerRegistryContainerStatus', 'containerRegistryId', containerRegistryId)
            const localVarPath = `/organization/{organizationId}/containerRegistry/{containerRegistryId}/container/status`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"containerRegistryId"}}`, encodeURIComponent(String(containerRegistryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Default values for each setting are available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/advanced-settings/)
         * @summary List default container advanced settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultContainerAdvancedSettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/defaultContainerAdvancedSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of containers with only their id and status.
         * @summary List all environment container statuses
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentContainerStatus: async (environmentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('getEnvironmentContainerStatus', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/container/status`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List containers
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainer: async (environmentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('listContainer', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/container`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Triggers a new container preview for each environment matching the following conditions - preview environment feature should be enabled for the container - the container should have the same image name and a different tag 
         * @summary Preview container environments
         * @param {string} organizationId Organization ID
         * @param {OrganizationContainerPreviewRequest} [organizationContainerPreviewRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewContainerEnvironments: async (organizationId: string, organizationContainerPreviewRequest?: OrganizationContainerPreviewRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('previewContainerEnvironments', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/container/preview`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationContainerPreviewRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContainersApi - functional programming interface
 * @export
 */
export const ContainersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContainersApiAxiosParamCreator(configuration)
    return {
        /**
         * Triggers a new container deploy in each environment matching the following conditions - environment should have the auto-deploy enabled - the container should have the same image name and a different tag 
         * @summary Auto deploy containers
         * @param {string} organizationId Organization ID
         * @param {OrganizationContainerAutoDeployRequest} [organizationContainerAutoDeployRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autoDeployContainerEnvironments(organizationId: string, organizationContainerAutoDeployRequest?: OrganizationContainerAutoDeployRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autoDeployContainerEnvironments(organizationId, organizationContainerAutoDeployRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContainersApi.autoDeployContainerEnvironments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This will create a new container with the same configuration on the targeted environment Id.
         * @summary Clone container
         * @param {string} containerId Container ID
         * @param {CloneServiceRequest} [cloneServiceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloneContainer(containerId: string, cloneServiceRequest?: CloneServiceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cloneContainer(containerId, cloneServiceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContainersApi.cloneContainer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a container
         * @param {string} environmentId Environment ID
         * @param {ContainerRequest} [containerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContainer(environmentId: string, containerRequest?: ContainerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContainer(environmentId, containerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContainersApi.createContainer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of containers with only their id and status.
         * @summary List all container registry container statuses
         * @param {string} organizationId Organization ID
         * @param {string} containerRegistryId Container Registry ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContainerRegistryContainerStatus(organizationId: string, containerRegistryId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReferenceObjectStatusResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContainerRegistryContainerStatus(organizationId, containerRegistryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContainersApi.getContainerRegistryContainerStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Default values for each setting are available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/advanced-settings/)
         * @summary List default container advanced settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDefaultContainerAdvancedSettings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerAdvancedSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDefaultContainerAdvancedSettings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContainersApi.getDefaultContainerAdvancedSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of containers with only their id and status.
         * @summary List all environment container statuses
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironmentContainerStatus(environmentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReferenceObjectStatusResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironmentContainerStatus(environmentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContainersApi.getEnvironmentContainerStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List containers
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContainer(environmentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listContainer(environmentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContainersApi.listContainer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Triggers a new container preview for each environment matching the following conditions - preview environment feature should be enabled for the container - the container should have the same image name and a different tag 
         * @summary Preview container environments
         * @param {string} organizationId Organization ID
         * @param {OrganizationContainerPreviewRequest} [organizationContainerPreviewRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async previewContainerEnvironments(organizationId: string, organizationContainerPreviewRequest?: OrganizationContainerPreviewRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.previewContainerEnvironments(organizationId, organizationContainerPreviewRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContainersApi.previewContainerEnvironments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContainersApi - factory interface
 * @export
 */
export const ContainersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContainersApiFp(configuration)
    return {
        /**
         * Triggers a new container deploy in each environment matching the following conditions - environment should have the auto-deploy enabled - the container should have the same image name and a different tag 
         * @summary Auto deploy containers
         * @param {string} organizationId Organization ID
         * @param {OrganizationContainerAutoDeployRequest} [organizationContainerAutoDeployRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoDeployContainerEnvironments(organizationId: string, organizationContainerAutoDeployRequest?: OrganizationContainerAutoDeployRequest, options?: RawAxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.autoDeployContainerEnvironments(organizationId, organizationContainerAutoDeployRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This will create a new container with the same configuration on the targeted environment Id.
         * @summary Clone container
         * @param {string} containerId Container ID
         * @param {CloneServiceRequest} [cloneServiceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneContainer(containerId: string, cloneServiceRequest?: CloneServiceRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContainerResponse> {
            return localVarFp.cloneContainer(containerId, cloneServiceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a container
         * @param {string} environmentId Environment ID
         * @param {ContainerRequest} [containerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainer(environmentId: string, containerRequest?: ContainerRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContainerResponse> {
            return localVarFp.createContainer(environmentId, containerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of containers with only their id and status.
         * @summary List all container registry container statuses
         * @param {string} organizationId Organization ID
         * @param {string} containerRegistryId Container Registry ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainerRegistryContainerStatus(organizationId: string, containerRegistryId: string, options?: RawAxiosRequestConfig): AxiosPromise<ReferenceObjectStatusResponseList> {
            return localVarFp.getContainerRegistryContainerStatus(organizationId, containerRegistryId, options).then((request) => request(axios, basePath));
        },
        /**
         * Default values for each setting are available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/advanced-settings/)
         * @summary List default container advanced settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultContainerAdvancedSettings(options?: RawAxiosRequestConfig): AxiosPromise<ContainerAdvancedSettings> {
            return localVarFp.getDefaultContainerAdvancedSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of containers with only their id and status.
         * @summary List all environment container statuses
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentContainerStatus(environmentId: string, options?: RawAxiosRequestConfig): AxiosPromise<ReferenceObjectStatusResponseList> {
            return localVarFp.getEnvironmentContainerStatus(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List containers
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainer(environmentId: string, options?: RawAxiosRequestConfig): AxiosPromise<ContainerResponseList> {
            return localVarFp.listContainer(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Triggers a new container preview for each environment matching the following conditions - preview environment feature should be enabled for the container - the container should have the same image name and a different tag 
         * @summary Preview container environments
         * @param {string} organizationId Organization ID
         * @param {OrganizationContainerPreviewRequest} [organizationContainerPreviewRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewContainerEnvironments(organizationId: string, organizationContainerPreviewRequest?: OrganizationContainerPreviewRequest, options?: RawAxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.previewContainerEnvironments(organizationId, organizationContainerPreviewRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContainersApi - object-oriented interface
 * @export
 * @class ContainersApi
 * @extends {BaseAPI}
 */
export class ContainersApi extends BaseAPI {
    /**
     * Triggers a new container deploy in each environment matching the following conditions - environment should have the auto-deploy enabled - the container should have the same image name and a different tag 
     * @summary Auto deploy containers
     * @param {string} organizationId Organization ID
     * @param {OrganizationContainerAutoDeployRequest} [organizationContainerAutoDeployRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public autoDeployContainerEnvironments(organizationId: string, organizationContainerAutoDeployRequest?: OrganizationContainerAutoDeployRequest, options?: RawAxiosRequestConfig) {
        return ContainersApiFp(this.configuration).autoDeployContainerEnvironments(organizationId, organizationContainerAutoDeployRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will create a new container with the same configuration on the targeted environment Id.
     * @summary Clone container
     * @param {string} containerId Container ID
     * @param {CloneServiceRequest} [cloneServiceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public cloneContainer(containerId: string, cloneServiceRequest?: CloneServiceRequest, options?: RawAxiosRequestConfig) {
        return ContainersApiFp(this.configuration).cloneContainer(containerId, cloneServiceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a container
     * @param {string} environmentId Environment ID
     * @param {ContainerRequest} [containerRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public createContainer(environmentId: string, containerRequest?: ContainerRequest, options?: RawAxiosRequestConfig) {
        return ContainersApiFp(this.configuration).createContainer(environmentId, containerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of containers with only their id and status.
     * @summary List all container registry container statuses
     * @param {string} organizationId Organization ID
     * @param {string} containerRegistryId Container Registry ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public getContainerRegistryContainerStatus(organizationId: string, containerRegistryId: string, options?: RawAxiosRequestConfig) {
        return ContainersApiFp(this.configuration).getContainerRegistryContainerStatus(organizationId, containerRegistryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Default values for each setting are available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/advanced-settings/)
     * @summary List default container advanced settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public getDefaultContainerAdvancedSettings(options?: RawAxiosRequestConfig) {
        return ContainersApiFp(this.configuration).getDefaultContainerAdvancedSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of containers with only their id and status.
     * @summary List all environment container statuses
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public getEnvironmentContainerStatus(environmentId: string, options?: RawAxiosRequestConfig) {
        return ContainersApiFp(this.configuration).getEnvironmentContainerStatus(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List containers
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public listContainer(environmentId: string, options?: RawAxiosRequestConfig) {
        return ContainersApiFp(this.configuration).listContainer(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Triggers a new container preview for each environment matching the following conditions - preview environment feature should be enabled for the container - the container should have the same image name and a different tag 
     * @summary Preview container environments
     * @param {string} organizationId Organization ID
     * @param {OrganizationContainerPreviewRequest} [organizationContainerPreviewRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public previewContainerEnvironments(organizationId: string, organizationContainerPreviewRequest?: OrganizationContainerPreviewRequest, options?: RawAxiosRequestConfig) {
        return ContainersApiFp(this.configuration).previewContainerEnvironments(organizationId, organizationContainerPreviewRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DatabaseActionsApi - axios parameter creator
 * @export
 */
export const DatabaseActionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deploy database 
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployDatabase: async (databaseId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('deployDatabase', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}/deploy`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retart database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rebootDatabase: async (databaseId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('rebootDatabase', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}/restart-service`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Redeploy database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeployDatabase: async (databaseId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('redeployDatabase', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}/redeploy`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopDatabase: async (databaseId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('stopDatabase', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}/stop`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Uninstall database
         * @param {string} databaseId Database ID
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uninstallDatabase: async (databaseId: string, body?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('uninstallDatabase', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}/uninstall`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatabaseActionsApi - functional programming interface
 * @export
 */
export const DatabaseActionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DatabaseActionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Deploy database 
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployDatabase(databaseId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployDatabase(databaseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatabaseActionsApi.deployDatabase']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retart database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rebootDatabase(databaseId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rebootDatabase(databaseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatabaseActionsApi.rebootDatabase']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Redeploy database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async redeployDatabase(databaseId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.redeployDatabase(databaseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatabaseActionsApi.redeployDatabase']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Stop database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopDatabase(databaseId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopDatabase(databaseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatabaseActionsApi.stopDatabase']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Uninstall database
         * @param {string} databaseId Database ID
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uninstallDatabase(databaseId: string, body?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uninstallDatabase(databaseId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatabaseActionsApi.uninstallDatabase']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DatabaseActionsApi - factory interface
 * @export
 */
export const DatabaseActionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DatabaseActionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Deploy database 
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployDatabase(databaseId: string, options?: RawAxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.deployDatabase(databaseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retart database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rebootDatabase(databaseId: string, options?: RawAxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.rebootDatabase(databaseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Redeploy database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeployDatabase(databaseId: string, options?: RawAxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.redeployDatabase(databaseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Stop database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopDatabase(databaseId: string, options?: RawAxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.stopDatabase(databaseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Uninstall database
         * @param {string} databaseId Database ID
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uninstallDatabase(databaseId: string, body?: object, options?: RawAxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.uninstallDatabase(databaseId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DatabaseActionsApi - object-oriented interface
 * @export
 * @class DatabaseActionsApi
 * @extends {BaseAPI}
 */
export class DatabaseActionsApi extends BaseAPI {
    /**
     * 
     * @summary Deploy database 
     * @param {string} databaseId Database ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseActionsApi
     */
    public deployDatabase(databaseId: string, options?: RawAxiosRequestConfig) {
        return DatabaseActionsApiFp(this.configuration).deployDatabase(databaseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retart database
     * @param {string} databaseId Database ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseActionsApi
     */
    public rebootDatabase(databaseId: string, options?: RawAxiosRequestConfig) {
        return DatabaseActionsApiFp(this.configuration).rebootDatabase(databaseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Redeploy database
     * @param {string} databaseId Database ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseActionsApi
     */
    public redeployDatabase(databaseId: string, options?: RawAxiosRequestConfig) {
        return DatabaseActionsApiFp(this.configuration).redeployDatabase(databaseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Stop database
     * @param {string} databaseId Database ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseActionsApi
     */
    public stopDatabase(databaseId: string, options?: RawAxiosRequestConfig) {
        return DatabaseActionsApiFp(this.configuration).stopDatabase(databaseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Uninstall database
     * @param {string} databaseId Database ID
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseActionsApi
     */
    public uninstallDatabase(databaseId: string, body?: object, options?: RawAxiosRequestConfig) {
        return DatabaseActionsApiFp(this.configuration).uninstallDatabase(databaseId, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DatabaseApplicationApi - axios parameter creator
 * @export
 */
export const DatabaseApplicationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List applications using the database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseApplication: async (databaseId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('listDatabaseApplication', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}/application`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove an application from this database 
         * @param {string} databaseId Database ID
         * @param {string} targetApplicationId Target application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeApplicationFromDatabase: async (databaseId: string, targetApplicationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('removeApplicationFromDatabase', 'databaseId', databaseId)
            // verify required parameter 'targetApplicationId' is not null or undefined
            assertParamExists('removeApplicationFromDatabase', 'targetApplicationId', targetApplicationId)
            const localVarPath = `/database/{databaseId}/application/{targetApplicationId}`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)))
                .replace(`{${"targetApplicationId"}}`, encodeURIComponent(String(targetApplicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatabaseApplicationApi - functional programming interface
 * @export
 */
export const DatabaseApplicationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DatabaseApplicationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List applications using the database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDatabaseApplication(databaseId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDatabaseApplication(databaseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatabaseApplicationApi.listDatabaseApplication']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove an application from this database 
         * @param {string} databaseId Database ID
         * @param {string} targetApplicationId Target application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeApplicationFromDatabase(databaseId: string, targetApplicationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeApplicationFromDatabase(databaseId, targetApplicationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatabaseApplicationApi.removeApplicationFromDatabase']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DatabaseApplicationApi - factory interface
 * @export
 */
export const DatabaseApplicationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DatabaseApplicationApiFp(configuration)
    return {
        /**
         * 
         * @summary List applications using the database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseApplication(databaseId: string, options?: RawAxiosRequestConfig): AxiosPromise<ApplicationResponseList> {
            return localVarFp.listDatabaseApplication(databaseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove an application from this database 
         * @param {string} databaseId Database ID
         * @param {string} targetApplicationId Target application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeApplicationFromDatabase(databaseId: string, targetApplicationId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.removeApplicationFromDatabase(databaseId, targetApplicationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DatabaseApplicationApi - object-oriented interface
 * @export
 * @class DatabaseApplicationApi
 * @extends {BaseAPI}
 */
export class DatabaseApplicationApi extends BaseAPI {
    /**
     * 
     * @summary List applications using the database
     * @param {string} databaseId Database ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseApplicationApi
     */
    public listDatabaseApplication(databaseId: string, options?: RawAxiosRequestConfig) {
        return DatabaseApplicationApiFp(this.configuration).listDatabaseApplication(databaseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove an application from this database 
     * @param {string} databaseId Database ID
     * @param {string} targetApplicationId Target application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseApplicationApi
     */
    public removeApplicationFromDatabase(databaseId: string, targetApplicationId: string, options?: RawAxiosRequestConfig) {
        return DatabaseApplicationApiFp(this.configuration).removeApplicationFromDatabase(databaseId, targetApplicationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DatabaseDeploymentHistoryApi - axios parameter creator
 * @export
 */
export const DatabaseDeploymentHistoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * By default it returns the 20 last results. The response is paginated.
         * @summary List database deploys
         * @param {string} databaseId Database ID
         * @param {string} [startId] Starting point after which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseDeploymentHistory: async (databaseId: string, startId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('listDatabaseDeploymentHistory', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}/deploymentHistory`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (startId !== undefined) {
                localVarQueryParameter['startId'] = startId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * By default it returns the 20 last results. The response is paginated.
         * @summary List database deploys
         * @param {string} databaseId 
         * @param {number | null} [pageSize] The number of deployments to return in the current page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseDeploymentHistoryV2: async (databaseId: string, pageSize?: number | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('listDatabaseDeploymentHistoryV2', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}/deploymentHistoryV2`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatabaseDeploymentHistoryApi - functional programming interface
 * @export
 */
export const DatabaseDeploymentHistoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DatabaseDeploymentHistoryApiAxiosParamCreator(configuration)
    return {
        /**
         * By default it returns the 20 last results. The response is paginated.
         * @summary List database deploys
         * @param {string} databaseId Database ID
         * @param {string} [startId] Starting point after which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDatabaseDeploymentHistory(databaseId: string, startId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListDatabaseDeploymentHistory200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDatabaseDeploymentHistory(databaseId, startId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatabaseDeploymentHistoryApi.listDatabaseDeploymentHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * By default it returns the 20 last results. The response is paginated.
         * @summary List database deploys
         * @param {string} databaseId 
         * @param {number | null} [pageSize] The number of deployments to return in the current page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDatabaseDeploymentHistoryV2(databaseId: string, pageSize?: number | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentHistoryServicePaginatedResponseListV2>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDatabaseDeploymentHistoryV2(databaseId, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatabaseDeploymentHistoryApi.listDatabaseDeploymentHistoryV2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DatabaseDeploymentHistoryApi - factory interface
 * @export
 */
export const DatabaseDeploymentHistoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DatabaseDeploymentHistoryApiFp(configuration)
    return {
        /**
         * By default it returns the 20 last results. The response is paginated.
         * @summary List database deploys
         * @param {string} databaseId Database ID
         * @param {string} [startId] Starting point after which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseDeploymentHistory(databaseId: string, startId?: string, options?: RawAxiosRequestConfig): AxiosPromise<ListDatabaseDeploymentHistory200Response> {
            return localVarFp.listDatabaseDeploymentHistory(databaseId, startId, options).then((request) => request(axios, basePath));
        },
        /**
         * By default it returns the 20 last results. The response is paginated.
         * @summary List database deploys
         * @param {string} databaseId 
         * @param {number | null} [pageSize] The number of deployments to return in the current page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseDeploymentHistoryV2(databaseId: string, pageSize?: number | null, options?: RawAxiosRequestConfig): AxiosPromise<DeploymentHistoryServicePaginatedResponseListV2> {
            return localVarFp.listDatabaseDeploymentHistoryV2(databaseId, pageSize, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DatabaseDeploymentHistoryApi - object-oriented interface
 * @export
 * @class DatabaseDeploymentHistoryApi
 * @extends {BaseAPI}
 */
export class DatabaseDeploymentHistoryApi extends BaseAPI {
    /**
     * By default it returns the 20 last results. The response is paginated.
     * @summary List database deploys
     * @param {string} databaseId Database ID
     * @param {string} [startId] Starting point after which to return results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseDeploymentHistoryApi
     */
    public listDatabaseDeploymentHistory(databaseId: string, startId?: string, options?: RawAxiosRequestConfig) {
        return DatabaseDeploymentHistoryApiFp(this.configuration).listDatabaseDeploymentHistory(databaseId, startId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * By default it returns the 20 last results. The response is paginated.
     * @summary List database deploys
     * @param {string} databaseId 
     * @param {number | null} [pageSize] The number of deployments to return in the current page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseDeploymentHistoryApi
     */
    public listDatabaseDeploymentHistoryV2(databaseId: string, pageSize?: number | null, options?: RawAxiosRequestConfig) {
        return DatabaseDeploymentHistoryApiFp(this.configuration).listDatabaseDeploymentHistoryV2(databaseId, pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DatabaseMainCallsApi - axios parameter creator
 * @export
 */
export const DatabaseMainCallsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * To delete a database you must have the admin permission
         * @summary Delete a database 
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDatabase: async (databaseId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('deleteDatabase', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To edit a database  you must have the admin permission
         * @summary Edit a database 
         * @param {string} databaseId Database ID
         * @param {DatabaseEditRequest} [databaseEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editDatabase: async (databaseId: string, databaseEditRequest?: DatabaseEditRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('editDatabase', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(databaseEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit database  master credentials
         * @param {string} databaseId Database ID
         * @param {CredentialsRequest} [credentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editDatabaseCredentials: async (databaseId: string, credentialsRequest?: CredentialsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('editDatabaseCredentials', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}/masterCredentials`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(credentialsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get database by ID
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabase: async (databaseId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('getDatabase', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get master credentials of the database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseMasterCredentials: async (databaseId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('getDatabaseMasterCredentials', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}/masterCredentials`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get database status
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseStatus: async (databaseId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('getDatabaseStatus', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}/status`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List eligible versions for the database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseVersion: async (databaseId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('listDatabaseVersion', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}/version`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatabaseMainCallsApi - functional programming interface
 * @export
 */
export const DatabaseMainCallsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DatabaseMainCallsApiAxiosParamCreator(configuration)
    return {
        /**
         * To delete a database you must have the admin permission
         * @summary Delete a database 
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDatabase(databaseId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDatabase(databaseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatabaseMainCallsApi.deleteDatabase']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * To edit a database  you must have the admin permission
         * @summary Edit a database 
         * @param {string} databaseId Database ID
         * @param {DatabaseEditRequest} [databaseEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editDatabase(databaseId: string, databaseEditRequest?: DatabaseEditRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Database>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editDatabase(databaseId, databaseEditRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatabaseMainCallsApi.editDatabase']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Edit database  master credentials
         * @param {string} databaseId Database ID
         * @param {CredentialsRequest} [credentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editDatabaseCredentials(databaseId: string, credentialsRequest?: CredentialsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Credentials>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editDatabaseCredentials(databaseId, credentialsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatabaseMainCallsApi.editDatabaseCredentials']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get database by ID
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDatabase(databaseId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Database>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDatabase(databaseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatabaseMainCallsApi.getDatabase']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get master credentials of the database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDatabaseMasterCredentials(databaseId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Credentials>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDatabaseMasterCredentials(databaseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatabaseMainCallsApi.getDatabaseMasterCredentials']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get database status
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDatabaseStatus(databaseId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDatabaseStatus(databaseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatabaseMainCallsApi.getDatabaseStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List eligible versions for the database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDatabaseVersion(databaseId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VersionResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDatabaseVersion(databaseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatabaseMainCallsApi.listDatabaseVersion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DatabaseMainCallsApi - factory interface
 * @export
 */
export const DatabaseMainCallsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DatabaseMainCallsApiFp(configuration)
    return {
        /**
         * To delete a database you must have the admin permission
         * @summary Delete a database 
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDatabase(databaseId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteDatabase(databaseId, options).then((request) => request(axios, basePath));
        },
        /**
         * To edit a database  you must have the admin permission
         * @summary Edit a database 
         * @param {string} databaseId Database ID
         * @param {DatabaseEditRequest} [databaseEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editDatabase(databaseId: string, databaseEditRequest?: DatabaseEditRequest, options?: RawAxiosRequestConfig): AxiosPromise<Database> {
            return localVarFp.editDatabase(databaseId, databaseEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit database  master credentials
         * @param {string} databaseId Database ID
         * @param {CredentialsRequest} [credentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editDatabaseCredentials(databaseId: string, credentialsRequest?: CredentialsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Credentials> {
            return localVarFp.editDatabaseCredentials(databaseId, credentialsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get database by ID
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabase(databaseId: string, options?: RawAxiosRequestConfig): AxiosPromise<Database> {
            return localVarFp.getDatabase(databaseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get master credentials of the database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseMasterCredentials(databaseId: string, options?: RawAxiosRequestConfig): AxiosPromise<Credentials> {
            return localVarFp.getDatabaseMasterCredentials(databaseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get database status
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseStatus(databaseId: string, options?: RawAxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.getDatabaseStatus(databaseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List eligible versions for the database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseVersion(databaseId: string, options?: RawAxiosRequestConfig): AxiosPromise<VersionResponseList> {
            return localVarFp.listDatabaseVersion(databaseId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DatabaseMainCallsApi - object-oriented interface
 * @export
 * @class DatabaseMainCallsApi
 * @extends {BaseAPI}
 */
export class DatabaseMainCallsApi extends BaseAPI {
    /**
     * To delete a database you must have the admin permission
     * @summary Delete a database 
     * @param {string} databaseId Database ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseMainCallsApi
     */
    public deleteDatabase(databaseId: string, options?: RawAxiosRequestConfig) {
        return DatabaseMainCallsApiFp(this.configuration).deleteDatabase(databaseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To edit a database  you must have the admin permission
     * @summary Edit a database 
     * @param {string} databaseId Database ID
     * @param {DatabaseEditRequest} [databaseEditRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseMainCallsApi
     */
    public editDatabase(databaseId: string, databaseEditRequest?: DatabaseEditRequest, options?: RawAxiosRequestConfig) {
        return DatabaseMainCallsApiFp(this.configuration).editDatabase(databaseId, databaseEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit database  master credentials
     * @param {string} databaseId Database ID
     * @param {CredentialsRequest} [credentialsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseMainCallsApi
     */
    public editDatabaseCredentials(databaseId: string, credentialsRequest?: CredentialsRequest, options?: RawAxiosRequestConfig) {
        return DatabaseMainCallsApiFp(this.configuration).editDatabaseCredentials(databaseId, credentialsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get database by ID
     * @param {string} databaseId Database ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseMainCallsApi
     */
    public getDatabase(databaseId: string, options?: RawAxiosRequestConfig) {
        return DatabaseMainCallsApiFp(this.configuration).getDatabase(databaseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get master credentials of the database
     * @param {string} databaseId Database ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseMainCallsApi
     */
    public getDatabaseMasterCredentials(databaseId: string, options?: RawAxiosRequestConfig) {
        return DatabaseMainCallsApiFp(this.configuration).getDatabaseMasterCredentials(databaseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get database status
     * @param {string} databaseId Database ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseMainCallsApi
     */
    public getDatabaseStatus(databaseId: string, options?: RawAxiosRequestConfig) {
        return DatabaseMainCallsApiFp(this.configuration).getDatabaseStatus(databaseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List eligible versions for the database
     * @param {string} databaseId Database ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseMainCallsApi
     */
    public listDatabaseVersion(databaseId: string, options?: RawAxiosRequestConfig) {
        return DatabaseMainCallsApiFp(this.configuration).listDatabaseVersion(databaseId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DatabasesApi - axios parameter creator
 * @export
 */
export const DatabasesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This will create a new database with the same configuration on the targeted environment Id.
         * @summary Clone database
         * @param {string} databaseId Database ID
         * @param {CloneServiceRequest} [cloneServiceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneDatabase: async (databaseId: string, cloneServiceRequest?: CloneServiceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('cloneDatabase', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}/clone`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloneServiceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a database
         * @param {string} environmentId Environment ID
         * @param {DatabaseRequest} [databaseRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatabase: async (environmentId: string, databaseRequest?: DatabaseRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('createDatabase', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/database`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(databaseRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of databases with only their id and status.
         * @summary List all environment databases statuses
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentDatabaseStatus: async (environmentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('getEnvironmentDatabaseStatus', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/database/status`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List environment databases
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabase: async (environmentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('listDatabase', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/database`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List eligible database types, versions and modes for the environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentDatabaseConfig: async (environmentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('listEnvironmentDatabaseConfig', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/databaseConfiguration`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatabasesApi - functional programming interface
 * @export
 */
export const DatabasesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DatabasesApiAxiosParamCreator(configuration)
    return {
        /**
         * This will create a new database with the same configuration on the targeted environment Id.
         * @summary Clone database
         * @param {string} databaseId Database ID
         * @param {CloneServiceRequest} [cloneServiceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloneDatabase(databaseId: string, cloneServiceRequest?: CloneServiceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Database>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cloneDatabase(databaseId, cloneServiceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatabasesApi.cloneDatabase']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a database
         * @param {string} environmentId Environment ID
         * @param {DatabaseRequest} [databaseRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDatabase(environmentId: string, databaseRequest?: DatabaseRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Database>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDatabase(environmentId, databaseRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatabasesApi.createDatabase']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of databases with only their id and status.
         * @summary List all environment databases statuses
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironmentDatabaseStatus(environmentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReferenceObjectStatusResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironmentDatabaseStatus(environmentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatabasesApi.getEnvironmentDatabaseStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List environment databases
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDatabase(environmentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatabaseResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDatabase(environmentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatabasesApi.listDatabase']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List eligible database types, versions and modes for the environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEnvironmentDatabaseConfig(environmentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatabaseConfigurationResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEnvironmentDatabaseConfig(environmentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatabasesApi.listEnvironmentDatabaseConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DatabasesApi - factory interface
 * @export
 */
export const DatabasesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DatabasesApiFp(configuration)
    return {
        /**
         * This will create a new database with the same configuration on the targeted environment Id.
         * @summary Clone database
         * @param {string} databaseId Database ID
         * @param {CloneServiceRequest} [cloneServiceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneDatabase(databaseId: string, cloneServiceRequest?: CloneServiceRequest, options?: RawAxiosRequestConfig): AxiosPromise<Database> {
            return localVarFp.cloneDatabase(databaseId, cloneServiceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a database
         * @param {string} environmentId Environment ID
         * @param {DatabaseRequest} [databaseRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatabase(environmentId: string, databaseRequest?: DatabaseRequest, options?: RawAxiosRequestConfig): AxiosPromise<Database> {
            return localVarFp.createDatabase(environmentId, databaseRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of databases with only their id and status.
         * @summary List all environment databases statuses
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentDatabaseStatus(environmentId: string, options?: RawAxiosRequestConfig): AxiosPromise<ReferenceObjectStatusResponseList> {
            return localVarFp.getEnvironmentDatabaseStatus(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List environment databases
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabase(environmentId: string, options?: RawAxiosRequestConfig): AxiosPromise<DatabaseResponseList> {
            return localVarFp.listDatabase(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List eligible database types, versions and modes for the environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentDatabaseConfig(environmentId: string, options?: RawAxiosRequestConfig): AxiosPromise<DatabaseConfigurationResponseList> {
            return localVarFp.listEnvironmentDatabaseConfig(environmentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DatabasesApi - object-oriented interface
 * @export
 * @class DatabasesApi
 * @extends {BaseAPI}
 */
export class DatabasesApi extends BaseAPI {
    /**
     * This will create a new database with the same configuration on the targeted environment Id.
     * @summary Clone database
     * @param {string} databaseId Database ID
     * @param {CloneServiceRequest} [cloneServiceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabasesApi
     */
    public cloneDatabase(databaseId: string, cloneServiceRequest?: CloneServiceRequest, options?: RawAxiosRequestConfig) {
        return DatabasesApiFp(this.configuration).cloneDatabase(databaseId, cloneServiceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a database
     * @param {string} environmentId Environment ID
     * @param {DatabaseRequest} [databaseRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabasesApi
     */
    public createDatabase(environmentId: string, databaseRequest?: DatabaseRequest, options?: RawAxiosRequestConfig) {
        return DatabasesApiFp(this.configuration).createDatabase(environmentId, databaseRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of databases with only their id and status.
     * @summary List all environment databases statuses
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabasesApi
     */
    public getEnvironmentDatabaseStatus(environmentId: string, options?: RawAxiosRequestConfig) {
        return DatabasesApiFp(this.configuration).getEnvironmentDatabaseStatus(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List environment databases
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabasesApi
     */
    public listDatabase(environmentId: string, options?: RawAxiosRequestConfig) {
        return DatabasesApiFp(this.configuration).listDatabase(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List eligible database types, versions and modes for the environment
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabasesApi
     */
    public listEnvironmentDatabaseConfig(environmentId: string, options?: RawAxiosRequestConfig) {
        return DatabasesApiFp(this.configuration).listEnvironmentDatabaseConfig(environmentId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get cluster token by clusterId
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterTokenByClusterId: async (clusterId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('getClusterTokenByClusterId', 'clusterId', clusterId)
            const localVarPath = `/cluster/{clusterId}/token`
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Deployment Status By DeploymentRequestId
         * @param {string} deploymentRequestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeploymentStatusByDeploymentRequestId: async (deploymentRequestId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deploymentRequestId' is not null or undefined
            assertParamExists('getDeploymentStatusByDeploymentRequestId', 'deploymentRequestId', deploymentRequestId)
            const localVarPath = `/environment/deploymentStatus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (deploymentRequestId !== undefined) {
                localVarQueryParameter['deploymentRequestId'] = deploymentRequestId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get cluster token by clusterId
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClusterTokenByClusterId(clusterId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetClusterTokenByClusterId200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClusterTokenByClusterId(clusterId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getClusterTokenByClusterId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Deployment Status By DeploymentRequestId
         * @param {string} deploymentRequestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeploymentStatusByDeploymentRequestId(deploymentRequestId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvDeploymentStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeploymentStatusByDeploymentRequestId(deploymentRequestId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getDeploymentStatusByDeploymentRequestId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Get cluster token by clusterId
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterTokenByClusterId(clusterId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetClusterTokenByClusterId200Response> {
            return localVarFp.getClusterTokenByClusterId(clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Deployment Status By DeploymentRequestId
         * @param {string} deploymentRequestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeploymentStatusByDeploymentRequestId(deploymentRequestId: string, options?: RawAxiosRequestConfig): AxiosPromise<EnvDeploymentStatus> {
            return localVarFp.getDeploymentStatusByDeploymentRequestId(deploymentRequestId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Get cluster token by clusterId
     * @param {string} clusterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getClusterTokenByClusterId(clusterId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getClusterTokenByClusterId(clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Deployment Status By DeploymentRequestId
     * @param {string} deploymentRequestId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getDeploymentStatusByDeploymentRequestId(deploymentRequestId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getDeploymentStatusByDeploymentRequestId(deploymentRequestId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DeploymentQueueActionsApi - axios parameter creator
 * @export
 */
export const DeploymentQueueActionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancel the a deployment request.
         * @summary Cancel deployment request
         * @param {string} deploymentRequestId 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelDeploymentRequest: async (deploymentRequestId: string, body?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deploymentRequestId' is not null or undefined
            assertParamExists('cancelDeploymentRequest', 'deploymentRequestId', deploymentRequestId)
            const localVarPath = `/deploymentQueue/{deploymentRequestId}/cancelDeployment`
                .replace(`{${"deploymentRequestId"}}`, encodeURIComponent(String(deploymentRequestId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeploymentQueueActionsApi - functional programming interface
 * @export
 */
export const DeploymentQueueActionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeploymentQueueActionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Cancel the a deployment request.
         * @summary Cancel deployment request
         * @param {string} deploymentRequestId 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelDeploymentRequest(deploymentRequestId: string, body?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelDeploymentRequest(deploymentRequestId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeploymentQueueActionsApi.cancelDeploymentRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DeploymentQueueActionsApi - factory interface
 * @export
 */
export const DeploymentQueueActionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeploymentQueueActionsApiFp(configuration)
    return {
        /**
         * Cancel the a deployment request.
         * @summary Cancel deployment request
         * @param {string} deploymentRequestId 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelDeploymentRequest(deploymentRequestId: string, body?: object, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.cancelDeploymentRequest(deploymentRequestId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeploymentQueueActionsApi - object-oriented interface
 * @export
 * @class DeploymentQueueActionsApi
 * @extends {BaseAPI}
 */
export class DeploymentQueueActionsApi extends BaseAPI {
    /**
     * Cancel the a deployment request.
     * @summary Cancel deployment request
     * @param {string} deploymentRequestId 
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentQueueActionsApi
     */
    public cancelDeploymentRequest(deploymentRequestId: string, body?: object, options?: RawAxiosRequestConfig) {
        return DeploymentQueueActionsApiFp(this.configuration).cancelDeploymentRequest(deploymentRequestId, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DeploymentStageMainCallsApi - axios parameter creator
 * @export
 */
export const DeploymentStageMainCallsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Attach service to deployment stage
         * @param {string} deploymentStageId Deployment Stage ID
         * @param {string} serviceId Service ID of an application/job/container/database
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachServiceToDeploymentStage: async (deploymentStageId: string, serviceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deploymentStageId' is not null or undefined
            assertParamExists('attachServiceToDeploymentStage', 'deploymentStageId', deploymentStageId)
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('attachServiceToDeploymentStage', 'serviceId', serviceId)
            const localVarPath = `/deploymentStage/{deploymentStageId}/service/{serviceId}`
                .replace(`{${"deploymentStageId"}}`, encodeURIComponent(String(deploymentStageId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create environment deployment stage
         * @param {string} environmentId Environment ID
         * @param {DeploymentStageRequest} [deploymentStageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironmentDeploymentStage: async (environmentId: string, deploymentStageRequest?: DeploymentStageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('createEnvironmentDeploymentStage', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/deploymentStage`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deploymentStageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete deployment stage
         * @param {string} deploymentStageId Deployment Stage ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeploymentStage: async (deploymentStageId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deploymentStageId' is not null or undefined
            assertParamExists('deleteDeploymentStage', 'deploymentStageId', deploymentStageId)
            const localVarPath = `/deploymentStage/{deploymentStageId}`
                .replace(`{${"deploymentStageId"}}`, encodeURIComponent(String(deploymentStageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit deployment stage
         * @param {string} deploymentStageId Deployment Stage ID
         * @param {DeploymentStageRequest} [deploymentStageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editDeploymentStage: async (deploymentStageId: string, deploymentStageRequest?: DeploymentStageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deploymentStageId' is not null or undefined
            assertParamExists('editDeploymentStage', 'deploymentStageId', deploymentStageId)
            const localVarPath = `/deploymentStage/{deploymentStageId}`
                .replace(`{${"deploymentStageId"}}`, encodeURIComponent(String(deploymentStageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deploymentStageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Deployment Stage
         * @param {string} deploymentStageId Deployment Stage ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeploymentStage: async (deploymentStageId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deploymentStageId' is not null or undefined
            assertParamExists('getDeploymentStage', 'deploymentStageId', deploymentStageId)
            const localVarPath = `/deploymentStage/{deploymentStageId}`
                .replace(`{${"deploymentStageId"}}`, encodeURIComponent(String(deploymentStageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Service Deployment Stage
         * @param {string} serviceId Service ID of an application/job/container/database
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeploymentStage: async (serviceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('getServiceDeploymentStage', 'serviceId', serviceId)
            const localVarPath = `/service/{serviceId}/deploymentStage`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List environment deployment stage
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentDeploymentStage: async (environmentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('listEnvironmentDeploymentStage', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/deploymentStage`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Move deployment stage after requested stage
         * @param {string} deploymentStageId Deployment Stage ID
         * @param {string} stageId Deployment Stage ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveAfterDeploymentStage: async (deploymentStageId: string, stageId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deploymentStageId' is not null or undefined
            assertParamExists('moveAfterDeploymentStage', 'deploymentStageId', deploymentStageId)
            // verify required parameter 'stageId' is not null or undefined
            assertParamExists('moveAfterDeploymentStage', 'stageId', stageId)
            const localVarPath = `/deploymentStage/{deploymentStageId}/moveAfter/{stageId}`
                .replace(`{${"deploymentStageId"}}`, encodeURIComponent(String(deploymentStageId)))
                .replace(`{${"stageId"}}`, encodeURIComponent(String(stageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Move deployment stage before requested stage
         * @param {string} deploymentStageId Deployment Stage ID
         * @param {string} stageId Deployment Stage ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveBeforeDeploymentStage: async (deploymentStageId: string, stageId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deploymentStageId' is not null or undefined
            assertParamExists('moveBeforeDeploymentStage', 'deploymentStageId', deploymentStageId)
            // verify required parameter 'stageId' is not null or undefined
            assertParamExists('moveBeforeDeploymentStage', 'stageId', stageId)
            const localVarPath = `/deploymentStage/{deploymentStageId}/moveBefore/{stageId}`
                .replace(`{${"deploymentStageId"}}`, encodeURIComponent(String(deploymentStageId)))
                .replace(`{${"stageId"}}`, encodeURIComponent(String(stageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeploymentStageMainCallsApi - functional programming interface
 * @export
 */
export const DeploymentStageMainCallsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeploymentStageMainCallsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Attach service to deployment stage
         * @param {string} deploymentStageId Deployment Stage ID
         * @param {string} serviceId Service ID of an application/job/container/database
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async attachServiceToDeploymentStage(deploymentStageId: string, serviceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentStageResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.attachServiceToDeploymentStage(deploymentStageId, serviceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeploymentStageMainCallsApi.attachServiceToDeploymentStage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create environment deployment stage
         * @param {string} environmentId Environment ID
         * @param {DeploymentStageRequest} [deploymentStageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEnvironmentDeploymentStage(environmentId: string, deploymentStageRequest?: DeploymentStageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentStageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEnvironmentDeploymentStage(environmentId, deploymentStageRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeploymentStageMainCallsApi.createEnvironmentDeploymentStage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete deployment stage
         * @param {string} deploymentStageId Deployment Stage ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDeploymentStage(deploymentStageId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDeploymentStage(deploymentStageId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeploymentStageMainCallsApi.deleteDeploymentStage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Edit deployment stage
         * @param {string} deploymentStageId Deployment Stage ID
         * @param {DeploymentStageRequest} [deploymentStageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editDeploymentStage(deploymentStageId: string, deploymentStageRequest?: DeploymentStageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentStageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editDeploymentStage(deploymentStageId, deploymentStageRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeploymentStageMainCallsApi.editDeploymentStage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Deployment Stage
         * @param {string} deploymentStageId Deployment Stage ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeploymentStage(deploymentStageId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentStageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeploymentStage(deploymentStageId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeploymentStageMainCallsApi.getDeploymentStage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Service Deployment Stage
         * @param {string} serviceId Service ID of an application/job/container/database
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceDeploymentStage(serviceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentStageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceDeploymentStage(serviceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeploymentStageMainCallsApi.getServiceDeploymentStage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List environment deployment stage
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEnvironmentDeploymentStage(environmentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentStageResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEnvironmentDeploymentStage(environmentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeploymentStageMainCallsApi.listEnvironmentDeploymentStage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Move deployment stage after requested stage
         * @param {string} deploymentStageId Deployment Stage ID
         * @param {string} stageId Deployment Stage ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moveAfterDeploymentStage(deploymentStageId: string, stageId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentStageResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moveAfterDeploymentStage(deploymentStageId, stageId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeploymentStageMainCallsApi.moveAfterDeploymentStage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Move deployment stage before requested stage
         * @param {string} deploymentStageId Deployment Stage ID
         * @param {string} stageId Deployment Stage ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moveBeforeDeploymentStage(deploymentStageId: string, stageId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentStageResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moveBeforeDeploymentStage(deploymentStageId, stageId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeploymentStageMainCallsApi.moveBeforeDeploymentStage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DeploymentStageMainCallsApi - factory interface
 * @export
 */
export const DeploymentStageMainCallsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeploymentStageMainCallsApiFp(configuration)
    return {
        /**
         * 
         * @summary Attach service to deployment stage
         * @param {string} deploymentStageId Deployment Stage ID
         * @param {string} serviceId Service ID of an application/job/container/database
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachServiceToDeploymentStage(deploymentStageId: string, serviceId: string, options?: RawAxiosRequestConfig): AxiosPromise<DeploymentStageResponseList> {
            return localVarFp.attachServiceToDeploymentStage(deploymentStageId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create environment deployment stage
         * @param {string} environmentId Environment ID
         * @param {DeploymentStageRequest} [deploymentStageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironmentDeploymentStage(environmentId: string, deploymentStageRequest?: DeploymentStageRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeploymentStageResponse> {
            return localVarFp.createEnvironmentDeploymentStage(environmentId, deploymentStageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete deployment stage
         * @param {string} deploymentStageId Deployment Stage ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeploymentStage(deploymentStageId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteDeploymentStage(deploymentStageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit deployment stage
         * @param {string} deploymentStageId Deployment Stage ID
         * @param {DeploymentStageRequest} [deploymentStageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editDeploymentStage(deploymentStageId: string, deploymentStageRequest?: DeploymentStageRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeploymentStageResponse> {
            return localVarFp.editDeploymentStage(deploymentStageId, deploymentStageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Deployment Stage
         * @param {string} deploymentStageId Deployment Stage ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeploymentStage(deploymentStageId: string, options?: RawAxiosRequestConfig): AxiosPromise<DeploymentStageResponse> {
            return localVarFp.getDeploymentStage(deploymentStageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Service Deployment Stage
         * @param {string} serviceId Service ID of an application/job/container/database
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeploymentStage(serviceId: string, options?: RawAxiosRequestConfig): AxiosPromise<DeploymentStageResponse> {
            return localVarFp.getServiceDeploymentStage(serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List environment deployment stage
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentDeploymentStage(environmentId: string, options?: RawAxiosRequestConfig): AxiosPromise<DeploymentStageResponseList> {
            return localVarFp.listEnvironmentDeploymentStage(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Move deployment stage after requested stage
         * @param {string} deploymentStageId Deployment Stage ID
         * @param {string} stageId Deployment Stage ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveAfterDeploymentStage(deploymentStageId: string, stageId: string, options?: RawAxiosRequestConfig): AxiosPromise<DeploymentStageResponseList> {
            return localVarFp.moveAfterDeploymentStage(deploymentStageId, stageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Move deployment stage before requested stage
         * @param {string} deploymentStageId Deployment Stage ID
         * @param {string} stageId Deployment Stage ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveBeforeDeploymentStage(deploymentStageId: string, stageId: string, options?: RawAxiosRequestConfig): AxiosPromise<DeploymentStageResponseList> {
            return localVarFp.moveBeforeDeploymentStage(deploymentStageId, stageId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeploymentStageMainCallsApi - object-oriented interface
 * @export
 * @class DeploymentStageMainCallsApi
 * @extends {BaseAPI}
 */
export class DeploymentStageMainCallsApi extends BaseAPI {
    /**
     * 
     * @summary Attach service to deployment stage
     * @param {string} deploymentStageId Deployment Stage ID
     * @param {string} serviceId Service ID of an application/job/container/database
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentStageMainCallsApi
     */
    public attachServiceToDeploymentStage(deploymentStageId: string, serviceId: string, options?: RawAxiosRequestConfig) {
        return DeploymentStageMainCallsApiFp(this.configuration).attachServiceToDeploymentStage(deploymentStageId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create environment deployment stage
     * @param {string} environmentId Environment ID
     * @param {DeploymentStageRequest} [deploymentStageRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentStageMainCallsApi
     */
    public createEnvironmentDeploymentStage(environmentId: string, deploymentStageRequest?: DeploymentStageRequest, options?: RawAxiosRequestConfig) {
        return DeploymentStageMainCallsApiFp(this.configuration).createEnvironmentDeploymentStage(environmentId, deploymentStageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete deployment stage
     * @param {string} deploymentStageId Deployment Stage ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentStageMainCallsApi
     */
    public deleteDeploymentStage(deploymentStageId: string, options?: RawAxiosRequestConfig) {
        return DeploymentStageMainCallsApiFp(this.configuration).deleteDeploymentStage(deploymentStageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit deployment stage
     * @param {string} deploymentStageId Deployment Stage ID
     * @param {DeploymentStageRequest} [deploymentStageRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentStageMainCallsApi
     */
    public editDeploymentStage(deploymentStageId: string, deploymentStageRequest?: DeploymentStageRequest, options?: RawAxiosRequestConfig) {
        return DeploymentStageMainCallsApiFp(this.configuration).editDeploymentStage(deploymentStageId, deploymentStageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Deployment Stage
     * @param {string} deploymentStageId Deployment Stage ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentStageMainCallsApi
     */
    public getDeploymentStage(deploymentStageId: string, options?: RawAxiosRequestConfig) {
        return DeploymentStageMainCallsApiFp(this.configuration).getDeploymentStage(deploymentStageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Service Deployment Stage
     * @param {string} serviceId Service ID of an application/job/container/database
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentStageMainCallsApi
     */
    public getServiceDeploymentStage(serviceId: string, options?: RawAxiosRequestConfig) {
        return DeploymentStageMainCallsApiFp(this.configuration).getServiceDeploymentStage(serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List environment deployment stage
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentStageMainCallsApi
     */
    public listEnvironmentDeploymentStage(environmentId: string, options?: RawAxiosRequestConfig) {
        return DeploymentStageMainCallsApiFp(this.configuration).listEnvironmentDeploymentStage(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Move deployment stage after requested stage
     * @param {string} deploymentStageId Deployment Stage ID
     * @param {string} stageId Deployment Stage ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentStageMainCallsApi
     */
    public moveAfterDeploymentStage(deploymentStageId: string, stageId: string, options?: RawAxiosRequestConfig) {
        return DeploymentStageMainCallsApiFp(this.configuration).moveAfterDeploymentStage(deploymentStageId, stageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Move deployment stage before requested stage
     * @param {string} deploymentStageId Deployment Stage ID
     * @param {string} stageId Deployment Stage ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentStageMainCallsApi
     */
    public moveBeforeDeploymentStage(deploymentStageId: string, stageId: string, options?: RawAxiosRequestConfig) {
        return DeploymentStageMainCallsApiFp(this.configuration).moveBeforeDeploymentStage(deploymentStageId, stageId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EnvironmentApi - axios parameter creator
 * @export
 */
export const EnvironmentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Check container image configuration is correct
         * @param {string} environmentId Environment ID
         * @param {ContainerImageCheckRequest} [containerImageCheckRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkContainerImage: async (environmentId: string, containerImageCheckRequest?: ContainerImageCheckRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('checkContainerImage', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/checkContainerImage`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(containerImageCheckRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check dockerfile configuration is correct
         * @param {string} environmentId Environment ID
         * @param {DockerfileCheckRequest} [dockerfileCheckRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkDockerfile: async (environmentId: string, dockerfileCheckRequest?: DockerfileCheckRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('checkDockerfile', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/checkDockerfile`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dockerfileCheckRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check git file configuration is correct
         * @param {string} environmentId Environment ID
         * @param {GitFileCheckRequest} [gitFileCheckRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkGitFile: async (environmentId: string, gitFileCheckRequest?: GitFileCheckRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('checkGitFile', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/checkGitFile`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gitFileCheckRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check helm repository configuration is correct
         * @param {string} environmentId Environment ID
         * @param {HelmCheckRequest} [helmCheckRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkHelmRepository: async (environmentId: string, helmCheckRequest?: HelmCheckRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('checkHelmRepository', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/checkHelmRepository`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(helmCheckRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List services links of an environment
         * @summary List environment services links
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentServicesLinks: async (environmentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('listEnvironmentServicesLinks', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/link`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentApi - functional programming interface
 * @export
 */
export const EnvironmentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnvironmentApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Check container image configuration is correct
         * @param {string} environmentId Environment ID
         * @param {ContainerImageCheckRequest} [containerImageCheckRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkContainerImage(environmentId: string, containerImageCheckRequest?: ContainerImageCheckRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkContainerImage(environmentId, containerImageCheckRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentApi.checkContainerImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Check dockerfile configuration is correct
         * @param {string} environmentId Environment ID
         * @param {DockerfileCheckRequest} [dockerfileCheckRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkDockerfile(environmentId: string, dockerfileCheckRequest?: DockerfileCheckRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DockerfileCheckResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkDockerfile(environmentId, dockerfileCheckRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentApi.checkDockerfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Check git file configuration is correct
         * @param {string} environmentId Environment ID
         * @param {GitFileCheckRequest} [gitFileCheckRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkGitFile(environmentId: string, gitFileCheckRequest?: GitFileCheckRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkGitFile(environmentId, gitFileCheckRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentApi.checkGitFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Check helm repository configuration is correct
         * @param {string} environmentId Environment ID
         * @param {HelmCheckRequest} [helmCheckRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkHelmRepository(environmentId: string, helmCheckRequest?: HelmCheckRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkHelmRepository(environmentId, helmCheckRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentApi.checkHelmRepository']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List services links of an environment
         * @summary List environment services links
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEnvironmentServicesLinks(environmentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEnvironmentServicesLinks(environmentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentApi.listEnvironmentServicesLinks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EnvironmentApi - factory interface
 * @export
 */
export const EnvironmentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnvironmentApiFp(configuration)
    return {
        /**
         * 
         * @summary Check container image configuration is correct
         * @param {string} environmentId Environment ID
         * @param {ContainerImageCheckRequest} [containerImageCheckRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkContainerImage(environmentId: string, containerImageCheckRequest?: ContainerImageCheckRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.checkContainerImage(environmentId, containerImageCheckRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check dockerfile configuration is correct
         * @param {string} environmentId Environment ID
         * @param {DockerfileCheckRequest} [dockerfileCheckRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkDockerfile(environmentId: string, dockerfileCheckRequest?: DockerfileCheckRequest, options?: RawAxiosRequestConfig): AxiosPromise<DockerfileCheckResponse> {
            return localVarFp.checkDockerfile(environmentId, dockerfileCheckRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check git file configuration is correct
         * @param {string} environmentId Environment ID
         * @param {GitFileCheckRequest} [gitFileCheckRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkGitFile(environmentId: string, gitFileCheckRequest?: GitFileCheckRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.checkGitFile(environmentId, gitFileCheckRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check helm repository configuration is correct
         * @param {string} environmentId Environment ID
         * @param {HelmCheckRequest} [helmCheckRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkHelmRepository(environmentId: string, helmCheckRequest?: HelmCheckRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.checkHelmRepository(environmentId, helmCheckRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * List services links of an environment
         * @summary List environment services links
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentServicesLinks(environmentId: string, options?: RawAxiosRequestConfig): AxiosPromise<LinkResponseList> {
            return localVarFp.listEnvironmentServicesLinks(environmentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnvironmentApi - object-oriented interface
 * @export
 * @class EnvironmentApi
 * @extends {BaseAPI}
 */
export class EnvironmentApi extends BaseAPI {
    /**
     * 
     * @summary Check container image configuration is correct
     * @param {string} environmentId Environment ID
     * @param {ContainerImageCheckRequest} [containerImageCheckRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public checkContainerImage(environmentId: string, containerImageCheckRequest?: ContainerImageCheckRequest, options?: RawAxiosRequestConfig) {
        return EnvironmentApiFp(this.configuration).checkContainerImage(environmentId, containerImageCheckRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check dockerfile configuration is correct
     * @param {string} environmentId Environment ID
     * @param {DockerfileCheckRequest} [dockerfileCheckRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public checkDockerfile(environmentId: string, dockerfileCheckRequest?: DockerfileCheckRequest, options?: RawAxiosRequestConfig) {
        return EnvironmentApiFp(this.configuration).checkDockerfile(environmentId, dockerfileCheckRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check git file configuration is correct
     * @param {string} environmentId Environment ID
     * @param {GitFileCheckRequest} [gitFileCheckRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public checkGitFile(environmentId: string, gitFileCheckRequest?: GitFileCheckRequest, options?: RawAxiosRequestConfig) {
        return EnvironmentApiFp(this.configuration).checkGitFile(environmentId, gitFileCheckRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check helm repository configuration is correct
     * @param {string} environmentId Environment ID
     * @param {HelmCheckRequest} [helmCheckRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public checkHelmRepository(environmentId: string, helmCheckRequest?: HelmCheckRequest, options?: RawAxiosRequestConfig) {
        return EnvironmentApiFp(this.configuration).checkHelmRepository(environmentId, helmCheckRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List services links of an environment
     * @summary List environment services links
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public listEnvironmentServicesLinks(environmentId: string, options?: RawAxiosRequestConfig) {
        return EnvironmentApiFp(this.configuration).listEnvironmentServicesLinks(environmentId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EnvironmentActionsApi - axios parameter creator
 * @export
 */
export const EnvironmentActionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancel the current deployment of your environment.
         * @summary Cancel environment deployment
         * @param {string} environmentId Environment ID
         * @param {CancelEnvironmentDeploymentRequest} [cancelEnvironmentDeploymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelEnvironmentDeployment: async (environmentId: string, cancelEnvironmentDeploymentRequest?: CancelEnvironmentDeploymentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('cancelEnvironmentDeployment', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/cancelDeployment`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cancelEnvironmentDeploymentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Clean failed jobs within an environment
         * @param {string} environmentId 
         * @param {CleanFailedJobsRequest} [cleanFailedJobsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cleanFailedJobs: async (environmentId: string, cleanFailedJobsRequest?: CleanFailedJobsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('cleanFailedJobs', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/cleanFailedJobs`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cleanFailedJobsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You must provide a name. This will create a new environment, with the same configuration, and same applications and databases. Database data is not cloned.
         * @summary Clone environment
         * @param {string} environmentId Environment ID
         * @param {CloneEnvironmentRequest} [cloneEnvironmentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneEnvironment: async (environmentId: string, cloneEnvironmentRequest?: CloneEnvironmentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('cloneEnvironment', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/clone`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloneEnvironmentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete selected services
         * @summary Delete services
         * @param {string} environmentId Environment ID
         * @param {EnvironmentServiceIdsAllRequest} [environmentServiceIdsAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSelectedServices: async (environmentId: string, environmentServiceIdsAllRequest?: EnvironmentServiceIdsAllRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('deleteSelectedServices', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/service/delete`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentServiceIdsAllRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update and deploy the selected services
         * @summary Deploy services
         * @param {string} environmentId Environment ID
         * @param {DeployAllRequest} [deployAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployAllServices: async (environmentId: string, deployAllRequest?: DeployAllRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('deployAllServices', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/service/deploy`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deployAllRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This will deploy all the services of this environment to their latest version.
         * @summary Deploy environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployEnvironment: async (environmentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('deployEnvironment', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/deploy`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update and reboot the selected services
         * @summary Reboot services
         * @param {string} environmentId Environment ID
         * @param {RebootServicesRequest} [rebootServicesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rebootServices: async (environmentId: string, rebootServicesRequest?: RebootServicesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('rebootServices', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/service/restart-service`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rebootServicesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Redeploy environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeployEnvironment: async (environmentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('redeployEnvironment', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/redeploy`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopEnvironment: async (environmentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('stopEnvironment', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/stop`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stop selected services
         * @summary Stop services
         * @param {string} environmentId Environment ID
         * @param {EnvironmentServiceIdsAllRequest} [environmentServiceIdsAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopSelectedServices: async (environmentId: string, environmentServiceIdsAllRequest?: EnvironmentServiceIdsAllRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('stopSelectedServices', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/service/stop`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentServiceIdsAllRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This will uninstall all the services of this environment.
         * @summary Uninstall environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uninstallEnvironment: async (environmentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('uninstallEnvironment', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/uninstall`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * uninstall selected services
         * @summary Uninstall services
         * @param {string} environmentId Environment ID
         * @param {EnvironmentServiceIdsAllRequest} [environmentServiceIdsAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uninstallSelectedServices: async (environmentId: string, environmentServiceIdsAllRequest?: EnvironmentServiceIdsAllRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('uninstallSelectedServices', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/service/uninstall`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentServiceIdsAllRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentActionsApi - functional programming interface
 * @export
 */
export const EnvironmentActionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnvironmentActionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Cancel the current deployment of your environment.
         * @summary Cancel environment deployment
         * @param {string} environmentId Environment ID
         * @param {CancelEnvironmentDeploymentRequest} [cancelEnvironmentDeploymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelEnvironmentDeployment(environmentId: string, cancelEnvironmentDeploymentRequest?: CancelEnvironmentDeploymentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelEnvironmentDeployment(environmentId, cancelEnvironmentDeploymentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentActionsApi.cancelEnvironmentDeployment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Clean failed jobs within an environment
         * @param {string} environmentId 
         * @param {CleanFailedJobsRequest} [cleanFailedJobsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cleanFailedJobs(environmentId: string, cleanFailedJobsRequest?: CleanFailedJobsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CleanFailedJobs200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cleanFailedJobs(environmentId, cleanFailedJobsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentActionsApi.cleanFailedJobs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * You must provide a name. This will create a new environment, with the same configuration, and same applications and databases. Database data is not cloned.
         * @summary Clone environment
         * @param {string} environmentId Environment ID
         * @param {CloneEnvironmentRequest} [cloneEnvironmentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloneEnvironment(environmentId: string, cloneEnvironmentRequest?: CloneEnvironmentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Environment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cloneEnvironment(environmentId, cloneEnvironmentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentActionsApi.cloneEnvironment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete selected services
         * @summary Delete services
         * @param {string} environmentId Environment ID
         * @param {EnvironmentServiceIdsAllRequest} [environmentServiceIdsAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSelectedServices(environmentId: string, environmentServiceIdsAllRequest?: EnvironmentServiceIdsAllRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSelectedServices(environmentId, environmentServiceIdsAllRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentActionsApi.deleteSelectedServices']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update and deploy the selected services
         * @summary Deploy services
         * @param {string} environmentId Environment ID
         * @param {DeployAllRequest} [deployAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployAllServices(environmentId: string, deployAllRequest?: DeployAllRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployAllServices(environmentId, deployAllRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentActionsApi.deployAllServices']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This will deploy all the services of this environment to their latest version.
         * @summary Deploy environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployEnvironment(environmentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployEnvironment(environmentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentActionsApi.deployEnvironment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update and reboot the selected services
         * @summary Reboot services
         * @param {string} environmentId Environment ID
         * @param {RebootServicesRequest} [rebootServicesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rebootServices(environmentId: string, rebootServicesRequest?: RebootServicesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rebootServices(environmentId, rebootServicesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentActionsApi.rebootServices']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Redeploy environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async redeployEnvironment(environmentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.redeployEnvironment(environmentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentActionsApi.redeployEnvironment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Stop environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopEnvironment(environmentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopEnvironment(environmentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentActionsApi.stopEnvironment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Stop selected services
         * @summary Stop services
         * @param {string} environmentId Environment ID
         * @param {EnvironmentServiceIdsAllRequest} [environmentServiceIdsAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopSelectedServices(environmentId: string, environmentServiceIdsAllRequest?: EnvironmentServiceIdsAllRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopSelectedServices(environmentId, environmentServiceIdsAllRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentActionsApi.stopSelectedServices']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This will uninstall all the services of this environment.
         * @summary Uninstall environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uninstallEnvironment(environmentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uninstallEnvironment(environmentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentActionsApi.uninstallEnvironment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * uninstall selected services
         * @summary Uninstall services
         * @param {string} environmentId Environment ID
         * @param {EnvironmentServiceIdsAllRequest} [environmentServiceIdsAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uninstallSelectedServices(environmentId: string, environmentServiceIdsAllRequest?: EnvironmentServiceIdsAllRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uninstallSelectedServices(environmentId, environmentServiceIdsAllRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentActionsApi.uninstallSelectedServices']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EnvironmentActionsApi - factory interface
 * @export
 */
export const EnvironmentActionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnvironmentActionsApiFp(configuration)
    return {
        /**
         * Cancel the current deployment of your environment.
         * @summary Cancel environment deployment
         * @param {string} environmentId Environment ID
         * @param {CancelEnvironmentDeploymentRequest} [cancelEnvironmentDeploymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelEnvironmentDeployment(environmentId: string, cancelEnvironmentDeploymentRequest?: CancelEnvironmentDeploymentRequest, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentStatus> {
            return localVarFp.cancelEnvironmentDeployment(environmentId, cancelEnvironmentDeploymentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Clean failed jobs within an environment
         * @param {string} environmentId 
         * @param {CleanFailedJobsRequest} [cleanFailedJobsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cleanFailedJobs(environmentId: string, cleanFailedJobsRequest?: CleanFailedJobsRequest, options?: RawAxiosRequestConfig): AxiosPromise<CleanFailedJobs200Response> {
            return localVarFp.cleanFailedJobs(environmentId, cleanFailedJobsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * You must provide a name. This will create a new environment, with the same configuration, and same applications and databases. Database data is not cloned.
         * @summary Clone environment
         * @param {string} environmentId Environment ID
         * @param {CloneEnvironmentRequest} [cloneEnvironmentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneEnvironment(environmentId: string, cloneEnvironmentRequest?: CloneEnvironmentRequest, options?: RawAxiosRequestConfig): AxiosPromise<Environment> {
            return localVarFp.cloneEnvironment(environmentId, cloneEnvironmentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete selected services
         * @summary Delete services
         * @param {string} environmentId Environment ID
         * @param {EnvironmentServiceIdsAllRequest} [environmentServiceIdsAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSelectedServices(environmentId: string, environmentServiceIdsAllRequest?: EnvironmentServiceIdsAllRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSelectedServices(environmentId, environmentServiceIdsAllRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update and deploy the selected services
         * @summary Deploy services
         * @param {string} environmentId Environment ID
         * @param {DeployAllRequest} [deployAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployAllServices(environmentId: string, deployAllRequest?: DeployAllRequest, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentStatus> {
            return localVarFp.deployAllServices(environmentId, deployAllRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This will deploy all the services of this environment to their latest version.
         * @summary Deploy environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployEnvironment(environmentId: string, options?: RawAxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.deployEnvironment(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update and reboot the selected services
         * @summary Reboot services
         * @param {string} environmentId Environment ID
         * @param {RebootServicesRequest} [rebootServicesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rebootServices(environmentId: string, rebootServicesRequest?: RebootServicesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.rebootServices(environmentId, rebootServicesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Redeploy environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeployEnvironment(environmentId: string, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentStatus> {
            return localVarFp.redeployEnvironment(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Stop environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopEnvironment(environmentId: string, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentStatus> {
            return localVarFp.stopEnvironment(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Stop selected services
         * @summary Stop services
         * @param {string} environmentId Environment ID
         * @param {EnvironmentServiceIdsAllRequest} [environmentServiceIdsAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopSelectedServices(environmentId: string, environmentServiceIdsAllRequest?: EnvironmentServiceIdsAllRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.stopSelectedServices(environmentId, environmentServiceIdsAllRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This will uninstall all the services of this environment.
         * @summary Uninstall environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uninstallEnvironment(environmentId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.uninstallEnvironment(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * uninstall selected services
         * @summary Uninstall services
         * @param {string} environmentId Environment ID
         * @param {EnvironmentServiceIdsAllRequest} [environmentServiceIdsAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uninstallSelectedServices(environmentId: string, environmentServiceIdsAllRequest?: EnvironmentServiceIdsAllRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.uninstallSelectedServices(environmentId, environmentServiceIdsAllRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnvironmentActionsApi - object-oriented interface
 * @export
 * @class EnvironmentActionsApi
 * @extends {BaseAPI}
 */
export class EnvironmentActionsApi extends BaseAPI {
    /**
     * Cancel the current deployment of your environment.
     * @summary Cancel environment deployment
     * @param {string} environmentId Environment ID
     * @param {CancelEnvironmentDeploymentRequest} [cancelEnvironmentDeploymentRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentActionsApi
     */
    public cancelEnvironmentDeployment(environmentId: string, cancelEnvironmentDeploymentRequest?: CancelEnvironmentDeploymentRequest, options?: RawAxiosRequestConfig) {
        return EnvironmentActionsApiFp(this.configuration).cancelEnvironmentDeployment(environmentId, cancelEnvironmentDeploymentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Clean failed jobs within an environment
     * @param {string} environmentId 
     * @param {CleanFailedJobsRequest} [cleanFailedJobsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentActionsApi
     */
    public cleanFailedJobs(environmentId: string, cleanFailedJobsRequest?: CleanFailedJobsRequest, options?: RawAxiosRequestConfig) {
        return EnvironmentActionsApiFp(this.configuration).cleanFailedJobs(environmentId, cleanFailedJobsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You must provide a name. This will create a new environment, with the same configuration, and same applications and databases. Database data is not cloned.
     * @summary Clone environment
     * @param {string} environmentId Environment ID
     * @param {CloneEnvironmentRequest} [cloneEnvironmentRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentActionsApi
     */
    public cloneEnvironment(environmentId: string, cloneEnvironmentRequest?: CloneEnvironmentRequest, options?: RawAxiosRequestConfig) {
        return EnvironmentActionsApiFp(this.configuration).cloneEnvironment(environmentId, cloneEnvironmentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete selected services
     * @summary Delete services
     * @param {string} environmentId Environment ID
     * @param {EnvironmentServiceIdsAllRequest} [environmentServiceIdsAllRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentActionsApi
     */
    public deleteSelectedServices(environmentId: string, environmentServiceIdsAllRequest?: EnvironmentServiceIdsAllRequest, options?: RawAxiosRequestConfig) {
        return EnvironmentActionsApiFp(this.configuration).deleteSelectedServices(environmentId, environmentServiceIdsAllRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update and deploy the selected services
     * @summary Deploy services
     * @param {string} environmentId Environment ID
     * @param {DeployAllRequest} [deployAllRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentActionsApi
     */
    public deployAllServices(environmentId: string, deployAllRequest?: DeployAllRequest, options?: RawAxiosRequestConfig) {
        return EnvironmentActionsApiFp(this.configuration).deployAllServices(environmentId, deployAllRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will deploy all the services of this environment to their latest version.
     * @summary Deploy environment
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentActionsApi
     */
    public deployEnvironment(environmentId: string, options?: RawAxiosRequestConfig) {
        return EnvironmentActionsApiFp(this.configuration).deployEnvironment(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update and reboot the selected services
     * @summary Reboot services
     * @param {string} environmentId Environment ID
     * @param {RebootServicesRequest} [rebootServicesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentActionsApi
     */
    public rebootServices(environmentId: string, rebootServicesRequest?: RebootServicesRequest, options?: RawAxiosRequestConfig) {
        return EnvironmentActionsApiFp(this.configuration).rebootServices(environmentId, rebootServicesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Redeploy environment
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentActionsApi
     */
    public redeployEnvironment(environmentId: string, options?: RawAxiosRequestConfig) {
        return EnvironmentActionsApiFp(this.configuration).redeployEnvironment(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Stop environment
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentActionsApi
     */
    public stopEnvironment(environmentId: string, options?: RawAxiosRequestConfig) {
        return EnvironmentActionsApiFp(this.configuration).stopEnvironment(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Stop selected services
     * @summary Stop services
     * @param {string} environmentId Environment ID
     * @param {EnvironmentServiceIdsAllRequest} [environmentServiceIdsAllRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentActionsApi
     */
    public stopSelectedServices(environmentId: string, environmentServiceIdsAllRequest?: EnvironmentServiceIdsAllRequest, options?: RawAxiosRequestConfig) {
        return EnvironmentActionsApiFp(this.configuration).stopSelectedServices(environmentId, environmentServiceIdsAllRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will uninstall all the services of this environment.
     * @summary Uninstall environment
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentActionsApi
     */
    public uninstallEnvironment(environmentId: string, options?: RawAxiosRequestConfig) {
        return EnvironmentActionsApiFp(this.configuration).uninstallEnvironment(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * uninstall selected services
     * @summary Uninstall services
     * @param {string} environmentId Environment ID
     * @param {EnvironmentServiceIdsAllRequest} [environmentServiceIdsAllRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentActionsApi
     */
    public uninstallSelectedServices(environmentId: string, environmentServiceIdsAllRequest?: EnvironmentServiceIdsAllRequest, options?: RawAxiosRequestConfig) {
        return EnvironmentActionsApiFp(this.configuration).uninstallSelectedServices(environmentId, environmentServiceIdsAllRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EnvironmentDeploymentHistoryApi - axios parameter creator
 * @export
 */
export const EnvironmentDeploymentHistoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List previous and current environment deployments with the status deployment and the related services. By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter
         * @summary List environment deployments
         * @param {string} environmentId Environment ID
         * @param {string} [startId] Starting point after which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentDeploymentHistory: async (environmentId: string, startId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('listEnvironmentDeploymentHistory', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/deploymentHistory`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (startId !== undefined) {
                localVarQueryParameter['startId'] = startId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List previous and current environment deployments with the status deployment and the related services. By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter
         * @summary List environment deployments
         * @param {string} environmentId 
         * @param {number | null} [pageSize] The number of deployments to return in the current page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentDeploymentHistoryV2: async (environmentId: string, pageSize?: number | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('listEnvironmentDeploymentHistoryV2', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/deploymentHistoryV2`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentDeploymentHistoryApi - functional programming interface
 * @export
 */
export const EnvironmentDeploymentHistoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnvironmentDeploymentHistoryApiAxiosParamCreator(configuration)
    return {
        /**
         * List previous and current environment deployments with the status deployment and the related services. By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter
         * @summary List environment deployments
         * @param {string} environmentId Environment ID
         * @param {string} [startId] Starting point after which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEnvironmentDeploymentHistory(environmentId: string, startId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentHistoryEnvironmentPaginatedResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEnvironmentDeploymentHistory(environmentId, startId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentDeploymentHistoryApi.listEnvironmentDeploymentHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List previous and current environment deployments with the status deployment and the related services. By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter
         * @summary List environment deployments
         * @param {string} environmentId 
         * @param {number | null} [pageSize] The number of deployments to return in the current page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEnvironmentDeploymentHistoryV2(environmentId: string, pageSize?: number | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentHistoryEnvironmentPaginatedResponseListV2>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEnvironmentDeploymentHistoryV2(environmentId, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentDeploymentHistoryApi.listEnvironmentDeploymentHistoryV2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EnvironmentDeploymentHistoryApi - factory interface
 * @export
 */
export const EnvironmentDeploymentHistoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnvironmentDeploymentHistoryApiFp(configuration)
    return {
        /**
         * List previous and current environment deployments with the status deployment and the related services. By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter
         * @summary List environment deployments
         * @param {string} environmentId Environment ID
         * @param {string} [startId] Starting point after which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentDeploymentHistory(environmentId: string, startId?: string, options?: RawAxiosRequestConfig): AxiosPromise<DeploymentHistoryEnvironmentPaginatedResponseList> {
            return localVarFp.listEnvironmentDeploymentHistory(environmentId, startId, options).then((request) => request(axios, basePath));
        },
        /**
         * List previous and current environment deployments with the status deployment and the related services. By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter
         * @summary List environment deployments
         * @param {string} environmentId 
         * @param {number | null} [pageSize] The number of deployments to return in the current page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentDeploymentHistoryV2(environmentId: string, pageSize?: number | null, options?: RawAxiosRequestConfig): AxiosPromise<DeploymentHistoryEnvironmentPaginatedResponseListV2> {
            return localVarFp.listEnvironmentDeploymentHistoryV2(environmentId, pageSize, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnvironmentDeploymentHistoryApi - object-oriented interface
 * @export
 * @class EnvironmentDeploymentHistoryApi
 * @extends {BaseAPI}
 */
export class EnvironmentDeploymentHistoryApi extends BaseAPI {
    /**
     * List previous and current environment deployments with the status deployment and the related services. By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter
     * @summary List environment deployments
     * @param {string} environmentId Environment ID
     * @param {string} [startId] Starting point after which to return results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentDeploymentHistoryApi
     */
    public listEnvironmentDeploymentHistory(environmentId: string, startId?: string, options?: RawAxiosRequestConfig) {
        return EnvironmentDeploymentHistoryApiFp(this.configuration).listEnvironmentDeploymentHistory(environmentId, startId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List previous and current environment deployments with the status deployment and the related services. By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter
     * @summary List environment deployments
     * @param {string} environmentId 
     * @param {number | null} [pageSize] The number of deployments to return in the current page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentDeploymentHistoryApi
     */
    public listEnvironmentDeploymentHistoryV2(environmentId: string, pageSize?: number | null, options?: RawAxiosRequestConfig) {
        return EnvironmentDeploymentHistoryApiFp(this.configuration).listEnvironmentDeploymentHistoryV2(environmentId, pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EnvironmentDeploymentRuleApi - axios parameter creator
 * @export
 */
export const EnvironmentDeploymentRuleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Edit an environment deployment rule
         * @param {string} environmentId Environment ID
         * @param {string} deploymentRuleId Deployment Rule ID
         * @param {EnvironmentDeploymentRuleEditRequest} [environmentDeploymentRuleEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editEnvironmentDeploymentRule: async (environmentId: string, deploymentRuleId: string, environmentDeploymentRuleEditRequest?: EnvironmentDeploymentRuleEditRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('editEnvironmentDeploymentRule', 'environmentId', environmentId)
            // verify required parameter 'deploymentRuleId' is not null or undefined
            assertParamExists('editEnvironmentDeploymentRule', 'deploymentRuleId', deploymentRuleId)
            const localVarPath = `/environment/{environmentId}/deploymentRule/{deploymentRuleId}`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)))
                .replace(`{${"deploymentRuleId"}}`, encodeURIComponent(String(deploymentRuleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentDeploymentRuleEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get environment deployment rule
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentDeploymentRule: async (environmentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('getEnvironmentDeploymentRule', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/deploymentRule`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentDeploymentRuleApi - functional programming interface
 * @export
 */
export const EnvironmentDeploymentRuleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnvironmentDeploymentRuleApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Edit an environment deployment rule
         * @param {string} environmentId Environment ID
         * @param {string} deploymentRuleId Deployment Rule ID
         * @param {EnvironmentDeploymentRuleEditRequest} [environmentDeploymentRuleEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editEnvironmentDeploymentRule(environmentId: string, deploymentRuleId: string, environmentDeploymentRuleEditRequest?: EnvironmentDeploymentRuleEditRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentDeploymentRule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editEnvironmentDeploymentRule(environmentId, deploymentRuleId, environmentDeploymentRuleEditRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentDeploymentRuleApi.editEnvironmentDeploymentRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get environment deployment rule
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironmentDeploymentRule(environmentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentDeploymentRule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironmentDeploymentRule(environmentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentDeploymentRuleApi.getEnvironmentDeploymentRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EnvironmentDeploymentRuleApi - factory interface
 * @export
 */
export const EnvironmentDeploymentRuleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnvironmentDeploymentRuleApiFp(configuration)
    return {
        /**
         * 
         * @summary Edit an environment deployment rule
         * @param {string} environmentId Environment ID
         * @param {string} deploymentRuleId Deployment Rule ID
         * @param {EnvironmentDeploymentRuleEditRequest} [environmentDeploymentRuleEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editEnvironmentDeploymentRule(environmentId: string, deploymentRuleId: string, environmentDeploymentRuleEditRequest?: EnvironmentDeploymentRuleEditRequest, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentDeploymentRule> {
            return localVarFp.editEnvironmentDeploymentRule(environmentId, deploymentRuleId, environmentDeploymentRuleEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get environment deployment rule
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentDeploymentRule(environmentId: string, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentDeploymentRule> {
            return localVarFp.getEnvironmentDeploymentRule(environmentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnvironmentDeploymentRuleApi - object-oriented interface
 * @export
 * @class EnvironmentDeploymentRuleApi
 * @extends {BaseAPI}
 */
export class EnvironmentDeploymentRuleApi extends BaseAPI {
    /**
     * 
     * @summary Edit an environment deployment rule
     * @param {string} environmentId Environment ID
     * @param {string} deploymentRuleId Deployment Rule ID
     * @param {EnvironmentDeploymentRuleEditRequest} [environmentDeploymentRuleEditRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentDeploymentRuleApi
     */
    public editEnvironmentDeploymentRule(environmentId: string, deploymentRuleId: string, environmentDeploymentRuleEditRequest?: EnvironmentDeploymentRuleEditRequest, options?: RawAxiosRequestConfig) {
        return EnvironmentDeploymentRuleApiFp(this.configuration).editEnvironmentDeploymentRule(environmentId, deploymentRuleId, environmentDeploymentRuleEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get environment deployment rule
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentDeploymentRuleApi
     */
    public getEnvironmentDeploymentRule(environmentId: string, options?: RawAxiosRequestConfig) {
        return EnvironmentDeploymentRuleApiFp(this.configuration).getEnvironmentDeploymentRule(environmentId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EnvironmentExportApi - axios parameter creator
 * @export
 */
export const EnvironmentExportApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Export full environment and its resources into Terraform manifests
         * @param {string} environmentId Environment ID
         * @param {boolean} [exportSecrets] export Secrets from configuration and include them into Terraform export
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportEnvironmentConfigurationIntoTerraform: async (environmentId: string, exportSecrets?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('exportEnvironmentConfigurationIntoTerraform', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/terraformExport`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (exportSecrets !== undefined) {
                localVarQueryParameter['exportSecrets'] = exportSecrets;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentExportApi - functional programming interface
 * @export
 */
export const EnvironmentExportApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnvironmentExportApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Export full environment and its resources into Terraform manifests
         * @param {string} environmentId Environment ID
         * @param {boolean} [exportSecrets] export Secrets from configuration and include them into Terraform export
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportEnvironmentConfigurationIntoTerraform(environmentId: string, exportSecrets?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportEnvironmentConfigurationIntoTerraform(environmentId, exportSecrets, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentExportApi.exportEnvironmentConfigurationIntoTerraform']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EnvironmentExportApi - factory interface
 * @export
 */
export const EnvironmentExportApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnvironmentExportApiFp(configuration)
    return {
        /**
         * 
         * @summary Export full environment and its resources into Terraform manifests
         * @param {string} environmentId Environment ID
         * @param {boolean} [exportSecrets] export Secrets from configuration and include them into Terraform export
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportEnvironmentConfigurationIntoTerraform(environmentId: string, exportSecrets?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.exportEnvironmentConfigurationIntoTerraform(environmentId, exportSecrets, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnvironmentExportApi - object-oriented interface
 * @export
 * @class EnvironmentExportApi
 * @extends {BaseAPI}
 */
export class EnvironmentExportApi extends BaseAPI {
    /**
     * 
     * @summary Export full environment and its resources into Terraform manifests
     * @param {string} environmentId Environment ID
     * @param {boolean} [exportSecrets] export Secrets from configuration and include them into Terraform export
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentExportApi
     */
    public exportEnvironmentConfigurationIntoTerraform(environmentId: string, exportSecrets?: boolean, options?: RawAxiosRequestConfig) {
        return EnvironmentExportApiFp(this.configuration).exportEnvironmentConfigurationIntoTerraform(environmentId, exportSecrets, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EnvironmentLogsApi - axios parameter creator
 * @export
 */
export const EnvironmentLogsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This returns the last 1000 environment deployment logs.
         * @summary List environment deployment logs
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentLog: async (environmentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('listEnvironmentLog', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/log`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This returns the last 1000 environment deployment logs v2
         * @summary List environment deployment logs v2
         * @param {string} environmentId Environment ID
         * @param {string} [version] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentLogs: async (environmentId: string, version?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('listEnvironmentLogs', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/logs`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentLogsApi - functional programming interface
 * @export
 */
export const EnvironmentLogsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnvironmentLogsApiAxiosParamCreator(configuration)
    return {
        /**
         * This returns the last 1000 environment deployment logs.
         * @summary List environment deployment logs
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEnvironmentLog(environmentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentLogResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEnvironmentLog(environmentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentLogsApi.listEnvironmentLog']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This returns the last 1000 environment deployment logs v2
         * @summary List environment deployment logs v2
         * @param {string} environmentId Environment ID
         * @param {string} [version] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEnvironmentLogs(environmentId: string, version?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EnvironmentLogs>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEnvironmentLogs(environmentId, version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentLogsApi.listEnvironmentLogs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EnvironmentLogsApi - factory interface
 * @export
 */
export const EnvironmentLogsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnvironmentLogsApiFp(configuration)
    return {
        /**
         * This returns the last 1000 environment deployment logs.
         * @summary List environment deployment logs
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentLog(environmentId: string, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentLogResponseList> {
            return localVarFp.listEnvironmentLog(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * This returns the last 1000 environment deployment logs v2
         * @summary List environment deployment logs v2
         * @param {string} environmentId Environment ID
         * @param {string} [version] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentLogs(environmentId: string, version?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<EnvironmentLogs>> {
            return localVarFp.listEnvironmentLogs(environmentId, version, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnvironmentLogsApi - object-oriented interface
 * @export
 * @class EnvironmentLogsApi
 * @extends {BaseAPI}
 */
export class EnvironmentLogsApi extends BaseAPI {
    /**
     * This returns the last 1000 environment deployment logs.
     * @summary List environment deployment logs
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentLogsApi
     */
    public listEnvironmentLog(environmentId: string, options?: RawAxiosRequestConfig) {
        return EnvironmentLogsApiFp(this.configuration).listEnvironmentLog(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This returns the last 1000 environment deployment logs v2
     * @summary List environment deployment logs v2
     * @param {string} environmentId Environment ID
     * @param {string} [version] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentLogsApi
     */
    public listEnvironmentLogs(environmentId: string, version?: string, options?: RawAxiosRequestConfig) {
        return EnvironmentLogsApiFp(this.configuration).listEnvironmentLogs(environmentId, version, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EnvironmentMainCallsApi - axios parameter creator
 * @export
 */
export const EnvironmentMainCallsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * To delete an environment you must have the admin permission
         * @summary Delete an environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEnvironment: async (environmentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('deleteEnvironment', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To edit an environment you must have the admin permission
         * @summary Edit an environment
         * @param {string} environmentId Environment ID
         * @param {EnvironmentEditRequest} [environmentEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editEnvironment: async (environmentId: string, environmentEditRequest?: EnvironmentEditRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('editEnvironment', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get environment by ID
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironment: async (environmentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('getEnvironment', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get environment status
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentStatus: async (environmentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('getEnvironmentStatus', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/status`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get environment statuses with services status
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentStatuses: async (environmentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('getEnvironmentStatuses', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/statuses`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get environment statuses with stages
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentStatusesWithStages: async (environmentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('getEnvironmentStatusesWithStages', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/statusesWithStages`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Deployment Queue Request By EnvironmentId
         * @param {string} environmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDeploymentRequestByEnvironmentId: async (environmentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('listDeploymentRequestByEnvironmentId', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/deploymentQueue`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Deployment Queue Request By ServiceId
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDeploymentRequestByServiceId: async (serviceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('listDeploymentRequestByServiceId', 'serviceId', serviceId)
            const localVarPath = `/service/{serviceId}/deploymentQueue`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Services By EnvironmentId
         * @param {string} environmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServicesByEnvironmentId: async (environmentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('listServicesByEnvironmentId', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/services`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentMainCallsApi - functional programming interface
 * @export
 */
export const EnvironmentMainCallsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnvironmentMainCallsApiAxiosParamCreator(configuration)
    return {
        /**
         * To delete an environment you must have the admin permission
         * @summary Delete an environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEnvironment(environmentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEnvironment(environmentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentMainCallsApi.deleteEnvironment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * To edit an environment you must have the admin permission
         * @summary Edit an environment
         * @param {string} environmentId Environment ID
         * @param {EnvironmentEditRequest} [environmentEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editEnvironment(environmentId: string, environmentEditRequest?: EnvironmentEditRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Environment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editEnvironment(environmentId, environmentEditRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentMainCallsApi.editEnvironment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get environment by ID
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironment(environmentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Environment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironment(environmentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentMainCallsApi.getEnvironment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get environment status
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironmentStatus(environmentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironmentStatus(environmentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentMainCallsApi.getEnvironmentStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get environment statuses with services status
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironmentStatuses(environmentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentStatuses>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironmentStatuses(environmentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentMainCallsApi.getEnvironmentStatuses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get environment statuses with stages
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironmentStatusesWithStages(environmentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentStatusesWithStages>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironmentStatusesWithStages(environmentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentMainCallsApi.getEnvironmentStatusesWithStages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Deployment Queue Request By EnvironmentId
         * @param {string} environmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDeploymentRequestByEnvironmentId(environmentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListDeploymentRequestByEnvironmentId200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDeploymentRequestByEnvironmentId(environmentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentMainCallsApi.listDeploymentRequestByEnvironmentId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Deployment Queue Request By ServiceId
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDeploymentRequestByServiceId(serviceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListDeploymentRequestByServiceId200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDeploymentRequestByServiceId(serviceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentMainCallsApi.listDeploymentRequestByServiceId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Services By EnvironmentId
         * @param {string} environmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listServicesByEnvironmentId(environmentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListServicesByEnvironmentId200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listServicesByEnvironmentId(environmentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentMainCallsApi.listServicesByEnvironmentId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EnvironmentMainCallsApi - factory interface
 * @export
 */
export const EnvironmentMainCallsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnvironmentMainCallsApiFp(configuration)
    return {
        /**
         * To delete an environment you must have the admin permission
         * @summary Delete an environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEnvironment(environmentId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteEnvironment(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * To edit an environment you must have the admin permission
         * @summary Edit an environment
         * @param {string} environmentId Environment ID
         * @param {EnvironmentEditRequest} [environmentEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editEnvironment(environmentId: string, environmentEditRequest?: EnvironmentEditRequest, options?: RawAxiosRequestConfig): AxiosPromise<Environment> {
            return localVarFp.editEnvironment(environmentId, environmentEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get environment by ID
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironment(environmentId: string, options?: RawAxiosRequestConfig): AxiosPromise<Environment> {
            return localVarFp.getEnvironment(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get environment status
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentStatus(environmentId: string, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentStatus> {
            return localVarFp.getEnvironmentStatus(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get environment statuses with services status
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentStatuses(environmentId: string, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentStatuses> {
            return localVarFp.getEnvironmentStatuses(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get environment statuses with stages
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentStatusesWithStages(environmentId: string, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentStatusesWithStages> {
            return localVarFp.getEnvironmentStatusesWithStages(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Deployment Queue Request By EnvironmentId
         * @param {string} environmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDeploymentRequestByEnvironmentId(environmentId: string, options?: RawAxiosRequestConfig): AxiosPromise<ListDeploymentRequestByEnvironmentId200Response> {
            return localVarFp.listDeploymentRequestByEnvironmentId(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Deployment Queue Request By ServiceId
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDeploymentRequestByServiceId(serviceId: string, options?: RawAxiosRequestConfig): AxiosPromise<ListDeploymentRequestByServiceId200Response> {
            return localVarFp.listDeploymentRequestByServiceId(serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Services By EnvironmentId
         * @param {string} environmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServicesByEnvironmentId(environmentId: string, options?: RawAxiosRequestConfig): AxiosPromise<ListServicesByEnvironmentId200Response> {
            return localVarFp.listServicesByEnvironmentId(environmentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnvironmentMainCallsApi - object-oriented interface
 * @export
 * @class EnvironmentMainCallsApi
 * @extends {BaseAPI}
 */
export class EnvironmentMainCallsApi extends BaseAPI {
    /**
     * To delete an environment you must have the admin permission
     * @summary Delete an environment
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentMainCallsApi
     */
    public deleteEnvironment(environmentId: string, options?: RawAxiosRequestConfig) {
        return EnvironmentMainCallsApiFp(this.configuration).deleteEnvironment(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To edit an environment you must have the admin permission
     * @summary Edit an environment
     * @param {string} environmentId Environment ID
     * @param {EnvironmentEditRequest} [environmentEditRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentMainCallsApi
     */
    public editEnvironment(environmentId: string, environmentEditRequest?: EnvironmentEditRequest, options?: RawAxiosRequestConfig) {
        return EnvironmentMainCallsApiFp(this.configuration).editEnvironment(environmentId, environmentEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get environment by ID
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentMainCallsApi
     */
    public getEnvironment(environmentId: string, options?: RawAxiosRequestConfig) {
        return EnvironmentMainCallsApiFp(this.configuration).getEnvironment(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get environment status
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentMainCallsApi
     */
    public getEnvironmentStatus(environmentId: string, options?: RawAxiosRequestConfig) {
        return EnvironmentMainCallsApiFp(this.configuration).getEnvironmentStatus(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get environment statuses with services status
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentMainCallsApi
     */
    public getEnvironmentStatuses(environmentId: string, options?: RawAxiosRequestConfig) {
        return EnvironmentMainCallsApiFp(this.configuration).getEnvironmentStatuses(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get environment statuses with stages
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentMainCallsApi
     */
    public getEnvironmentStatusesWithStages(environmentId: string, options?: RawAxiosRequestConfig) {
        return EnvironmentMainCallsApiFp(this.configuration).getEnvironmentStatusesWithStages(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Deployment Queue Request By EnvironmentId
     * @param {string} environmentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentMainCallsApi
     */
    public listDeploymentRequestByEnvironmentId(environmentId: string, options?: RawAxiosRequestConfig) {
        return EnvironmentMainCallsApiFp(this.configuration).listDeploymentRequestByEnvironmentId(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Deployment Queue Request By ServiceId
     * @param {string} serviceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentMainCallsApi
     */
    public listDeploymentRequestByServiceId(serviceId: string, options?: RawAxiosRequestConfig) {
        return EnvironmentMainCallsApiFp(this.configuration).listDeploymentRequestByServiceId(serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Services By EnvironmentId
     * @param {string} environmentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentMainCallsApi
     */
    public listServicesByEnvironmentId(environmentId: string, options?: RawAxiosRequestConfig) {
        return EnvironmentMainCallsApiFp(this.configuration).listServicesByEnvironmentId(environmentId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EnvironmentSecretApi - axios parameter creator
 * @export
 */
export const EnvironmentSecretApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * - Add a secret to the environment.   - If the secret key already exists, then it will be replaced by the new one.   - If the secret value points toward an existing secret key, it will be considered as an alias. 
         * @summary Add a secret to the environment
         * @param {string} environmentId Environment ID
         * @param {SecretRequest} [secretRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironmentSecret: async (environmentId: string, secretRequest?: SecretRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('createEnvironmentSecret', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/secret`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(secretRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to add an alias at environment level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at environment level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - You can\'t create an alias on an alias 
         * @summary Create a secret alias at the environment level
         * @param {string} environmentId Environment ID
         * @param {string} secretId Secret ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironmentSecretAlias: async (environmentId: string, secretId: string, key?: Key, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('createEnvironmentSecretAlias', 'environmentId', environmentId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('createEnvironmentSecretAlias', 'secretId', secretId)
            const localVarPath = `/environment/{environmentId}/secret/{secretId}/alias`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(key, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to override at environment level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at environment level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
         * @summary Create a secret override at the environment level
         * @param {string} environmentId Environment ID
         * @param {string} secretId Secret ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironmentSecretOverride: async (environmentId: string, secretId: string, value?: Value, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('createEnvironmentSecretOverride', 'environmentId', environmentId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('createEnvironmentSecretOverride', 'secretId', secretId)
            const localVarPath = `/environment/{environmentId}/secret/{secretId}/override`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(value, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well  operationId: deleteEnvironmentSecret 
         * @summary Delete a secret from the environment
         * @param {string} environmentId Environment ID
         * @param {string} secretId Secret ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEnvironmentSecret: async (environmentId: string, secretId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('deleteEnvironmentSecret', 'environmentId', environmentId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('deleteEnvironmentSecret', 'secretId', secretId)
            const localVarPath = `/environment/{environmentId}/secret/{secretId}`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit a secret belonging to the environment
         * @param {string} environmentId Environment ID
         * @param {string} secretId Secret ID
         * @param {SecretEditRequest} secretEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editEnvironmentSecret: async (environmentId: string, secretId: string, secretEditRequest: SecretEditRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('editEnvironmentSecret', 'environmentId', environmentId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('editEnvironmentSecret', 'secretId', secretId)
            // verify required parameter 'secretEditRequest' is not null or undefined
            assertParamExists('editEnvironmentSecret', 'secretEditRequest', secretEditRequest)
            const localVarPath = `/environment/{environmentId}/secret/{secretId}`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(secretEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List environment secrets
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentSecrets: async (environmentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('listEnvironmentSecrets', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/secret`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentSecretApi - functional programming interface
 * @export
 */
export const EnvironmentSecretApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnvironmentSecretApiAxiosParamCreator(configuration)
    return {
        /**
         * - Add a secret to the environment.   - If the secret key already exists, then it will be replaced by the new one.   - If the secret value points toward an existing secret key, it will be considered as an alias. 
         * @summary Add a secret to the environment
         * @param {string} environmentId Environment ID
         * @param {SecretRequest} [secretRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEnvironmentSecret(environmentId: string, secretRequest?: SecretRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEnvironmentSecret(environmentId, secretRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentSecretApi.createEnvironmentSecret']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - Allows you to add an alias at environment level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at environment level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - You can\'t create an alias on an alias 
         * @summary Create a secret alias at the environment level
         * @param {string} environmentId Environment ID
         * @param {string} secretId Secret ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEnvironmentSecretAlias(environmentId: string, secretId: string, key?: Key, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEnvironmentSecretAlias(environmentId, secretId, key, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentSecretApi.createEnvironmentSecretAlias']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - Allows you to override at environment level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at environment level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
         * @summary Create a secret override at the environment level
         * @param {string} environmentId Environment ID
         * @param {string} secretId Secret ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEnvironmentSecretOverride(environmentId: string, secretId: string, value?: Value, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEnvironmentSecretOverride(environmentId, secretId, value, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentSecretApi.createEnvironmentSecretOverride']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well  operationId: deleteEnvironmentSecret 
         * @summary Delete a secret from the environment
         * @param {string} environmentId Environment ID
         * @param {string} secretId Secret ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEnvironmentSecret(environmentId: string, secretId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEnvironmentSecret(environmentId, secretId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentSecretApi.deleteEnvironmentSecret']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit a secret belonging to the environment
         * @param {string} environmentId Environment ID
         * @param {string} secretId Secret ID
         * @param {SecretEditRequest} secretEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editEnvironmentSecret(environmentId: string, secretId: string, secretEditRequest: SecretEditRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editEnvironmentSecret(environmentId, secretId, secretEditRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentSecretApi.editEnvironmentSecret']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List environment secrets
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEnvironmentSecrets(environmentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecretResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEnvironmentSecrets(environmentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentSecretApi.listEnvironmentSecrets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EnvironmentSecretApi - factory interface
 * @export
 */
export const EnvironmentSecretApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnvironmentSecretApiFp(configuration)
    return {
        /**
         * - Add a secret to the environment.   - If the secret key already exists, then it will be replaced by the new one.   - If the secret value points toward an existing secret key, it will be considered as an alias. 
         * @summary Add a secret to the environment
         * @param {string} environmentId Environment ID
         * @param {SecretRequest} [secretRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironmentSecret(environmentId: string, secretRequest?: SecretRequest, options?: RawAxiosRequestConfig): AxiosPromise<Secret> {
            return localVarFp.createEnvironmentSecret(environmentId, secretRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to add an alias at environment level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at environment level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - You can\'t create an alias on an alias 
         * @summary Create a secret alias at the environment level
         * @param {string} environmentId Environment ID
         * @param {string} secretId Secret ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironmentSecretAlias(environmentId: string, secretId: string, key?: Key, options?: RawAxiosRequestConfig): AxiosPromise<Secret> {
            return localVarFp.createEnvironmentSecretAlias(environmentId, secretId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to override at environment level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at environment level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
         * @summary Create a secret override at the environment level
         * @param {string} environmentId Environment ID
         * @param {string} secretId Secret ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironmentSecretOverride(environmentId: string, secretId: string, value?: Value, options?: RawAxiosRequestConfig): AxiosPromise<Secret> {
            return localVarFp.createEnvironmentSecretOverride(environmentId, secretId, value, options).then((request) => request(axios, basePath));
        },
        /**
         * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well  operationId: deleteEnvironmentSecret 
         * @summary Delete a secret from the environment
         * @param {string} environmentId Environment ID
         * @param {string} secretId Secret ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEnvironmentSecret(environmentId: string, secretId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteEnvironmentSecret(environmentId, secretId, options).then((request) => request(axios, basePath));
        },
        /**
         * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit a secret belonging to the environment
         * @param {string} environmentId Environment ID
         * @param {string} secretId Secret ID
         * @param {SecretEditRequest} secretEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editEnvironmentSecret(environmentId: string, secretId: string, secretEditRequest: SecretEditRequest, options?: RawAxiosRequestConfig): AxiosPromise<Secret> {
            return localVarFp.editEnvironmentSecret(environmentId, secretId, secretEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List environment secrets
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentSecrets(environmentId: string, options?: RawAxiosRequestConfig): AxiosPromise<SecretResponseList> {
            return localVarFp.listEnvironmentSecrets(environmentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnvironmentSecretApi - object-oriented interface
 * @export
 * @class EnvironmentSecretApi
 * @extends {BaseAPI}
 */
export class EnvironmentSecretApi extends BaseAPI {
    /**
     * - Add a secret to the environment.   - If the secret key already exists, then it will be replaced by the new one.   - If the secret value points toward an existing secret key, it will be considered as an alias. 
     * @summary Add a secret to the environment
     * @param {string} environmentId Environment ID
     * @param {SecretRequest} [secretRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentSecretApi
     */
    public createEnvironmentSecret(environmentId: string, secretRequest?: SecretRequest, options?: RawAxiosRequestConfig) {
        return EnvironmentSecretApiFp(this.configuration).createEnvironmentSecret(environmentId, secretRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to add an alias at environment level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at environment level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - You can\'t create an alias on an alias 
     * @summary Create a secret alias at the environment level
     * @param {string} environmentId Environment ID
     * @param {string} secretId Secret ID
     * @param {Key} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentSecretApi
     */
    public createEnvironmentSecretAlias(environmentId: string, secretId: string, key?: Key, options?: RawAxiosRequestConfig) {
        return EnvironmentSecretApiFp(this.configuration).createEnvironmentSecretAlias(environmentId, secretId, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to override at environment level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at environment level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
     * @summary Create a secret override at the environment level
     * @param {string} environmentId Environment ID
     * @param {string} secretId Secret ID
     * @param {Value} [value] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentSecretApi
     */
    public createEnvironmentSecretOverride(environmentId: string, secretId: string, value?: Value, options?: RawAxiosRequestConfig) {
        return EnvironmentSecretApiFp(this.configuration).createEnvironmentSecretOverride(environmentId, secretId, value, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well  operationId: deleteEnvironmentSecret 
     * @summary Delete a secret from the environment
     * @param {string} environmentId Environment ID
     * @param {string} secretId Secret ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentSecretApi
     */
    public deleteEnvironmentSecret(environmentId: string, secretId: string, options?: RawAxiosRequestConfig) {
        return EnvironmentSecretApiFp(this.configuration).deleteEnvironmentSecret(environmentId, secretId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
     * @summary Edit a secret belonging to the environment
     * @param {string} environmentId Environment ID
     * @param {string} secretId Secret ID
     * @param {SecretEditRequest} secretEditRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentSecretApi
     */
    public editEnvironmentSecret(environmentId: string, secretId: string, secretEditRequest: SecretEditRequest, options?: RawAxiosRequestConfig) {
        return EnvironmentSecretApiFp(this.configuration).editEnvironmentSecret(environmentId, secretId, secretEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List environment secrets
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentSecretApi
     */
    public listEnvironmentSecrets(environmentId: string, options?: RawAxiosRequestConfig) {
        return EnvironmentSecretApiFp(this.configuration).listEnvironmentSecrets(environmentId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EnvironmentVariableApi - axios parameter creator
 * @export
 */
export const EnvironmentVariableApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * - Add an environment variable to the environment.   - If the environment variable key already exists, then it will be replaced by the new one.   - If the environment variable value points toward an existing environment variable key, it will be considered as an alias. 
         * @summary Add an environment variable to the environment
         * @param {string} environmentId Environment ID
         * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironmentEnvironmentVariable: async (environmentId: string, environmentVariableRequest?: EnvironmentVariableRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('createEnvironmentEnvironmentVariable', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/environmentVariable`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentVariableRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to add an alias at environment level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at environment level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - You can\'t create an alias on an alias 
         * @summary Create an environment variable alias at the environment level
         * @param {string} environmentId Environment ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironmentEnvironmentVariableAlias: async (environmentId: string, environmentVariableId: string, key?: Key, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('createEnvironmentEnvironmentVariableAlias', 'environmentId', environmentId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('createEnvironmentEnvironmentVariableAlias', 'environmentVariableId', environmentVariableId)
            const localVarPath = `/environment/{environmentId}/environmentVariable/{environmentVariableId}/alias`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(key, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to override at environment level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at environment level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
         * @summary Create an environment variable override at the environment level
         * @param {string} environmentId Environment ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironmentEnvironmentVariableOverride: async (environmentId: string, environmentVariableId: string, value?: Value, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('createEnvironmentEnvironmentVariableOverride', 'environmentId', environmentId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('createEnvironmentEnvironmentVariableOverride', 'environmentVariableId', environmentVariableId)
            const localVarPath = `/environment/{environmentId}/environmentVariable/{environmentVariableId}/override`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(value, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - To delete an environment variable you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete an environment variable from an environment
         * @param {string} environmentId Environment ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEnvironmentEnvironmentVariable: async (environmentId: string, environmentVariableId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('deleteEnvironmentEnvironmentVariable', 'environmentId', environmentId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('deleteEnvironmentEnvironmentVariable', 'environmentVariableId', environmentVariableId)
            const localVarPath = `/environment/{environmentId}/environmentVariable/{environmentVariableId}`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit an environment variable belonging to the environment
         * @param {string} environmentId Environment ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editEnvironmentEnvironmentVariable: async (environmentId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('editEnvironmentEnvironmentVariable', 'environmentId', environmentId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('editEnvironmentEnvironmentVariable', 'environmentVariableId', environmentVariableId)
            // verify required parameter 'environmentVariableEditRequest' is not null or undefined
            assertParamExists('editEnvironmentEnvironmentVariable', 'environmentVariableEditRequest', environmentVariableEditRequest)
            const localVarPath = `/environment/{environmentId}/environmentVariable/{environmentVariableId}`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentVariableEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List environment variables
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentEnvironmentVariable: async (environmentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('listEnvironmentEnvironmentVariable', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/environmentVariable`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentVariableApi - functional programming interface
 * @export
 */
export const EnvironmentVariableApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnvironmentVariableApiAxiosParamCreator(configuration)
    return {
        /**
         * - Add an environment variable to the environment.   - If the environment variable key already exists, then it will be replaced by the new one.   - If the environment variable value points toward an existing environment variable key, it will be considered as an alias. 
         * @summary Add an environment variable to the environment
         * @param {string} environmentId Environment ID
         * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEnvironmentEnvironmentVariable(environmentId: string, environmentVariableRequest?: EnvironmentVariableRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEnvironmentEnvironmentVariable(environmentId, environmentVariableRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentVariableApi.createEnvironmentEnvironmentVariable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - Allows you to add an alias at environment level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at environment level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - You can\'t create an alias on an alias 
         * @summary Create an environment variable alias at the environment level
         * @param {string} environmentId Environment ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEnvironmentEnvironmentVariableAlias(environmentId: string, environmentVariableId: string, key?: Key, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEnvironmentEnvironmentVariableAlias(environmentId, environmentVariableId, key, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentVariableApi.createEnvironmentEnvironmentVariableAlias']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - Allows you to override at environment level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at environment level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
         * @summary Create an environment variable override at the environment level
         * @param {string} environmentId Environment ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEnvironmentEnvironmentVariableOverride(environmentId: string, environmentVariableId: string, value?: Value, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEnvironmentEnvironmentVariableOverride(environmentId, environmentVariableId, value, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentVariableApi.createEnvironmentEnvironmentVariableOverride']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - To delete an environment variable you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete an environment variable from an environment
         * @param {string} environmentId Environment ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEnvironmentEnvironmentVariable(environmentId: string, environmentVariableId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEnvironmentEnvironmentVariable(environmentId, environmentVariableId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentVariableApi.deleteEnvironmentEnvironmentVariable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit an environment variable belonging to the environment
         * @param {string} environmentId Environment ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editEnvironmentEnvironmentVariable(environmentId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editEnvironmentEnvironmentVariable(environmentId, environmentVariableId, environmentVariableEditRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentVariableApi.editEnvironmentEnvironmentVariable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List environment variables
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEnvironmentEnvironmentVariable(environmentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariableResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEnvironmentEnvironmentVariable(environmentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentVariableApi.listEnvironmentEnvironmentVariable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EnvironmentVariableApi - factory interface
 * @export
 */
export const EnvironmentVariableApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnvironmentVariableApiFp(configuration)
    return {
        /**
         * - Add an environment variable to the environment.   - If the environment variable key already exists, then it will be replaced by the new one.   - If the environment variable value points toward an existing environment variable key, it will be considered as an alias. 
         * @summary Add an environment variable to the environment
         * @param {string} environmentId Environment ID
         * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironmentEnvironmentVariable(environmentId: string, environmentVariableRequest?: EnvironmentVariableRequest, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentVariable> {
            return localVarFp.createEnvironmentEnvironmentVariable(environmentId, environmentVariableRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to add an alias at environment level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at environment level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - You can\'t create an alias on an alias 
         * @summary Create an environment variable alias at the environment level
         * @param {string} environmentId Environment ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironmentEnvironmentVariableAlias(environmentId: string, environmentVariableId: string, key?: Key, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentVariable> {
            return localVarFp.createEnvironmentEnvironmentVariableAlias(environmentId, environmentVariableId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to override at environment level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at environment level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
         * @summary Create an environment variable override at the environment level
         * @param {string} environmentId Environment ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironmentEnvironmentVariableOverride(environmentId: string, environmentVariableId: string, value?: Value, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentVariable> {
            return localVarFp.createEnvironmentEnvironmentVariableOverride(environmentId, environmentVariableId, value, options).then((request) => request(axios, basePath));
        },
        /**
         * - To delete an environment variable you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete an environment variable from an environment
         * @param {string} environmentId Environment ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEnvironmentEnvironmentVariable(environmentId: string, environmentVariableId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteEnvironmentEnvironmentVariable(environmentId, environmentVariableId, options).then((request) => request(axios, basePath));
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit an environment variable belonging to the environment
         * @param {string} environmentId Environment ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editEnvironmentEnvironmentVariable(environmentId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentVariable> {
            return localVarFp.editEnvironmentEnvironmentVariable(environmentId, environmentVariableId, environmentVariableEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List environment variables
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentEnvironmentVariable(environmentId: string, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentVariableResponseList> {
            return localVarFp.listEnvironmentEnvironmentVariable(environmentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnvironmentVariableApi - object-oriented interface
 * @export
 * @class EnvironmentVariableApi
 * @extends {BaseAPI}
 */
export class EnvironmentVariableApi extends BaseAPI {
    /**
     * - Add an environment variable to the environment.   - If the environment variable key already exists, then it will be replaced by the new one.   - If the environment variable value points toward an existing environment variable key, it will be considered as an alias. 
     * @summary Add an environment variable to the environment
     * @param {string} environmentId Environment ID
     * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentVariableApi
     */
    public createEnvironmentEnvironmentVariable(environmentId: string, environmentVariableRequest?: EnvironmentVariableRequest, options?: RawAxiosRequestConfig) {
        return EnvironmentVariableApiFp(this.configuration).createEnvironmentEnvironmentVariable(environmentId, environmentVariableRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to add an alias at environment level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at environment level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - You can\'t create an alias on an alias 
     * @summary Create an environment variable alias at the environment level
     * @param {string} environmentId Environment ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {Key} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentVariableApi
     */
    public createEnvironmentEnvironmentVariableAlias(environmentId: string, environmentVariableId: string, key?: Key, options?: RawAxiosRequestConfig) {
        return EnvironmentVariableApiFp(this.configuration).createEnvironmentEnvironmentVariableAlias(environmentId, environmentVariableId, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to override at environment level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at environment level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
     * @summary Create an environment variable override at the environment level
     * @param {string} environmentId Environment ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {Value} [value] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentVariableApi
     */
    public createEnvironmentEnvironmentVariableOverride(environmentId: string, environmentVariableId: string, value?: Value, options?: RawAxiosRequestConfig) {
        return EnvironmentVariableApiFp(this.configuration).createEnvironmentEnvironmentVariableOverride(environmentId, environmentVariableId, value, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - To delete an environment variable you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
     * @summary Delete an environment variable from an environment
     * @param {string} environmentId Environment ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentVariableApi
     */
    public deleteEnvironmentEnvironmentVariable(environmentId: string, environmentVariableId: string, options?: RawAxiosRequestConfig) {
        return EnvironmentVariableApiFp(this.configuration).deleteEnvironmentEnvironmentVariable(environmentId, environmentVariableId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
     * @summary Edit an environment variable belonging to the environment
     * @param {string} environmentId Environment ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentVariableApi
     */
    public editEnvironmentEnvironmentVariable(environmentId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options?: RawAxiosRequestConfig) {
        return EnvironmentVariableApiFp(this.configuration).editEnvironmentEnvironmentVariable(environmentId, environmentVariableId, environmentVariableEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List environment variables
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentVariableApi
     */
    public listEnvironmentEnvironmentVariable(environmentId: string, options?: RawAxiosRequestConfig) {
        return EnvironmentVariableApiFp(this.configuration).listEnvironmentEnvironmentVariable(environmentId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EnvironmentsApi - axios parameter creator
 * @export
 */
export const EnvironmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create an environment
         * @param {string} projectId Project ID
         * @param {CreateEnvironmentRequest} [createEnvironmentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironment: async (projectId: string, createEnvironmentRequest?: CreateEnvironmentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createEnvironment', 'projectId', projectId)
            const localVarPath = `/project/{projectId}/environment`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createEnvironmentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of environment ids, and for each its total numberof services
         * @summary List total number of services for each environment of the project
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectEnvironmentServiceNumber: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getProjectEnvironmentServiceNumber', 'projectId', projectId)
            const localVarPath = `/project/{projectId}/environment/stats`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of environments with only their id and status.
         * @summary List environments statuses
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectEnvironmentsStatus: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getProjectEnvironmentsStatus', 'projectId', projectId)
            const localVarPath = `/project/{projectId}/environment/status`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List environments
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironment: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('listEnvironment', 'projectId', projectId)
            const localVarPath = `/project/{projectId}/environment`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentsApi - functional programming interface
 * @export
 */
export const EnvironmentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnvironmentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create an environment
         * @param {string} projectId Project ID
         * @param {CreateEnvironmentRequest} [createEnvironmentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEnvironment(projectId: string, createEnvironmentRequest?: CreateEnvironmentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Environment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEnvironment(projectId, createEnvironmentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentsApi.createEnvironment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of environment ids, and for each its total numberof services
         * @summary List total number of services for each environment of the project
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjectEnvironmentServiceNumber(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentStatsResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectEnvironmentServiceNumber(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentsApi.getProjectEnvironmentServiceNumber']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of environments with only their id and status.
         * @summary List environments statuses
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjectEnvironmentsStatus(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentStatusList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectEnvironmentsStatus(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentsApi.getProjectEnvironmentsStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List environments
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEnvironment(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEnvironment(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentsApi.listEnvironment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EnvironmentsApi - factory interface
 * @export
 */
export const EnvironmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnvironmentsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create an environment
         * @param {string} projectId Project ID
         * @param {CreateEnvironmentRequest} [createEnvironmentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironment(projectId: string, createEnvironmentRequest?: CreateEnvironmentRequest, options?: RawAxiosRequestConfig): AxiosPromise<Environment> {
            return localVarFp.createEnvironment(projectId, createEnvironmentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of environment ids, and for each its total numberof services
         * @summary List total number of services for each environment of the project
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectEnvironmentServiceNumber(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentStatsResponseList> {
            return localVarFp.getProjectEnvironmentServiceNumber(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of environments with only their id and status.
         * @summary List environments statuses
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectEnvironmentsStatus(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentStatusList> {
            return localVarFp.getProjectEnvironmentsStatus(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List environments
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironment(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentResponseList> {
            return localVarFp.listEnvironment(projectId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnvironmentsApi - object-oriented interface
 * @export
 * @class EnvironmentsApi
 * @extends {BaseAPI}
 */
export class EnvironmentsApi extends BaseAPI {
    /**
     * 
     * @summary Create an environment
     * @param {string} projectId Project ID
     * @param {CreateEnvironmentRequest} [createEnvironmentRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public createEnvironment(projectId: string, createEnvironmentRequest?: CreateEnvironmentRequest, options?: RawAxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).createEnvironment(projectId, createEnvironmentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of environment ids, and for each its total numberof services
     * @summary List total number of services for each environment of the project
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public getProjectEnvironmentServiceNumber(projectId: string, options?: RawAxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).getProjectEnvironmentServiceNumber(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of environments with only their id and status.
     * @summary List environments statuses
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public getProjectEnvironmentsStatus(projectId: string, options?: RawAxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).getProjectEnvironmentsStatus(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List environments
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public listEnvironment(projectId: string, options?: RawAxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).listEnvironment(projectId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GitRepositoriesApi - axios parameter creator
 * @export
 */
export const GitRepositoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get bitbucket repositories of the connected user
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getBitbucketRepositories: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/bitbucket/repository`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get bitbucket branches of the specified repository
         * @param {string} [name] The name of the repository where to retrieve the branches
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getBitbucketRepositoryBranches: async (name?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/bitbucket/repository/branch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get git provider accounts
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getGitProviderAccount: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/gitAuthProvider`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get github repositories of the connected user
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getGithubRepositories: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/github/repository`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get github branches of the specified repository
         * @param {string} [name] The name of the repository where to retrieve the branches
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getGithubRepositoryBranches: async (name?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/github/repository/branch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get gitlab repositories of the connected user
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getGitlabRepositories: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/gitlab/repository`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get gitlab branches of the specified repository
         * @param {string} [name] The name of the repository to retrieve the branches
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getGitlabRepositoryBranches: async (name?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/gitlab/repository/branch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List immediate subdirectories at a specified path in a git repository. This endpoint is used when creating Terraform services to help users browse and select the appropriate root path. 
         * @summary List directories from a git repository
         * @param {string} organizationId Organization ID
         * @param {ApplicationGitRepositoryRequest} [applicationGitRepositoryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDirectoriesFromGitRepository: async (organizationId: string, applicationGitRepositoryRequest?: ApplicationGitRepositoryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listDirectoriesFromGitRepository', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/listDirectoriesFromGitRepository`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(applicationGitRepositoryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GitRepositoriesApi - functional programming interface
 * @export
 */
export const GitRepositoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GitRepositoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get bitbucket repositories of the connected user
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getBitbucketRepositories(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitRepositoryResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBitbucketRepositories(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GitRepositoriesApi.getBitbucketRepositories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get bitbucket branches of the specified repository
         * @param {string} [name] The name of the repository where to retrieve the branches
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getBitbucketRepositoryBranches(name?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitRepositoryBranchResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBitbucketRepositoryBranches(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GitRepositoriesApi.getBitbucketRepositoryBranches']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get git provider accounts
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getGitProviderAccount(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitAuthProviderResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGitProviderAccount(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GitRepositoriesApi.getGitProviderAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get github repositories of the connected user
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getGithubRepositories(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitRepositoryResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGithubRepositories(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GitRepositoriesApi.getGithubRepositories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get github branches of the specified repository
         * @param {string} [name] The name of the repository where to retrieve the branches
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getGithubRepositoryBranches(name?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitRepositoryBranchResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGithubRepositoryBranches(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GitRepositoriesApi.getGithubRepositoryBranches']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get gitlab repositories of the connected user
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getGitlabRepositories(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitRepositoryResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGitlabRepositories(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GitRepositoriesApi.getGitlabRepositories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get gitlab branches of the specified repository
         * @param {string} [name] The name of the repository to retrieve the branches
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getGitlabRepositoryBranches(name?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitRepositoryBranchResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGitlabRepositoryBranches(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GitRepositoriesApi.getGitlabRepositoryBranches']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List immediate subdirectories at a specified path in a git repository. This endpoint is used when creating Terraform services to help users browse and select the appropriate root path. 
         * @summary List directories from a git repository
         * @param {string} organizationId Organization ID
         * @param {ApplicationGitRepositoryRequest} [applicationGitRepositoryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDirectoriesFromGitRepository(organizationId: string, applicationGitRepositoryRequest?: ApplicationGitRepositoryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListDirectoriesFromGitRepository200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDirectoriesFromGitRepository(organizationId, applicationGitRepositoryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GitRepositoriesApi.listDirectoriesFromGitRepository']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GitRepositoriesApi - factory interface
 * @export
 */
export const GitRepositoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GitRepositoriesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get bitbucket repositories of the connected user
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getBitbucketRepositories(options?: RawAxiosRequestConfig): AxiosPromise<GitRepositoryResponseList> {
            return localVarFp.getBitbucketRepositories(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get bitbucket branches of the specified repository
         * @param {string} [name] The name of the repository where to retrieve the branches
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getBitbucketRepositoryBranches(name?: string, options?: RawAxiosRequestConfig): AxiosPromise<GitRepositoryBranchResponseList> {
            return localVarFp.getBitbucketRepositoryBranches(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get git provider accounts
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getGitProviderAccount(options?: RawAxiosRequestConfig): AxiosPromise<GitAuthProviderResponseList> {
            return localVarFp.getGitProviderAccount(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get github repositories of the connected user
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getGithubRepositories(options?: RawAxiosRequestConfig): AxiosPromise<GitRepositoryResponseList> {
            return localVarFp.getGithubRepositories(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get github branches of the specified repository
         * @param {string} [name] The name of the repository where to retrieve the branches
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getGithubRepositoryBranches(name?: string, options?: RawAxiosRequestConfig): AxiosPromise<GitRepositoryBranchResponseList> {
            return localVarFp.getGithubRepositoryBranches(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get gitlab repositories of the connected user
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getGitlabRepositories(options?: RawAxiosRequestConfig): AxiosPromise<GitRepositoryResponseList> {
            return localVarFp.getGitlabRepositories(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get gitlab branches of the specified repository
         * @param {string} [name] The name of the repository to retrieve the branches
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getGitlabRepositoryBranches(name?: string, options?: RawAxiosRequestConfig): AxiosPromise<GitRepositoryBranchResponseList> {
            return localVarFp.getGitlabRepositoryBranches(name, options).then((request) => request(axios, basePath));
        },
        /**
         * List immediate subdirectories at a specified path in a git repository. This endpoint is used when creating Terraform services to help users browse and select the appropriate root path. 
         * @summary List directories from a git repository
         * @param {string} organizationId Organization ID
         * @param {ApplicationGitRepositoryRequest} [applicationGitRepositoryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDirectoriesFromGitRepository(organizationId: string, applicationGitRepositoryRequest?: ApplicationGitRepositoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<ListDirectoriesFromGitRepository200Response> {
            return localVarFp.listDirectoriesFromGitRepository(organizationId, applicationGitRepositoryRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GitRepositoriesApi - object-oriented interface
 * @export
 * @class GitRepositoriesApi
 * @extends {BaseAPI}
 */
export class GitRepositoriesApi extends BaseAPI {
    /**
     * 
     * @summary Get bitbucket repositories of the connected user
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof GitRepositoriesApi
     */
    public getBitbucketRepositories(options?: RawAxiosRequestConfig) {
        return GitRepositoriesApiFp(this.configuration).getBitbucketRepositories(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get bitbucket branches of the specified repository
     * @param {string} [name] The name of the repository where to retrieve the branches
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof GitRepositoriesApi
     */
    public getBitbucketRepositoryBranches(name?: string, options?: RawAxiosRequestConfig) {
        return GitRepositoriesApiFp(this.configuration).getBitbucketRepositoryBranches(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get git provider accounts
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof GitRepositoriesApi
     */
    public getGitProviderAccount(options?: RawAxiosRequestConfig) {
        return GitRepositoriesApiFp(this.configuration).getGitProviderAccount(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get github repositories of the connected user
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof GitRepositoriesApi
     */
    public getGithubRepositories(options?: RawAxiosRequestConfig) {
        return GitRepositoriesApiFp(this.configuration).getGithubRepositories(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get github branches of the specified repository
     * @param {string} [name] The name of the repository where to retrieve the branches
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof GitRepositoriesApi
     */
    public getGithubRepositoryBranches(name?: string, options?: RawAxiosRequestConfig) {
        return GitRepositoriesApiFp(this.configuration).getGithubRepositoryBranches(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get gitlab repositories of the connected user
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof GitRepositoriesApi
     */
    public getGitlabRepositories(options?: RawAxiosRequestConfig) {
        return GitRepositoriesApiFp(this.configuration).getGitlabRepositories(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get gitlab branches of the specified repository
     * @param {string} [name] The name of the repository to retrieve the branches
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof GitRepositoriesApi
     */
    public getGitlabRepositoryBranches(name?: string, options?: RawAxiosRequestConfig) {
        return GitRepositoriesApiFp(this.configuration).getGitlabRepositoryBranches(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List immediate subdirectories at a specified path in a git repository. This endpoint is used when creating Terraform services to help users browse and select the appropriate root path. 
     * @summary List directories from a git repository
     * @param {string} organizationId Organization ID
     * @param {ApplicationGitRepositoryRequest} [applicationGitRepositoryRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GitRepositoriesApi
     */
    public listDirectoriesFromGitRepository(organizationId: string, applicationGitRepositoryRequest?: ApplicationGitRepositoryRequest, options?: RawAxiosRequestConfig) {
        return GitRepositoriesApiFp(this.configuration).listDirectoriesFromGitRepository(organizationId, applicationGitRepositoryRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GithubAppApi - axios parameter creator
 * @export
 */
export const GithubAppApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Connect a github account to an organization
         * @param {string} organizationId Organization ID
         * @param {OrganizationGithubAppConnectRequest} [organizationGithubAppConnectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationGithubAppConnect: async (organizationId: string, organizationGithubAppConnectRequest?: OrganizationGithubAppConnectRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('organizationGithubAppConnect', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/github/connect`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationGithubAppConnectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Disconnect a github account from an organization
         * @param {string} organizationId Organization ID
         * @param {boolean} [force] Indicates if the github app should be disconnected despite github applications linked to organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationGithubAppDisconnect: async (organizationId: string, force?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('organizationGithubAppDisconnect', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/github/disconnect`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GithubAppApi - functional programming interface
 * @export
 */
export const GithubAppApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GithubAppApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Connect a github account to an organization
         * @param {string} organizationId Organization ID
         * @param {OrganizationGithubAppConnectRequest} [organizationGithubAppConnectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationGithubAppConnect(organizationId: string, organizationGithubAppConnectRequest?: OrganizationGithubAppConnectRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationGithubAppConnect(organizationId, organizationGithubAppConnectRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GithubAppApi.organizationGithubAppConnect']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Disconnect a github account from an organization
         * @param {string} organizationId Organization ID
         * @param {boolean} [force] Indicates if the github app should be disconnected despite github applications linked to organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationGithubAppDisconnect(organizationId: string, force?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationGithubAppDisconnect(organizationId, force, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GithubAppApi.organizationGithubAppDisconnect']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GithubAppApi - factory interface
 * @export
 */
export const GithubAppApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GithubAppApiFp(configuration)
    return {
        /**
         * 
         * @summary Connect a github account to an organization
         * @param {string} organizationId Organization ID
         * @param {OrganizationGithubAppConnectRequest} [organizationGithubAppConnectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationGithubAppConnect(organizationId: string, organizationGithubAppConnectRequest?: OrganizationGithubAppConnectRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.organizationGithubAppConnect(organizationId, organizationGithubAppConnectRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Disconnect a github account from an organization
         * @param {string} organizationId Organization ID
         * @param {boolean} [force] Indicates if the github app should be disconnected despite github applications linked to organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationGithubAppDisconnect(organizationId: string, force?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.organizationGithubAppDisconnect(organizationId, force, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GithubAppApi - object-oriented interface
 * @export
 * @class GithubAppApi
 * @extends {BaseAPI}
 */
export class GithubAppApi extends BaseAPI {
    /**
     * 
     * @summary Connect a github account to an organization
     * @param {string} organizationId Organization ID
     * @param {OrganizationGithubAppConnectRequest} [organizationGithubAppConnectRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GithubAppApi
     */
    public organizationGithubAppConnect(organizationId: string, organizationGithubAppConnectRequest?: OrganizationGithubAppConnectRequest, options?: RawAxiosRequestConfig) {
        return GithubAppApiFp(this.configuration).organizationGithubAppConnect(organizationId, organizationGithubAppConnectRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Disconnect a github account from an organization
     * @param {string} organizationId Organization ID
     * @param {boolean} [force] Indicates if the github app should be disconnected despite github applications linked to organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GithubAppApi
     */
    public organizationGithubAppDisconnect(organizationId: string, force?: boolean, options?: RawAxiosRequestConfig) {
        return GithubAppApiFp(this.configuration).organizationGithubAppDisconnect(organizationId, force, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HelmActionsApi - axios parameter creator
 * @export
 */
export const HelmActionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * You must provide a git commit id or a helm version depending on the source location of your code (git vs helm repository).
         * @summary Deploy helm
         * @param {string} helmId Helm ID
         * @param {HelmForceEvent} [forceEvent] When filled, it indicates the target event to be deployed.   If the concerned helm hasn\&#39;t the target event provided, the helm won\&#39;t be deployed. 
         * @param {HelmDeployRequest} [helmDeployRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployHelm: async (helmId: string, forceEvent?: HelmForceEvent, helmDeployRequest?: HelmDeployRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'helmId' is not null or undefined
            assertParamExists('deployHelm', 'helmId', helmId)
            const localVarPath = `/helm/{helmId}/deploy`
                .replace(`{${"helmId"}}`, encodeURIComponent(String(helmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (forceEvent !== undefined) {
                localVarQueryParameter['forceEvent'] = forceEvent;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(helmDeployRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Redeploy helm
         * @param {string} helmId Helm ID
         * @param {HelmForceEvent} [forceEvent] When filled, it indicates the target event to be deployed.   If the concerned helm hasn\&#39;t the target event provided, the helm won\&#39;t be deployed. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeployHelm: async (helmId: string, forceEvent?: HelmForceEvent, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'helmId' is not null or undefined
            assertParamExists('redeployHelm', 'helmId', helmId)
            const localVarPath = `/helm/{helmId}/redeploy`
                .replace(`{${"helmId"}}`, encodeURIComponent(String(helmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (forceEvent !== undefined) {
                localVarQueryParameter['forceEvent'] = forceEvent;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop helm
         * @param {string} helmId Helm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopHelm: async (helmId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'helmId' is not null or undefined
            assertParamExists('stopHelm', 'helmId', helmId)
            const localVarPath = `/helm/{helmId}/stop`
                .replace(`{${"helmId"}}`, encodeURIComponent(String(helmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the resources of the helm but keep Qovery configuration
         * @summary Uninstall helm
         * @param {string} helmId Helm ID
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uninstallHelm: async (helmId: string, body?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'helmId' is not null or undefined
            assertParamExists('uninstallHelm', 'helmId', helmId)
            const localVarPath = `/helm/{helmId}/uninstall`
                .replace(`{${"helmId"}}`, encodeURIComponent(String(helmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HelmActionsApi - functional programming interface
 * @export
 */
export const HelmActionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HelmActionsApiAxiosParamCreator(configuration)
    return {
        /**
         * You must provide a git commit id or a helm version depending on the source location of your code (git vs helm repository).
         * @summary Deploy helm
         * @param {string} helmId Helm ID
         * @param {HelmForceEvent} [forceEvent] When filled, it indicates the target event to be deployed.   If the concerned helm hasn\&#39;t the target event provided, the helm won\&#39;t be deployed. 
         * @param {HelmDeployRequest} [helmDeployRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployHelm(helmId: string, forceEvent?: HelmForceEvent, helmDeployRequest?: HelmDeployRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployHelm(helmId, forceEvent, helmDeployRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HelmActionsApi.deployHelm']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Redeploy helm
         * @param {string} helmId Helm ID
         * @param {HelmForceEvent} [forceEvent] When filled, it indicates the target event to be deployed.   If the concerned helm hasn\&#39;t the target event provided, the helm won\&#39;t be deployed. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async redeployHelm(helmId: string, forceEvent?: HelmForceEvent, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.redeployHelm(helmId, forceEvent, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HelmActionsApi.redeployHelm']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Stop helm
         * @param {string} helmId Helm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopHelm(helmId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopHelm(helmId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HelmActionsApi.stopHelm']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete the resources of the helm but keep Qovery configuration
         * @summary Uninstall helm
         * @param {string} helmId Helm ID
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uninstallHelm(helmId: string, body?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uninstallHelm(helmId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HelmActionsApi.uninstallHelm']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HelmActionsApi - factory interface
 * @export
 */
export const HelmActionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HelmActionsApiFp(configuration)
    return {
        /**
         * You must provide a git commit id or a helm version depending on the source location of your code (git vs helm repository).
         * @summary Deploy helm
         * @param {string} helmId Helm ID
         * @param {HelmForceEvent} [forceEvent] When filled, it indicates the target event to be deployed.   If the concerned helm hasn\&#39;t the target event provided, the helm won\&#39;t be deployed. 
         * @param {HelmDeployRequest} [helmDeployRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployHelm(helmId: string, forceEvent?: HelmForceEvent, helmDeployRequest?: HelmDeployRequest, options?: RawAxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.deployHelm(helmId, forceEvent, helmDeployRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Redeploy helm
         * @param {string} helmId Helm ID
         * @param {HelmForceEvent} [forceEvent] When filled, it indicates the target event to be deployed.   If the concerned helm hasn\&#39;t the target event provided, the helm won\&#39;t be deployed. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeployHelm(helmId: string, forceEvent?: HelmForceEvent, options?: RawAxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.redeployHelm(helmId, forceEvent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Stop helm
         * @param {string} helmId Helm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopHelm(helmId: string, options?: RawAxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.stopHelm(helmId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete the resources of the helm but keep Qovery configuration
         * @summary Uninstall helm
         * @param {string} helmId Helm ID
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uninstallHelm(helmId: string, body?: object, options?: RawAxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.uninstallHelm(helmId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HelmActionsApi - object-oriented interface
 * @export
 * @class HelmActionsApi
 * @extends {BaseAPI}
 */
export class HelmActionsApi extends BaseAPI {
    /**
     * You must provide a git commit id or a helm version depending on the source location of your code (git vs helm repository).
     * @summary Deploy helm
     * @param {string} helmId Helm ID
     * @param {HelmForceEvent} [forceEvent] When filled, it indicates the target event to be deployed.   If the concerned helm hasn\&#39;t the target event provided, the helm won\&#39;t be deployed. 
     * @param {HelmDeployRequest} [helmDeployRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmActionsApi
     */
    public deployHelm(helmId: string, forceEvent?: HelmForceEvent, helmDeployRequest?: HelmDeployRequest, options?: RawAxiosRequestConfig) {
        return HelmActionsApiFp(this.configuration).deployHelm(helmId, forceEvent, helmDeployRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Redeploy helm
     * @param {string} helmId Helm ID
     * @param {HelmForceEvent} [forceEvent] When filled, it indicates the target event to be deployed.   If the concerned helm hasn\&#39;t the target event provided, the helm won\&#39;t be deployed. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmActionsApi
     */
    public redeployHelm(helmId: string, forceEvent?: HelmForceEvent, options?: RawAxiosRequestConfig) {
        return HelmActionsApiFp(this.configuration).redeployHelm(helmId, forceEvent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Stop helm
     * @param {string} helmId Helm ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmActionsApi
     */
    public stopHelm(helmId: string, options?: RawAxiosRequestConfig) {
        return HelmActionsApiFp(this.configuration).stopHelm(helmId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete the resources of the helm but keep Qovery configuration
     * @summary Uninstall helm
     * @param {string} helmId Helm ID
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmActionsApi
     */
    public uninstallHelm(helmId: string, body?: object, options?: RawAxiosRequestConfig) {
        return HelmActionsApiFp(this.configuration).uninstallHelm(helmId, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HelmConfigurationApi - axios parameter creator
 * @export
 */
export const HelmConfigurationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Edit advanced settings by returning table of advanced settings.
         * @summary Edit advanced settings
         * @param {string} helmId Helm ID
         * @param {HelmAdvancedSettings} [helmAdvancedSettings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editHelmAdvancedSettings: async (helmId: string, helmAdvancedSettings?: HelmAdvancedSettings, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'helmId' is not null or undefined
            assertParamExists('editHelmAdvancedSettings', 'helmId', helmId)
            const localVarPath = `/helm/{helmId}/advancedSettings`
                .replace(`{${"helmId"}}`, encodeURIComponent(String(helmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(helmAdvancedSettings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list and values of the advanced settings of the helm.
         * @summary Get advanced settings
         * @param {string} helmId Helm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHelmAdvancedSettings: async (helmId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'helmId' is not null or undefined
            assertParamExists('getHelmAdvancedSettings', 'helmId', helmId)
            const localVarPath = `/helm/{helmId}/advancedSettings`
                .replace(`{${"helmId"}}`, encodeURIComponent(String(helmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HelmConfigurationApi - functional programming interface
 * @export
 */
export const HelmConfigurationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HelmConfigurationApiAxiosParamCreator(configuration)
    return {
        /**
         * Edit advanced settings by returning table of advanced settings.
         * @summary Edit advanced settings
         * @param {string} helmId Helm ID
         * @param {HelmAdvancedSettings} [helmAdvancedSettings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editHelmAdvancedSettings(helmId: string, helmAdvancedSettings?: HelmAdvancedSettings, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HelmAdvancedSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editHelmAdvancedSettings(helmId, helmAdvancedSettings, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HelmConfigurationApi.editHelmAdvancedSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get list and values of the advanced settings of the helm.
         * @summary Get advanced settings
         * @param {string} helmId Helm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHelmAdvancedSettings(helmId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HelmAdvancedSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHelmAdvancedSettings(helmId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HelmConfigurationApi.getHelmAdvancedSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HelmConfigurationApi - factory interface
 * @export
 */
export const HelmConfigurationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HelmConfigurationApiFp(configuration)
    return {
        /**
         * Edit advanced settings by returning table of advanced settings.
         * @summary Edit advanced settings
         * @param {string} helmId Helm ID
         * @param {HelmAdvancedSettings} [helmAdvancedSettings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editHelmAdvancedSettings(helmId: string, helmAdvancedSettings?: HelmAdvancedSettings, options?: RawAxiosRequestConfig): AxiosPromise<HelmAdvancedSettings> {
            return localVarFp.editHelmAdvancedSettings(helmId, helmAdvancedSettings, options).then((request) => request(axios, basePath));
        },
        /**
         * Get list and values of the advanced settings of the helm.
         * @summary Get advanced settings
         * @param {string} helmId Helm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHelmAdvancedSettings(helmId: string, options?: RawAxiosRequestConfig): AxiosPromise<HelmAdvancedSettings> {
            return localVarFp.getHelmAdvancedSettings(helmId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HelmConfigurationApi - object-oriented interface
 * @export
 * @class HelmConfigurationApi
 * @extends {BaseAPI}
 */
export class HelmConfigurationApi extends BaseAPI {
    /**
     * Edit advanced settings by returning table of advanced settings.
     * @summary Edit advanced settings
     * @param {string} helmId Helm ID
     * @param {HelmAdvancedSettings} [helmAdvancedSettings] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmConfigurationApi
     */
    public editHelmAdvancedSettings(helmId: string, helmAdvancedSettings?: HelmAdvancedSettings, options?: RawAxiosRequestConfig) {
        return HelmConfigurationApiFp(this.configuration).editHelmAdvancedSettings(helmId, helmAdvancedSettings, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list and values of the advanced settings of the helm.
     * @summary Get advanced settings
     * @param {string} helmId Helm ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmConfigurationApi
     */
    public getHelmAdvancedSettings(helmId: string, options?: RawAxiosRequestConfig) {
        return HelmConfigurationApiFp(this.configuration).getHelmAdvancedSettings(helmId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HelmCustomDomainApi - axios parameter creator
 * @export
 */
export const HelmCustomDomainApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Check Helm Custom Domain
         * @param {string} helmId Helm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkHelmCustomDomain: async (helmId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'helmId' is not null or undefined
            assertParamExists('checkHelmCustomDomain', 'helmId', helmId)
            const localVarPath = `/helm/{helmId}/checkCustomDomain`
                .replace(`{${"helmId"}}`, encodeURIComponent(String(helmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a custom domain to this helm in order not to use qovery autogenerated domain
         * @summary Add custom domain to the helm.
         * @param {string} helmId Helm ID
         * @param {CustomDomainRequest} [customDomainRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHelmCustomDomain: async (helmId: string, customDomainRequest?: CustomDomainRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'helmId' is not null or undefined
            assertParamExists('createHelmCustomDomain', 'helmId', helmId)
            const localVarPath = `/helm/{helmId}/customDomain`
                .replace(`{${"helmId"}}`, encodeURIComponent(String(helmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customDomainRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To delete an CustomDomain you must have the project user permission
         * @summary Delete a Custom Domain
         * @param {string} helmId Helm ID
         * @param {string} customDomainId Custom Domain ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHelmCustomDomain: async (helmId: string, customDomainId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'helmId' is not null or undefined
            assertParamExists('deleteHelmCustomDomain', 'helmId', helmId)
            // verify required parameter 'customDomainId' is not null or undefined
            assertParamExists('deleteHelmCustomDomain', 'customDomainId', customDomainId)
            const localVarPath = `/helm/{helmId}/customDomain/{customDomainId}`
                .replace(`{${"helmId"}}`, encodeURIComponent(String(helmId)))
                .replace(`{${"customDomainId"}}`, encodeURIComponent(String(customDomainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To edit a Custom Domain you must have the project user permission
         * @summary Edit a Custom Domain
         * @param {string} helmId Helm ID
         * @param {string} customDomainId Custom Domain ID
         * @param {CustomDomainRequest} [customDomainRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editHelmCustomDomain: async (helmId: string, customDomainId: string, customDomainRequest?: CustomDomainRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'helmId' is not null or undefined
            assertParamExists('editHelmCustomDomain', 'helmId', helmId)
            // verify required parameter 'customDomainId' is not null or undefined
            assertParamExists('editHelmCustomDomain', 'customDomainId', customDomainId)
            const localVarPath = `/helm/{helmId}/customDomain/{customDomainId}`
                .replace(`{${"helmId"}}`, encodeURIComponent(String(helmId)))
                .replace(`{${"customDomainId"}}`, encodeURIComponent(String(customDomainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customDomainRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a custom domain
         * @summary Get a Custom Domain
         * @param {string} helmId Helm ID
         * @param {string} customDomainId Custom Domain ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHelmCustomDomain: async (helmId: string, customDomainId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'helmId' is not null or undefined
            assertParamExists('getHelmCustomDomain', 'helmId', helmId)
            // verify required parameter 'customDomainId' is not null or undefined
            assertParamExists('getHelmCustomDomain', 'customDomainId', customDomainId)
            const localVarPath = `/helm/{helmId}/customDomain/{customDomainId}`
                .replace(`{${"helmId"}}`, encodeURIComponent(String(helmId)))
                .replace(`{${"customDomainId"}}`, encodeURIComponent(String(customDomainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the custom domains of this helm
         * @summary List helm custom domains
         * @param {string} helmId Helm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHelmCustomDomain: async (helmId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'helmId' is not null or undefined
            assertParamExists('listHelmCustomDomain', 'helmId', helmId)
            const localVarPath = `/helm/{helmId}/customDomain`
                .replace(`{${"helmId"}}`, encodeURIComponent(String(helmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HelmCustomDomainApi - functional programming interface
 * @export
 */
export const HelmCustomDomainApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HelmCustomDomainApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Check Helm Custom Domain
         * @param {string} helmId Helm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkHelmCustomDomain(helmId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckedCustomDomainsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkHelmCustomDomain(helmId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HelmCustomDomainApi.checkHelmCustomDomain']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add a custom domain to this helm in order not to use qovery autogenerated domain
         * @summary Add custom domain to the helm.
         * @param {string} helmId Helm ID
         * @param {CustomDomainRequest} [customDomainRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createHelmCustomDomain(helmId: string, customDomainRequest?: CustomDomainRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomDomain>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createHelmCustomDomain(helmId, customDomainRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HelmCustomDomainApi.createHelmCustomDomain']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * To delete an CustomDomain you must have the project user permission
         * @summary Delete a Custom Domain
         * @param {string} helmId Helm ID
         * @param {string} customDomainId Custom Domain ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteHelmCustomDomain(helmId: string, customDomainId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteHelmCustomDomain(helmId, customDomainId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HelmCustomDomainApi.deleteHelmCustomDomain']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * To edit a Custom Domain you must have the project user permission
         * @summary Edit a Custom Domain
         * @param {string} helmId Helm ID
         * @param {string} customDomainId Custom Domain ID
         * @param {CustomDomainRequest} [customDomainRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editHelmCustomDomain(helmId: string, customDomainId: string, customDomainRequest?: CustomDomainRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomDomain>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editHelmCustomDomain(helmId, customDomainId, customDomainRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HelmCustomDomainApi.editHelmCustomDomain']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a custom domain
         * @summary Get a Custom Domain
         * @param {string} helmId Helm ID
         * @param {string} customDomainId Custom Domain ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHelmCustomDomain(helmId: string, customDomainId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomDomain>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHelmCustomDomain(helmId, customDomainId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HelmCustomDomainApi.getHelmCustomDomain']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the custom domains of this helm
         * @summary List helm custom domains
         * @param {string} helmId Helm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listHelmCustomDomain(helmId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomDomainResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listHelmCustomDomain(helmId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HelmCustomDomainApi.listHelmCustomDomain']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HelmCustomDomainApi - factory interface
 * @export
 */
export const HelmCustomDomainApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HelmCustomDomainApiFp(configuration)
    return {
        /**
         * 
         * @summary Check Helm Custom Domain
         * @param {string} helmId Helm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkHelmCustomDomain(helmId: string, options?: RawAxiosRequestConfig): AxiosPromise<CheckedCustomDomainsResponse> {
            return localVarFp.checkHelmCustomDomain(helmId, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a custom domain to this helm in order not to use qovery autogenerated domain
         * @summary Add custom domain to the helm.
         * @param {string} helmId Helm ID
         * @param {CustomDomainRequest} [customDomainRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHelmCustomDomain(helmId: string, customDomainRequest?: CustomDomainRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomDomain> {
            return localVarFp.createHelmCustomDomain(helmId, customDomainRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * To delete an CustomDomain you must have the project user permission
         * @summary Delete a Custom Domain
         * @param {string} helmId Helm ID
         * @param {string} customDomainId Custom Domain ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHelmCustomDomain(helmId: string, customDomainId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteHelmCustomDomain(helmId, customDomainId, options).then((request) => request(axios, basePath));
        },
        /**
         * To edit a Custom Domain you must have the project user permission
         * @summary Edit a Custom Domain
         * @param {string} helmId Helm ID
         * @param {string} customDomainId Custom Domain ID
         * @param {CustomDomainRequest} [customDomainRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editHelmCustomDomain(helmId: string, customDomainId: string, customDomainRequest?: CustomDomainRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomDomain> {
            return localVarFp.editHelmCustomDomain(helmId, customDomainId, customDomainRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a custom domain
         * @summary Get a Custom Domain
         * @param {string} helmId Helm ID
         * @param {string} customDomainId Custom Domain ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHelmCustomDomain(helmId: string, customDomainId: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomDomain> {
            return localVarFp.getHelmCustomDomain(helmId, customDomainId, options).then((request) => request(axios, basePath));
        },
        /**
         * List the custom domains of this helm
         * @summary List helm custom domains
         * @param {string} helmId Helm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHelmCustomDomain(helmId: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomDomainResponseList> {
            return localVarFp.listHelmCustomDomain(helmId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HelmCustomDomainApi - object-oriented interface
 * @export
 * @class HelmCustomDomainApi
 * @extends {BaseAPI}
 */
export class HelmCustomDomainApi extends BaseAPI {
    /**
     * 
     * @summary Check Helm Custom Domain
     * @param {string} helmId Helm ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmCustomDomainApi
     */
    public checkHelmCustomDomain(helmId: string, options?: RawAxiosRequestConfig) {
        return HelmCustomDomainApiFp(this.configuration).checkHelmCustomDomain(helmId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a custom domain to this helm in order not to use qovery autogenerated domain
     * @summary Add custom domain to the helm.
     * @param {string} helmId Helm ID
     * @param {CustomDomainRequest} [customDomainRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmCustomDomainApi
     */
    public createHelmCustomDomain(helmId: string, customDomainRequest?: CustomDomainRequest, options?: RawAxiosRequestConfig) {
        return HelmCustomDomainApiFp(this.configuration).createHelmCustomDomain(helmId, customDomainRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To delete an CustomDomain you must have the project user permission
     * @summary Delete a Custom Domain
     * @param {string} helmId Helm ID
     * @param {string} customDomainId Custom Domain ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmCustomDomainApi
     */
    public deleteHelmCustomDomain(helmId: string, customDomainId: string, options?: RawAxiosRequestConfig) {
        return HelmCustomDomainApiFp(this.configuration).deleteHelmCustomDomain(helmId, customDomainId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To edit a Custom Domain you must have the project user permission
     * @summary Edit a Custom Domain
     * @param {string} helmId Helm ID
     * @param {string} customDomainId Custom Domain ID
     * @param {CustomDomainRequest} [customDomainRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmCustomDomainApi
     */
    public editHelmCustomDomain(helmId: string, customDomainId: string, customDomainRequest?: CustomDomainRequest, options?: RawAxiosRequestConfig) {
        return HelmCustomDomainApiFp(this.configuration).editHelmCustomDomain(helmId, customDomainId, customDomainRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a custom domain
     * @summary Get a Custom Domain
     * @param {string} helmId Helm ID
     * @param {string} customDomainId Custom Domain ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmCustomDomainApi
     */
    public getHelmCustomDomain(helmId: string, customDomainId: string, options?: RawAxiosRequestConfig) {
        return HelmCustomDomainApiFp(this.configuration).getHelmCustomDomain(helmId, customDomainId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the custom domains of this helm
     * @summary List helm custom domains
     * @param {string} helmId Helm ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmCustomDomainApi
     */
    public listHelmCustomDomain(helmId: string, options?: RawAxiosRequestConfig) {
        return HelmCustomDomainApiFp(this.configuration).listHelmCustomDomain(helmId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HelmDeploymentHistoryApi - axios parameter creator
 * @export
 */
export const HelmDeploymentHistoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the 20 last helm deployments
         * @summary List helm deployments
         * @param {string} helmId Helm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHelmDeploymentHistory: async (helmId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'helmId' is not null or undefined
            assertParamExists('listHelmDeploymentHistory', 'helmId', helmId)
            const localVarPath = `/helm/{helmId}/deploymentHistory`
                .replace(`{${"helmId"}}`, encodeURIComponent(String(helmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the 20 last helm deployments
         * @summary List helm deployments
         * @param {string} helmId 
         * @param {number | null} [pageSize] The number of deployments to return in the current page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHelmDeploymentHistoryV2: async (helmId: string, pageSize?: number | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'helmId' is not null or undefined
            assertParamExists('listHelmDeploymentHistoryV2', 'helmId', helmId)
            const localVarPath = `/helm/{helmId}/deploymentHistoryV2`
                .replace(`{${"helmId"}}`, encodeURIComponent(String(helmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HelmDeploymentHistoryApi - functional programming interface
 * @export
 */
export const HelmDeploymentHistoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HelmDeploymentHistoryApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the 20 last helm deployments
         * @summary List helm deployments
         * @param {string} helmId Helm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listHelmDeploymentHistory(helmId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListHelmDeploymentHistory200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listHelmDeploymentHistory(helmId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HelmDeploymentHistoryApi.listHelmDeploymentHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the 20 last helm deployments
         * @summary List helm deployments
         * @param {string} helmId 
         * @param {number | null} [pageSize] The number of deployments to return in the current page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listHelmDeploymentHistoryV2(helmId: string, pageSize?: number | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentHistoryServicePaginatedResponseListV2>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listHelmDeploymentHistoryV2(helmId, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HelmDeploymentHistoryApi.listHelmDeploymentHistoryV2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HelmDeploymentHistoryApi - factory interface
 * @export
 */
export const HelmDeploymentHistoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HelmDeploymentHistoryApiFp(configuration)
    return {
        /**
         * Returns the 20 last helm deployments
         * @summary List helm deployments
         * @param {string} helmId Helm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHelmDeploymentHistory(helmId: string, options?: RawAxiosRequestConfig): AxiosPromise<ListHelmDeploymentHistory200Response> {
            return localVarFp.listHelmDeploymentHistory(helmId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the 20 last helm deployments
         * @summary List helm deployments
         * @param {string} helmId 
         * @param {number | null} [pageSize] The number of deployments to return in the current page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHelmDeploymentHistoryV2(helmId: string, pageSize?: number | null, options?: RawAxiosRequestConfig): AxiosPromise<DeploymentHistoryServicePaginatedResponseListV2> {
            return localVarFp.listHelmDeploymentHistoryV2(helmId, pageSize, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HelmDeploymentHistoryApi - object-oriented interface
 * @export
 * @class HelmDeploymentHistoryApi
 * @extends {BaseAPI}
 */
export class HelmDeploymentHistoryApi extends BaseAPI {
    /**
     * Returns the 20 last helm deployments
     * @summary List helm deployments
     * @param {string} helmId Helm ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmDeploymentHistoryApi
     */
    public listHelmDeploymentHistory(helmId: string, options?: RawAxiosRequestConfig) {
        return HelmDeploymentHistoryApiFp(this.configuration).listHelmDeploymentHistory(helmId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the 20 last helm deployments
     * @summary List helm deployments
     * @param {string} helmId 
     * @param {number | null} [pageSize] The number of deployments to return in the current page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmDeploymentHistoryApi
     */
    public listHelmDeploymentHistoryV2(helmId: string, pageSize?: number | null, options?: RawAxiosRequestConfig) {
        return HelmDeploymentHistoryApiFp(this.configuration).listHelmDeploymentHistoryV2(helmId, pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HelmDeploymentRestrictionApi - axios parameter creator
 * @export
 */
export const HelmDeploymentRestrictionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a helm deployment restriction
         * @summary Create a helm deployment restriction
         * @param {string} helmId Helm ID
         * @param {HelmDeploymentRestrictionRequest} [helmDeploymentRestrictionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHelmDeploymentRestriction: async (helmId: string, helmDeploymentRestrictionRequest?: HelmDeploymentRestrictionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'helmId' is not null or undefined
            assertParamExists('createHelmDeploymentRestriction', 'helmId', helmId)
            const localVarPath = `/helm/{helmId}/deploymentRestriction`
                .replace(`{${"helmId"}}`, encodeURIComponent(String(helmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(helmDeploymentRestrictionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a helm deployment restriction
         * @summary Delete a helm deployment restriction
         * @param {string} helmId Helm ID
         * @param {string} deploymentRestrictionId Deployment Restriction ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHelmDeploymentRestriction: async (helmId: string, deploymentRestrictionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'helmId' is not null or undefined
            assertParamExists('deleteHelmDeploymentRestriction', 'helmId', helmId)
            // verify required parameter 'deploymentRestrictionId' is not null or undefined
            assertParamExists('deleteHelmDeploymentRestriction', 'deploymentRestrictionId', deploymentRestrictionId)
            const localVarPath = `/helm/{helmId}/deploymentRestriction/{deploymentRestrictionId}`
                .replace(`{${"helmId"}}`, encodeURIComponent(String(helmId)))
                .replace(`{${"deploymentRestrictionId"}}`, encodeURIComponent(String(deploymentRestrictionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit a helm deployment restriction
         * @summary Edit a helm deployment restriction
         * @param {string} helmId Helm ID
         * @param {string} deploymentRestrictionId Deployment Restriction ID
         * @param {HelmDeploymentRestrictionRequest} [helmDeploymentRestrictionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editHelmDeploymentRestriction: async (helmId: string, deploymentRestrictionId: string, helmDeploymentRestrictionRequest?: HelmDeploymentRestrictionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'helmId' is not null or undefined
            assertParamExists('editHelmDeploymentRestriction', 'helmId', helmId)
            // verify required parameter 'deploymentRestrictionId' is not null or undefined
            assertParamExists('editHelmDeploymentRestriction', 'deploymentRestrictionId', deploymentRestrictionId)
            const localVarPath = `/helm/{helmId}/deploymentRestriction/{deploymentRestrictionId}`
                .replace(`{${"helmId"}}`, encodeURIComponent(String(helmId)))
                .replace(`{${"deploymentRestrictionId"}}`, encodeURIComponent(String(deploymentRestrictionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(helmDeploymentRestrictionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get helm deployment restrictions
         * @summary Get helm deployment restrictions
         * @param {string} helmId Helm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHelmDeploymentRestrictions: async (helmId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'helmId' is not null or undefined
            assertParamExists('getHelmDeploymentRestrictions', 'helmId', helmId)
            const localVarPath = `/helm/{helmId}/deploymentRestriction`
                .replace(`{${"helmId"}}`, encodeURIComponent(String(helmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HelmDeploymentRestrictionApi - functional programming interface
 * @export
 */
export const HelmDeploymentRestrictionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HelmDeploymentRestrictionApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a helm deployment restriction
         * @summary Create a helm deployment restriction
         * @param {string} helmId Helm ID
         * @param {HelmDeploymentRestrictionRequest} [helmDeploymentRestrictionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createHelmDeploymentRestriction(helmId: string, helmDeploymentRestrictionRequest?: HelmDeploymentRestrictionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HelmDeploymentRestrictionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createHelmDeploymentRestriction(helmId, helmDeploymentRestrictionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HelmDeploymentRestrictionApi.createHelmDeploymentRestriction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a helm deployment restriction
         * @summary Delete a helm deployment restriction
         * @param {string} helmId Helm ID
         * @param {string} deploymentRestrictionId Deployment Restriction ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteHelmDeploymentRestriction(helmId: string, deploymentRestrictionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteHelmDeploymentRestriction(helmId, deploymentRestrictionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HelmDeploymentRestrictionApi.deleteHelmDeploymentRestriction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Edit a helm deployment restriction
         * @summary Edit a helm deployment restriction
         * @param {string} helmId Helm ID
         * @param {string} deploymentRestrictionId Deployment Restriction ID
         * @param {HelmDeploymentRestrictionRequest} [helmDeploymentRestrictionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editHelmDeploymentRestriction(helmId: string, deploymentRestrictionId: string, helmDeploymentRestrictionRequest?: HelmDeploymentRestrictionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HelmDeploymentRestrictionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editHelmDeploymentRestriction(helmId, deploymentRestrictionId, helmDeploymentRestrictionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HelmDeploymentRestrictionApi.editHelmDeploymentRestriction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get helm deployment restrictions
         * @summary Get helm deployment restrictions
         * @param {string} helmId Helm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHelmDeploymentRestrictions(helmId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HelmDeploymentRestrictionResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHelmDeploymentRestrictions(helmId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HelmDeploymentRestrictionApi.getHelmDeploymentRestrictions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HelmDeploymentRestrictionApi - factory interface
 * @export
 */
export const HelmDeploymentRestrictionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HelmDeploymentRestrictionApiFp(configuration)
    return {
        /**
         * Create a helm deployment restriction
         * @summary Create a helm deployment restriction
         * @param {string} helmId Helm ID
         * @param {HelmDeploymentRestrictionRequest} [helmDeploymentRestrictionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHelmDeploymentRestriction(helmId: string, helmDeploymentRestrictionRequest?: HelmDeploymentRestrictionRequest, options?: RawAxiosRequestConfig): AxiosPromise<HelmDeploymentRestrictionResponse> {
            return localVarFp.createHelmDeploymentRestriction(helmId, helmDeploymentRestrictionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a helm deployment restriction
         * @summary Delete a helm deployment restriction
         * @param {string} helmId Helm ID
         * @param {string} deploymentRestrictionId Deployment Restriction ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHelmDeploymentRestriction(helmId: string, deploymentRestrictionId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteHelmDeploymentRestriction(helmId, deploymentRestrictionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit a helm deployment restriction
         * @summary Edit a helm deployment restriction
         * @param {string} helmId Helm ID
         * @param {string} deploymentRestrictionId Deployment Restriction ID
         * @param {HelmDeploymentRestrictionRequest} [helmDeploymentRestrictionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editHelmDeploymentRestriction(helmId: string, deploymentRestrictionId: string, helmDeploymentRestrictionRequest?: HelmDeploymentRestrictionRequest, options?: RawAxiosRequestConfig): AxiosPromise<HelmDeploymentRestrictionResponse> {
            return localVarFp.editHelmDeploymentRestriction(helmId, deploymentRestrictionId, helmDeploymentRestrictionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get helm deployment restrictions
         * @summary Get helm deployment restrictions
         * @param {string} helmId Helm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHelmDeploymentRestrictions(helmId: string, options?: RawAxiosRequestConfig): AxiosPromise<HelmDeploymentRestrictionResponseList> {
            return localVarFp.getHelmDeploymentRestrictions(helmId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HelmDeploymentRestrictionApi - object-oriented interface
 * @export
 * @class HelmDeploymentRestrictionApi
 * @extends {BaseAPI}
 */
export class HelmDeploymentRestrictionApi extends BaseAPI {
    /**
     * Create a helm deployment restriction
     * @summary Create a helm deployment restriction
     * @param {string} helmId Helm ID
     * @param {HelmDeploymentRestrictionRequest} [helmDeploymentRestrictionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmDeploymentRestrictionApi
     */
    public createHelmDeploymentRestriction(helmId: string, helmDeploymentRestrictionRequest?: HelmDeploymentRestrictionRequest, options?: RawAxiosRequestConfig) {
        return HelmDeploymentRestrictionApiFp(this.configuration).createHelmDeploymentRestriction(helmId, helmDeploymentRestrictionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a helm deployment restriction
     * @summary Delete a helm deployment restriction
     * @param {string} helmId Helm ID
     * @param {string} deploymentRestrictionId Deployment Restriction ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmDeploymentRestrictionApi
     */
    public deleteHelmDeploymentRestriction(helmId: string, deploymentRestrictionId: string, options?: RawAxiosRequestConfig) {
        return HelmDeploymentRestrictionApiFp(this.configuration).deleteHelmDeploymentRestriction(helmId, deploymentRestrictionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit a helm deployment restriction
     * @summary Edit a helm deployment restriction
     * @param {string} helmId Helm ID
     * @param {string} deploymentRestrictionId Deployment Restriction ID
     * @param {HelmDeploymentRestrictionRequest} [helmDeploymentRestrictionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmDeploymentRestrictionApi
     */
    public editHelmDeploymentRestriction(helmId: string, deploymentRestrictionId: string, helmDeploymentRestrictionRequest?: HelmDeploymentRestrictionRequest, options?: RawAxiosRequestConfig) {
        return HelmDeploymentRestrictionApiFp(this.configuration).editHelmDeploymentRestriction(helmId, deploymentRestrictionId, helmDeploymentRestrictionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get helm deployment restrictions
     * @summary Get helm deployment restrictions
     * @param {string} helmId Helm ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmDeploymentRestrictionApi
     */
    public getHelmDeploymentRestrictions(helmId: string, options?: RawAxiosRequestConfig) {
        return HelmDeploymentRestrictionApiFp(this.configuration).getHelmDeploymentRestrictions(helmId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HelmMainCallsApi - axios parameter creator
 * @export
 */
export const HelmMainCallsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * To delete the helm you must have the admin permission
         * @summary Delete helm
         * @param {string} helmId Helm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHelm: async (helmId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'helmId' is not null or undefined
            assertParamExists('deleteHelm', 'helmId', helmId)
            const localVarPath = `/helm/{helmId}`
                .replace(`{${"helmId"}}`, encodeURIComponent(String(helmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - To edit the helm you must have the admin permission. 
         * @summary Edit helm
         * @param {string} helmId Helm ID
         * @param {HelmRequest} [helmRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editHelm: async (helmId: string, helmRequest?: HelmRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'helmId' is not null or undefined
            assertParamExists('editHelm', 'helmId', helmId)
            const localVarPath = `/helm/{helmId}`
                .replace(`{${"helmId"}}`, encodeURIComponent(String(helmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(helmRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get helm by ID
         * @param {string} helmId Helm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHelm: async (helmId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'helmId' is not null or undefined
            assertParamExists('getHelm', 'helmId', helmId)
            const localVarPath = `/helm/{helmId}`
                .replace(`{${"helmId"}}`, encodeURIComponent(String(helmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get helm kubernetes services
         * @summary Get helm kubernetes services
         * @param {string} helmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHelmKubernetesServices: async (helmId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'helmId' is not null or undefined
            assertParamExists('getHelmKubernetesServices', 'helmId', helmId)
            const localVarPath = `/helm/{helmId}/listServices`
                .replace(`{${"helmId"}}`, encodeURIComponent(String(helmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get helm status
         * @param {string} helmId Helm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHelmStatus: async (helmId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'helmId' is not null or undefined
            assertParamExists('getHelmStatus', 'helmId', helmId)
            const localVarPath = `/helm/{helmId}/status`
                .replace(`{${"helmId"}}`, encodeURIComponent(String(helmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns list of the last 100 commits made on the repository linked to helm
         * @summary List last helm commits
         * @param {string} helmId Helm ID
         * @param {string} [of] Source of git commit. Can be \&#39;chart\&#39; or \&#39;values\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHelmCommit: async (helmId: string, of?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'helmId' is not null or undefined
            assertParamExists('listHelmCommit', 'helmId', helmId)
            const localVarPath = `/helm/{helmId}/commit`
                .replace(`{${"helmId"}}`, encodeURIComponent(String(helmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (of !== undefined) {
                localVarQueryParameter['of'] = of;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This will return all the custom domains and Qovery autogenerated domain for the given helm
         * @summary List all URLs of the helm
         * @param {string} helmId Helm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHelmLinks: async (helmId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'helmId' is not null or undefined
            assertParamExists('listHelmLinks', 'helmId', helmId)
            const localVarPath = `/helm/{helmId}/link`
                .replace(`{${"helmId"}}`, encodeURIComponent(String(helmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HelmMainCallsApi - functional programming interface
 * @export
 */
export const HelmMainCallsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HelmMainCallsApiAxiosParamCreator(configuration)
    return {
        /**
         * To delete the helm you must have the admin permission
         * @summary Delete helm
         * @param {string} helmId Helm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteHelm(helmId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteHelm(helmId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HelmMainCallsApi.deleteHelm']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - To edit the helm you must have the admin permission. 
         * @summary Edit helm
         * @param {string} helmId Helm ID
         * @param {HelmRequest} [helmRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editHelm(helmId: string, helmRequest?: HelmRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HelmResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editHelm(helmId, helmRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HelmMainCallsApi.editHelm']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get helm by ID
         * @param {string} helmId Helm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHelm(helmId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HelmResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHelm(helmId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HelmMainCallsApi.getHelm']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get helm kubernetes services
         * @summary Get helm kubernetes services
         * @param {string} helmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHelmKubernetesServices(helmId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KubernetesServiceResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHelmKubernetesServices(helmId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HelmMainCallsApi.getHelmKubernetesServices']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get helm status
         * @param {string} helmId Helm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHelmStatus(helmId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHelmStatus(helmId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HelmMainCallsApi.getHelmStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns list of the last 100 commits made on the repository linked to helm
         * @summary List last helm commits
         * @param {string} helmId Helm ID
         * @param {string} [of] Source of git commit. Can be \&#39;chart\&#39; or \&#39;values\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listHelmCommit(helmId: string, of?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommitResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listHelmCommit(helmId, of, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HelmMainCallsApi.listHelmCommit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This will return all the custom domains and Qovery autogenerated domain for the given helm
         * @summary List all URLs of the helm
         * @param {string} helmId Helm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listHelmLinks(helmId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listHelmLinks(helmId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HelmMainCallsApi.listHelmLinks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HelmMainCallsApi - factory interface
 * @export
 */
export const HelmMainCallsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HelmMainCallsApiFp(configuration)
    return {
        /**
         * To delete the helm you must have the admin permission
         * @summary Delete helm
         * @param {string} helmId Helm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHelm(helmId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteHelm(helmId, options).then((request) => request(axios, basePath));
        },
        /**
         * - To edit the helm you must have the admin permission. 
         * @summary Edit helm
         * @param {string} helmId Helm ID
         * @param {HelmRequest} [helmRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editHelm(helmId: string, helmRequest?: HelmRequest, options?: RawAxiosRequestConfig): AxiosPromise<HelmResponse> {
            return localVarFp.editHelm(helmId, helmRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get helm by ID
         * @param {string} helmId Helm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHelm(helmId: string, options?: RawAxiosRequestConfig): AxiosPromise<HelmResponse> {
            return localVarFp.getHelm(helmId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get helm kubernetes services
         * @summary Get helm kubernetes services
         * @param {string} helmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHelmKubernetesServices(helmId: string, options?: RawAxiosRequestConfig): AxiosPromise<KubernetesServiceResponseList> {
            return localVarFp.getHelmKubernetesServices(helmId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get helm status
         * @param {string} helmId Helm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHelmStatus(helmId: string, options?: RawAxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.getHelmStatus(helmId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns list of the last 100 commits made on the repository linked to helm
         * @summary List last helm commits
         * @param {string} helmId Helm ID
         * @param {string} [of] Source of git commit. Can be \&#39;chart\&#39; or \&#39;values\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHelmCommit(helmId: string, of?: string, options?: RawAxiosRequestConfig): AxiosPromise<CommitResponseList> {
            return localVarFp.listHelmCommit(helmId, of, options).then((request) => request(axios, basePath));
        },
        /**
         * This will return all the custom domains and Qovery autogenerated domain for the given helm
         * @summary List all URLs of the helm
         * @param {string} helmId Helm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHelmLinks(helmId: string, options?: RawAxiosRequestConfig): AxiosPromise<LinkResponseList> {
            return localVarFp.listHelmLinks(helmId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HelmMainCallsApi - object-oriented interface
 * @export
 * @class HelmMainCallsApi
 * @extends {BaseAPI}
 */
export class HelmMainCallsApi extends BaseAPI {
    /**
     * To delete the helm you must have the admin permission
     * @summary Delete helm
     * @param {string} helmId Helm ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmMainCallsApi
     */
    public deleteHelm(helmId: string, options?: RawAxiosRequestConfig) {
        return HelmMainCallsApiFp(this.configuration).deleteHelm(helmId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - To edit the helm you must have the admin permission. 
     * @summary Edit helm
     * @param {string} helmId Helm ID
     * @param {HelmRequest} [helmRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmMainCallsApi
     */
    public editHelm(helmId: string, helmRequest?: HelmRequest, options?: RawAxiosRequestConfig) {
        return HelmMainCallsApiFp(this.configuration).editHelm(helmId, helmRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get helm by ID
     * @param {string} helmId Helm ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmMainCallsApi
     */
    public getHelm(helmId: string, options?: RawAxiosRequestConfig) {
        return HelmMainCallsApiFp(this.configuration).getHelm(helmId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get helm kubernetes services
     * @summary Get helm kubernetes services
     * @param {string} helmId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmMainCallsApi
     */
    public getHelmKubernetesServices(helmId: string, options?: RawAxiosRequestConfig) {
        return HelmMainCallsApiFp(this.configuration).getHelmKubernetesServices(helmId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get helm status
     * @param {string} helmId Helm ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmMainCallsApi
     */
    public getHelmStatus(helmId: string, options?: RawAxiosRequestConfig) {
        return HelmMainCallsApiFp(this.configuration).getHelmStatus(helmId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns list of the last 100 commits made on the repository linked to helm
     * @summary List last helm commits
     * @param {string} helmId Helm ID
     * @param {string} [of] Source of git commit. Can be \&#39;chart\&#39; or \&#39;values\&#39;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmMainCallsApi
     */
    public listHelmCommit(helmId: string, of?: string, options?: RawAxiosRequestConfig) {
        return HelmMainCallsApiFp(this.configuration).listHelmCommit(helmId, of, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will return all the custom domains and Qovery autogenerated domain for the given helm
     * @summary List all URLs of the helm
     * @param {string} helmId Helm ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmMainCallsApi
     */
    public listHelmLinks(helmId: string, options?: RawAxiosRequestConfig) {
        return HelmMainCallsApiFp(this.configuration).listHelmLinks(helmId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HelmRepositoriesApi - axios parameter creator
 * @export
 */
export const HelmRepositoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a helm repository
         * @param {string} organizationId Organization ID
         * @param {HelmRepositoryRequest} [helmRepositoryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHelmRepository: async (organizationId: string, helmRepositoryRequest?: HelmRepositoryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createHelmRepository', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/helmRepository`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(helmRepositoryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a helm repository
         * @param {string} organizationId Organization ID
         * @param {string} helmRepositoryId Helm chart repository ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHelmRepository: async (organizationId: string, helmRepositoryId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteHelmRepository', 'organizationId', organizationId)
            // verify required parameter 'helmRepositoryId' is not null or undefined
            assertParamExists('deleteHelmRepository', 'helmRepositoryId', helmRepositoryId)
            const localVarPath = `/organization/{organizationId}/helmRepository/{helmRepositoryId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"helmRepositoryId"}}`, encodeURIComponent(String(helmRepositoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a helm repository
         * @param {string} organizationId Organization ID
         * @param {string} helmRepositoryId Helm chart repository ID
         * @param {HelmRepositoryRequest} [helmRepositoryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editHelmRepository: async (organizationId: string, helmRepositoryId: string, helmRepositoryRequest?: HelmRepositoryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('editHelmRepository', 'organizationId', organizationId)
            // verify required parameter 'helmRepositoryId' is not null or undefined
            assertParamExists('editHelmRepository', 'helmRepositoryId', helmRepositoryId)
            const localVarPath = `/organization/{organizationId}/helmRepository/{helmRepositoryId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"helmRepositoryId"}}`, encodeURIComponent(String(helmRepositoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(helmRepositoryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List helm charts contained inside the repository
         * @param {string} organizationId Organization ID
         * @param {string} helmRepositoryId Helm chart repository ID
         * @param {string} [chartName] Helm chart name to filter the result on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHelmCharts: async (organizationId: string, helmRepositoryId: string, chartName?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getHelmCharts', 'organizationId', organizationId)
            // verify required parameter 'helmRepositoryId' is not null or undefined
            assertParamExists('getHelmCharts', 'helmRepositoryId', helmRepositoryId)
            const localVarPath = `/organization/{organizationId}/helmRepository/{helmRepositoryId}/charts`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"helmRepositoryId"}}`, encodeURIComponent(String(helmRepositoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (chartName !== undefined) {
                localVarQueryParameter['chartName'] = chartName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a helm repository
         * @param {string} organizationId Organization ID
         * @param {string} helmRepositoryId Helm chart repository ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHelmRepository: async (organizationId: string, helmRepositoryId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getHelmRepository', 'organizationId', organizationId)
            // verify required parameter 'helmRepositoryId' is not null or undefined
            assertParamExists('getHelmRepository', 'helmRepositoryId', helmRepositoryId)
            const localVarPath = `/organization/{organizationId}/helmRepository/{helmRepositoryId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"helmRepositoryId"}}`, encodeURIComponent(String(helmRepositoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List supported helm repository by Qovery and get the mandatory authentification configuration.
         * @summary List supported helm repository
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAvailableHelmRepository: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/availableHelmRepository`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List organization helm repositories
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHelmRepository: async (organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listHelmRepository', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/helmRepository`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HelmRepositoriesApi - functional programming interface
 * @export
 */
export const HelmRepositoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HelmRepositoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a helm repository
         * @param {string} organizationId Organization ID
         * @param {HelmRepositoryRequest} [helmRepositoryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createHelmRepository(organizationId: string, helmRepositoryRequest?: HelmRepositoryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HelmRepositoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createHelmRepository(organizationId, helmRepositoryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HelmRepositoriesApi.createHelmRepository']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a helm repository
         * @param {string} organizationId Organization ID
         * @param {string} helmRepositoryId Helm chart repository ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteHelmRepository(organizationId: string, helmRepositoryId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteHelmRepository(organizationId, helmRepositoryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HelmRepositoriesApi.deleteHelmRepository']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Edit a helm repository
         * @param {string} organizationId Organization ID
         * @param {string} helmRepositoryId Helm chart repository ID
         * @param {HelmRepositoryRequest} [helmRepositoryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editHelmRepository(organizationId: string, helmRepositoryId: string, helmRepositoryRequest?: HelmRepositoryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HelmRepositoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editHelmRepository(organizationId, helmRepositoryId, helmRepositoryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HelmRepositoriesApi.editHelmRepository']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List helm charts contained inside the repository
         * @param {string} organizationId Organization ID
         * @param {string} helmRepositoryId Helm chart repository ID
         * @param {string} [chartName] Helm chart name to filter the result on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHelmCharts(organizationId: string, helmRepositoryId: string, chartName?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HelmVersionResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHelmCharts(organizationId, helmRepositoryId, chartName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HelmRepositoriesApi.getHelmCharts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a helm repository
         * @param {string} organizationId Organization ID
         * @param {string} helmRepositoryId Helm chart repository ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHelmRepository(organizationId: string, helmRepositoryId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HelmRepositoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHelmRepository(organizationId, helmRepositoryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HelmRepositoriesApi.getHelmRepository']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List supported helm repository by Qovery and get the mandatory authentification configuration.
         * @summary List supported helm repository
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAvailableHelmRepository(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AvailableHelmRepositoryResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAvailableHelmRepository(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HelmRepositoriesApi.listAvailableHelmRepository']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List organization helm repositories
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listHelmRepository(organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HelmRepositoryResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listHelmRepository(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HelmRepositoriesApi.listHelmRepository']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HelmRepositoriesApi - factory interface
 * @export
 */
export const HelmRepositoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HelmRepositoriesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a helm repository
         * @param {string} organizationId Organization ID
         * @param {HelmRepositoryRequest} [helmRepositoryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHelmRepository(organizationId: string, helmRepositoryRequest?: HelmRepositoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<HelmRepositoryResponse> {
            return localVarFp.createHelmRepository(organizationId, helmRepositoryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a helm repository
         * @param {string} organizationId Organization ID
         * @param {string} helmRepositoryId Helm chart repository ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHelmRepository(organizationId: string, helmRepositoryId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteHelmRepository(organizationId, helmRepositoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a helm repository
         * @param {string} organizationId Organization ID
         * @param {string} helmRepositoryId Helm chart repository ID
         * @param {HelmRepositoryRequest} [helmRepositoryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editHelmRepository(organizationId: string, helmRepositoryId: string, helmRepositoryRequest?: HelmRepositoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<HelmRepositoryResponse> {
            return localVarFp.editHelmRepository(organizationId, helmRepositoryId, helmRepositoryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List helm charts contained inside the repository
         * @param {string} organizationId Organization ID
         * @param {string} helmRepositoryId Helm chart repository ID
         * @param {string} [chartName] Helm chart name to filter the result on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHelmCharts(organizationId: string, helmRepositoryId: string, chartName?: string, options?: RawAxiosRequestConfig): AxiosPromise<HelmVersionResponseList> {
            return localVarFp.getHelmCharts(organizationId, helmRepositoryId, chartName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a helm repository
         * @param {string} organizationId Organization ID
         * @param {string} helmRepositoryId Helm chart repository ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHelmRepository(organizationId: string, helmRepositoryId: string, options?: RawAxiosRequestConfig): AxiosPromise<HelmRepositoryResponse> {
            return localVarFp.getHelmRepository(organizationId, helmRepositoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * List supported helm repository by Qovery and get the mandatory authentification configuration.
         * @summary List supported helm repository
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAvailableHelmRepository(options?: RawAxiosRequestConfig): AxiosPromise<AvailableHelmRepositoryResponseList> {
            return localVarFp.listAvailableHelmRepository(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List organization helm repositories
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHelmRepository(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise<HelmRepositoryResponseList> {
            return localVarFp.listHelmRepository(organizationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HelmRepositoriesApi - object-oriented interface
 * @export
 * @class HelmRepositoriesApi
 * @extends {BaseAPI}
 */
export class HelmRepositoriesApi extends BaseAPI {
    /**
     * 
     * @summary Create a helm repository
     * @param {string} organizationId Organization ID
     * @param {HelmRepositoryRequest} [helmRepositoryRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmRepositoriesApi
     */
    public createHelmRepository(organizationId: string, helmRepositoryRequest?: HelmRepositoryRequest, options?: RawAxiosRequestConfig) {
        return HelmRepositoriesApiFp(this.configuration).createHelmRepository(organizationId, helmRepositoryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a helm repository
     * @param {string} organizationId Organization ID
     * @param {string} helmRepositoryId Helm chart repository ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmRepositoriesApi
     */
    public deleteHelmRepository(organizationId: string, helmRepositoryId: string, options?: RawAxiosRequestConfig) {
        return HelmRepositoriesApiFp(this.configuration).deleteHelmRepository(organizationId, helmRepositoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a helm repository
     * @param {string} organizationId Organization ID
     * @param {string} helmRepositoryId Helm chart repository ID
     * @param {HelmRepositoryRequest} [helmRepositoryRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmRepositoriesApi
     */
    public editHelmRepository(organizationId: string, helmRepositoryId: string, helmRepositoryRequest?: HelmRepositoryRequest, options?: RawAxiosRequestConfig) {
        return HelmRepositoriesApiFp(this.configuration).editHelmRepository(organizationId, helmRepositoryId, helmRepositoryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List helm charts contained inside the repository
     * @param {string} organizationId Organization ID
     * @param {string} helmRepositoryId Helm chart repository ID
     * @param {string} [chartName] Helm chart name to filter the result on
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmRepositoriesApi
     */
    public getHelmCharts(organizationId: string, helmRepositoryId: string, chartName?: string, options?: RawAxiosRequestConfig) {
        return HelmRepositoriesApiFp(this.configuration).getHelmCharts(organizationId, helmRepositoryId, chartName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a helm repository
     * @param {string} organizationId Organization ID
     * @param {string} helmRepositoryId Helm chart repository ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmRepositoriesApi
     */
    public getHelmRepository(organizationId: string, helmRepositoryId: string, options?: RawAxiosRequestConfig) {
        return HelmRepositoriesApiFp(this.configuration).getHelmRepository(organizationId, helmRepositoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List supported helm repository by Qovery and get the mandatory authentification configuration.
     * @summary List supported helm repository
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmRepositoriesApi
     */
    public listAvailableHelmRepository(options?: RawAxiosRequestConfig) {
        return HelmRepositoriesApiFp(this.configuration).listAvailableHelmRepository(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List organization helm repositories
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmRepositoriesApi
     */
    public listHelmRepository(organizationId: string, options?: RawAxiosRequestConfig) {
        return HelmRepositoriesApiFp(this.configuration).listHelmRepository(organizationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HelmsApi - axios parameter creator
 * @export
 */
export const HelmsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This will create a new helm with the same configuration on the targeted environment Id.
         * @summary Clone helm
         * @param {string} helmId Helm ID
         * @param {CloneServiceRequest} [cloneServiceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneHelm: async (helmId: string, cloneServiceRequest?: CloneServiceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'helmId' is not null or undefined
            assertParamExists('cloneHelm', 'helmId', helmId)
            const localVarPath = `/helm/{helmId}/clone`
                .replace(`{${"helmId"}}`, encodeURIComponent(String(helmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloneServiceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a helm
         * @param {string} environmentId Environment ID
         * @param {HelmRequest} [helmRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHelm: async (environmentId: string, helmRequest?: HelmRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('createHelm', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/helm`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(helmRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get helm default values
         * @param {string} environmentId Environment ID
         * @param {HelmDefaultValuesRequest} [helmDefaultValuesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHelmDefaultValues: async (environmentId: string, helmDefaultValuesRequest?: HelmDefaultValuesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('createHelmDefaultValues', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/helmDefaultValues`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(helmDefaultValuesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List default helm advanced settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultHelmAdvancedSettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/defaultHelmAdvancedSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of helms with only their id and status.
         * @summary List all environment helm statuses
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentHelmStatus: async (environmentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('getEnvironmentHelmStatus', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/helm/status`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List helms
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHelms: async (environmentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('listHelms', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/helm`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HelmsApi - functional programming interface
 * @export
 */
export const HelmsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HelmsApiAxiosParamCreator(configuration)
    return {
        /**
         * This will create a new helm with the same configuration on the targeted environment Id.
         * @summary Clone helm
         * @param {string} helmId Helm ID
         * @param {CloneServiceRequest} [cloneServiceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloneHelm(helmId: string, cloneServiceRequest?: CloneServiceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HelmResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cloneHelm(helmId, cloneServiceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HelmsApi.cloneHelm']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a helm
         * @param {string} environmentId Environment ID
         * @param {HelmRequest} [helmRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createHelm(environmentId: string, helmRequest?: HelmRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HelmResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createHelm(environmentId, helmRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HelmsApi.createHelm']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get helm default values
         * @param {string} environmentId Environment ID
         * @param {HelmDefaultValuesRequest} [helmDefaultValuesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createHelmDefaultValues(environmentId: string, helmDefaultValuesRequest?: HelmDefaultValuesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createHelmDefaultValues(environmentId, helmDefaultValuesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HelmsApi.createHelmDefaultValues']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List default helm advanced settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDefaultHelmAdvancedSettings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HelmAdvancedSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDefaultHelmAdvancedSettings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HelmsApi.getDefaultHelmAdvancedSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of helms with only their id and status.
         * @summary List all environment helm statuses
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironmentHelmStatus(environmentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReferenceObjectStatusResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironmentHelmStatus(environmentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HelmsApi.getEnvironmentHelmStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List helms
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listHelms(environmentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HelmResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listHelms(environmentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HelmsApi.listHelms']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HelmsApi - factory interface
 * @export
 */
export const HelmsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HelmsApiFp(configuration)
    return {
        /**
         * This will create a new helm with the same configuration on the targeted environment Id.
         * @summary Clone helm
         * @param {string} helmId Helm ID
         * @param {CloneServiceRequest} [cloneServiceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneHelm(helmId: string, cloneServiceRequest?: CloneServiceRequest, options?: RawAxiosRequestConfig): AxiosPromise<HelmResponse> {
            return localVarFp.cloneHelm(helmId, cloneServiceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a helm
         * @param {string} environmentId Environment ID
         * @param {HelmRequest} [helmRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHelm(environmentId: string, helmRequest?: HelmRequest, options?: RawAxiosRequestConfig): AxiosPromise<HelmResponse> {
            return localVarFp.createHelm(environmentId, helmRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get helm default values
         * @param {string} environmentId Environment ID
         * @param {HelmDefaultValuesRequest} [helmDefaultValuesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHelmDefaultValues(environmentId: string, helmDefaultValuesRequest?: HelmDefaultValuesRequest, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.createHelmDefaultValues(environmentId, helmDefaultValuesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List default helm advanced settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultHelmAdvancedSettings(options?: RawAxiosRequestConfig): AxiosPromise<HelmAdvancedSettings> {
            return localVarFp.getDefaultHelmAdvancedSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of helms with only their id and status.
         * @summary List all environment helm statuses
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentHelmStatus(environmentId: string, options?: RawAxiosRequestConfig): AxiosPromise<ReferenceObjectStatusResponseList> {
            return localVarFp.getEnvironmentHelmStatus(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List helms
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHelms(environmentId: string, options?: RawAxiosRequestConfig): AxiosPromise<HelmResponseList> {
            return localVarFp.listHelms(environmentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HelmsApi - object-oriented interface
 * @export
 * @class HelmsApi
 * @extends {BaseAPI}
 */
export class HelmsApi extends BaseAPI {
    /**
     * This will create a new helm with the same configuration on the targeted environment Id.
     * @summary Clone helm
     * @param {string} helmId Helm ID
     * @param {CloneServiceRequest} [cloneServiceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmsApi
     */
    public cloneHelm(helmId: string, cloneServiceRequest?: CloneServiceRequest, options?: RawAxiosRequestConfig) {
        return HelmsApiFp(this.configuration).cloneHelm(helmId, cloneServiceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a helm
     * @param {string} environmentId Environment ID
     * @param {HelmRequest} [helmRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmsApi
     */
    public createHelm(environmentId: string, helmRequest?: HelmRequest, options?: RawAxiosRequestConfig) {
        return HelmsApiFp(this.configuration).createHelm(environmentId, helmRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get helm default values
     * @param {string} environmentId Environment ID
     * @param {HelmDefaultValuesRequest} [helmDefaultValuesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmsApi
     */
    public createHelmDefaultValues(environmentId: string, helmDefaultValuesRequest?: HelmDefaultValuesRequest, options?: RawAxiosRequestConfig) {
        return HelmsApiFp(this.configuration).createHelmDefaultValues(environmentId, helmDefaultValuesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List default helm advanced settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmsApi
     */
    public getDefaultHelmAdvancedSettings(options?: RawAxiosRequestConfig) {
        return HelmsApiFp(this.configuration).getDefaultHelmAdvancedSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of helms with only their id and status.
     * @summary List all environment helm statuses
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmsApi
     */
    public getEnvironmentHelmStatus(environmentId: string, options?: RawAxiosRequestConfig) {
        return HelmsApiFp(this.configuration).getEnvironmentHelmStatus(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List helms
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmsApi
     */
    public listHelms(environmentId: string, options?: RawAxiosRequestConfig) {
        return HelmsApiFp(this.configuration).listHelms(environmentId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * JobActionsApi - axios parameter creator
 * @export
 */
export const JobActionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Clean a failed job
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cleanFailedJob: async (jobId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('cleanFailedJob', 'jobId', jobId)
            const localVarPath = `/job/{jobId}/cleanFailedJob`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You must provide a git commit id or an image tag depending on the source location of your code (git vs image repository).
         * @summary Deploy job
         * @param {string} jobId Job ID
         * @param {JobForceEvent} [forceEvent] When filled, it indicates the target event to be deployed.   If the concerned job hasn\&#39;t the target event provided, the job won\&#39;t be deployed. 
         * @param {JobDeployRequest} [jobDeployRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployJob: async (jobId: string, forceEvent?: JobForceEvent, jobDeployRequest?: JobDeployRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('deployJob', 'jobId', jobId)
            const localVarPath = `/job/{jobId}/deploy`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (forceEvent !== undefined) {
                localVarQueryParameter['forceEvent'] = forceEvent;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jobDeployRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Redeploy job
         * @param {string} jobId Job ID
         * @param {JobForceEvent} [forceEvent] When filled, it indicates the target event to be deployed.   If the concerned job hasn\&#39;t the target event provided, the job won\&#39;t be deployed. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeployJob: async (jobId: string, forceEvent?: JobForceEvent, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('redeployJob', 'jobId', jobId)
            const localVarPath = `/job/{jobId}/redeploy`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (forceEvent !== undefined) {
                localVarQueryParameter['forceEvent'] = forceEvent;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop job
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopJob: async (jobId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('stopJob', 'jobId', jobId)
            const localVarPath = `/job/{jobId}/stop`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the resources of the job but keep Qovery configuration
         * @summary Uninstall job
         * @param {string} jobId Job ID
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uninstallJob: async (jobId: string, body?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('uninstallJob', 'jobId', jobId)
            const localVarPath = `/job/{jobId}/uninstall`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobActionsApi - functional programming interface
 * @export
 */
export const JobActionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JobActionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Clean a failed job
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cleanFailedJob(jobId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CleanFailedJob200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cleanFailedJob(jobId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobActionsApi.cleanFailedJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * You must provide a git commit id or an image tag depending on the source location of your code (git vs image repository).
         * @summary Deploy job
         * @param {string} jobId Job ID
         * @param {JobForceEvent} [forceEvent] When filled, it indicates the target event to be deployed.   If the concerned job hasn\&#39;t the target event provided, the job won\&#39;t be deployed. 
         * @param {JobDeployRequest} [jobDeployRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployJob(jobId: string, forceEvent?: JobForceEvent, jobDeployRequest?: JobDeployRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployJob(jobId, forceEvent, jobDeployRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobActionsApi.deployJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Redeploy job
         * @param {string} jobId Job ID
         * @param {JobForceEvent} [forceEvent] When filled, it indicates the target event to be deployed.   If the concerned job hasn\&#39;t the target event provided, the job won\&#39;t be deployed. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async redeployJob(jobId: string, forceEvent?: JobForceEvent, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.redeployJob(jobId, forceEvent, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobActionsApi.redeployJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Stop job
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopJob(jobId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopJob(jobId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobActionsApi.stopJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete the resources of the job but keep Qovery configuration
         * @summary Uninstall job
         * @param {string} jobId Job ID
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uninstallJob(jobId: string, body?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uninstallJob(jobId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobActionsApi.uninstallJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * JobActionsApi - factory interface
 * @export
 */
export const JobActionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JobActionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Clean a failed job
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cleanFailedJob(jobId: string, options?: RawAxiosRequestConfig): AxiosPromise<CleanFailedJob200Response> {
            return localVarFp.cleanFailedJob(jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * You must provide a git commit id or an image tag depending on the source location of your code (git vs image repository).
         * @summary Deploy job
         * @param {string} jobId Job ID
         * @param {JobForceEvent} [forceEvent] When filled, it indicates the target event to be deployed.   If the concerned job hasn\&#39;t the target event provided, the job won\&#39;t be deployed. 
         * @param {JobDeployRequest} [jobDeployRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployJob(jobId: string, forceEvent?: JobForceEvent, jobDeployRequest?: JobDeployRequest, options?: RawAxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.deployJob(jobId, forceEvent, jobDeployRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Redeploy job
         * @param {string} jobId Job ID
         * @param {JobForceEvent} [forceEvent] When filled, it indicates the target event to be deployed.   If the concerned job hasn\&#39;t the target event provided, the job won\&#39;t be deployed. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeployJob(jobId: string, forceEvent?: JobForceEvent, options?: RawAxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.redeployJob(jobId, forceEvent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Stop job
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopJob(jobId: string, options?: RawAxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.stopJob(jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete the resources of the job but keep Qovery configuration
         * @summary Uninstall job
         * @param {string} jobId Job ID
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uninstallJob(jobId: string, body?: object, options?: RawAxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.uninstallJob(jobId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JobActionsApi - object-oriented interface
 * @export
 * @class JobActionsApi
 * @extends {BaseAPI}
 */
export class JobActionsApi extends BaseAPI {
    /**
     * 
     * @summary Clean a failed job
     * @param {string} jobId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobActionsApi
     */
    public cleanFailedJob(jobId: string, options?: RawAxiosRequestConfig) {
        return JobActionsApiFp(this.configuration).cleanFailedJob(jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You must provide a git commit id or an image tag depending on the source location of your code (git vs image repository).
     * @summary Deploy job
     * @param {string} jobId Job ID
     * @param {JobForceEvent} [forceEvent] When filled, it indicates the target event to be deployed.   If the concerned job hasn\&#39;t the target event provided, the job won\&#39;t be deployed. 
     * @param {JobDeployRequest} [jobDeployRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobActionsApi
     */
    public deployJob(jobId: string, forceEvent?: JobForceEvent, jobDeployRequest?: JobDeployRequest, options?: RawAxiosRequestConfig) {
        return JobActionsApiFp(this.configuration).deployJob(jobId, forceEvent, jobDeployRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Redeploy job
     * @param {string} jobId Job ID
     * @param {JobForceEvent} [forceEvent] When filled, it indicates the target event to be deployed.   If the concerned job hasn\&#39;t the target event provided, the job won\&#39;t be deployed. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobActionsApi
     */
    public redeployJob(jobId: string, forceEvent?: JobForceEvent, options?: RawAxiosRequestConfig) {
        return JobActionsApiFp(this.configuration).redeployJob(jobId, forceEvent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Stop job
     * @param {string} jobId Job ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobActionsApi
     */
    public stopJob(jobId: string, options?: RawAxiosRequestConfig) {
        return JobActionsApiFp(this.configuration).stopJob(jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete the resources of the job but keep Qovery configuration
     * @summary Uninstall job
     * @param {string} jobId Job ID
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobActionsApi
     */
    public uninstallJob(jobId: string, body?: object, options?: RawAxiosRequestConfig) {
        return JobActionsApiFp(this.configuration).uninstallJob(jobId, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * JobConfigurationApi - axios parameter creator
 * @export
 */
export const JobConfigurationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Edit advanced settings by returning table of advanced settings.
         * @summary Edit advanced settings
         * @param {string} jobId Job ID
         * @param {JobAdvancedSettings} [jobAdvancedSettings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editJobAdvancedSettings: async (jobId: string, jobAdvancedSettings?: JobAdvancedSettings, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('editJobAdvancedSettings', 'jobId', jobId)
            const localVarPath = `/job/{jobId}/advancedSettings`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jobAdvancedSettings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list and values of the advanced settings of the job. Default values for each setting are available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/advanced-settings/) 
         * @summary Get advanced settings
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobAdvancedSettings: async (jobId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getJobAdvancedSettings', 'jobId', jobId)
            const localVarPath = `/job/{jobId}/advancedSettings`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobConfigurationApi - functional programming interface
 * @export
 */
export const JobConfigurationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JobConfigurationApiAxiosParamCreator(configuration)
    return {
        /**
         * Edit advanced settings by returning table of advanced settings.
         * @summary Edit advanced settings
         * @param {string} jobId Job ID
         * @param {JobAdvancedSettings} [jobAdvancedSettings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editJobAdvancedSettings(jobId: string, jobAdvancedSettings?: JobAdvancedSettings, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobAdvancedSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editJobAdvancedSettings(jobId, jobAdvancedSettings, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobConfigurationApi.editJobAdvancedSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get list and values of the advanced settings of the job. Default values for each setting are available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/advanced-settings/) 
         * @summary Get advanced settings
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobAdvancedSettings(jobId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobAdvancedSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobAdvancedSettings(jobId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobConfigurationApi.getJobAdvancedSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * JobConfigurationApi - factory interface
 * @export
 */
export const JobConfigurationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JobConfigurationApiFp(configuration)
    return {
        /**
         * Edit advanced settings by returning table of advanced settings.
         * @summary Edit advanced settings
         * @param {string} jobId Job ID
         * @param {JobAdvancedSettings} [jobAdvancedSettings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editJobAdvancedSettings(jobId: string, jobAdvancedSettings?: JobAdvancedSettings, options?: RawAxiosRequestConfig): AxiosPromise<JobAdvancedSettings> {
            return localVarFp.editJobAdvancedSettings(jobId, jobAdvancedSettings, options).then((request) => request(axios, basePath));
        },
        /**
         * Get list and values of the advanced settings of the job. Default values for each setting are available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/advanced-settings/) 
         * @summary Get advanced settings
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobAdvancedSettings(jobId: string, options?: RawAxiosRequestConfig): AxiosPromise<JobAdvancedSettings> {
            return localVarFp.getJobAdvancedSettings(jobId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JobConfigurationApi - object-oriented interface
 * @export
 * @class JobConfigurationApi
 * @extends {BaseAPI}
 */
export class JobConfigurationApi extends BaseAPI {
    /**
     * Edit advanced settings by returning table of advanced settings.
     * @summary Edit advanced settings
     * @param {string} jobId Job ID
     * @param {JobAdvancedSettings} [jobAdvancedSettings] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobConfigurationApi
     */
    public editJobAdvancedSettings(jobId: string, jobAdvancedSettings?: JobAdvancedSettings, options?: RawAxiosRequestConfig) {
        return JobConfigurationApiFp(this.configuration).editJobAdvancedSettings(jobId, jobAdvancedSettings, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list and values of the advanced settings of the job. Default values for each setting are available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/advanced-settings/) 
     * @summary Get advanced settings
     * @param {string} jobId Job ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobConfigurationApi
     */
    public getJobAdvancedSettings(jobId: string, options?: RawAxiosRequestConfig) {
        return JobConfigurationApiFp(this.configuration).getJobAdvancedSettings(jobId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * JobDeploymentHistoryApi - axios parameter creator
 * @export
 */
export const JobDeploymentHistoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the 20 last job deployments
         * @summary List job deployments
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobDeploymentHistory: async (jobId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('listJobDeploymentHistory', 'jobId', jobId)
            const localVarPath = `/job/{jobId}/deploymentHistory`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the 20 last job deployments
         * @summary List job deployments
         * @param {string} jobId 
         * @param {number | null} [pageSize] The number of deployments to return in the current page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobDeploymentHistoryV2: async (jobId: string, pageSize?: number | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('listJobDeploymentHistoryV2', 'jobId', jobId)
            const localVarPath = `/job/{jobId}/deploymentHistoryV2`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobDeploymentHistoryApi - functional programming interface
 * @export
 */
export const JobDeploymentHistoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JobDeploymentHistoryApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the 20 last job deployments
         * @summary List job deployments
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listJobDeploymentHistory(jobId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListJobDeploymentHistory200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listJobDeploymentHistory(jobId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobDeploymentHistoryApi.listJobDeploymentHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the 20 last job deployments
         * @summary List job deployments
         * @param {string} jobId 
         * @param {number | null} [pageSize] The number of deployments to return in the current page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listJobDeploymentHistoryV2(jobId: string, pageSize?: number | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentHistoryServicePaginatedResponseListV2>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listJobDeploymentHistoryV2(jobId, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobDeploymentHistoryApi.listJobDeploymentHistoryV2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * JobDeploymentHistoryApi - factory interface
 * @export
 */
export const JobDeploymentHistoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JobDeploymentHistoryApiFp(configuration)
    return {
        /**
         * Returns the 20 last job deployments
         * @summary List job deployments
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobDeploymentHistory(jobId: string, options?: RawAxiosRequestConfig): AxiosPromise<ListJobDeploymentHistory200Response> {
            return localVarFp.listJobDeploymentHistory(jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the 20 last job deployments
         * @summary List job deployments
         * @param {string} jobId 
         * @param {number | null} [pageSize] The number of deployments to return in the current page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobDeploymentHistoryV2(jobId: string, pageSize?: number | null, options?: RawAxiosRequestConfig): AxiosPromise<DeploymentHistoryServicePaginatedResponseListV2> {
            return localVarFp.listJobDeploymentHistoryV2(jobId, pageSize, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JobDeploymentHistoryApi - object-oriented interface
 * @export
 * @class JobDeploymentHistoryApi
 * @extends {BaseAPI}
 */
export class JobDeploymentHistoryApi extends BaseAPI {
    /**
     * Returns the 20 last job deployments
     * @summary List job deployments
     * @param {string} jobId Job ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobDeploymentHistoryApi
     */
    public listJobDeploymentHistory(jobId: string, options?: RawAxiosRequestConfig) {
        return JobDeploymentHistoryApiFp(this.configuration).listJobDeploymentHistory(jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the 20 last job deployments
     * @summary List job deployments
     * @param {string} jobId 
     * @param {number | null} [pageSize] The number of deployments to return in the current page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobDeploymentHistoryApi
     */
    public listJobDeploymentHistoryV2(jobId: string, pageSize?: number | null, options?: RawAxiosRequestConfig) {
        return JobDeploymentHistoryApiFp(this.configuration).listJobDeploymentHistoryV2(jobId, pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * JobDeploymentRestrictionApi - axios parameter creator
 * @export
 */
export const JobDeploymentRestrictionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a job deployment restriction
         * @summary Create a job deployment restriction
         * @param {string} jobId Job ID
         * @param {JobDeploymentRestrictionRequest} [jobDeploymentRestrictionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJobDeploymentRestriction: async (jobId: string, jobDeploymentRestrictionRequest?: JobDeploymentRestrictionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('createJobDeploymentRestriction', 'jobId', jobId)
            const localVarPath = `/job/{jobId}/deploymentRestriction`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jobDeploymentRestrictionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a job deployment restriction
         * @summary Delete a job deployment restriction
         * @param {string} jobId Job ID
         * @param {string} deploymentRestrictionId Deployment Restriction ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJobDeploymentRestriction: async (jobId: string, deploymentRestrictionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('deleteJobDeploymentRestriction', 'jobId', jobId)
            // verify required parameter 'deploymentRestrictionId' is not null or undefined
            assertParamExists('deleteJobDeploymentRestriction', 'deploymentRestrictionId', deploymentRestrictionId)
            const localVarPath = `/job/{jobId}/deploymentRestriction/{deploymentRestrictionId}`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)))
                .replace(`{${"deploymentRestrictionId"}}`, encodeURIComponent(String(deploymentRestrictionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit a job deployment restriction
         * @summary Edit a job deployment restriction
         * @param {string} jobId Job ID
         * @param {string} deploymentRestrictionId Deployment Restriction ID
         * @param {JobDeploymentRestrictionRequest} [jobDeploymentRestrictionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editJobDeploymentRestriction: async (jobId: string, deploymentRestrictionId: string, jobDeploymentRestrictionRequest?: JobDeploymentRestrictionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('editJobDeploymentRestriction', 'jobId', jobId)
            // verify required parameter 'deploymentRestrictionId' is not null or undefined
            assertParamExists('editJobDeploymentRestriction', 'deploymentRestrictionId', deploymentRestrictionId)
            const localVarPath = `/job/{jobId}/deploymentRestriction/{deploymentRestrictionId}`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)))
                .replace(`{${"deploymentRestrictionId"}}`, encodeURIComponent(String(deploymentRestrictionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jobDeploymentRestrictionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get job deployment restrictions
         * @summary Get job deployment restrictions
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobDeploymentRestrictions: async (jobId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getJobDeploymentRestrictions', 'jobId', jobId)
            const localVarPath = `/job/{jobId}/deploymentRestriction`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobDeploymentRestrictionApi - functional programming interface
 * @export
 */
export const JobDeploymentRestrictionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JobDeploymentRestrictionApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a job deployment restriction
         * @summary Create a job deployment restriction
         * @param {string} jobId Job ID
         * @param {JobDeploymentRestrictionRequest} [jobDeploymentRestrictionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createJobDeploymentRestriction(jobId: string, jobDeploymentRestrictionRequest?: JobDeploymentRestrictionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobDeploymentRestrictionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createJobDeploymentRestriction(jobId, jobDeploymentRestrictionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobDeploymentRestrictionApi.createJobDeploymentRestriction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a job deployment restriction
         * @summary Delete a job deployment restriction
         * @param {string} jobId Job ID
         * @param {string} deploymentRestrictionId Deployment Restriction ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteJobDeploymentRestriction(jobId: string, deploymentRestrictionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteJobDeploymentRestriction(jobId, deploymentRestrictionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobDeploymentRestrictionApi.deleteJobDeploymentRestriction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Edit a job deployment restriction
         * @summary Edit a job deployment restriction
         * @param {string} jobId Job ID
         * @param {string} deploymentRestrictionId Deployment Restriction ID
         * @param {JobDeploymentRestrictionRequest} [jobDeploymentRestrictionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editJobDeploymentRestriction(jobId: string, deploymentRestrictionId: string, jobDeploymentRestrictionRequest?: JobDeploymentRestrictionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobDeploymentRestrictionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editJobDeploymentRestriction(jobId, deploymentRestrictionId, jobDeploymentRestrictionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobDeploymentRestrictionApi.editJobDeploymentRestriction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get job deployment restrictions
         * @summary Get job deployment restrictions
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobDeploymentRestrictions(jobId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobDeploymentRestrictionResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobDeploymentRestrictions(jobId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobDeploymentRestrictionApi.getJobDeploymentRestrictions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * JobDeploymentRestrictionApi - factory interface
 * @export
 */
export const JobDeploymentRestrictionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JobDeploymentRestrictionApiFp(configuration)
    return {
        /**
         * Create a job deployment restriction
         * @summary Create a job deployment restriction
         * @param {string} jobId Job ID
         * @param {JobDeploymentRestrictionRequest} [jobDeploymentRestrictionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJobDeploymentRestriction(jobId: string, jobDeploymentRestrictionRequest?: JobDeploymentRestrictionRequest, options?: RawAxiosRequestConfig): AxiosPromise<JobDeploymentRestrictionResponse> {
            return localVarFp.createJobDeploymentRestriction(jobId, jobDeploymentRestrictionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a job deployment restriction
         * @summary Delete a job deployment restriction
         * @param {string} jobId Job ID
         * @param {string} deploymentRestrictionId Deployment Restriction ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJobDeploymentRestriction(jobId: string, deploymentRestrictionId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteJobDeploymentRestriction(jobId, deploymentRestrictionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit a job deployment restriction
         * @summary Edit a job deployment restriction
         * @param {string} jobId Job ID
         * @param {string} deploymentRestrictionId Deployment Restriction ID
         * @param {JobDeploymentRestrictionRequest} [jobDeploymentRestrictionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editJobDeploymentRestriction(jobId: string, deploymentRestrictionId: string, jobDeploymentRestrictionRequest?: JobDeploymentRestrictionRequest, options?: RawAxiosRequestConfig): AxiosPromise<JobDeploymentRestrictionResponse> {
            return localVarFp.editJobDeploymentRestriction(jobId, deploymentRestrictionId, jobDeploymentRestrictionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get job deployment restrictions
         * @summary Get job deployment restrictions
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobDeploymentRestrictions(jobId: string, options?: RawAxiosRequestConfig): AxiosPromise<JobDeploymentRestrictionResponseList> {
            return localVarFp.getJobDeploymentRestrictions(jobId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JobDeploymentRestrictionApi - object-oriented interface
 * @export
 * @class JobDeploymentRestrictionApi
 * @extends {BaseAPI}
 */
export class JobDeploymentRestrictionApi extends BaseAPI {
    /**
     * Create a job deployment restriction
     * @summary Create a job deployment restriction
     * @param {string} jobId Job ID
     * @param {JobDeploymentRestrictionRequest} [jobDeploymentRestrictionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobDeploymentRestrictionApi
     */
    public createJobDeploymentRestriction(jobId: string, jobDeploymentRestrictionRequest?: JobDeploymentRestrictionRequest, options?: RawAxiosRequestConfig) {
        return JobDeploymentRestrictionApiFp(this.configuration).createJobDeploymentRestriction(jobId, jobDeploymentRestrictionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a job deployment restriction
     * @summary Delete a job deployment restriction
     * @param {string} jobId Job ID
     * @param {string} deploymentRestrictionId Deployment Restriction ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobDeploymentRestrictionApi
     */
    public deleteJobDeploymentRestriction(jobId: string, deploymentRestrictionId: string, options?: RawAxiosRequestConfig) {
        return JobDeploymentRestrictionApiFp(this.configuration).deleteJobDeploymentRestriction(jobId, deploymentRestrictionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit a job deployment restriction
     * @summary Edit a job deployment restriction
     * @param {string} jobId Job ID
     * @param {string} deploymentRestrictionId Deployment Restriction ID
     * @param {JobDeploymentRestrictionRequest} [jobDeploymentRestrictionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobDeploymentRestrictionApi
     */
    public editJobDeploymentRestriction(jobId: string, deploymentRestrictionId: string, jobDeploymentRestrictionRequest?: JobDeploymentRestrictionRequest, options?: RawAxiosRequestConfig) {
        return JobDeploymentRestrictionApiFp(this.configuration).editJobDeploymentRestriction(jobId, deploymentRestrictionId, jobDeploymentRestrictionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get job deployment restrictions
     * @summary Get job deployment restrictions
     * @param {string} jobId Job ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobDeploymentRestrictionApi
     */
    public getJobDeploymentRestrictions(jobId: string, options?: RawAxiosRequestConfig) {
        return JobDeploymentRestrictionApiFp(this.configuration).getJobDeploymentRestrictions(jobId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * JobEnvironmentVariableApi - axios parameter creator
 * @export
 */
export const JobEnvironmentVariableApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * - Add an environment variable to the job. 
         * @summary Add an environment variable to the job
         * @param {string} jobId Job ID
         * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJobEnvironmentVariable: async (jobId: string, environmentVariableRequest?: EnvironmentVariableRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('createJobEnvironmentVariable', 'jobId', jobId)
            const localVarPath = `/job/{jobId}/environmentVariable`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentVariableRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to add an alias at job level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at job level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - You can\'t create an alias on an alias 
         * @summary Create an environment variable alias at the job level
         * @param {string} jobId Job ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJobEnvironmentVariableAlias: async (jobId: string, environmentVariableId: string, key?: Key, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('createJobEnvironmentVariableAlias', 'jobId', jobId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('createJobEnvironmentVariableAlias', 'environmentVariableId', environmentVariableId)
            const localVarPath = `/job/{jobId}/environmentVariable/{environmentVariableId}/alias`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(key, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to override at job level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at job level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
         * @summary Create an environment variable override at the job level
         * @param {string} jobId Job ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJobEnvironmentVariableOverride: async (jobId: string, environmentVariableId: string, value?: Value, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('createJobEnvironmentVariableOverride', 'jobId', jobId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('createJobEnvironmentVariableOverride', 'environmentVariableId', environmentVariableId)
            const localVarPath = `/job/{jobId}/environmentVariable/{environmentVariableId}/override`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(value, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - To delete an environment variable from an job you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete an environment variable from a job
         * @param {string} jobId Job ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJobEnvironmentVariable: async (jobId: string, environmentVariableId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('deleteJobEnvironmentVariable', 'jobId', jobId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('deleteJobEnvironmentVariable', 'environmentVariableId', environmentVariableId)
            const localVarPath = `/job/{jobId}/environmentVariable/{environmentVariableId}`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > CONTAINER) 
         * @summary Edit an environment variable belonging to the job
         * @param {string} jobId Job ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editJobEnvironmentVariable: async (jobId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('editJobEnvironmentVariable', 'jobId', jobId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('editJobEnvironmentVariable', 'environmentVariableId', environmentVariableId)
            // verify required parameter 'environmentVariableEditRequest' is not null or undefined
            assertParamExists('editJobEnvironmentVariable', 'environmentVariableEditRequest', environmentVariableEditRequest)
            const localVarPath = `/job/{jobId}/environmentVariable/{environmentVariableId}`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentVariableEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Import environment variables in a defined scope, with a defined visibility.
         * @summary Import variables
         * @param {string} jobId Job ID
         * @param {VariableImportRequest} [variableImportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importJobEnvironmentVariable: async (jobId: string, variableImportRequest?: VariableImportRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('importJobEnvironmentVariable', 'jobId', jobId)
            const localVarPath = `/job/{jobId}/environmentVariable/import`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(variableImportRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List environment variables
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobEnvironmentVariable: async (jobId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('listJobEnvironmentVariable', 'jobId', jobId)
            const localVarPath = `/job/{jobId}/environmentVariable`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobEnvironmentVariableApi - functional programming interface
 * @export
 */
export const JobEnvironmentVariableApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JobEnvironmentVariableApiAxiosParamCreator(configuration)
    return {
        /**
         * - Add an environment variable to the job. 
         * @summary Add an environment variable to the job
         * @param {string} jobId Job ID
         * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createJobEnvironmentVariable(jobId: string, environmentVariableRequest?: EnvironmentVariableRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createJobEnvironmentVariable(jobId, environmentVariableRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobEnvironmentVariableApi.createJobEnvironmentVariable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - Allows you to add an alias at job level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at job level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - You can\'t create an alias on an alias 
         * @summary Create an environment variable alias at the job level
         * @param {string} jobId Job ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createJobEnvironmentVariableAlias(jobId: string, environmentVariableId: string, key?: Key, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createJobEnvironmentVariableAlias(jobId, environmentVariableId, key, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobEnvironmentVariableApi.createJobEnvironmentVariableAlias']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - Allows you to override at job level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at job level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
         * @summary Create an environment variable override at the job level
         * @param {string} jobId Job ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createJobEnvironmentVariableOverride(jobId: string, environmentVariableId: string, value?: Value, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createJobEnvironmentVariableOverride(jobId, environmentVariableId, value, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobEnvironmentVariableApi.createJobEnvironmentVariableOverride']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - To delete an environment variable from an job you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete an environment variable from a job
         * @param {string} jobId Job ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteJobEnvironmentVariable(jobId: string, environmentVariableId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteJobEnvironmentVariable(jobId, environmentVariableId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobEnvironmentVariableApi.deleteJobEnvironmentVariable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > CONTAINER) 
         * @summary Edit an environment variable belonging to the job
         * @param {string} jobId Job ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editJobEnvironmentVariable(jobId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editJobEnvironmentVariable(jobId, environmentVariableId, environmentVariableEditRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobEnvironmentVariableApi.editJobEnvironmentVariable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Import environment variables in a defined scope, with a defined visibility.
         * @summary Import variables
         * @param {string} jobId Job ID
         * @param {VariableImportRequest} [variableImportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importJobEnvironmentVariable(jobId: string, variableImportRequest?: VariableImportRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariableImport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importJobEnvironmentVariable(jobId, variableImportRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobEnvironmentVariableApi.importJobEnvironmentVariable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List environment variables
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listJobEnvironmentVariable(jobId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariableResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listJobEnvironmentVariable(jobId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobEnvironmentVariableApi.listJobEnvironmentVariable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * JobEnvironmentVariableApi - factory interface
 * @export
 */
export const JobEnvironmentVariableApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JobEnvironmentVariableApiFp(configuration)
    return {
        /**
         * - Add an environment variable to the job. 
         * @summary Add an environment variable to the job
         * @param {string} jobId Job ID
         * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJobEnvironmentVariable(jobId: string, environmentVariableRequest?: EnvironmentVariableRequest, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentVariable> {
            return localVarFp.createJobEnvironmentVariable(jobId, environmentVariableRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to add an alias at job level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at job level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - You can\'t create an alias on an alias 
         * @summary Create an environment variable alias at the job level
         * @param {string} jobId Job ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJobEnvironmentVariableAlias(jobId: string, environmentVariableId: string, key?: Key, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentVariable> {
            return localVarFp.createJobEnvironmentVariableAlias(jobId, environmentVariableId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to override at job level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at job level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
         * @summary Create an environment variable override at the job level
         * @param {string} jobId Job ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJobEnvironmentVariableOverride(jobId: string, environmentVariableId: string, value?: Value, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentVariable> {
            return localVarFp.createJobEnvironmentVariableOverride(jobId, environmentVariableId, value, options).then((request) => request(axios, basePath));
        },
        /**
         * - To delete an environment variable from an job you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete an environment variable from a job
         * @param {string} jobId Job ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJobEnvironmentVariable(jobId: string, environmentVariableId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteJobEnvironmentVariable(jobId, environmentVariableId, options).then((request) => request(axios, basePath));
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > CONTAINER) 
         * @summary Edit an environment variable belonging to the job
         * @param {string} jobId Job ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editJobEnvironmentVariable(jobId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentVariable> {
            return localVarFp.editJobEnvironmentVariable(jobId, environmentVariableId, environmentVariableEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Import environment variables in a defined scope, with a defined visibility.
         * @summary Import variables
         * @param {string} jobId Job ID
         * @param {VariableImportRequest} [variableImportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importJobEnvironmentVariable(jobId: string, variableImportRequest?: VariableImportRequest, options?: RawAxiosRequestConfig): AxiosPromise<VariableImport> {
            return localVarFp.importJobEnvironmentVariable(jobId, variableImportRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List environment variables
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobEnvironmentVariable(jobId: string, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentVariableResponseList> {
            return localVarFp.listJobEnvironmentVariable(jobId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JobEnvironmentVariableApi - object-oriented interface
 * @export
 * @class JobEnvironmentVariableApi
 * @extends {BaseAPI}
 */
export class JobEnvironmentVariableApi extends BaseAPI {
    /**
     * - Add an environment variable to the job. 
     * @summary Add an environment variable to the job
     * @param {string} jobId Job ID
     * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobEnvironmentVariableApi
     */
    public createJobEnvironmentVariable(jobId: string, environmentVariableRequest?: EnvironmentVariableRequest, options?: RawAxiosRequestConfig) {
        return JobEnvironmentVariableApiFp(this.configuration).createJobEnvironmentVariable(jobId, environmentVariableRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to add an alias at job level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at job level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - You can\'t create an alias on an alias 
     * @summary Create an environment variable alias at the job level
     * @param {string} jobId Job ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {Key} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobEnvironmentVariableApi
     */
    public createJobEnvironmentVariableAlias(jobId: string, environmentVariableId: string, key?: Key, options?: RawAxiosRequestConfig) {
        return JobEnvironmentVariableApiFp(this.configuration).createJobEnvironmentVariableAlias(jobId, environmentVariableId, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to override at job level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at job level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
     * @summary Create an environment variable override at the job level
     * @param {string} jobId Job ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {Value} [value] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobEnvironmentVariableApi
     */
    public createJobEnvironmentVariableOverride(jobId: string, environmentVariableId: string, value?: Value, options?: RawAxiosRequestConfig) {
        return JobEnvironmentVariableApiFp(this.configuration).createJobEnvironmentVariableOverride(jobId, environmentVariableId, value, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - To delete an environment variable from an job you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
     * @summary Delete an environment variable from a job
     * @param {string} jobId Job ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobEnvironmentVariableApi
     */
    public deleteJobEnvironmentVariable(jobId: string, environmentVariableId: string, options?: RawAxiosRequestConfig) {
        return JobEnvironmentVariableApiFp(this.configuration).deleteJobEnvironmentVariable(jobId, environmentVariableId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > CONTAINER) 
     * @summary Edit an environment variable belonging to the job
     * @param {string} jobId Job ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobEnvironmentVariableApi
     */
    public editJobEnvironmentVariable(jobId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options?: RawAxiosRequestConfig) {
        return JobEnvironmentVariableApiFp(this.configuration).editJobEnvironmentVariable(jobId, environmentVariableId, environmentVariableEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Import environment variables in a defined scope, with a defined visibility.
     * @summary Import variables
     * @param {string} jobId Job ID
     * @param {VariableImportRequest} [variableImportRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobEnvironmentVariableApi
     */
    public importJobEnvironmentVariable(jobId: string, variableImportRequest?: VariableImportRequest, options?: RawAxiosRequestConfig) {
        return JobEnvironmentVariableApiFp(this.configuration).importJobEnvironmentVariable(jobId, variableImportRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List environment variables
     * @param {string} jobId Job ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobEnvironmentVariableApi
     */
    public listJobEnvironmentVariable(jobId: string, options?: RawAxiosRequestConfig) {
        return JobEnvironmentVariableApiFp(this.configuration).listJobEnvironmentVariable(jobId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * JobMainCallsApi - axios parameter creator
 * @export
 */
export const JobMainCallsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * To delete the job you must have the admin permission
         * @summary Delete job
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJob: async (jobId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('deleteJob', 'jobId', jobId)
            const localVarPath = `/job/{jobId}`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - To edit the job you must have the admin permission. 
         * @summary Edit job
         * @param {string} jobId Job ID
         * @param {JobRequest} [jobRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editJob: async (jobId: string, jobRequest?: JobRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('editJob', 'jobId', jobId)
            const localVarPath = `/job/{jobId}`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jobRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get job by ID
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJob: async (jobId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getJob', 'jobId', jobId)
            const localVarPath = `/job/{jobId}`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get job status
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobStatus: async (jobId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getJobStatus', 'jobId', jobId)
            const localVarPath = `/job/{jobId}/status`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns list of the last 100 commits made on the repository linked to the job
         * @summary List last job commits
         * @param {string} jobId Job ID
         * @param {string} [startId] Starting point after which to return results
         * @param {string} [gitCommitId] Git Commit ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobCommit: async (jobId: string, startId?: string, gitCommitId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('listJobCommit', 'jobId', jobId)
            const localVarPath = `/job/{jobId}/commit`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (startId !== undefined) {
                localVarQueryParameter['startId'] = startId;
            }

            if (gitCommitId !== undefined) {
                localVarQueryParameter['gitCommitId'] = gitCommitId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobMainCallsApi - functional programming interface
 * @export
 */
export const JobMainCallsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JobMainCallsApiAxiosParamCreator(configuration)
    return {
        /**
         * To delete the job you must have the admin permission
         * @summary Delete job
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteJob(jobId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteJob(jobId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobMainCallsApi.deleteJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - To edit the job you must have the admin permission. 
         * @summary Edit job
         * @param {string} jobId Job ID
         * @param {JobRequest} [jobRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editJob(jobId: string, jobRequest?: JobRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editJob(jobId, jobRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobMainCallsApi.editJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get job by ID
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJob(jobId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJob(jobId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobMainCallsApi.getJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get job status
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobStatus(jobId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobStatus(jobId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobMainCallsApi.getJobStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns list of the last 100 commits made on the repository linked to the job
         * @summary List last job commits
         * @param {string} jobId Job ID
         * @param {string} [startId] Starting point after which to return results
         * @param {string} [gitCommitId] Git Commit ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listJobCommit(jobId: string, startId?: string, gitCommitId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommitResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listJobCommit(jobId, startId, gitCommitId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobMainCallsApi.listJobCommit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * JobMainCallsApi - factory interface
 * @export
 */
export const JobMainCallsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JobMainCallsApiFp(configuration)
    return {
        /**
         * To delete the job you must have the admin permission
         * @summary Delete job
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJob(jobId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteJob(jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * - To edit the job you must have the admin permission. 
         * @summary Edit job
         * @param {string} jobId Job ID
         * @param {JobRequest} [jobRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editJob(jobId: string, jobRequest?: JobRequest, options?: RawAxiosRequestConfig): AxiosPromise<JobResponse> {
            return localVarFp.editJob(jobId, jobRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get job by ID
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJob(jobId: string, options?: RawAxiosRequestConfig): AxiosPromise<JobResponse> {
            return localVarFp.getJob(jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get job status
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobStatus(jobId: string, options?: RawAxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.getJobStatus(jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns list of the last 100 commits made on the repository linked to the job
         * @summary List last job commits
         * @param {string} jobId Job ID
         * @param {string} [startId] Starting point after which to return results
         * @param {string} [gitCommitId] Git Commit ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobCommit(jobId: string, startId?: string, gitCommitId?: string, options?: RawAxiosRequestConfig): AxiosPromise<CommitResponseList> {
            return localVarFp.listJobCommit(jobId, startId, gitCommitId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JobMainCallsApi - object-oriented interface
 * @export
 * @class JobMainCallsApi
 * @extends {BaseAPI}
 */
export class JobMainCallsApi extends BaseAPI {
    /**
     * To delete the job you must have the admin permission
     * @summary Delete job
     * @param {string} jobId Job ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobMainCallsApi
     */
    public deleteJob(jobId: string, options?: RawAxiosRequestConfig) {
        return JobMainCallsApiFp(this.configuration).deleteJob(jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - To edit the job you must have the admin permission. 
     * @summary Edit job
     * @param {string} jobId Job ID
     * @param {JobRequest} [jobRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobMainCallsApi
     */
    public editJob(jobId: string, jobRequest?: JobRequest, options?: RawAxiosRequestConfig) {
        return JobMainCallsApiFp(this.configuration).editJob(jobId, jobRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get job by ID
     * @param {string} jobId Job ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobMainCallsApi
     */
    public getJob(jobId: string, options?: RawAxiosRequestConfig) {
        return JobMainCallsApiFp(this.configuration).getJob(jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get job status
     * @param {string} jobId Job ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobMainCallsApi
     */
    public getJobStatus(jobId: string, options?: RawAxiosRequestConfig) {
        return JobMainCallsApiFp(this.configuration).getJobStatus(jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns list of the last 100 commits made on the repository linked to the job
     * @summary List last job commits
     * @param {string} jobId Job ID
     * @param {string} [startId] Starting point after which to return results
     * @param {string} [gitCommitId] Git Commit ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobMainCallsApi
     */
    public listJobCommit(jobId: string, startId?: string, gitCommitId?: string, options?: RawAxiosRequestConfig) {
        return JobMainCallsApiFp(this.configuration).listJobCommit(jobId, startId, gitCommitId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * JobSecretApi - axios parameter creator
 * @export
 */
export const JobSecretApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * - Add a secret to the job. 
         * @summary Add a secret to the job
         * @param {string} jobId Job ID
         * @param {SecretRequest} [secretRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJobSecret: async (jobId: string, secretRequest?: SecretRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('createJobSecret', 'jobId', jobId)
            const localVarPath = `/job/{jobId}/secret`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(secretRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to add an alias at job level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at job level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - You can\'t create an alias on an alias 
         * @summary Create a secret alias at the job level
         * @param {string} jobId Job ID
         * @param {string} secretId Secret ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJobSecretAlias: async (jobId: string, secretId: string, key?: Key, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('createJobSecretAlias', 'jobId', jobId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('createJobSecretAlias', 'secretId', secretId)
            const localVarPath = `/job/{jobId}/secret/{secretId}/alias`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(key, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to override at job level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at job level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
         * @summary Create a secret override at the job level
         * @param {string} jobId Job ID
         * @param {string} secretId Secret ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJobSecretOverride: async (jobId: string, secretId: string, value?: Value, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('createJobSecretOverride', 'jobId', jobId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('createJobSecretOverride', 'secretId', secretId)
            const localVarPath = `/job/{jobId}/secret/{secretId}/override`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(value, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete a secret from an job
         * @param {string} jobId Job ID
         * @param {string} secretId Secret ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJobSecret: async (jobId: string, secretId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('deleteJobSecret', 'jobId', jobId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('deleteJobSecret', 'secretId', secretId)
            const localVarPath = `/job/{jobId}/secret/{secretId}`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > CONTAINER) 
         * @summary Edit a secret belonging to the job
         * @param {string} jobId Job ID
         * @param {string} secretId Secret ID
         * @param {SecretEditRequest} secretEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editJobSecret: async (jobId: string, secretId: string, secretEditRequest: SecretEditRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('editJobSecret', 'jobId', jobId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('editJobSecret', 'secretId', secretId)
            // verify required parameter 'secretEditRequest' is not null or undefined
            assertParamExists('editJobSecret', 'secretEditRequest', secretEditRequest)
            const localVarPath = `/job/{jobId}/secret/{secretId}`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(secretEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Secrets are like environment variables, but they are secured and can\'t be revealed.
         * @summary List job secrets
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobSecrets: async (jobId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('listJobSecrets', 'jobId', jobId)
            const localVarPath = `/job/{jobId}/secret`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobSecretApi - functional programming interface
 * @export
 */
export const JobSecretApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JobSecretApiAxiosParamCreator(configuration)
    return {
        /**
         * - Add a secret to the job. 
         * @summary Add a secret to the job
         * @param {string} jobId Job ID
         * @param {SecretRequest} [secretRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createJobSecret(jobId: string, secretRequest?: SecretRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createJobSecret(jobId, secretRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobSecretApi.createJobSecret']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - Allows you to add an alias at job level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at job level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - You can\'t create an alias on an alias 
         * @summary Create a secret alias at the job level
         * @param {string} jobId Job ID
         * @param {string} secretId Secret ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createJobSecretAlias(jobId: string, secretId: string, key?: Key, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createJobSecretAlias(jobId, secretId, key, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobSecretApi.createJobSecretAlias']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - Allows you to override at job level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at job level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
         * @summary Create a secret override at the job level
         * @param {string} jobId Job ID
         * @param {string} secretId Secret ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createJobSecretOverride(jobId: string, secretId: string, value?: Value, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createJobSecretOverride(jobId, secretId, value, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobSecretApi.createJobSecretOverride']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete a secret from an job
         * @param {string} jobId Job ID
         * @param {string} secretId Secret ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteJobSecret(jobId: string, secretId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteJobSecret(jobId, secretId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobSecretApi.deleteJobSecret']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > CONTAINER) 
         * @summary Edit a secret belonging to the job
         * @param {string} jobId Job ID
         * @param {string} secretId Secret ID
         * @param {SecretEditRequest} secretEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editJobSecret(jobId: string, secretId: string, secretEditRequest: SecretEditRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editJobSecret(jobId, secretId, secretEditRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobSecretApi.editJobSecret']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Secrets are like environment variables, but they are secured and can\'t be revealed.
         * @summary List job secrets
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listJobSecrets(jobId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecretResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listJobSecrets(jobId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobSecretApi.listJobSecrets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * JobSecretApi - factory interface
 * @export
 */
export const JobSecretApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JobSecretApiFp(configuration)
    return {
        /**
         * - Add a secret to the job. 
         * @summary Add a secret to the job
         * @param {string} jobId Job ID
         * @param {SecretRequest} [secretRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJobSecret(jobId: string, secretRequest?: SecretRequest, options?: RawAxiosRequestConfig): AxiosPromise<Secret> {
            return localVarFp.createJobSecret(jobId, secretRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to add an alias at job level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at job level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - You can\'t create an alias on an alias 
         * @summary Create a secret alias at the job level
         * @param {string} jobId Job ID
         * @param {string} secretId Secret ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJobSecretAlias(jobId: string, secretId: string, key?: Key, options?: RawAxiosRequestConfig): AxiosPromise<Secret> {
            return localVarFp.createJobSecretAlias(jobId, secretId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to override at job level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at job level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
         * @summary Create a secret override at the job level
         * @param {string} jobId Job ID
         * @param {string} secretId Secret ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJobSecretOverride(jobId: string, secretId: string, value?: Value, options?: RawAxiosRequestConfig): AxiosPromise<Secret> {
            return localVarFp.createJobSecretOverride(jobId, secretId, value, options).then((request) => request(axios, basePath));
        },
        /**
         * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete a secret from an job
         * @param {string} jobId Job ID
         * @param {string} secretId Secret ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJobSecret(jobId: string, secretId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteJobSecret(jobId, secretId, options).then((request) => request(axios, basePath));
        },
        /**
         * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > CONTAINER) 
         * @summary Edit a secret belonging to the job
         * @param {string} jobId Job ID
         * @param {string} secretId Secret ID
         * @param {SecretEditRequest} secretEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editJobSecret(jobId: string, secretId: string, secretEditRequest: SecretEditRequest, options?: RawAxiosRequestConfig): AxiosPromise<Secret> {
            return localVarFp.editJobSecret(jobId, secretId, secretEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Secrets are like environment variables, but they are secured and can\'t be revealed.
         * @summary List job secrets
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobSecrets(jobId: string, options?: RawAxiosRequestConfig): AxiosPromise<SecretResponseList> {
            return localVarFp.listJobSecrets(jobId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JobSecretApi - object-oriented interface
 * @export
 * @class JobSecretApi
 * @extends {BaseAPI}
 */
export class JobSecretApi extends BaseAPI {
    /**
     * - Add a secret to the job. 
     * @summary Add a secret to the job
     * @param {string} jobId Job ID
     * @param {SecretRequest} [secretRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobSecretApi
     */
    public createJobSecret(jobId: string, secretRequest?: SecretRequest, options?: RawAxiosRequestConfig) {
        return JobSecretApiFp(this.configuration).createJobSecret(jobId, secretRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to add an alias at job level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at job level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - You can\'t create an alias on an alias 
     * @summary Create a secret alias at the job level
     * @param {string} jobId Job ID
     * @param {string} secretId Secret ID
     * @param {Key} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobSecretApi
     */
    public createJobSecretAlias(jobId: string, secretId: string, key?: Key, options?: RawAxiosRequestConfig) {
        return JobSecretApiFp(this.configuration).createJobSecretAlias(jobId, secretId, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to override at job level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at job level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
     * @summary Create a secret override at the job level
     * @param {string} jobId Job ID
     * @param {string} secretId Secret ID
     * @param {Value} [value] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobSecretApi
     */
    public createJobSecretOverride(jobId: string, secretId: string, value?: Value, options?: RawAxiosRequestConfig) {
        return JobSecretApiFp(this.configuration).createJobSecretOverride(jobId, secretId, value, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well 
     * @summary Delete a secret from an job
     * @param {string} jobId Job ID
     * @param {string} secretId Secret ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobSecretApi
     */
    public deleteJobSecret(jobId: string, secretId: string, options?: RawAxiosRequestConfig) {
        return JobSecretApiFp(this.configuration).deleteJobSecret(jobId, secretId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > CONTAINER) 
     * @summary Edit a secret belonging to the job
     * @param {string} jobId Job ID
     * @param {string} secretId Secret ID
     * @param {SecretEditRequest} secretEditRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobSecretApi
     */
    public editJobSecret(jobId: string, secretId: string, secretEditRequest: SecretEditRequest, options?: RawAxiosRequestConfig) {
        return JobSecretApiFp(this.configuration).editJobSecret(jobId, secretId, secretEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Secrets are like environment variables, but they are secured and can\'t be revealed.
     * @summary List job secrets
     * @param {string} jobId Job ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobSecretApi
     */
    public listJobSecrets(jobId: string, options?: RawAxiosRequestConfig) {
        return JobSecretApiFp(this.configuration).listJobSecrets(jobId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * JobsApi - axios parameter creator
 * @export
 */
export const JobsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Triggers a new job deploy in each environment matching the following conditions - environment should have the auto-deploy enabled - the job should have the same image name and a different tag 
         * @summary Auto deploy jobs
         * @param {string} organizationId Organization ID
         * @param {OrganizationJobAutoDeployRequest} [organizationJobAutoDeployRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoDeployJobEnvironments: async (organizationId: string, organizationJobAutoDeployRequest?: OrganizationJobAutoDeployRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('autoDeployJobEnvironments', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/job/deploy`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationJobAutoDeployRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This will create a new job with the same configuration on the targeted environment Id.
         * @summary Clone job
         * @param {string} jobId Job ID
         * @param {CloneServiceRequest} [cloneServiceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneJob: async (jobId: string, cloneServiceRequest?: CloneServiceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('cloneJob', 'jobId', jobId)
            const localVarPath = `/job/{jobId}/clone`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloneServiceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a job
         * @param {string} environmentId Environment ID
         * @param {JobRequest} [jobRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJob: async (environmentId: string, jobRequest?: JobRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('createJob', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/job`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jobRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Default values for each setting is available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/advanced-settings/)
         * @summary List default job advanced settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultJobAdvancedSettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/defaultJobAdvancedSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of jobs with only their id and status.
         * @summary List all environment job statuses
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentJobStatus: async (environmentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('getEnvironmentJobStatus', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/job/status`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List jobs
         * @param {string} environmentId Environment ID
         * @param {boolean} [toUpdate] return (or not) results that must be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobs: async (environmentId: string, toUpdate?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('listJobs', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/job`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (toUpdate !== undefined) {
                localVarQueryParameter['toUpdate'] = toUpdate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobsApi - functional programming interface
 * @export
 */
export const JobsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JobsApiAxiosParamCreator(configuration)
    return {
        /**
         * Triggers a new job deploy in each environment matching the following conditions - environment should have the auto-deploy enabled - the job should have the same image name and a different tag 
         * @summary Auto deploy jobs
         * @param {string} organizationId Organization ID
         * @param {OrganizationJobAutoDeployRequest} [organizationJobAutoDeployRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autoDeployJobEnvironments(organizationId: string, organizationJobAutoDeployRequest?: OrganizationJobAutoDeployRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autoDeployJobEnvironments(organizationId, organizationJobAutoDeployRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobsApi.autoDeployJobEnvironments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This will create a new job with the same configuration on the targeted environment Id.
         * @summary Clone job
         * @param {string} jobId Job ID
         * @param {CloneServiceRequest} [cloneServiceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloneJob(jobId: string, cloneServiceRequest?: CloneServiceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cloneJob(jobId, cloneServiceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobsApi.cloneJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a job
         * @param {string} environmentId Environment ID
         * @param {JobRequest} [jobRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createJob(environmentId: string, jobRequest?: JobRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createJob(environmentId, jobRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobsApi.createJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Default values for each setting is available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/advanced-settings/)
         * @summary List default job advanced settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDefaultJobAdvancedSettings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobAdvancedSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDefaultJobAdvancedSettings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobsApi.getDefaultJobAdvancedSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of jobs with only their id and status.
         * @summary List all environment job statuses
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironmentJobStatus(environmentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReferenceObjectStatusResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironmentJobStatus(environmentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobsApi.getEnvironmentJobStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List jobs
         * @param {string} environmentId Environment ID
         * @param {boolean} [toUpdate] return (or not) results that must be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listJobs(environmentId: string, toUpdate?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listJobs(environmentId, toUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobsApi.listJobs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * JobsApi - factory interface
 * @export
 */
export const JobsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JobsApiFp(configuration)
    return {
        /**
         * Triggers a new job deploy in each environment matching the following conditions - environment should have the auto-deploy enabled - the job should have the same image name and a different tag 
         * @summary Auto deploy jobs
         * @param {string} organizationId Organization ID
         * @param {OrganizationJobAutoDeployRequest} [organizationJobAutoDeployRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoDeployJobEnvironments(organizationId: string, organizationJobAutoDeployRequest?: OrganizationJobAutoDeployRequest, options?: RawAxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.autoDeployJobEnvironments(organizationId, organizationJobAutoDeployRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This will create a new job with the same configuration on the targeted environment Id.
         * @summary Clone job
         * @param {string} jobId Job ID
         * @param {CloneServiceRequest} [cloneServiceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneJob(jobId: string, cloneServiceRequest?: CloneServiceRequest, options?: RawAxiosRequestConfig): AxiosPromise<JobResponse> {
            return localVarFp.cloneJob(jobId, cloneServiceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a job
         * @param {string} environmentId Environment ID
         * @param {JobRequest} [jobRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJob(environmentId: string, jobRequest?: JobRequest, options?: RawAxiosRequestConfig): AxiosPromise<JobResponse> {
            return localVarFp.createJob(environmentId, jobRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Default values for each setting is available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/advanced-settings/)
         * @summary List default job advanced settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultJobAdvancedSettings(options?: RawAxiosRequestConfig): AxiosPromise<JobAdvancedSettings> {
            return localVarFp.getDefaultJobAdvancedSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of jobs with only their id and status.
         * @summary List all environment job statuses
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentJobStatus(environmentId: string, options?: RawAxiosRequestConfig): AxiosPromise<ReferenceObjectStatusResponseList> {
            return localVarFp.getEnvironmentJobStatus(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List jobs
         * @param {string} environmentId Environment ID
         * @param {boolean} [toUpdate] return (or not) results that must be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobs(environmentId: string, toUpdate?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<JobResponseList> {
            return localVarFp.listJobs(environmentId, toUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JobsApi - object-oriented interface
 * @export
 * @class JobsApi
 * @extends {BaseAPI}
 */
export class JobsApi extends BaseAPI {
    /**
     * Triggers a new job deploy in each environment matching the following conditions - environment should have the auto-deploy enabled - the job should have the same image name and a different tag 
     * @summary Auto deploy jobs
     * @param {string} organizationId Organization ID
     * @param {OrganizationJobAutoDeployRequest} [organizationJobAutoDeployRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public autoDeployJobEnvironments(organizationId: string, organizationJobAutoDeployRequest?: OrganizationJobAutoDeployRequest, options?: RawAxiosRequestConfig) {
        return JobsApiFp(this.configuration).autoDeployJobEnvironments(organizationId, organizationJobAutoDeployRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will create a new job with the same configuration on the targeted environment Id.
     * @summary Clone job
     * @param {string} jobId Job ID
     * @param {CloneServiceRequest} [cloneServiceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public cloneJob(jobId: string, cloneServiceRequest?: CloneServiceRequest, options?: RawAxiosRequestConfig) {
        return JobsApiFp(this.configuration).cloneJob(jobId, cloneServiceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a job
     * @param {string} environmentId Environment ID
     * @param {JobRequest} [jobRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public createJob(environmentId: string, jobRequest?: JobRequest, options?: RawAxiosRequestConfig) {
        return JobsApiFp(this.configuration).createJob(environmentId, jobRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Default values for each setting is available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/advanced-settings/)
     * @summary List default job advanced settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public getDefaultJobAdvancedSettings(options?: RawAxiosRequestConfig) {
        return JobsApiFp(this.configuration).getDefaultJobAdvancedSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of jobs with only their id and status.
     * @summary List all environment job statuses
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public getEnvironmentJobStatus(environmentId: string, options?: RawAxiosRequestConfig) {
        return JobsApiFp(this.configuration).getEnvironmentJobStatus(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List jobs
     * @param {string} environmentId Environment ID
     * @param {boolean} [toUpdate] return (or not) results that must be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public listJobs(environmentId: string, toUpdate?: boolean, options?: RawAxiosRequestConfig) {
        return JobsApiFp(this.configuration).listJobs(environmentId, toUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LifecycleTemplateMainCallsApi - axios parameter creator
 * @export
 */
export const LifecycleTemplateMainCallsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get specific lifecycle template
         * @param {string} environmentId 
         * @param {string} lifecycleTemplateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentLifecycleTemplate: async (environmentId: string, lifecycleTemplateId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('getEnvironmentLifecycleTemplate', 'environmentId', environmentId)
            // verify required parameter 'lifecycleTemplateId' is not null or undefined
            assertParamExists('getEnvironmentLifecycleTemplate', 'lifecycleTemplateId', lifecycleTemplateId)
            const localVarPath = `/environment/{environmentId}/lifecycleTemplate/{lifecycleTemplateId}`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)))
                .replace(`{${"lifecycleTemplateId"}}`, encodeURIComponent(String(lifecycleTemplateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List available lifecycle template for this environment
         * @param {string} environmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentLifecycleTemplates: async (environmentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('listEnvironmentLifecycleTemplates', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/lifecycleTemplate`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LifecycleTemplateMainCallsApi - functional programming interface
 * @export
 */
export const LifecycleTemplateMainCallsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LifecycleTemplateMainCallsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get specific lifecycle template
         * @param {string} environmentId 
         * @param {string} lifecycleTemplateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironmentLifecycleTemplate(environmentId: string, lifecycleTemplateId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifecycleTemplateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironmentLifecycleTemplate(environmentId, lifecycleTemplateId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LifecycleTemplateMainCallsApi.getEnvironmentLifecycleTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List available lifecycle template for this environment
         * @param {string} environmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEnvironmentLifecycleTemplates(environmentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifecycleTemplateListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEnvironmentLifecycleTemplates(environmentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LifecycleTemplateMainCallsApi.listEnvironmentLifecycleTemplates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LifecycleTemplateMainCallsApi - factory interface
 * @export
 */
export const LifecycleTemplateMainCallsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LifecycleTemplateMainCallsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get specific lifecycle template
         * @param {string} environmentId 
         * @param {string} lifecycleTemplateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentLifecycleTemplate(environmentId: string, lifecycleTemplateId: string, options?: RawAxiosRequestConfig): AxiosPromise<LifecycleTemplateResponse> {
            return localVarFp.getEnvironmentLifecycleTemplate(environmentId, lifecycleTemplateId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List available lifecycle template for this environment
         * @param {string} environmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentLifecycleTemplates(environmentId: string, options?: RawAxiosRequestConfig): AxiosPromise<LifecycleTemplateListResponse> {
            return localVarFp.listEnvironmentLifecycleTemplates(environmentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LifecycleTemplateMainCallsApi - object-oriented interface
 * @export
 * @class LifecycleTemplateMainCallsApi
 * @extends {BaseAPI}
 */
export class LifecycleTemplateMainCallsApi extends BaseAPI {
    /**
     * 
     * @summary Get specific lifecycle template
     * @param {string} environmentId 
     * @param {string} lifecycleTemplateId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LifecycleTemplateMainCallsApi
     */
    public getEnvironmentLifecycleTemplate(environmentId: string, lifecycleTemplateId: string, options?: RawAxiosRequestConfig) {
        return LifecycleTemplateMainCallsApiFp(this.configuration).getEnvironmentLifecycleTemplate(environmentId, lifecycleTemplateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List available lifecycle template for this environment
     * @param {string} environmentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LifecycleTemplateMainCallsApi
     */
    public listEnvironmentLifecycleTemplates(environmentId: string, options?: RawAxiosRequestConfig) {
        return LifecycleTemplateMainCallsApiFp(this.configuration).listEnvironmentLifecycleTemplates(environmentId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MembersApi - axios parameter creator
 * @export
 */
export const MembersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove an invited member
         * @param {string} organizationId Organization ID
         * @param {string} inviteId Invite ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInviteMember: async (organizationId: string, inviteId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteInviteMember', 'organizationId', organizationId)
            // verify required parameter 'inviteId' is not null or undefined
            assertParamExists('deleteInviteMember', 'inviteId', inviteId)
            const localVarPath = `/organization/{organizationId}/inviteMember/{inviteId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"inviteId"}}`, encodeURIComponent(String(inviteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a member
         * @param {string} organizationId Organization ID
         * @param {DeleteMemberRequest} [deleteMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMember: async (organizationId: string, deleteMemberRequest?: DeleteMemberRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteMember', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/member`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteMemberRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit an organization member role
         * @summary Edit an organization member role
         * @param {string} organizationId Organization ID
         * @param {MemberRoleUpdateRequest} [memberRoleUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editOrganizationMemberRole: async (organizationId: string, memberRoleUpdateRequest?: MemberRoleUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('editOrganizationMemberRole', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/member`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(memberRoleUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get member invitation
         * @param {string} organizationId Organization ID
         * @param {string} inviteId Invite ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMemberInvitation: async (organizationId: string, inviteId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getMemberInvitation', 'organizationId', organizationId)
            // verify required parameter 'inviteId' is not null or undefined
            assertParamExists('getMemberInvitation', 'inviteId', inviteId)
            const localVarPath = `/organization/{organizationId}/inviteMember/{inviteId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"inviteId"}}`, encodeURIComponent(String(inviteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get invited members
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationInvitedMembers: async (organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationInvitedMembers', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/inviteMember`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get organization members
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationMembers: async (organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationMembers', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/member`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Accept Invite in the organization
         * @param {string} organizationId Organization ID
         * @param {string} inviteId Invite ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAcceptInviteMember: async (organizationId: string, inviteId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('postAcceptInviteMember', 'organizationId', organizationId)
            // verify required parameter 'inviteId' is not null or undefined
            assertParamExists('postAcceptInviteMember', 'inviteId', inviteId)
            const localVarPath = `/organization/{organizationId}/inviteMember/{inviteId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"inviteId"}}`, encodeURIComponent(String(inviteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invite someone in the organization
         * @param {string} organizationId Organization ID
         * @param {InviteMemberRequest} [inviteMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postInviteMember: async (organizationId: string, inviteMemberRequest?: InviteMemberRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('postInviteMember', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/inviteMember`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inviteMemberRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Transfer organization ownership to another user
         * @param {string} organizationId Organization ID
         * @param {TransferOwnershipRequest} [transferOwnershipRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrganizationTransferOwnership: async (organizationId: string, transferOwnershipRequest?: TransferOwnershipRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('postOrganizationTransferOwnership', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/transferOwnership`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transferOwnershipRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MembersApi - functional programming interface
 * @export
 */
export const MembersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MembersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove an invited member
         * @param {string} organizationId Organization ID
         * @param {string} inviteId Invite ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteInviteMember(organizationId: string, inviteId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteInviteMember(organizationId, inviteId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MembersApi.deleteInviteMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove a member
         * @param {string} organizationId Organization ID
         * @param {DeleteMemberRequest} [deleteMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMember(organizationId: string, deleteMemberRequest?: DeleteMemberRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMember(organizationId, deleteMemberRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MembersApi.deleteMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Edit an organization member role
         * @summary Edit an organization member role
         * @param {string} organizationId Organization ID
         * @param {MemberRoleUpdateRequest} [memberRoleUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editOrganizationMemberRole(organizationId: string, memberRoleUpdateRequest?: MemberRoleUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editOrganizationMemberRole(organizationId, memberRoleUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MembersApi.editOrganizationMemberRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get member invitation
         * @param {string} organizationId Organization ID
         * @param {string} inviteId Invite ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMemberInvitation(organizationId: string, inviteId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InviteMember>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMemberInvitation(organizationId, inviteId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MembersApi.getMemberInvitation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get invited members
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationInvitedMembers(organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InviteMemberResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationInvitedMembers(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MembersApi.getOrganizationInvitedMembers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get organization members
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationMembers(organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemberResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationMembers(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MembersApi.getOrganizationMembers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Accept Invite in the organization
         * @param {string} organizationId Organization ID
         * @param {string} inviteId Invite ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAcceptInviteMember(organizationId: string, inviteId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InviteMember>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postAcceptInviteMember(organizationId, inviteId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MembersApi.postAcceptInviteMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invite someone in the organization
         * @param {string} organizationId Organization ID
         * @param {InviteMemberRequest} [inviteMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postInviteMember(organizationId: string, inviteMemberRequest?: InviteMemberRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InviteMember>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postInviteMember(organizationId, inviteMemberRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MembersApi.postInviteMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Transfer organization ownership to another user
         * @param {string} organizationId Organization ID
         * @param {TransferOwnershipRequest} [transferOwnershipRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postOrganizationTransferOwnership(organizationId: string, transferOwnershipRequest?: TransferOwnershipRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postOrganizationTransferOwnership(organizationId, transferOwnershipRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MembersApi.postOrganizationTransferOwnership']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MembersApi - factory interface
 * @export
 */
export const MembersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MembersApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove an invited member
         * @param {string} organizationId Organization ID
         * @param {string} inviteId Invite ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInviteMember(organizationId: string, inviteId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteInviteMember(organizationId, inviteId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a member
         * @param {string} organizationId Organization ID
         * @param {DeleteMemberRequest} [deleteMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMember(organizationId: string, deleteMemberRequest?: DeleteMemberRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteMember(organizationId, deleteMemberRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit an organization member role
         * @summary Edit an organization member role
         * @param {string} organizationId Organization ID
         * @param {MemberRoleUpdateRequest} [memberRoleUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editOrganizationMemberRole(organizationId: string, memberRoleUpdateRequest?: MemberRoleUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.editOrganizationMemberRole(organizationId, memberRoleUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get member invitation
         * @param {string} organizationId Organization ID
         * @param {string} inviteId Invite ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMemberInvitation(organizationId: string, inviteId: string, options?: RawAxiosRequestConfig): AxiosPromise<InviteMember> {
            return localVarFp.getMemberInvitation(organizationId, inviteId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get invited members
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationInvitedMembers(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise<InviteMemberResponseList> {
            return localVarFp.getOrganizationInvitedMembers(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get organization members
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationMembers(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise<MemberResponseList> {
            return localVarFp.getOrganizationMembers(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Accept Invite in the organization
         * @param {string} organizationId Organization ID
         * @param {string} inviteId Invite ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAcceptInviteMember(organizationId: string, inviteId: string, options?: RawAxiosRequestConfig): AxiosPromise<InviteMember> {
            return localVarFp.postAcceptInviteMember(organizationId, inviteId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invite someone in the organization
         * @param {string} organizationId Organization ID
         * @param {InviteMemberRequest} [inviteMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postInviteMember(organizationId: string, inviteMemberRequest?: InviteMemberRequest, options?: RawAxiosRequestConfig): AxiosPromise<InviteMember> {
            return localVarFp.postInviteMember(organizationId, inviteMemberRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Transfer organization ownership to another user
         * @param {string} organizationId Organization ID
         * @param {TransferOwnershipRequest} [transferOwnershipRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrganizationTransferOwnership(organizationId: string, transferOwnershipRequest?: TransferOwnershipRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postOrganizationTransferOwnership(organizationId, transferOwnershipRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MembersApi - object-oriented interface
 * @export
 * @class MembersApi
 * @extends {BaseAPI}
 */
export class MembersApi extends BaseAPI {
    /**
     * 
     * @summary Remove an invited member
     * @param {string} organizationId Organization ID
     * @param {string} inviteId Invite ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public deleteInviteMember(organizationId: string, inviteId: string, options?: RawAxiosRequestConfig) {
        return MembersApiFp(this.configuration).deleteInviteMember(organizationId, inviteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a member
     * @param {string} organizationId Organization ID
     * @param {DeleteMemberRequest} [deleteMemberRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public deleteMember(organizationId: string, deleteMemberRequest?: DeleteMemberRequest, options?: RawAxiosRequestConfig) {
        return MembersApiFp(this.configuration).deleteMember(organizationId, deleteMemberRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit an organization member role
     * @summary Edit an organization member role
     * @param {string} organizationId Organization ID
     * @param {MemberRoleUpdateRequest} [memberRoleUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public editOrganizationMemberRole(organizationId: string, memberRoleUpdateRequest?: MemberRoleUpdateRequest, options?: RawAxiosRequestConfig) {
        return MembersApiFp(this.configuration).editOrganizationMemberRole(organizationId, memberRoleUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get member invitation
     * @param {string} organizationId Organization ID
     * @param {string} inviteId Invite ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public getMemberInvitation(organizationId: string, inviteId: string, options?: RawAxiosRequestConfig) {
        return MembersApiFp(this.configuration).getMemberInvitation(organizationId, inviteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get invited members
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public getOrganizationInvitedMembers(organizationId: string, options?: RawAxiosRequestConfig) {
        return MembersApiFp(this.configuration).getOrganizationInvitedMembers(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get organization members
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public getOrganizationMembers(organizationId: string, options?: RawAxiosRequestConfig) {
        return MembersApiFp(this.configuration).getOrganizationMembers(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Accept Invite in the organization
     * @param {string} organizationId Organization ID
     * @param {string} inviteId Invite ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public postAcceptInviteMember(organizationId: string, inviteId: string, options?: RawAxiosRequestConfig) {
        return MembersApiFp(this.configuration).postAcceptInviteMember(organizationId, inviteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invite someone in the organization
     * @param {string} organizationId Organization ID
     * @param {InviteMemberRequest} [inviteMemberRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public postInviteMember(organizationId: string, inviteMemberRequest?: InviteMemberRequest, options?: RawAxiosRequestConfig) {
        return MembersApiFp(this.configuration).postInviteMember(organizationId, inviteMemberRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Transfer organization ownership to another user
     * @param {string} organizationId Organization ID
     * @param {TransferOwnershipRequest} [transferOwnershipRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public postOrganizationTransferOwnership(organizationId: string, transferOwnershipRequest?: TransferOwnershipRequest, options?: RawAxiosRequestConfig) {
        return MembersApiFp(this.configuration).postOrganizationTransferOwnership(organizationId, transferOwnershipRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrganizationAccountGitRepositoriesApi - axios parameter creator
 * @export
 */
export const OrganizationAccountGitRepositoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get bitbucket repositories of the connected user
         * @param {string} organizationId Organization ID
         * @param {string} [gitTokenId] The git token id that must be used for the application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationBitbucketRepositories: async (organizationId: string, gitTokenId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationBitbucketRepositories', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/account/bitbucket/repository`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (gitTokenId !== undefined) {
                localVarQueryParameter['gitTokenId'] = gitTokenId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get bitbucket branches of the specified repository
         * @param {string} organizationId Organization ID
         * @param {string} [name] The name of the repository where to retrieve the branches
         * @param {string} [gitTokenId] The git token id that must be used for the application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationBitbucketRepositoryBranches: async (organizationId: string, name?: string, gitTokenId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationBitbucketRepositoryBranches', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/account/bitbucket/repository/branch`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (gitTokenId !== undefined) {
                localVarQueryParameter['gitTokenId'] = gitTokenId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get git provider accounts
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationGitProviderAccount: async (organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationGitProviderAccount', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/account/gitAuthProvider`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get github repositories of the connected user
         * @param {string} organizationId Organization ID
         * @param {string} [gitTokenId] The git token id that must be used for the application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationGithubRepositories: async (organizationId: string, gitTokenId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationGithubRepositories', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/account/github/repository`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (gitTokenId !== undefined) {
                localVarQueryParameter['gitTokenId'] = gitTokenId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get github branches of the specified repository
         * @param {string} organizationId Organization ID
         * @param {string} [name] The name of the repository where to retrieve the branches
         * @param {string} [gitTokenId] The git token id that must be used for the application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationGithubRepositoryBranches: async (organizationId: string, name?: string, gitTokenId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationGithubRepositoryBranches', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/account/github/repository/branch`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (gitTokenId !== undefined) {
                localVarQueryParameter['gitTokenId'] = gitTokenId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get gitlab repositories of the connected user
         * @param {string} organizationId Organization ID
         * @param {string} [gitTokenId] The git token id that must be used for the application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationGitlabRepositories: async (organizationId: string, gitTokenId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationGitlabRepositories', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/account/gitlab/repository`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (gitTokenId !== undefined) {
                localVarQueryParameter['gitTokenId'] = gitTokenId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get gitlab branches of the specified repository
         * @param {string} organizationId Organization ID
         * @param {string} [name] The name of the repository to retrieve the branches
         * @param {string} [gitTokenId] The git token id that must be used for the application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationGitlabRepositoryBranches: async (organizationId: string, name?: string, gitTokenId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationGitlabRepositoryBranches', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/account/gitlab/repository/branch`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (gitTokenId !== undefined) {
                localVarQueryParameter['gitTokenId'] = gitTokenId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationAccountGitRepositoriesApi - functional programming interface
 * @export
 */
export const OrganizationAccountGitRepositoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationAccountGitRepositoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get bitbucket repositories of the connected user
         * @param {string} organizationId Organization ID
         * @param {string} [gitTokenId] The git token id that must be used for the application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationBitbucketRepositories(organizationId: string, gitTokenId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitRepositoryResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationBitbucketRepositories(organizationId, gitTokenId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationAccountGitRepositoriesApi.getOrganizationBitbucketRepositories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get bitbucket branches of the specified repository
         * @param {string} organizationId Organization ID
         * @param {string} [name] The name of the repository where to retrieve the branches
         * @param {string} [gitTokenId] The git token id that must be used for the application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationBitbucketRepositoryBranches(organizationId: string, name?: string, gitTokenId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitRepositoryBranchResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationBitbucketRepositoryBranches(organizationId, name, gitTokenId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationAccountGitRepositoriesApi.getOrganizationBitbucketRepositoryBranches']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get git provider accounts
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationGitProviderAccount(organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitAuthProviderResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationGitProviderAccount(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationAccountGitRepositoriesApi.getOrganizationGitProviderAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get github repositories of the connected user
         * @param {string} organizationId Organization ID
         * @param {string} [gitTokenId] The git token id that must be used for the application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationGithubRepositories(organizationId: string, gitTokenId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitRepositoryResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationGithubRepositories(organizationId, gitTokenId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationAccountGitRepositoriesApi.getOrganizationGithubRepositories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get github branches of the specified repository
         * @param {string} organizationId Organization ID
         * @param {string} [name] The name of the repository where to retrieve the branches
         * @param {string} [gitTokenId] The git token id that must be used for the application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationGithubRepositoryBranches(organizationId: string, name?: string, gitTokenId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitRepositoryBranchResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationGithubRepositoryBranches(organizationId, name, gitTokenId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationAccountGitRepositoriesApi.getOrganizationGithubRepositoryBranches']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get gitlab repositories of the connected user
         * @param {string} organizationId Organization ID
         * @param {string} [gitTokenId] The git token id that must be used for the application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationGitlabRepositories(organizationId: string, gitTokenId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitRepositoryResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationGitlabRepositories(organizationId, gitTokenId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationAccountGitRepositoriesApi.getOrganizationGitlabRepositories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get gitlab branches of the specified repository
         * @param {string} organizationId Organization ID
         * @param {string} [name] The name of the repository to retrieve the branches
         * @param {string} [gitTokenId] The git token id that must be used for the application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationGitlabRepositoryBranches(organizationId: string, name?: string, gitTokenId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitRepositoryBranchResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationGitlabRepositoryBranches(organizationId, name, gitTokenId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationAccountGitRepositoriesApi.getOrganizationGitlabRepositoryBranches']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrganizationAccountGitRepositoriesApi - factory interface
 * @export
 */
export const OrganizationAccountGitRepositoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationAccountGitRepositoriesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get bitbucket repositories of the connected user
         * @param {string} organizationId Organization ID
         * @param {string} [gitTokenId] The git token id that must be used for the application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationBitbucketRepositories(organizationId: string, gitTokenId?: string, options?: RawAxiosRequestConfig): AxiosPromise<GitRepositoryResponseList> {
            return localVarFp.getOrganizationBitbucketRepositories(organizationId, gitTokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get bitbucket branches of the specified repository
         * @param {string} organizationId Organization ID
         * @param {string} [name] The name of the repository where to retrieve the branches
         * @param {string} [gitTokenId] The git token id that must be used for the application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationBitbucketRepositoryBranches(organizationId: string, name?: string, gitTokenId?: string, options?: RawAxiosRequestConfig): AxiosPromise<GitRepositoryBranchResponseList> {
            return localVarFp.getOrganizationBitbucketRepositoryBranches(organizationId, name, gitTokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get git provider accounts
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationGitProviderAccount(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise<GitAuthProviderResponseList> {
            return localVarFp.getOrganizationGitProviderAccount(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get github repositories of the connected user
         * @param {string} organizationId Organization ID
         * @param {string} [gitTokenId] The git token id that must be used for the application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationGithubRepositories(organizationId: string, gitTokenId?: string, options?: RawAxiosRequestConfig): AxiosPromise<GitRepositoryResponseList> {
            return localVarFp.getOrganizationGithubRepositories(organizationId, gitTokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get github branches of the specified repository
         * @param {string} organizationId Organization ID
         * @param {string} [name] The name of the repository where to retrieve the branches
         * @param {string} [gitTokenId] The git token id that must be used for the application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationGithubRepositoryBranches(organizationId: string, name?: string, gitTokenId?: string, options?: RawAxiosRequestConfig): AxiosPromise<GitRepositoryBranchResponseList> {
            return localVarFp.getOrganizationGithubRepositoryBranches(organizationId, name, gitTokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get gitlab repositories of the connected user
         * @param {string} organizationId Organization ID
         * @param {string} [gitTokenId] The git token id that must be used for the application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationGitlabRepositories(organizationId: string, gitTokenId?: string, options?: RawAxiosRequestConfig): AxiosPromise<GitRepositoryResponseList> {
            return localVarFp.getOrganizationGitlabRepositories(organizationId, gitTokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get gitlab branches of the specified repository
         * @param {string} organizationId Organization ID
         * @param {string} [name] The name of the repository to retrieve the branches
         * @param {string} [gitTokenId] The git token id that must be used for the application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationGitlabRepositoryBranches(organizationId: string, name?: string, gitTokenId?: string, options?: RawAxiosRequestConfig): AxiosPromise<GitRepositoryBranchResponseList> {
            return localVarFp.getOrganizationGitlabRepositoryBranches(organizationId, name, gitTokenId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationAccountGitRepositoriesApi - object-oriented interface
 * @export
 * @class OrganizationAccountGitRepositoriesApi
 * @extends {BaseAPI}
 */
export class OrganizationAccountGitRepositoriesApi extends BaseAPI {
    /**
     * 
     * @summary Get bitbucket repositories of the connected user
     * @param {string} organizationId Organization ID
     * @param {string} [gitTokenId] The git token id that must be used for the application
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationAccountGitRepositoriesApi
     */
    public getOrganizationBitbucketRepositories(organizationId: string, gitTokenId?: string, options?: RawAxiosRequestConfig) {
        return OrganizationAccountGitRepositoriesApiFp(this.configuration).getOrganizationBitbucketRepositories(organizationId, gitTokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get bitbucket branches of the specified repository
     * @param {string} organizationId Organization ID
     * @param {string} [name] The name of the repository where to retrieve the branches
     * @param {string} [gitTokenId] The git token id that must be used for the application
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationAccountGitRepositoriesApi
     */
    public getOrganizationBitbucketRepositoryBranches(organizationId: string, name?: string, gitTokenId?: string, options?: RawAxiosRequestConfig) {
        return OrganizationAccountGitRepositoriesApiFp(this.configuration).getOrganizationBitbucketRepositoryBranches(organizationId, name, gitTokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get git provider accounts
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationAccountGitRepositoriesApi
     */
    public getOrganizationGitProviderAccount(organizationId: string, options?: RawAxiosRequestConfig) {
        return OrganizationAccountGitRepositoriesApiFp(this.configuration).getOrganizationGitProviderAccount(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get github repositories of the connected user
     * @param {string} organizationId Organization ID
     * @param {string} [gitTokenId] The git token id that must be used for the application
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationAccountGitRepositoriesApi
     */
    public getOrganizationGithubRepositories(organizationId: string, gitTokenId?: string, options?: RawAxiosRequestConfig) {
        return OrganizationAccountGitRepositoriesApiFp(this.configuration).getOrganizationGithubRepositories(organizationId, gitTokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get github branches of the specified repository
     * @param {string} organizationId Organization ID
     * @param {string} [name] The name of the repository where to retrieve the branches
     * @param {string} [gitTokenId] The git token id that must be used for the application
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationAccountGitRepositoriesApi
     */
    public getOrganizationGithubRepositoryBranches(organizationId: string, name?: string, gitTokenId?: string, options?: RawAxiosRequestConfig) {
        return OrganizationAccountGitRepositoriesApiFp(this.configuration).getOrganizationGithubRepositoryBranches(organizationId, name, gitTokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get gitlab repositories of the connected user
     * @param {string} organizationId Organization ID
     * @param {string} [gitTokenId] The git token id that must be used for the application
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationAccountGitRepositoriesApi
     */
    public getOrganizationGitlabRepositories(organizationId: string, gitTokenId?: string, options?: RawAxiosRequestConfig) {
        return OrganizationAccountGitRepositoriesApiFp(this.configuration).getOrganizationGitlabRepositories(organizationId, gitTokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get gitlab branches of the specified repository
     * @param {string} organizationId Organization ID
     * @param {string} [name] The name of the repository to retrieve the branches
     * @param {string} [gitTokenId] The git token id that must be used for the application
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationAccountGitRepositoriesApi
     */
    public getOrganizationGitlabRepositoryBranches(organizationId: string, name?: string, gitTokenId?: string, options?: RawAxiosRequestConfig) {
        return OrganizationAccountGitRepositoriesApiFp(this.configuration).getOrganizationGitlabRepositoryBranches(organizationId, name, gitTokenId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrganizationAnnotationsGroupApi - axios parameter creator
 * @export
 */
export const OrganizationAnnotationsGroupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an organization annotations group
         * @summary Create an organization annotations group
         * @param {string} organizationId Organization ID
         * @param {OrganizationAnnotationsGroupCreateRequest} [organizationAnnotationsGroupCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationAnnotationsGroup: async (organizationId: string, organizationAnnotationsGroupCreateRequest?: OrganizationAnnotationsGroupCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createOrganizationAnnotationsGroup', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/annotationsGroups`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationAnnotationsGroupCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete organization annotations group
         * @summary Delete organization annotations group
         * @param {string} organizationId Organization ID
         * @param {string} annotationsGroupId Organization annotations group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationAnnotationsGroup: async (organizationId: string, annotationsGroupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteOrganizationAnnotationsGroup', 'organizationId', organizationId)
            // verify required parameter 'annotationsGroupId' is not null or undefined
            assertParamExists('deleteOrganizationAnnotationsGroup', 'annotationsGroupId', annotationsGroupId)
            const localVarPath = `/organization/{organizationId}/annotationsGroups/{annotationsGroupId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"annotationsGroupId"}}`, encodeURIComponent(String(annotationsGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit organization annotations group
         * @summary Edit organization annotations group
         * @param {string} organizationId Organization ID
         * @param {string} annotationsGroupId Organization annotations group ID
         * @param {OrganizationAnnotationsGroupCreateRequest} [organizationAnnotationsGroupCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editOrganizationAnnotationsGroup: async (organizationId: string, annotationsGroupId: string, organizationAnnotationsGroupCreateRequest?: OrganizationAnnotationsGroupCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('editOrganizationAnnotationsGroup', 'organizationId', organizationId)
            // verify required parameter 'annotationsGroupId' is not null or undefined
            assertParamExists('editOrganizationAnnotationsGroup', 'annotationsGroupId', annotationsGroupId)
            const localVarPath = `/organization/{organizationId}/annotationsGroups/{annotationsGroupId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"annotationsGroupId"}}`, encodeURIComponent(String(annotationsGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationAnnotationsGroupCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get organization annotations group
         * @summary Get organization annotations group
         * @param {string} organizationId Organization ID
         * @param {string} annotationsGroupId Organization annotations group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationAnnotationsGroup: async (organizationId: string, annotationsGroupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationAnnotationsGroup', 'organizationId', organizationId)
            // verify required parameter 'annotationsGroupId' is not null or undefined
            assertParamExists('getOrganizationAnnotationsGroup', 'annotationsGroupId', annotationsGroupId)
            const localVarPath = `/organization/{organizationId}/annotationsGroups/{annotationsGroupId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"annotationsGroupId"}}`, encodeURIComponent(String(annotationsGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get organization annotations group associated items
         * @summary Get organization annotations group associated items
         * @param {string} organizationId Organization ID
         * @param {string} annotationsGroupId Organization annotations group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationAnnotationsGroupAssociatedItems: async (organizationId: string, annotationsGroupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationAnnotationsGroupAssociatedItems', 'organizationId', organizationId)
            // verify required parameter 'annotationsGroupId' is not null or undefined
            assertParamExists('getOrganizationAnnotationsGroupAssociatedItems', 'annotationsGroupId', annotationsGroupId)
            const localVarPath = `/organization/{organizationId}/annotationsGroups/{annotationsGroupId}/associatedItems`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"annotationsGroupId"}}`, encodeURIComponent(String(annotationsGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List organization annotations group
         * @summary List organization annotations group
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationAnnotationsGroup: async (organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listOrganizationAnnotationsGroup', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/annotationsGroups`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationAnnotationsGroupApi - functional programming interface
 * @export
 */
export const OrganizationAnnotationsGroupApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationAnnotationsGroupApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an organization annotations group
         * @summary Create an organization annotations group
         * @param {string} organizationId Organization ID
         * @param {OrganizationAnnotationsGroupCreateRequest} [organizationAnnotationsGroupCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrganizationAnnotationsGroup(organizationId: string, organizationAnnotationsGroupCreateRequest?: OrganizationAnnotationsGroupCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationAnnotationsGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrganizationAnnotationsGroup(organizationId, organizationAnnotationsGroupCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationAnnotationsGroupApi.createOrganizationAnnotationsGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete organization annotations group
         * @summary Delete organization annotations group
         * @param {string} organizationId Organization ID
         * @param {string} annotationsGroupId Organization annotations group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrganizationAnnotationsGroup(organizationId: string, annotationsGroupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrganizationAnnotationsGroup(organizationId, annotationsGroupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationAnnotationsGroupApi.deleteOrganizationAnnotationsGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Edit organization annotations group
         * @summary Edit organization annotations group
         * @param {string} organizationId Organization ID
         * @param {string} annotationsGroupId Organization annotations group ID
         * @param {OrganizationAnnotationsGroupCreateRequest} [organizationAnnotationsGroupCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editOrganizationAnnotationsGroup(organizationId: string, annotationsGroupId: string, organizationAnnotationsGroupCreateRequest?: OrganizationAnnotationsGroupCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationAnnotationsGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editOrganizationAnnotationsGroup(organizationId, annotationsGroupId, organizationAnnotationsGroupCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationAnnotationsGroupApi.editOrganizationAnnotationsGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get organization annotations group
         * @summary Get organization annotations group
         * @param {string} organizationId Organization ID
         * @param {string} annotationsGroupId Organization annotations group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationAnnotationsGroup(organizationId: string, annotationsGroupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationAnnotationsGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationAnnotationsGroup(organizationId, annotationsGroupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationAnnotationsGroupApi.getOrganizationAnnotationsGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get organization annotations group associated items
         * @summary Get organization annotations group associated items
         * @param {string} organizationId Organization ID
         * @param {string} annotationsGroupId Organization annotations group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationAnnotationsGroupAssociatedItems(organizationId: string, annotationsGroupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationAnnotationsGroupAssociatedItemsResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationAnnotationsGroupAssociatedItems(organizationId, annotationsGroupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationAnnotationsGroupApi.getOrganizationAnnotationsGroupAssociatedItems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List organization annotations group
         * @summary List organization annotations group
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizationAnnotationsGroup(organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOrganizationAnnotationsGroup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationAnnotationsGroup(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationAnnotationsGroupApi.listOrganizationAnnotationsGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrganizationAnnotationsGroupApi - factory interface
 * @export
 */
export const OrganizationAnnotationsGroupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationAnnotationsGroupApiFp(configuration)
    return {
        /**
         * Create an organization annotations group
         * @summary Create an organization annotations group
         * @param {string} organizationId Organization ID
         * @param {OrganizationAnnotationsGroupCreateRequest} [organizationAnnotationsGroupCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationAnnotationsGroup(organizationId: string, organizationAnnotationsGroupCreateRequest?: OrganizationAnnotationsGroupCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<OrganizationAnnotationsGroupResponse> {
            return localVarFp.createOrganizationAnnotationsGroup(organizationId, organizationAnnotationsGroupCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete organization annotations group
         * @summary Delete organization annotations group
         * @param {string} organizationId Organization ID
         * @param {string} annotationsGroupId Organization annotations group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationAnnotationsGroup(organizationId: string, annotationsGroupId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteOrganizationAnnotationsGroup(organizationId, annotationsGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit organization annotations group
         * @summary Edit organization annotations group
         * @param {string} organizationId Organization ID
         * @param {string} annotationsGroupId Organization annotations group ID
         * @param {OrganizationAnnotationsGroupCreateRequest} [organizationAnnotationsGroupCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editOrganizationAnnotationsGroup(organizationId: string, annotationsGroupId: string, organizationAnnotationsGroupCreateRequest?: OrganizationAnnotationsGroupCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<OrganizationAnnotationsGroupResponse> {
            return localVarFp.editOrganizationAnnotationsGroup(organizationId, annotationsGroupId, organizationAnnotationsGroupCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get organization annotations group
         * @summary Get organization annotations group
         * @param {string} organizationId Organization ID
         * @param {string} annotationsGroupId Organization annotations group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationAnnotationsGroup(organizationId: string, annotationsGroupId: string, options?: RawAxiosRequestConfig): AxiosPromise<OrganizationAnnotationsGroupResponse> {
            return localVarFp.getOrganizationAnnotationsGroup(organizationId, annotationsGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get organization annotations group associated items
         * @summary Get organization annotations group associated items
         * @param {string} organizationId Organization ID
         * @param {string} annotationsGroupId Organization annotations group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationAnnotationsGroupAssociatedItems(organizationId: string, annotationsGroupId: string, options?: RawAxiosRequestConfig): AxiosPromise<OrganizationAnnotationsGroupAssociatedItemsResponseList> {
            return localVarFp.getOrganizationAnnotationsGroupAssociatedItems(organizationId, annotationsGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * List organization annotations group
         * @summary List organization annotations group
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationAnnotationsGroup(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise<ListOrganizationAnnotationsGroup200Response> {
            return localVarFp.listOrganizationAnnotationsGroup(organizationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationAnnotationsGroupApi - object-oriented interface
 * @export
 * @class OrganizationAnnotationsGroupApi
 * @extends {BaseAPI}
 */
export class OrganizationAnnotationsGroupApi extends BaseAPI {
    /**
     * Create an organization annotations group
     * @summary Create an organization annotations group
     * @param {string} organizationId Organization ID
     * @param {OrganizationAnnotationsGroupCreateRequest} [organizationAnnotationsGroupCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationAnnotationsGroupApi
     */
    public createOrganizationAnnotationsGroup(organizationId: string, organizationAnnotationsGroupCreateRequest?: OrganizationAnnotationsGroupCreateRequest, options?: RawAxiosRequestConfig) {
        return OrganizationAnnotationsGroupApiFp(this.configuration).createOrganizationAnnotationsGroup(organizationId, organizationAnnotationsGroupCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete organization annotations group
     * @summary Delete organization annotations group
     * @param {string} organizationId Organization ID
     * @param {string} annotationsGroupId Organization annotations group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationAnnotationsGroupApi
     */
    public deleteOrganizationAnnotationsGroup(organizationId: string, annotationsGroupId: string, options?: RawAxiosRequestConfig) {
        return OrganizationAnnotationsGroupApiFp(this.configuration).deleteOrganizationAnnotationsGroup(organizationId, annotationsGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit organization annotations group
     * @summary Edit organization annotations group
     * @param {string} organizationId Organization ID
     * @param {string} annotationsGroupId Organization annotations group ID
     * @param {OrganizationAnnotationsGroupCreateRequest} [organizationAnnotationsGroupCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationAnnotationsGroupApi
     */
    public editOrganizationAnnotationsGroup(organizationId: string, annotationsGroupId: string, organizationAnnotationsGroupCreateRequest?: OrganizationAnnotationsGroupCreateRequest, options?: RawAxiosRequestConfig) {
        return OrganizationAnnotationsGroupApiFp(this.configuration).editOrganizationAnnotationsGroup(organizationId, annotationsGroupId, organizationAnnotationsGroupCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get organization annotations group
     * @summary Get organization annotations group
     * @param {string} organizationId Organization ID
     * @param {string} annotationsGroupId Organization annotations group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationAnnotationsGroupApi
     */
    public getOrganizationAnnotationsGroup(organizationId: string, annotationsGroupId: string, options?: RawAxiosRequestConfig) {
        return OrganizationAnnotationsGroupApiFp(this.configuration).getOrganizationAnnotationsGroup(organizationId, annotationsGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get organization annotations group associated items
     * @summary Get organization annotations group associated items
     * @param {string} organizationId Organization ID
     * @param {string} annotationsGroupId Organization annotations group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationAnnotationsGroupApi
     */
    public getOrganizationAnnotationsGroupAssociatedItems(organizationId: string, annotationsGroupId: string, options?: RawAxiosRequestConfig) {
        return OrganizationAnnotationsGroupApiFp(this.configuration).getOrganizationAnnotationsGroupAssociatedItems(organizationId, annotationsGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List organization annotations group
     * @summary List organization annotations group
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationAnnotationsGroupApi
     */
    public listOrganizationAnnotationsGroup(organizationId: string, options?: RawAxiosRequestConfig) {
        return OrganizationAnnotationsGroupApiFp(this.configuration).listOrganizationAnnotationsGroup(organizationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrganizationApiTokenApi - axios parameter creator
 * @export
 */
export const OrganizationApiTokenApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an organization api token. You can use the generated token to interact in a programmatic way with our API.
         * @summary Create an organization api token
         * @param {string} organizationId Organization ID
         * @param {OrganizationApiTokenCreateRequest} [organizationApiTokenCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationApiToken: async (organizationId: string, organizationApiTokenCreateRequest?: OrganizationApiTokenCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createOrganizationApiToken', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/apiToken`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationApiTokenCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete organization api token
         * @summary Delete organization api token
         * @param {string} organizationId Organization ID
         * @param {string} apiTokenId Organization Api Token ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationApiToken: async (organizationId: string, apiTokenId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteOrganizationApiToken', 'organizationId', organizationId)
            // verify required parameter 'apiTokenId' is not null or undefined
            assertParamExists('deleteOrganizationApiToken', 'apiTokenId', apiTokenId)
            const localVarPath = `/organization/{organizationId}/apiToken/{apiTokenId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"apiTokenId"}}`, encodeURIComponent(String(apiTokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List organization api tokens
         * @summary List organization api tokens
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationApiTokens: async (organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listOrganizationApiTokens', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/apiToken`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationApiTokenApi - functional programming interface
 * @export
 */
export const OrganizationApiTokenApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationApiTokenApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an organization api token. You can use the generated token to interact in a programmatic way with our API.
         * @summary Create an organization api token
         * @param {string} organizationId Organization ID
         * @param {OrganizationApiTokenCreateRequest} [organizationApiTokenCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrganizationApiToken(organizationId: string, organizationApiTokenCreateRequest?: OrganizationApiTokenCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationApiTokenCreate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrganizationApiToken(organizationId, organizationApiTokenCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApiTokenApi.createOrganizationApiToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete organization api token
         * @summary Delete organization api token
         * @param {string} organizationId Organization ID
         * @param {string} apiTokenId Organization Api Token ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrganizationApiToken(organizationId: string, apiTokenId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrganizationApiToken(organizationId, apiTokenId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApiTokenApi.deleteOrganizationApiToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List organization api tokens
         * @summary List organization api tokens
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizationApiTokens(organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationApiTokenResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationApiTokens(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApiTokenApi.listOrganizationApiTokens']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrganizationApiTokenApi - factory interface
 * @export
 */
export const OrganizationApiTokenApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationApiTokenApiFp(configuration)
    return {
        /**
         * Create an organization api token. You can use the generated token to interact in a programmatic way with our API.
         * @summary Create an organization api token
         * @param {string} organizationId Organization ID
         * @param {OrganizationApiTokenCreateRequest} [organizationApiTokenCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationApiToken(organizationId: string, organizationApiTokenCreateRequest?: OrganizationApiTokenCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<OrganizationApiTokenCreate> {
            return localVarFp.createOrganizationApiToken(organizationId, organizationApiTokenCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete organization api token
         * @summary Delete organization api token
         * @param {string} organizationId Organization ID
         * @param {string} apiTokenId Organization Api Token ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationApiToken(organizationId: string, apiTokenId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteOrganizationApiToken(organizationId, apiTokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * List organization api tokens
         * @summary List organization api tokens
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationApiTokens(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise<OrganizationApiTokenResponseList> {
            return localVarFp.listOrganizationApiTokens(organizationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationApiTokenApi - object-oriented interface
 * @export
 * @class OrganizationApiTokenApi
 * @extends {BaseAPI}
 */
export class OrganizationApiTokenApi extends BaseAPI {
    /**
     * Create an organization api token. You can use the generated token to interact in a programmatic way with our API.
     * @summary Create an organization api token
     * @param {string} organizationId Organization ID
     * @param {OrganizationApiTokenCreateRequest} [organizationApiTokenCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiTokenApi
     */
    public createOrganizationApiToken(organizationId: string, organizationApiTokenCreateRequest?: OrganizationApiTokenCreateRequest, options?: RawAxiosRequestConfig) {
        return OrganizationApiTokenApiFp(this.configuration).createOrganizationApiToken(organizationId, organizationApiTokenCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete organization api token
     * @summary Delete organization api token
     * @param {string} organizationId Organization ID
     * @param {string} apiTokenId Organization Api Token ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiTokenApi
     */
    public deleteOrganizationApiToken(organizationId: string, apiTokenId: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiTokenApiFp(this.configuration).deleteOrganizationApiToken(organizationId, apiTokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List organization api tokens
     * @summary List organization api tokens
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiTokenApi
     */
    public listOrganizationApiTokens(organizationId: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiTokenApiFp(this.configuration).listOrganizationApiTokens(organizationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrganizationClusterLockApi - axios parameter creator
 * @export
 */
export const OrganizationClusterLockApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List locked Cluster by organization
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listClusterLock: async (organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listClusterLock', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/lock`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationClusterLockApi - functional programming interface
 * @export
 */
export const OrganizationClusterLockApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationClusterLockApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List locked Cluster by organization
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listClusterLock(organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterLockList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listClusterLock(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationClusterLockApi.listClusterLock']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrganizationClusterLockApi - factory interface
 * @export
 */
export const OrganizationClusterLockApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationClusterLockApiFp(configuration)
    return {
        /**
         * 
         * @summary List locked Cluster by organization
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listClusterLock(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise<ClusterLockList> {
            return localVarFp.listClusterLock(organizationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationClusterLockApi - object-oriented interface
 * @export
 * @class OrganizationClusterLockApi
 * @extends {BaseAPI}
 */
export class OrganizationClusterLockApi extends BaseAPI {
    /**
     * 
     * @summary List locked Cluster by organization
     * @param {string} organizationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationClusterLockApi
     */
    public listClusterLock(organizationId: string, options?: RawAxiosRequestConfig) {
        return OrganizationClusterLockApiFp(this.configuration).listClusterLock(organizationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrganizationCustomRoleApi - axios parameter creator
 * @export
 */
export const OrganizationCustomRoleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an organization custom role
         * @summary Create an organization custom role
         * @param {string} organizationId Organization ID
         * @param {OrganizationCustomRoleCreateRequest} [organizationCustomRoleCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationCustomRole: async (organizationId: string, organizationCustomRoleCreateRequest?: OrganizationCustomRoleCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createOrganizationCustomRole', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/customRole`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationCustomRoleCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete organization custom role
         * @summary Delete organization custom role
         * @param {string} organizationId Organization ID
         * @param {string} customRoleId Custom Role ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationCustomRole: async (organizationId: string, customRoleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteOrganizationCustomRole', 'organizationId', organizationId)
            // verify required parameter 'customRoleId' is not null or undefined
            assertParamExists('deleteOrganizationCustomRole', 'customRoleId', customRoleId)
            const localVarPath = `/organization/{organizationId}/customRole/{customRoleId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"customRoleId"}}`, encodeURIComponent(String(customRoleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit an organization custom role
         * @summary Edit an organization custom role
         * @param {string} organizationId Organization ID
         * @param {string} customRoleId Custom Role ID
         * @param {OrganizationCustomRoleUpdateRequest} [organizationCustomRoleUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editOrganizationCustomRole: async (organizationId: string, customRoleId: string, organizationCustomRoleUpdateRequest?: OrganizationCustomRoleUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('editOrganizationCustomRole', 'organizationId', organizationId)
            // verify required parameter 'customRoleId' is not null or undefined
            assertParamExists('editOrganizationCustomRole', 'customRoleId', customRoleId)
            const localVarPath = `/organization/{organizationId}/customRole/{customRoleId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"customRoleId"}}`, encodeURIComponent(String(customRoleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationCustomRoleUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an organization custom role 
         * @summary Get an organization custom role 
         * @param {string} organizationId Organization ID
         * @param {string} customRoleId Custom Role ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationCustomRole: async (organizationId: string, customRoleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationCustomRole', 'organizationId', organizationId)
            // verify required parameter 'customRoleId' is not null or undefined
            assertParamExists('getOrganizationCustomRole', 'customRoleId', customRoleId)
            const localVarPath = `/organization/{organizationId}/customRole/{customRoleId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"customRoleId"}}`, encodeURIComponent(String(customRoleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List organization custom roles
         * @summary List organization custom roles
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationCustomRoles: async (organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listOrganizationCustomRoles', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/customRole`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationCustomRoleApi - functional programming interface
 * @export
 */
export const OrganizationCustomRoleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationCustomRoleApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an organization custom role
         * @summary Create an organization custom role
         * @param {string} organizationId Organization ID
         * @param {OrganizationCustomRoleCreateRequest} [organizationCustomRoleCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrganizationCustomRole(organizationId: string, organizationCustomRoleCreateRequest?: OrganizationCustomRoleCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationCustomRole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrganizationCustomRole(organizationId, organizationCustomRoleCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationCustomRoleApi.createOrganizationCustomRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete organization custom role
         * @summary Delete organization custom role
         * @param {string} organizationId Organization ID
         * @param {string} customRoleId Custom Role ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrganizationCustomRole(organizationId: string, customRoleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrganizationCustomRole(organizationId, customRoleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationCustomRoleApi.deleteOrganizationCustomRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Edit an organization custom role
         * @summary Edit an organization custom role
         * @param {string} organizationId Organization ID
         * @param {string} customRoleId Custom Role ID
         * @param {OrganizationCustomRoleUpdateRequest} [organizationCustomRoleUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editOrganizationCustomRole(organizationId: string, customRoleId: string, organizationCustomRoleUpdateRequest?: OrganizationCustomRoleUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationCustomRole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editOrganizationCustomRole(organizationId, customRoleId, organizationCustomRoleUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationCustomRoleApi.editOrganizationCustomRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an organization custom role 
         * @summary Get an organization custom role 
         * @param {string} organizationId Organization ID
         * @param {string} customRoleId Custom Role ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationCustomRole(organizationId: string, customRoleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationCustomRole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationCustomRole(organizationId, customRoleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationCustomRoleApi.getOrganizationCustomRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List organization custom roles
         * @summary List organization custom roles
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizationCustomRoles(organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationCustomRoleList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationCustomRoles(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationCustomRoleApi.listOrganizationCustomRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrganizationCustomRoleApi - factory interface
 * @export
 */
export const OrganizationCustomRoleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationCustomRoleApiFp(configuration)
    return {
        /**
         * Create an organization custom role
         * @summary Create an organization custom role
         * @param {string} organizationId Organization ID
         * @param {OrganizationCustomRoleCreateRequest} [organizationCustomRoleCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationCustomRole(organizationId: string, organizationCustomRoleCreateRequest?: OrganizationCustomRoleCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<OrganizationCustomRole> {
            return localVarFp.createOrganizationCustomRole(organizationId, organizationCustomRoleCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete organization custom role
         * @summary Delete organization custom role
         * @param {string} organizationId Organization ID
         * @param {string} customRoleId Custom Role ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationCustomRole(organizationId: string, customRoleId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteOrganizationCustomRole(organizationId, customRoleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit an organization custom role
         * @summary Edit an organization custom role
         * @param {string} organizationId Organization ID
         * @param {string} customRoleId Custom Role ID
         * @param {OrganizationCustomRoleUpdateRequest} [organizationCustomRoleUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editOrganizationCustomRole(organizationId: string, customRoleId: string, organizationCustomRoleUpdateRequest?: OrganizationCustomRoleUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<OrganizationCustomRole> {
            return localVarFp.editOrganizationCustomRole(organizationId, customRoleId, organizationCustomRoleUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an organization custom role 
         * @summary Get an organization custom role 
         * @param {string} organizationId Organization ID
         * @param {string} customRoleId Custom Role ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationCustomRole(organizationId: string, customRoleId: string, options?: RawAxiosRequestConfig): AxiosPromise<OrganizationCustomRole> {
            return localVarFp.getOrganizationCustomRole(organizationId, customRoleId, options).then((request) => request(axios, basePath));
        },
        /**
         * List organization custom roles
         * @summary List organization custom roles
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationCustomRoles(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise<OrganizationCustomRoleList> {
            return localVarFp.listOrganizationCustomRoles(organizationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationCustomRoleApi - object-oriented interface
 * @export
 * @class OrganizationCustomRoleApi
 * @extends {BaseAPI}
 */
export class OrganizationCustomRoleApi extends BaseAPI {
    /**
     * Create an organization custom role
     * @summary Create an organization custom role
     * @param {string} organizationId Organization ID
     * @param {OrganizationCustomRoleCreateRequest} [organizationCustomRoleCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationCustomRoleApi
     */
    public createOrganizationCustomRole(organizationId: string, organizationCustomRoleCreateRequest?: OrganizationCustomRoleCreateRequest, options?: RawAxiosRequestConfig) {
        return OrganizationCustomRoleApiFp(this.configuration).createOrganizationCustomRole(organizationId, organizationCustomRoleCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete organization custom role
     * @summary Delete organization custom role
     * @param {string} organizationId Organization ID
     * @param {string} customRoleId Custom Role ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationCustomRoleApi
     */
    public deleteOrganizationCustomRole(organizationId: string, customRoleId: string, options?: RawAxiosRequestConfig) {
        return OrganizationCustomRoleApiFp(this.configuration).deleteOrganizationCustomRole(organizationId, customRoleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit an organization custom role
     * @summary Edit an organization custom role
     * @param {string} organizationId Organization ID
     * @param {string} customRoleId Custom Role ID
     * @param {OrganizationCustomRoleUpdateRequest} [organizationCustomRoleUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationCustomRoleApi
     */
    public editOrganizationCustomRole(organizationId: string, customRoleId: string, organizationCustomRoleUpdateRequest?: OrganizationCustomRoleUpdateRequest, options?: RawAxiosRequestConfig) {
        return OrganizationCustomRoleApiFp(this.configuration).editOrganizationCustomRole(organizationId, customRoleId, organizationCustomRoleUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an organization custom role 
     * @summary Get an organization custom role 
     * @param {string} organizationId Organization ID
     * @param {string} customRoleId Custom Role ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationCustomRoleApi
     */
    public getOrganizationCustomRole(organizationId: string, customRoleId: string, options?: RawAxiosRequestConfig) {
        return OrganizationCustomRoleApiFp(this.configuration).getOrganizationCustomRole(organizationId, customRoleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List organization custom roles
     * @summary List organization custom roles
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationCustomRoleApi
     */
    public listOrganizationCustomRoles(organizationId: string, options?: RawAxiosRequestConfig) {
        return OrganizationCustomRoleApiFp(this.configuration).listOrganizationCustomRoles(organizationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrganizationEnterpriseConnectionApi - axios parameter creator
 * @export
 */
export const OrganizationEnterpriseConnectionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get enterprise connection
         * @param {string} organizationId Organization ID
         * @param {string} connectionName The name of the Organization\&#39;s Enterprise Connection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationEnterpriseConnection: async (organizationId: string, connectionName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationEnterpriseConnection', 'organizationId', organizationId)
            // verify required parameter 'connectionName' is not null or undefined
            assertParamExists('getOrganizationEnterpriseConnection', 'connectionName', connectionName)
            const localVarPath = `/organization/{organizationId}/enterpriseconnection/{connectionName}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"connectionName"}}`, encodeURIComponent(String(connectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List enterprise connections
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationEnterpriseConnections: async (organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listOrganizationEnterpriseConnections', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/enterpriseconnection`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update enterprise connection
         * @param {string} organizationId Organization ID
         * @param {string} connectionName The name of the Organization\&#39;s Enterprise Connection
         * @param {EnterpriseConnectionDto} [enterpriseConnectionDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationEnterpriseConnection: async (organizationId: string, connectionName: string, enterpriseConnectionDto?: EnterpriseConnectionDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateOrganizationEnterpriseConnection', 'organizationId', organizationId)
            // verify required parameter 'connectionName' is not null or undefined
            assertParamExists('updateOrganizationEnterpriseConnection', 'connectionName', connectionName)
            const localVarPath = `/organization/{organizationId}/enterpriseconnection/{connectionName}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"connectionName"}}`, encodeURIComponent(String(connectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(enterpriseConnectionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationEnterpriseConnectionApi - functional programming interface
 * @export
 */
export const OrganizationEnterpriseConnectionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationEnterpriseConnectionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get enterprise connection
         * @param {string} organizationId Organization ID
         * @param {string} connectionName The name of the Organization\&#39;s Enterprise Connection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationEnterpriseConnection(organizationId: string, connectionName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnterpriseConnectionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationEnterpriseConnection(organizationId, connectionName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationEnterpriseConnectionApi.getOrganizationEnterpriseConnection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List enterprise connections
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizationEnterpriseConnections(organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnterpriseConnectionResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationEnterpriseConnections(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationEnterpriseConnectionApi.listOrganizationEnterpriseConnections']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update enterprise connection
         * @param {string} organizationId Organization ID
         * @param {string} connectionName The name of the Organization\&#39;s Enterprise Connection
         * @param {EnterpriseConnectionDto} [enterpriseConnectionDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrganizationEnterpriseConnection(organizationId: string, connectionName: string, enterpriseConnectionDto?: EnterpriseConnectionDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnterpriseConnectionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrganizationEnterpriseConnection(organizationId, connectionName, enterpriseConnectionDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationEnterpriseConnectionApi.updateOrganizationEnterpriseConnection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrganizationEnterpriseConnectionApi - factory interface
 * @export
 */
export const OrganizationEnterpriseConnectionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationEnterpriseConnectionApiFp(configuration)
    return {
        /**
         * 
         * @summary Get enterprise connection
         * @param {string} organizationId Organization ID
         * @param {string} connectionName The name of the Organization\&#39;s Enterprise Connection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationEnterpriseConnection(organizationId: string, connectionName: string, options?: RawAxiosRequestConfig): AxiosPromise<EnterpriseConnectionDto> {
            return localVarFp.getOrganizationEnterpriseConnection(organizationId, connectionName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List enterprise connections
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationEnterpriseConnections(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise<EnterpriseConnectionResponseList> {
            return localVarFp.listOrganizationEnterpriseConnections(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update enterprise connection
         * @param {string} organizationId Organization ID
         * @param {string} connectionName The name of the Organization\&#39;s Enterprise Connection
         * @param {EnterpriseConnectionDto} [enterpriseConnectionDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationEnterpriseConnection(organizationId: string, connectionName: string, enterpriseConnectionDto?: EnterpriseConnectionDto, options?: RawAxiosRequestConfig): AxiosPromise<EnterpriseConnectionDto> {
            return localVarFp.updateOrganizationEnterpriseConnection(organizationId, connectionName, enterpriseConnectionDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationEnterpriseConnectionApi - object-oriented interface
 * @export
 * @class OrganizationEnterpriseConnectionApi
 * @extends {BaseAPI}
 */
export class OrganizationEnterpriseConnectionApi extends BaseAPI {
    /**
     * 
     * @summary Get enterprise connection
     * @param {string} organizationId Organization ID
     * @param {string} connectionName The name of the Organization\&#39;s Enterprise Connection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationEnterpriseConnectionApi
     */
    public getOrganizationEnterpriseConnection(organizationId: string, connectionName: string, options?: RawAxiosRequestConfig) {
        return OrganizationEnterpriseConnectionApiFp(this.configuration).getOrganizationEnterpriseConnection(organizationId, connectionName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List enterprise connections
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationEnterpriseConnectionApi
     */
    public listOrganizationEnterpriseConnections(organizationId: string, options?: RawAxiosRequestConfig) {
        return OrganizationEnterpriseConnectionApiFp(this.configuration).listOrganizationEnterpriseConnections(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update enterprise connection
     * @param {string} organizationId Organization ID
     * @param {string} connectionName The name of the Organization\&#39;s Enterprise Connection
     * @param {EnterpriseConnectionDto} [enterpriseConnectionDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationEnterpriseConnectionApi
     */
    public updateOrganizationEnterpriseConnection(organizationId: string, connectionName: string, enterpriseConnectionDto?: EnterpriseConnectionDto, options?: RawAxiosRequestConfig) {
        return OrganizationEnterpriseConnectionApiFp(this.configuration).updateOrganizationEnterpriseConnection(organizationId, connectionName, enterpriseConnectionDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrganizationEventApi - axios parameter creator
 * @export
 */
export const OrganizationEventApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get available event targets to filter events
         * @summary Get available event targets to filter events
         * @param {string} organizationId Organization ID
         * @param {string | null} [fromTimestamp] Display targets available since this timestamp.   A range of date can be specified by using &#x60;from-timestamp&#x60; with &#x60;to-timestamp&#x60; The format is a timestamp with nano precision 
         * @param {string | null} [toTimestamp] Display targets triggered before this timestamp.   A range of date can be specified by using &#x60;to-timestamp&#x60; with &#x60;from-timestamp&#x60; The format is a timestamp with nano precision 
         * @param {OrganizationEventType} [eventType] 
         * @param {OrganizationEventTargetType} [targetType] 
         * @param {string} [triggeredBy] Information about the owner of the event (user name / apitoken / automatic action)
         * @param {OrganizationEventOrigin} [origin] 
         * @param {string} [projectId] Mandatory when requesting an environment or a service
         * @param {string} [environmentId] Mandatory when requesting a service
         * @param {OrganizationEventTargetLevel} [targetLevelToFetch] Used only to retrieve projects or environments linked to service typed events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationEventTargets: async (organizationId: string, fromTimestamp?: string | null, toTimestamp?: string | null, eventType?: OrganizationEventType, targetType?: OrganizationEventTargetType, triggeredBy?: string, origin?: OrganizationEventOrigin, projectId?: string, environmentId?: string, targetLevelToFetch?: OrganizationEventTargetLevel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationEventTargets', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/targets`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fromTimestamp !== undefined) {
                localVarQueryParameter['fromTimestamp'] = fromTimestamp;
            }

            if (toTimestamp !== undefined) {
                localVarQueryParameter['toTimestamp'] = toTimestamp;
            }

            if (eventType !== undefined) {
                localVarQueryParameter['eventType'] = eventType;
            }

            if (targetType !== undefined) {
                localVarQueryParameter['targetType'] = targetType;
            }

            if (triggeredBy !== undefined) {
                localVarQueryParameter['triggeredBy'] = triggeredBy;
            }

            if (origin !== undefined) {
                localVarQueryParameter['origin'] = origin;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }

            if (environmentId !== undefined) {
                localVarQueryParameter['environmentId'] = environmentId;
            }

            if (targetLevelToFetch !== undefined) {
                localVarQueryParameter['targetLevelToFetch'] = targetLevelToFetch;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all events inside the organization
         * @summary Get all events inside the organization
         * @param {string} organizationId Organization ID
         * @param {number | null} [pageSize] The number of events to display in the current page
         * @param {string | null} [fromTimestamp] Display events triggered since this timestamp.   A range of date can be specified by using &#x60;from-timestamp&#x60; with &#x60;to-timestamp&#x60; The format is a timestamp with nano precision 
         * @param {string | null} [toTimestamp] Display events triggered before this timestamp.   A range of date can be specified by using &#x60;to-timestamp&#x60; with &#x60;from-timestamp&#x60; The format is a timestamp with nano precision 
         * @param {string} [continueToken] Token used to fetch the next page results The format is a timestamp with nano precision 
         * @param {string} [stepBackToken] Token used to fetch the previous page results The format is a timestamp with nano precision 
         * @param {OrganizationEventType} [eventType] 
         * @param {OrganizationEventTargetType} [targetType] 
         * @param {string | null} [targetId] The target resource id to search.   Must be specified with the corresponding &#x60;target_type&#x60; 
         * @param {OrganizationEventSubTargetType} [subTargetType] 
         * @param {string} [triggeredBy] Information about the owner of the event (user name / apitoken / automatic action)
         * @param {OrganizationEventOrigin} [origin] 
         * @param {string} [serviceProjectId] The project chosen when filtering on a service type
         * @param {string} [serviceEnvironmentId] The environment chosen when filtering on a service type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationEvents: async (organizationId: string, pageSize?: number | null, fromTimestamp?: string | null, toTimestamp?: string | null, continueToken?: string, stepBackToken?: string, eventType?: OrganizationEventType, targetType?: OrganizationEventTargetType, targetId?: string | null, subTargetType?: OrganizationEventSubTargetType, triggeredBy?: string, origin?: OrganizationEventOrigin, serviceProjectId?: string, serviceEnvironmentId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationEvents', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/events`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (fromTimestamp !== undefined) {
                localVarQueryParameter['fromTimestamp'] = fromTimestamp;
            }

            if (toTimestamp !== undefined) {
                localVarQueryParameter['toTimestamp'] = toTimestamp;
            }

            if (continueToken !== undefined) {
                localVarQueryParameter['continueToken'] = continueToken;
            }

            if (stepBackToken !== undefined) {
                localVarQueryParameter['stepBackToken'] = stepBackToken;
            }

            if (eventType !== undefined) {
                localVarQueryParameter['eventType'] = eventType;
            }

            if (targetType !== undefined) {
                localVarQueryParameter['targetType'] = targetType;
            }

            if (targetId !== undefined) {
                localVarQueryParameter['targetId'] = targetId;
            }

            if (subTargetType !== undefined) {
                localVarQueryParameter['subTargetType'] = subTargetType;
            }

            if (triggeredBy !== undefined) {
                localVarQueryParameter['triggeredBy'] = triggeredBy;
            }

            if (origin !== undefined) {
                localVarQueryParameter['origin'] = origin;
            }

            if (serviceProjectId !== undefined) {
                localVarQueryParameter['serviceProjectId'] = serviceProjectId;
            }

            if (serviceEnvironmentId !== undefined) {
                localVarQueryParameter['serviceEnvironmentId'] = serviceEnvironmentId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationEventApi - functional programming interface
 * @export
 */
export const OrganizationEventApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationEventApiAxiosParamCreator(configuration)
    return {
        /**
         * Get available event targets to filter events
         * @summary Get available event targets to filter events
         * @param {string} organizationId Organization ID
         * @param {string | null} [fromTimestamp] Display targets available since this timestamp.   A range of date can be specified by using &#x60;from-timestamp&#x60; with &#x60;to-timestamp&#x60; The format is a timestamp with nano precision 
         * @param {string | null} [toTimestamp] Display targets triggered before this timestamp.   A range of date can be specified by using &#x60;to-timestamp&#x60; with &#x60;from-timestamp&#x60; The format is a timestamp with nano precision 
         * @param {OrganizationEventType} [eventType] 
         * @param {OrganizationEventTargetType} [targetType] 
         * @param {string} [triggeredBy] Information about the owner of the event (user name / apitoken / automatic action)
         * @param {OrganizationEventOrigin} [origin] 
         * @param {string} [projectId] Mandatory when requesting an environment or a service
         * @param {string} [environmentId] Mandatory when requesting a service
         * @param {OrganizationEventTargetLevel} [targetLevelToFetch] Used only to retrieve projects or environments linked to service typed events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationEventTargets(organizationId: string, fromTimestamp?: string | null, toTimestamp?: string | null, eventType?: OrganizationEventType, targetType?: OrganizationEventTargetType, triggeredBy?: string, origin?: OrganizationEventOrigin, projectId?: string, environmentId?: string, targetLevelToFetch?: OrganizationEventTargetLevel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationEventTargetResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationEventTargets(organizationId, fromTimestamp, toTimestamp, eventType, targetType, triggeredBy, origin, projectId, environmentId, targetLevelToFetch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationEventApi.getOrganizationEventTargets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all events inside the organization
         * @summary Get all events inside the organization
         * @param {string} organizationId Organization ID
         * @param {number | null} [pageSize] The number of events to display in the current page
         * @param {string | null} [fromTimestamp] Display events triggered since this timestamp.   A range of date can be specified by using &#x60;from-timestamp&#x60; with &#x60;to-timestamp&#x60; The format is a timestamp with nano precision 
         * @param {string | null} [toTimestamp] Display events triggered before this timestamp.   A range of date can be specified by using &#x60;to-timestamp&#x60; with &#x60;from-timestamp&#x60; The format is a timestamp with nano precision 
         * @param {string} [continueToken] Token used to fetch the next page results The format is a timestamp with nano precision 
         * @param {string} [stepBackToken] Token used to fetch the previous page results The format is a timestamp with nano precision 
         * @param {OrganizationEventType} [eventType] 
         * @param {OrganizationEventTargetType} [targetType] 
         * @param {string | null} [targetId] The target resource id to search.   Must be specified with the corresponding &#x60;target_type&#x60; 
         * @param {OrganizationEventSubTargetType} [subTargetType] 
         * @param {string} [triggeredBy] Information about the owner of the event (user name / apitoken / automatic action)
         * @param {OrganizationEventOrigin} [origin] 
         * @param {string} [serviceProjectId] The project chosen when filtering on a service type
         * @param {string} [serviceEnvironmentId] The environment chosen when filtering on a service type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationEvents(organizationId: string, pageSize?: number | null, fromTimestamp?: string | null, toTimestamp?: string | null, continueToken?: string, stepBackToken?: string, eventType?: OrganizationEventType, targetType?: OrganizationEventTargetType, targetId?: string | null, subTargetType?: OrganizationEventSubTargetType, triggeredBy?: string, origin?: OrganizationEventOrigin, serviceProjectId?: string, serviceEnvironmentId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationEventResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationEvents(organizationId, pageSize, fromTimestamp, toTimestamp, continueToken, stepBackToken, eventType, targetType, targetId, subTargetType, triggeredBy, origin, serviceProjectId, serviceEnvironmentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationEventApi.getOrganizationEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrganizationEventApi - factory interface
 * @export
 */
export const OrganizationEventApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationEventApiFp(configuration)
    return {
        /**
         * Get available event targets to filter events
         * @summary Get available event targets to filter events
         * @param {string} organizationId Organization ID
         * @param {string | null} [fromTimestamp] Display targets available since this timestamp.   A range of date can be specified by using &#x60;from-timestamp&#x60; with &#x60;to-timestamp&#x60; The format is a timestamp with nano precision 
         * @param {string | null} [toTimestamp] Display targets triggered before this timestamp.   A range of date can be specified by using &#x60;to-timestamp&#x60; with &#x60;from-timestamp&#x60; The format is a timestamp with nano precision 
         * @param {OrganizationEventType} [eventType] 
         * @param {OrganizationEventTargetType} [targetType] 
         * @param {string} [triggeredBy] Information about the owner of the event (user name / apitoken / automatic action)
         * @param {OrganizationEventOrigin} [origin] 
         * @param {string} [projectId] Mandatory when requesting an environment or a service
         * @param {string} [environmentId] Mandatory when requesting a service
         * @param {OrganizationEventTargetLevel} [targetLevelToFetch] Used only to retrieve projects or environments linked to service typed events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationEventTargets(organizationId: string, fromTimestamp?: string | null, toTimestamp?: string | null, eventType?: OrganizationEventType, targetType?: OrganizationEventTargetType, triggeredBy?: string, origin?: OrganizationEventOrigin, projectId?: string, environmentId?: string, targetLevelToFetch?: OrganizationEventTargetLevel, options?: RawAxiosRequestConfig): AxiosPromise<OrganizationEventTargetResponseList> {
            return localVarFp.getOrganizationEventTargets(organizationId, fromTimestamp, toTimestamp, eventType, targetType, triggeredBy, origin, projectId, environmentId, targetLevelToFetch, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all events inside the organization
         * @summary Get all events inside the organization
         * @param {string} organizationId Organization ID
         * @param {number | null} [pageSize] The number of events to display in the current page
         * @param {string | null} [fromTimestamp] Display events triggered since this timestamp.   A range of date can be specified by using &#x60;from-timestamp&#x60; with &#x60;to-timestamp&#x60; The format is a timestamp with nano precision 
         * @param {string | null} [toTimestamp] Display events triggered before this timestamp.   A range of date can be specified by using &#x60;to-timestamp&#x60; with &#x60;from-timestamp&#x60; The format is a timestamp with nano precision 
         * @param {string} [continueToken] Token used to fetch the next page results The format is a timestamp with nano precision 
         * @param {string} [stepBackToken] Token used to fetch the previous page results The format is a timestamp with nano precision 
         * @param {OrganizationEventType} [eventType] 
         * @param {OrganizationEventTargetType} [targetType] 
         * @param {string | null} [targetId] The target resource id to search.   Must be specified with the corresponding &#x60;target_type&#x60; 
         * @param {OrganizationEventSubTargetType} [subTargetType] 
         * @param {string} [triggeredBy] Information about the owner of the event (user name / apitoken / automatic action)
         * @param {OrganizationEventOrigin} [origin] 
         * @param {string} [serviceProjectId] The project chosen when filtering on a service type
         * @param {string} [serviceEnvironmentId] The environment chosen when filtering on a service type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationEvents(organizationId: string, pageSize?: number | null, fromTimestamp?: string | null, toTimestamp?: string | null, continueToken?: string, stepBackToken?: string, eventType?: OrganizationEventType, targetType?: OrganizationEventTargetType, targetId?: string | null, subTargetType?: OrganizationEventSubTargetType, triggeredBy?: string, origin?: OrganizationEventOrigin, serviceProjectId?: string, serviceEnvironmentId?: string, options?: RawAxiosRequestConfig): AxiosPromise<OrganizationEventResponseList> {
            return localVarFp.getOrganizationEvents(organizationId, pageSize, fromTimestamp, toTimestamp, continueToken, stepBackToken, eventType, targetType, targetId, subTargetType, triggeredBy, origin, serviceProjectId, serviceEnvironmentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationEventApi - object-oriented interface
 * @export
 * @class OrganizationEventApi
 * @extends {BaseAPI}
 */
export class OrganizationEventApi extends BaseAPI {
    /**
     * Get available event targets to filter events
     * @summary Get available event targets to filter events
     * @param {string} organizationId Organization ID
     * @param {string | null} [fromTimestamp] Display targets available since this timestamp.   A range of date can be specified by using &#x60;from-timestamp&#x60; with &#x60;to-timestamp&#x60; The format is a timestamp with nano precision 
     * @param {string | null} [toTimestamp] Display targets triggered before this timestamp.   A range of date can be specified by using &#x60;to-timestamp&#x60; with &#x60;from-timestamp&#x60; The format is a timestamp with nano precision 
     * @param {OrganizationEventType} [eventType] 
     * @param {OrganizationEventTargetType} [targetType] 
     * @param {string} [triggeredBy] Information about the owner of the event (user name / apitoken / automatic action)
     * @param {OrganizationEventOrigin} [origin] 
     * @param {string} [projectId] Mandatory when requesting an environment or a service
     * @param {string} [environmentId] Mandatory when requesting a service
     * @param {OrganizationEventTargetLevel} [targetLevelToFetch] Used only to retrieve projects or environments linked to service typed events
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationEventApi
     */
    public getOrganizationEventTargets(organizationId: string, fromTimestamp?: string | null, toTimestamp?: string | null, eventType?: OrganizationEventType, targetType?: OrganizationEventTargetType, triggeredBy?: string, origin?: OrganizationEventOrigin, projectId?: string, environmentId?: string, targetLevelToFetch?: OrganizationEventTargetLevel, options?: RawAxiosRequestConfig) {
        return OrganizationEventApiFp(this.configuration).getOrganizationEventTargets(organizationId, fromTimestamp, toTimestamp, eventType, targetType, triggeredBy, origin, projectId, environmentId, targetLevelToFetch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all events inside the organization
     * @summary Get all events inside the organization
     * @param {string} organizationId Organization ID
     * @param {number | null} [pageSize] The number of events to display in the current page
     * @param {string | null} [fromTimestamp] Display events triggered since this timestamp.   A range of date can be specified by using &#x60;from-timestamp&#x60; with &#x60;to-timestamp&#x60; The format is a timestamp with nano precision 
     * @param {string | null} [toTimestamp] Display events triggered before this timestamp.   A range of date can be specified by using &#x60;to-timestamp&#x60; with &#x60;from-timestamp&#x60; The format is a timestamp with nano precision 
     * @param {string} [continueToken] Token used to fetch the next page results The format is a timestamp with nano precision 
     * @param {string} [stepBackToken] Token used to fetch the previous page results The format is a timestamp with nano precision 
     * @param {OrganizationEventType} [eventType] 
     * @param {OrganizationEventTargetType} [targetType] 
     * @param {string | null} [targetId] The target resource id to search.   Must be specified with the corresponding &#x60;target_type&#x60; 
     * @param {OrganizationEventSubTargetType} [subTargetType] 
     * @param {string} [triggeredBy] Information about the owner of the event (user name / apitoken / automatic action)
     * @param {OrganizationEventOrigin} [origin] 
     * @param {string} [serviceProjectId] The project chosen when filtering on a service type
     * @param {string} [serviceEnvironmentId] The environment chosen when filtering on a service type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationEventApi
     */
    public getOrganizationEvents(organizationId: string, pageSize?: number | null, fromTimestamp?: string | null, toTimestamp?: string | null, continueToken?: string, stepBackToken?: string, eventType?: OrganizationEventType, targetType?: OrganizationEventTargetType, targetId?: string | null, subTargetType?: OrganizationEventSubTargetType, triggeredBy?: string, origin?: OrganizationEventOrigin, serviceProjectId?: string, serviceEnvironmentId?: string, options?: RawAxiosRequestConfig) {
        return OrganizationEventApiFp(this.configuration).getOrganizationEvents(organizationId, pageSize, fromTimestamp, toTimestamp, continueToken, stepBackToken, eventType, targetType, targetId, subTargetType, triggeredBy, origin, serviceProjectId, serviceEnvironmentId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrganizationLabelsGroupApi - axios parameter creator
 * @export
 */
export const OrganizationLabelsGroupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an organization labels group
         * @summary Create an organization labels group
         * @param {string} organizationId Organization ID
         * @param {OrganizationLabelsGroupCreateRequest} [organizationLabelsGroupCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationLabelsGroup: async (organizationId: string, organizationLabelsGroupCreateRequest?: OrganizationLabelsGroupCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createOrganizationLabelsGroup', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/labelsGroups`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationLabelsGroupCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete organization labels group
         * @summary Delete organization labels group
         * @param {string} organizationId Organization ID
         * @param {string} labelsGroupId Organization labels group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationLabelsGroup: async (organizationId: string, labelsGroupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteOrganizationLabelsGroup', 'organizationId', organizationId)
            // verify required parameter 'labelsGroupId' is not null or undefined
            assertParamExists('deleteOrganizationLabelsGroup', 'labelsGroupId', labelsGroupId)
            const localVarPath = `/organization/{organizationId}/labelsGroups/{labelsGroupId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"labelsGroupId"}}`, encodeURIComponent(String(labelsGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit organization labels group
         * @summary Edit organization labels group
         * @param {string} organizationId Organization ID
         * @param {string} labelsGroupId Organization labels group ID
         * @param {OrganizationLabelsGroupCreateRequest} [organizationLabelsGroupCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editOrganizationLabelsGroup: async (organizationId: string, labelsGroupId: string, organizationLabelsGroupCreateRequest?: OrganizationLabelsGroupCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('editOrganizationLabelsGroup', 'organizationId', organizationId)
            // verify required parameter 'labelsGroupId' is not null or undefined
            assertParamExists('editOrganizationLabelsGroup', 'labelsGroupId', labelsGroupId)
            const localVarPath = `/organization/{organizationId}/labelsGroups/{labelsGroupId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"labelsGroupId"}}`, encodeURIComponent(String(labelsGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationLabelsGroupCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get organization labels group associated items
         * @summary Get organization labels group associated items
         * @param {string} organizationId Organization ID
         * @param {string} labelsGroupId Organization labels group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationLabelsGroupAssociatedItems: async (organizationId: string, labelsGroupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationLabelsGroupAssociatedItems', 'organizationId', organizationId)
            // verify required parameter 'labelsGroupId' is not null or undefined
            assertParamExists('getOrganizationLabelsGroupAssociatedItems', 'labelsGroupId', labelsGroupId)
            const localVarPath = `/organization/{organizationId}/labelsGroups/{labelsGroupId}/associatedItems`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"labelsGroupId"}}`, encodeURIComponent(String(labelsGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get organization labels group
         * @summary Get organization labels group
         * @param {string} organizationId Organization ID
         * @param {string} labelsGroupId Organization labels group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationLabelssGroup: async (organizationId: string, labelsGroupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationLabelssGroup', 'organizationId', organizationId)
            // verify required parameter 'labelsGroupId' is not null or undefined
            assertParamExists('getOrganizationLabelssGroup', 'labelsGroupId', labelsGroupId)
            const localVarPath = `/organization/{organizationId}/labelsGroups/{labelsGroupId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"labelsGroupId"}}`, encodeURIComponent(String(labelsGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List organization labels group
         * @summary List organization labels group
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationLabelsGroup: async (organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listOrganizationLabelsGroup', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/labelsGroups`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationLabelsGroupApi - functional programming interface
 * @export
 */
export const OrganizationLabelsGroupApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationLabelsGroupApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an organization labels group
         * @summary Create an organization labels group
         * @param {string} organizationId Organization ID
         * @param {OrganizationLabelsGroupCreateRequest} [organizationLabelsGroupCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrganizationLabelsGroup(organizationId: string, organizationLabelsGroupCreateRequest?: OrganizationLabelsGroupCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationLabelsGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrganizationLabelsGroup(organizationId, organizationLabelsGroupCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationLabelsGroupApi.createOrganizationLabelsGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete organization labels group
         * @summary Delete organization labels group
         * @param {string} organizationId Organization ID
         * @param {string} labelsGroupId Organization labels group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrganizationLabelsGroup(organizationId: string, labelsGroupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrganizationLabelsGroup(organizationId, labelsGroupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationLabelsGroupApi.deleteOrganizationLabelsGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Edit organization labels group
         * @summary Edit organization labels group
         * @param {string} organizationId Organization ID
         * @param {string} labelsGroupId Organization labels group ID
         * @param {OrganizationLabelsGroupCreateRequest} [organizationLabelsGroupCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editOrganizationLabelsGroup(organizationId: string, labelsGroupId: string, organizationLabelsGroupCreateRequest?: OrganizationLabelsGroupCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationLabelsGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editOrganizationLabelsGroup(organizationId, labelsGroupId, organizationLabelsGroupCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationLabelsGroupApi.editOrganizationLabelsGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get organization labels group associated items
         * @summary Get organization labels group associated items
         * @param {string} organizationId Organization ID
         * @param {string} labelsGroupId Organization labels group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationLabelsGroupAssociatedItems(organizationId: string, labelsGroupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationLabelsGroupAssociatedItemsResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationLabelsGroupAssociatedItems(organizationId, labelsGroupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationLabelsGroupApi.getOrganizationLabelsGroupAssociatedItems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get organization labels group
         * @summary Get organization labels group
         * @param {string} organizationId Organization ID
         * @param {string} labelsGroupId Organization labels group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationLabelssGroup(organizationId: string, labelsGroupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationLabelsGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationLabelssGroup(organizationId, labelsGroupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationLabelsGroupApi.getOrganizationLabelssGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List organization labels group
         * @summary List organization labels group
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizationLabelsGroup(organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOrganizationLabelsGroup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationLabelsGroup(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationLabelsGroupApi.listOrganizationLabelsGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrganizationLabelsGroupApi - factory interface
 * @export
 */
export const OrganizationLabelsGroupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationLabelsGroupApiFp(configuration)
    return {
        /**
         * Create an organization labels group
         * @summary Create an organization labels group
         * @param {string} organizationId Organization ID
         * @param {OrganizationLabelsGroupCreateRequest} [organizationLabelsGroupCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationLabelsGroup(organizationId: string, organizationLabelsGroupCreateRequest?: OrganizationLabelsGroupCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<OrganizationLabelsGroupResponse> {
            return localVarFp.createOrganizationLabelsGroup(organizationId, organizationLabelsGroupCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete organization labels group
         * @summary Delete organization labels group
         * @param {string} organizationId Organization ID
         * @param {string} labelsGroupId Organization labels group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationLabelsGroup(organizationId: string, labelsGroupId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteOrganizationLabelsGroup(organizationId, labelsGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit organization labels group
         * @summary Edit organization labels group
         * @param {string} organizationId Organization ID
         * @param {string} labelsGroupId Organization labels group ID
         * @param {OrganizationLabelsGroupCreateRequest} [organizationLabelsGroupCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editOrganizationLabelsGroup(organizationId: string, labelsGroupId: string, organizationLabelsGroupCreateRequest?: OrganizationLabelsGroupCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<OrganizationLabelsGroupResponse> {
            return localVarFp.editOrganizationLabelsGroup(organizationId, labelsGroupId, organizationLabelsGroupCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get organization labels group associated items
         * @summary Get organization labels group associated items
         * @param {string} organizationId Organization ID
         * @param {string} labelsGroupId Organization labels group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationLabelsGroupAssociatedItems(organizationId: string, labelsGroupId: string, options?: RawAxiosRequestConfig): AxiosPromise<OrganizationLabelsGroupAssociatedItemsResponseList> {
            return localVarFp.getOrganizationLabelsGroupAssociatedItems(organizationId, labelsGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get organization labels group
         * @summary Get organization labels group
         * @param {string} organizationId Organization ID
         * @param {string} labelsGroupId Organization labels group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationLabelssGroup(organizationId: string, labelsGroupId: string, options?: RawAxiosRequestConfig): AxiosPromise<OrganizationLabelsGroupResponse> {
            return localVarFp.getOrganizationLabelssGroup(organizationId, labelsGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * List organization labels group
         * @summary List organization labels group
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationLabelsGroup(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise<ListOrganizationLabelsGroup200Response> {
            return localVarFp.listOrganizationLabelsGroup(organizationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationLabelsGroupApi - object-oriented interface
 * @export
 * @class OrganizationLabelsGroupApi
 * @extends {BaseAPI}
 */
export class OrganizationLabelsGroupApi extends BaseAPI {
    /**
     * Create an organization labels group
     * @summary Create an organization labels group
     * @param {string} organizationId Organization ID
     * @param {OrganizationLabelsGroupCreateRequest} [organizationLabelsGroupCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationLabelsGroupApi
     */
    public createOrganizationLabelsGroup(organizationId: string, organizationLabelsGroupCreateRequest?: OrganizationLabelsGroupCreateRequest, options?: RawAxiosRequestConfig) {
        return OrganizationLabelsGroupApiFp(this.configuration).createOrganizationLabelsGroup(organizationId, organizationLabelsGroupCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete organization labels group
     * @summary Delete organization labels group
     * @param {string} organizationId Organization ID
     * @param {string} labelsGroupId Organization labels group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationLabelsGroupApi
     */
    public deleteOrganizationLabelsGroup(organizationId: string, labelsGroupId: string, options?: RawAxiosRequestConfig) {
        return OrganizationLabelsGroupApiFp(this.configuration).deleteOrganizationLabelsGroup(organizationId, labelsGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit organization labels group
     * @summary Edit organization labels group
     * @param {string} organizationId Organization ID
     * @param {string} labelsGroupId Organization labels group ID
     * @param {OrganizationLabelsGroupCreateRequest} [organizationLabelsGroupCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationLabelsGroupApi
     */
    public editOrganizationLabelsGroup(organizationId: string, labelsGroupId: string, organizationLabelsGroupCreateRequest?: OrganizationLabelsGroupCreateRequest, options?: RawAxiosRequestConfig) {
        return OrganizationLabelsGroupApiFp(this.configuration).editOrganizationLabelsGroup(organizationId, labelsGroupId, organizationLabelsGroupCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get organization labels group associated items
     * @summary Get organization labels group associated items
     * @param {string} organizationId Organization ID
     * @param {string} labelsGroupId Organization labels group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationLabelsGroupApi
     */
    public getOrganizationLabelsGroupAssociatedItems(organizationId: string, labelsGroupId: string, options?: RawAxiosRequestConfig) {
        return OrganizationLabelsGroupApiFp(this.configuration).getOrganizationLabelsGroupAssociatedItems(organizationId, labelsGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get organization labels group
     * @summary Get organization labels group
     * @param {string} organizationId Organization ID
     * @param {string} labelsGroupId Organization labels group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationLabelsGroupApi
     */
    public getOrganizationLabelssGroup(organizationId: string, labelsGroupId: string, options?: RawAxiosRequestConfig) {
        return OrganizationLabelsGroupApiFp(this.configuration).getOrganizationLabelssGroup(organizationId, labelsGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List organization labels group
     * @summary List organization labels group
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationLabelsGroupApi
     */
    public listOrganizationLabelsGroup(organizationId: string, options?: RawAxiosRequestConfig) {
        return OrganizationLabelsGroupApiFp(this.configuration).listOrganizationLabelsGroup(organizationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrganizationMainCallsApi - axios parameter creator
 * @export
 */
export const OrganizationMainCallsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new git token to be used as a git provider by a service
         * @summary Create a git token
         * @param {string} organizationId Organization ID
         * @param {GitTokenRequest} [gitTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGitToken: async (organizationId: string, gitTokenRequest?: GitTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createGitToken', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/gitToken`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gitTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an organization
         * @param {OrganizationRequest} [organizationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganization: async (organizationRequest?: OrganizationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/organization`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a git token
         * @param {string} organizationId Organization ID
         * @param {string} gitTokenId Git Token ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGitToken: async (organizationId: string, gitTokenId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteGitToken', 'organizationId', organizationId)
            // verify required parameter 'gitTokenId' is not null or undefined
            assertParamExists('deleteGitToken', 'gitTokenId', gitTokenId)
            const localVarPath = `/organization/{organizationId}/gitToken/{gitTokenId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"gitTokenId"}}`, encodeURIComponent(String(gitTokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To delete an organization you must have the admin permission
         * @summary Delete an organization
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganization: async (organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteOrganization', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a git token
         * @param {string} organizationId Organization ID
         * @param {string} gitTokenId Git Token ID
         * @param {GitTokenRequest} [gitTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editGitToken: async (organizationId: string, gitTokenId: string, gitTokenRequest?: GitTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('editGitToken', 'organizationId', organizationId)
            // verify required parameter 'gitTokenId' is not null or undefined
            assertParamExists('editGitToken', 'gitTokenId', gitTokenId)
            const localVarPath = `/organization/{organizationId}/gitToken/{gitTokenId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"gitTokenId"}}`, encodeURIComponent(String(gitTokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gitTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To edit an organization you must have the admin permission.
         * @summary Edit an organization
         * @param {string} organizationId Organization ID
         * @param {OrganizationEditRequest} [organizationEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editOrganization: async (organizationId: string, organizationEditRequest?: OrganizationEditRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('editOrganization', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get organization container registry associated services
         * @summary Get organization container registry associated services
         * @param {string} organizationId 
         * @param {string} containerRegistryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainerRegistryAssociatedServices: async (organizationId: string, containerRegistryId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getContainerRegistryAssociatedServices', 'organizationId', organizationId)
            // verify required parameter 'containerRegistryId' is not null or undefined
            assertParamExists('getContainerRegistryAssociatedServices', 'containerRegistryId', containerRegistryId)
            const localVarPath = `/organization/{organizationId}/containerRegistry/{containerRegistryId}/associatedServices`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"containerRegistryId"}}`, encodeURIComponent(String(containerRegistryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get organization git tokens associated services
         * @summary Get organization git token associated services
         * @param {string} organizationId Organization ID
         * @param {string} gitTokenId Git Token ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGitTokenAssociatedServices: async (organizationId: string, gitTokenId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getGitTokenAssociatedServices', 'organizationId', organizationId)
            // verify required parameter 'gitTokenId' is not null or undefined
            assertParamExists('getGitTokenAssociatedServices', 'gitTokenId', gitTokenId)
            const localVarPath = `/organization/{organizationId}/gitToken/{gitTokenId}/associatedServices`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"gitTokenId"}}`, encodeURIComponent(String(gitTokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get organization helm repository associated services
         * @summary Get organization helm repository associated services
         * @param {string} organizationId 
         * @param {string} helmRepositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHelmRepositoryAssociatedServices: async (organizationId: string, helmRepositoryId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getHelmRepositoryAssociatedServices', 'organizationId', organizationId)
            // verify required parameter 'helmRepositoryId' is not null or undefined
            assertParamExists('getHelmRepositoryAssociatedServices', 'helmRepositoryId', helmRepositoryId)
            const localVarPath = `/organization/{organizationId}/helmRepository/{helmRepositoryId}/associatedServices`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"helmRepositoryId"}}`, encodeURIComponent(String(helmRepositoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get organization by ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization: async (organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganization', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get organization git token
         * @summary Get organization git token
         * @param {string} organizationId Organization ID
         * @param {string} gitTokenId Git Token ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationGitToken: async (organizationId: string, gitTokenId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationGitToken', 'organizationId', organizationId)
            // verify required parameter 'gitTokenId' is not null or undefined
            assertParamExists('getOrganizationGitToken', 'gitTokenId', gitTokenId)
            const localVarPath = `/organization/{organizationId}/gitToken/{gitTokenId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"gitTokenId"}}`, encodeURIComponent(String(gitTokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List user organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganization: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/organization`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List organization available roles
         * @summary List organization available roles
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationAvailableRoles: async (organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listOrganizationAvailableRoles', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/availableRole`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List credentials of an organization and their associated clusters
         * @summary List credentials of an organization and their associated clusters
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationCredentials: async (organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listOrganizationCredentials', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/credentials`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List organization git tokens
         * @summary List organization git tokens
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationGitTokens: async (organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listOrganizationGitTokens', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/gitToken`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Services By OrganizationId
         * @param {string} organizationId 
         * @param {string | null} [projectId] 
         * @param {string | null} [environmentId] 
         * @param {string} [clusterId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServicesByOrganizationId: async (organizationId: string, projectId?: string | null, environmentId?: string | null, clusterId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listServicesByOrganizationId', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/services`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (environmentId !== undefined) {
                localVarQueryParameter['environment_id'] = environmentId;
            }

            if (clusterId !== undefined) {
                localVarQueryParameter['cluster_id'] = clusterId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Terraform tfvars files from Git repository
         * @param {string} organizationId Organization ID
         * @param {TfVarsListRequest} tfVarsListRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTfVarsFilesFromGitRepo: async (organizationId: string, tfVarsListRequest: TfVarsListRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listTfVarsFilesFromGitRepo', 'organizationId', organizationId)
            // verify required parameter 'tfVarsListRequest' is not null or undefined
            assertParamExists('listTfVarsFilesFromGitRepo', 'tfVarsListRequest', tfVarsListRequest)
            const localVarPath = `/organization/{organizationId}/listTfVarsFilesFromGitRepo`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tfVarsListRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Parse Terraform variables from Git repository
         * @param {string} organizationId Organization ID
         * @param {TerraformVariableParsingRequest} terraformVariableParsingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parseTerraformVariablesFromGitRepo: async (organizationId: string, terraformVariableParsingRequest: TerraformVariableParsingRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('parseTerraformVariablesFromGitRepo', 'organizationId', organizationId)
            // verify required parameter 'terraformVariableParsingRequest' is not null or undefined
            assertParamExists('parseTerraformVariablesFromGitRepo', 'terraformVariableParsingRequest', terraformVariableParsingRequest)
            const localVarPath = `/organization/{organizationId}/parseTerraformVariablesFromGitRepo`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(terraformVariableParsingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationMainCallsApi - functional programming interface
 * @export
 */
export const OrganizationMainCallsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationMainCallsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new git token to be used as a git provider by a service
         * @summary Create a git token
         * @param {string} organizationId Organization ID
         * @param {GitTokenRequest} [gitTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGitToken(organizationId: string, gitTokenRequest?: GitTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGitToken(organizationId, gitTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationMainCallsApi.createGitToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create an organization
         * @param {OrganizationRequest} [organizationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrganization(organizationRequest?: OrganizationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrganization(organizationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationMainCallsApi.createOrganization']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a git token
         * @param {string} organizationId Organization ID
         * @param {string} gitTokenId Git Token ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGitToken(organizationId: string, gitTokenId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGitToken(organizationId, gitTokenId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationMainCallsApi.deleteGitToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * To delete an organization you must have the admin permission
         * @summary Delete an organization
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrganization(organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrganization(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationMainCallsApi.deleteOrganization']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Edit a git token
         * @param {string} organizationId Organization ID
         * @param {string} gitTokenId Git Token ID
         * @param {GitTokenRequest} [gitTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editGitToken(organizationId: string, gitTokenId: string, gitTokenRequest?: GitTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editGitToken(organizationId, gitTokenId, gitTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationMainCallsApi.editGitToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * To edit an organization you must have the admin permission.
         * @summary Edit an organization
         * @param {string} organizationId Organization ID
         * @param {OrganizationEditRequest} [organizationEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editOrganization(organizationId: string, organizationEditRequest?: OrganizationEditRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editOrganization(organizationId, organizationEditRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationMainCallsApi.editOrganization']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get organization container registry associated services
         * @summary Get organization container registry associated services
         * @param {string} organizationId 
         * @param {string} containerRegistryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContainerRegistryAssociatedServices(organizationId: string, containerRegistryId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerRegistryAssociatedServicesResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContainerRegistryAssociatedServices(organizationId, containerRegistryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationMainCallsApi.getContainerRegistryAssociatedServices']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get organization git tokens associated services
         * @summary Get organization git token associated services
         * @param {string} organizationId Organization ID
         * @param {string} gitTokenId Git Token ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGitTokenAssociatedServices(organizationId: string, gitTokenId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitTokenAssociatedServicesResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGitTokenAssociatedServices(organizationId, gitTokenId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationMainCallsApi.getGitTokenAssociatedServices']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get organization helm repository associated services
         * @summary Get organization helm repository associated services
         * @param {string} organizationId 
         * @param {string} helmRepositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHelmRepositoryAssociatedServices(organizationId: string, helmRepositoryId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HelmRepositoryAssociatedServicesResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHelmRepositoryAssociatedServices(organizationId, helmRepositoryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationMainCallsApi.getHelmRepositoryAssociatedServices']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get organization by ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganization(organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganization(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationMainCallsApi.getOrganization']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get organization git token
         * @summary Get organization git token
         * @param {string} organizationId Organization ID
         * @param {string} gitTokenId Git Token ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationGitToken(organizationId: string, gitTokenId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationGitToken(organizationId, gitTokenId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationMainCallsApi.getOrganizationGitToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List user organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganization(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganization(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationMainCallsApi.listOrganization']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List organization available roles
         * @summary List organization available roles
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizationAvailableRoles(organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationAvailableRoleList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationAvailableRoles(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationMainCallsApi.listOrganizationAvailableRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List credentials of an organization and their associated clusters
         * @summary List credentials of an organization and their associated clusters
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizationCredentials(organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationCrendentialsResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationCredentials(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationMainCallsApi.listOrganizationCredentials']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List organization git tokens
         * @summary List organization git tokens
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizationGitTokens(organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitTokenResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationGitTokens(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationMainCallsApi.listOrganizationGitTokens']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Services By OrganizationId
         * @param {string} organizationId 
         * @param {string | null} [projectId] 
         * @param {string | null} [environmentId] 
         * @param {string} [clusterId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listServicesByOrganizationId(organizationId: string, projectId?: string | null, environmentId?: string | null, clusterId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListServicesByOrganizationId200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listServicesByOrganizationId(organizationId, projectId, environmentId, clusterId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationMainCallsApi.listServicesByOrganizationId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Terraform tfvars files from Git repository
         * @param {string} organizationId Organization ID
         * @param {TfVarsListRequest} tfVarsListRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTfVarsFilesFromGitRepo(organizationId: string, tfVarsListRequest: TfVarsListRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListTfVarsFilesFromGitRepo200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTfVarsFilesFromGitRepo(organizationId, tfVarsListRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationMainCallsApi.listTfVarsFilesFromGitRepo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Parse Terraform variables from Git repository
         * @param {string} organizationId Organization ID
         * @param {TerraformVariableParsingRequest} terraformVariableParsingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async parseTerraformVariablesFromGitRepo(organizationId: string, terraformVariableParsingRequest: TerraformVariableParsingRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ParseTerraformVariablesFromGitRepo200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.parseTerraformVariablesFromGitRepo(organizationId, terraformVariableParsingRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationMainCallsApi.parseTerraformVariablesFromGitRepo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrganizationMainCallsApi - factory interface
 * @export
 */
export const OrganizationMainCallsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationMainCallsApiFp(configuration)
    return {
        /**
         * Create a new git token to be used as a git provider by a service
         * @summary Create a git token
         * @param {string} organizationId Organization ID
         * @param {GitTokenRequest} [gitTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGitToken(organizationId: string, gitTokenRequest?: GitTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<GitTokenResponse> {
            return localVarFp.createGitToken(organizationId, gitTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create an organization
         * @param {OrganizationRequest} [organizationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganization(organizationRequest?: OrganizationRequest, options?: RawAxiosRequestConfig): AxiosPromise<Organization> {
            return localVarFp.createOrganization(organizationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a git token
         * @param {string} organizationId Organization ID
         * @param {string} gitTokenId Git Token ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGitToken(organizationId: string, gitTokenId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteGitToken(organizationId, gitTokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * To delete an organization you must have the admin permission
         * @summary Delete an organization
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganization(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteOrganization(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a git token
         * @param {string} organizationId Organization ID
         * @param {string} gitTokenId Git Token ID
         * @param {GitTokenRequest} [gitTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editGitToken(organizationId: string, gitTokenId: string, gitTokenRequest?: GitTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<GitTokenResponse> {
            return localVarFp.editGitToken(organizationId, gitTokenId, gitTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * To edit an organization you must have the admin permission.
         * @summary Edit an organization
         * @param {string} organizationId Organization ID
         * @param {OrganizationEditRequest} [organizationEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editOrganization(organizationId: string, organizationEditRequest?: OrganizationEditRequest, options?: RawAxiosRequestConfig): AxiosPromise<Organization> {
            return localVarFp.editOrganization(organizationId, organizationEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get organization container registry associated services
         * @summary Get organization container registry associated services
         * @param {string} organizationId 
         * @param {string} containerRegistryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainerRegistryAssociatedServices(organizationId: string, containerRegistryId: string, options?: RawAxiosRequestConfig): AxiosPromise<ContainerRegistryAssociatedServicesResponseList> {
            return localVarFp.getContainerRegistryAssociatedServices(organizationId, containerRegistryId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get organization git tokens associated services
         * @summary Get organization git token associated services
         * @param {string} organizationId Organization ID
         * @param {string} gitTokenId Git Token ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGitTokenAssociatedServices(organizationId: string, gitTokenId: string, options?: RawAxiosRequestConfig): AxiosPromise<GitTokenAssociatedServicesResponseList> {
            return localVarFp.getGitTokenAssociatedServices(organizationId, gitTokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get organization helm repository associated services
         * @summary Get organization helm repository associated services
         * @param {string} organizationId 
         * @param {string} helmRepositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHelmRepositoryAssociatedServices(organizationId: string, helmRepositoryId: string, options?: RawAxiosRequestConfig): AxiosPromise<HelmRepositoryAssociatedServicesResponseList> {
            return localVarFp.getHelmRepositoryAssociatedServices(organizationId, helmRepositoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get organization by ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise<Organization> {
            return localVarFp.getOrganization(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get organization git token
         * @summary Get organization git token
         * @param {string} organizationId Organization ID
         * @param {string} gitTokenId Git Token ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationGitToken(organizationId: string, gitTokenId: string, options?: RawAxiosRequestConfig): AxiosPromise<GitTokenResponse> {
            return localVarFp.getOrganizationGitToken(organizationId, gitTokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List user organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganization(options?: RawAxiosRequestConfig): AxiosPromise<OrganizationResponseList> {
            return localVarFp.listOrganization(options).then((request) => request(axios, basePath));
        },
        /**
         * List organization available roles
         * @summary List organization available roles
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationAvailableRoles(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise<OrganizationAvailableRoleList> {
            return localVarFp.listOrganizationAvailableRoles(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * List credentials of an organization and their associated clusters
         * @summary List credentials of an organization and their associated clusters
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationCredentials(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise<OrganizationCrendentialsResponseList> {
            return localVarFp.listOrganizationCredentials(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * List organization git tokens
         * @summary List organization git tokens
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationGitTokens(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise<GitTokenResponseList> {
            return localVarFp.listOrganizationGitTokens(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Services By OrganizationId
         * @param {string} organizationId 
         * @param {string | null} [projectId] 
         * @param {string | null} [environmentId] 
         * @param {string} [clusterId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServicesByOrganizationId(organizationId: string, projectId?: string | null, environmentId?: string | null, clusterId?: string, options?: RawAxiosRequestConfig): AxiosPromise<ListServicesByOrganizationId200Response> {
            return localVarFp.listServicesByOrganizationId(organizationId, projectId, environmentId, clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Terraform tfvars files from Git repository
         * @param {string} organizationId Organization ID
         * @param {TfVarsListRequest} tfVarsListRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTfVarsFilesFromGitRepo(organizationId: string, tfVarsListRequest: TfVarsListRequest, options?: RawAxiosRequestConfig): AxiosPromise<ListTfVarsFilesFromGitRepo200Response> {
            return localVarFp.listTfVarsFilesFromGitRepo(organizationId, tfVarsListRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Parse Terraform variables from Git repository
         * @param {string} organizationId Organization ID
         * @param {TerraformVariableParsingRequest} terraformVariableParsingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parseTerraformVariablesFromGitRepo(organizationId: string, terraformVariableParsingRequest: TerraformVariableParsingRequest, options?: RawAxiosRequestConfig): AxiosPromise<ParseTerraformVariablesFromGitRepo200Response> {
            return localVarFp.parseTerraformVariablesFromGitRepo(organizationId, terraformVariableParsingRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationMainCallsApi - object-oriented interface
 * @export
 * @class OrganizationMainCallsApi
 * @extends {BaseAPI}
 */
export class OrganizationMainCallsApi extends BaseAPI {
    /**
     * Create a new git token to be used as a git provider by a service
     * @summary Create a git token
     * @param {string} organizationId Organization ID
     * @param {GitTokenRequest} [gitTokenRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationMainCallsApi
     */
    public createGitToken(organizationId: string, gitTokenRequest?: GitTokenRequest, options?: RawAxiosRequestConfig) {
        return OrganizationMainCallsApiFp(this.configuration).createGitToken(organizationId, gitTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create an organization
     * @param {OrganizationRequest} [organizationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationMainCallsApi
     */
    public createOrganization(organizationRequest?: OrganizationRequest, options?: RawAxiosRequestConfig) {
        return OrganizationMainCallsApiFp(this.configuration).createOrganization(organizationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a git token
     * @param {string} organizationId Organization ID
     * @param {string} gitTokenId Git Token ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationMainCallsApi
     */
    public deleteGitToken(organizationId: string, gitTokenId: string, options?: RawAxiosRequestConfig) {
        return OrganizationMainCallsApiFp(this.configuration).deleteGitToken(organizationId, gitTokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To delete an organization you must have the admin permission
     * @summary Delete an organization
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationMainCallsApi
     */
    public deleteOrganization(organizationId: string, options?: RawAxiosRequestConfig) {
        return OrganizationMainCallsApiFp(this.configuration).deleteOrganization(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a git token
     * @param {string} organizationId Organization ID
     * @param {string} gitTokenId Git Token ID
     * @param {GitTokenRequest} [gitTokenRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationMainCallsApi
     */
    public editGitToken(organizationId: string, gitTokenId: string, gitTokenRequest?: GitTokenRequest, options?: RawAxiosRequestConfig) {
        return OrganizationMainCallsApiFp(this.configuration).editGitToken(organizationId, gitTokenId, gitTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To edit an organization you must have the admin permission.
     * @summary Edit an organization
     * @param {string} organizationId Organization ID
     * @param {OrganizationEditRequest} [organizationEditRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationMainCallsApi
     */
    public editOrganization(organizationId: string, organizationEditRequest?: OrganizationEditRequest, options?: RawAxiosRequestConfig) {
        return OrganizationMainCallsApiFp(this.configuration).editOrganization(organizationId, organizationEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get organization container registry associated services
     * @summary Get organization container registry associated services
     * @param {string} organizationId 
     * @param {string} containerRegistryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationMainCallsApi
     */
    public getContainerRegistryAssociatedServices(organizationId: string, containerRegistryId: string, options?: RawAxiosRequestConfig) {
        return OrganizationMainCallsApiFp(this.configuration).getContainerRegistryAssociatedServices(organizationId, containerRegistryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get organization git tokens associated services
     * @summary Get organization git token associated services
     * @param {string} organizationId Organization ID
     * @param {string} gitTokenId Git Token ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationMainCallsApi
     */
    public getGitTokenAssociatedServices(organizationId: string, gitTokenId: string, options?: RawAxiosRequestConfig) {
        return OrganizationMainCallsApiFp(this.configuration).getGitTokenAssociatedServices(organizationId, gitTokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get organization helm repository associated services
     * @summary Get organization helm repository associated services
     * @param {string} organizationId 
     * @param {string} helmRepositoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationMainCallsApi
     */
    public getHelmRepositoryAssociatedServices(organizationId: string, helmRepositoryId: string, options?: RawAxiosRequestConfig) {
        return OrganizationMainCallsApiFp(this.configuration).getHelmRepositoryAssociatedServices(organizationId, helmRepositoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get organization by ID
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationMainCallsApi
     */
    public getOrganization(organizationId: string, options?: RawAxiosRequestConfig) {
        return OrganizationMainCallsApiFp(this.configuration).getOrganization(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get organization git token
     * @summary Get organization git token
     * @param {string} organizationId Organization ID
     * @param {string} gitTokenId Git Token ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationMainCallsApi
     */
    public getOrganizationGitToken(organizationId: string, gitTokenId: string, options?: RawAxiosRequestConfig) {
        return OrganizationMainCallsApiFp(this.configuration).getOrganizationGitToken(organizationId, gitTokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List user organizations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationMainCallsApi
     */
    public listOrganization(options?: RawAxiosRequestConfig) {
        return OrganizationMainCallsApiFp(this.configuration).listOrganization(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List organization available roles
     * @summary List organization available roles
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationMainCallsApi
     */
    public listOrganizationAvailableRoles(organizationId: string, options?: RawAxiosRequestConfig) {
        return OrganizationMainCallsApiFp(this.configuration).listOrganizationAvailableRoles(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List credentials of an organization and their associated clusters
     * @summary List credentials of an organization and their associated clusters
     * @param {string} organizationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationMainCallsApi
     */
    public listOrganizationCredentials(organizationId: string, options?: RawAxiosRequestConfig) {
        return OrganizationMainCallsApiFp(this.configuration).listOrganizationCredentials(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List organization git tokens
     * @summary List organization git tokens
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationMainCallsApi
     */
    public listOrganizationGitTokens(organizationId: string, options?: RawAxiosRequestConfig) {
        return OrganizationMainCallsApiFp(this.configuration).listOrganizationGitTokens(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Services By OrganizationId
     * @param {string} organizationId 
     * @param {string | null} [projectId] 
     * @param {string | null} [environmentId] 
     * @param {string} [clusterId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationMainCallsApi
     */
    public listServicesByOrganizationId(organizationId: string, projectId?: string | null, environmentId?: string | null, clusterId?: string, options?: RawAxiosRequestConfig) {
        return OrganizationMainCallsApiFp(this.configuration).listServicesByOrganizationId(organizationId, projectId, environmentId, clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Terraform tfvars files from Git repository
     * @param {string} organizationId Organization ID
     * @param {TfVarsListRequest} tfVarsListRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationMainCallsApi
     */
    public listTfVarsFilesFromGitRepo(organizationId: string, tfVarsListRequest: TfVarsListRequest, options?: RawAxiosRequestConfig) {
        return OrganizationMainCallsApiFp(this.configuration).listTfVarsFilesFromGitRepo(organizationId, tfVarsListRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Parse Terraform variables from Git repository
     * @param {string} organizationId Organization ID
     * @param {TerraformVariableParsingRequest} terraformVariableParsingRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationMainCallsApi
     */
    public parseTerraformVariablesFromGitRepo(organizationId: string, terraformVariableParsingRequest: TerraformVariableParsingRequest, options?: RawAxiosRequestConfig) {
        return OrganizationMainCallsApiFp(this.configuration).parseTerraformVariablesFromGitRepo(organizationId, terraformVariableParsingRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrganizationWebhookApi - axios parameter creator
 * @export
 */
export const OrganizationWebhookApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an organization webhook.
         * @summary Create an organization webhook
         * @param {string} organizationId Organization ID
         * @param {OrganizationWebhookCreateRequest} [organizationWebhookCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationWebhook: async (organizationId: string, organizationWebhookCreateRequest?: OrganizationWebhookCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createOrganizationWebhook', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/webhook`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationWebhookCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete organization webhook
         * @summary Delete organization webhook
         * @param {string} organizationId Organization ID
         * @param {string} webhookId Webhook ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationWebhook: async (organizationId: string, webhookId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteOrganizationWebhook', 'organizationId', organizationId)
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('deleteOrganizationWebhook', 'webhookId', webhookId)
            const localVarPath = `/organization/{organizationId}/webhook/{webhookId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit an organization webhook
         * @summary Edit an organization webhook
         * @param {string} organizationId Organization ID
         * @param {string} webhookId Webhook ID
         * @param {OrganizationWebhookCreateRequest} [organizationWebhookCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editOrganizationWebhook: async (organizationId: string, webhookId: string, organizationWebhookCreateRequest?: OrganizationWebhookCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('editOrganizationWebhook', 'organizationId', organizationId)
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('editOrganizationWebhook', 'webhookId', webhookId)
            const localVarPath = `/organization/{organizationId}/webhook/{webhookId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationWebhookCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an Organization webhook
         * @summary Get an Organization webhook
         * @param {string} organizationId Organization ID
         * @param {string} webhookId Webhook ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationWebhook: async (organizationId: string, webhookId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationWebhook', 'organizationId', organizationId)
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('getOrganizationWebhook', 'webhookId', webhookId)
            const localVarPath = `/organization/{organizationId}/webhook/{webhookId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List organization webhooks
         * @summary List organization webhooks
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationWebHooks: async (organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listOrganizationWebHooks', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/webhook`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List events of a webhooks
         * @summary List events of a webhook
         * @param {string} organizationId Organization ID
         * @param {string} webhookId Webhook ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebhookEvent: async (organizationId: string, webhookId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listWebhookEvent', 'organizationId', organizationId)
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('listWebhookEvent', 'webhookId', webhookId)
            const localVarPath = `/organization/{organizationId}/webhook/{webhookId}/event`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationWebhookApi - functional programming interface
 * @export
 */
export const OrganizationWebhookApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationWebhookApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an organization webhook.
         * @summary Create an organization webhook
         * @param {string} organizationId Organization ID
         * @param {OrganizationWebhookCreateRequest} [organizationWebhookCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrganizationWebhook(organizationId: string, organizationWebhookCreateRequest?: OrganizationWebhookCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationWebhookCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrganizationWebhook(organizationId, organizationWebhookCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationWebhookApi.createOrganizationWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete organization webhook
         * @summary Delete organization webhook
         * @param {string} organizationId Organization ID
         * @param {string} webhookId Webhook ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrganizationWebhook(organizationId: string, webhookId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrganizationWebhook(organizationId, webhookId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationWebhookApi.deleteOrganizationWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Edit an organization webhook
         * @summary Edit an organization webhook
         * @param {string} organizationId Organization ID
         * @param {string} webhookId Webhook ID
         * @param {OrganizationWebhookCreateRequest} [organizationWebhookCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editOrganizationWebhook(organizationId: string, webhookId: string, organizationWebhookCreateRequest?: OrganizationWebhookCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationWebhookCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editOrganizationWebhook(organizationId, webhookId, organizationWebhookCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationWebhookApi.editOrganizationWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an Organization webhook
         * @summary Get an Organization webhook
         * @param {string} organizationId Organization ID
         * @param {string} webhookId Webhook ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationWebhook(organizationId: string, webhookId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationWebhookResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationWebhook(organizationId, webhookId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationWebhookApi.getOrganizationWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List organization webhooks
         * @summary List organization webhooks
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizationWebHooks(organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationWebhookResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationWebHooks(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationWebhookApi.listOrganizationWebHooks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List events of a webhooks
         * @summary List events of a webhook
         * @param {string} organizationId Organization ID
         * @param {string} webhookId Webhook ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWebhookEvent(organizationId: string, webhookId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookEventResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWebhookEvent(organizationId, webhookId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationWebhookApi.listWebhookEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrganizationWebhookApi - factory interface
 * @export
 */
export const OrganizationWebhookApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationWebhookApiFp(configuration)
    return {
        /**
         * Create an organization webhook.
         * @summary Create an organization webhook
         * @param {string} organizationId Organization ID
         * @param {OrganizationWebhookCreateRequest} [organizationWebhookCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationWebhook(organizationId: string, organizationWebhookCreateRequest?: OrganizationWebhookCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<OrganizationWebhookCreateResponse> {
            return localVarFp.createOrganizationWebhook(organizationId, organizationWebhookCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete organization webhook
         * @summary Delete organization webhook
         * @param {string} organizationId Organization ID
         * @param {string} webhookId Webhook ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationWebhook(organizationId: string, webhookId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteOrganizationWebhook(organizationId, webhookId, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit an organization webhook
         * @summary Edit an organization webhook
         * @param {string} organizationId Organization ID
         * @param {string} webhookId Webhook ID
         * @param {OrganizationWebhookCreateRequest} [organizationWebhookCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editOrganizationWebhook(organizationId: string, webhookId: string, organizationWebhookCreateRequest?: OrganizationWebhookCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<OrganizationWebhookCreateResponse> {
            return localVarFp.editOrganizationWebhook(organizationId, webhookId, organizationWebhookCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an Organization webhook
         * @summary Get an Organization webhook
         * @param {string} organizationId Organization ID
         * @param {string} webhookId Webhook ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationWebhook(organizationId: string, webhookId: string, options?: RawAxiosRequestConfig): AxiosPromise<OrganizationWebhookResponse> {
            return localVarFp.getOrganizationWebhook(organizationId, webhookId, options).then((request) => request(axios, basePath));
        },
        /**
         * List organization webhooks
         * @summary List organization webhooks
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationWebHooks(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise<OrganizationWebhookResponseList> {
            return localVarFp.listOrganizationWebHooks(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * List events of a webhooks
         * @summary List events of a webhook
         * @param {string} organizationId Organization ID
         * @param {string} webhookId Webhook ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebhookEvent(organizationId: string, webhookId: string, options?: RawAxiosRequestConfig): AxiosPromise<WebhookEventResponseList> {
            return localVarFp.listWebhookEvent(organizationId, webhookId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationWebhookApi - object-oriented interface
 * @export
 * @class OrganizationWebhookApi
 * @extends {BaseAPI}
 */
export class OrganizationWebhookApi extends BaseAPI {
    /**
     * Create an organization webhook.
     * @summary Create an organization webhook
     * @param {string} organizationId Organization ID
     * @param {OrganizationWebhookCreateRequest} [organizationWebhookCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationWebhookApi
     */
    public createOrganizationWebhook(organizationId: string, organizationWebhookCreateRequest?: OrganizationWebhookCreateRequest, options?: RawAxiosRequestConfig) {
        return OrganizationWebhookApiFp(this.configuration).createOrganizationWebhook(organizationId, organizationWebhookCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete organization webhook
     * @summary Delete organization webhook
     * @param {string} organizationId Organization ID
     * @param {string} webhookId Webhook ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationWebhookApi
     */
    public deleteOrganizationWebhook(organizationId: string, webhookId: string, options?: RawAxiosRequestConfig) {
        return OrganizationWebhookApiFp(this.configuration).deleteOrganizationWebhook(organizationId, webhookId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit an organization webhook
     * @summary Edit an organization webhook
     * @param {string} organizationId Organization ID
     * @param {string} webhookId Webhook ID
     * @param {OrganizationWebhookCreateRequest} [organizationWebhookCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationWebhookApi
     */
    public editOrganizationWebhook(organizationId: string, webhookId: string, organizationWebhookCreateRequest?: OrganizationWebhookCreateRequest, options?: RawAxiosRequestConfig) {
        return OrganizationWebhookApiFp(this.configuration).editOrganizationWebhook(organizationId, webhookId, organizationWebhookCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an Organization webhook
     * @summary Get an Organization webhook
     * @param {string} organizationId Organization ID
     * @param {string} webhookId Webhook ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationWebhookApi
     */
    public getOrganizationWebhook(organizationId: string, webhookId: string, options?: RawAxiosRequestConfig) {
        return OrganizationWebhookApiFp(this.configuration).getOrganizationWebhook(organizationId, webhookId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List organization webhooks
     * @summary List organization webhooks
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationWebhookApi
     */
    public listOrganizationWebHooks(organizationId: string, options?: RawAxiosRequestConfig) {
        return OrganizationWebhookApiFp(this.configuration).listOrganizationWebHooks(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List events of a webhooks
     * @summary List events of a webhook
     * @param {string} organizationId Organization ID
     * @param {string} webhookId Webhook ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationWebhookApi
     */
    public listWebhookEvent(organizationId: string, webhookId: string, options?: RawAxiosRequestConfig) {
        return OrganizationWebhookApiFp(this.configuration).listWebhookEvent(organizationId, webhookId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProjectDeploymentRuleApi - axios parameter creator
 * @export
 */
export const ProjectDeploymentRuleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a deployment rule
         * @summary Create a deployment rule
         * @param {string} projectId Project ID
         * @param {ProjectDeploymentRuleRequest} [projectDeploymentRuleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeploymentRule: async (projectId: string, projectDeploymentRuleRequest?: ProjectDeploymentRuleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createDeploymentRule', 'projectId', projectId)
            const localVarPath = `/project/{projectId}/deploymentRule`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectDeploymentRuleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a project deployment rule
         * @summary Delete a project deployment rule
         * @param {string} projectId Project ID
         * @param {string} deploymentRuleId Deployment Rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectDeploymentRule: async (projectId: string, deploymentRuleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteProjectDeploymentRule', 'projectId', projectId)
            // verify required parameter 'deploymentRuleId' is not null or undefined
            assertParamExists('deleteProjectDeploymentRule', 'deploymentRuleId', deploymentRuleId)
            const localVarPath = `/project/{projectId}/deploymentRule/{deploymentRuleId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"deploymentRuleId"}}`, encodeURIComponent(String(deploymentRuleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit a project deployment rule
         * @summary Edit a project deployment rule
         * @param {string} projectId Project ID
         * @param {string} deploymentRuleId Deployment Rule ID
         * @param {ProjectDeploymentRuleRequest} [projectDeploymentRuleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editProjectDeployemtnRule: async (projectId: string, deploymentRuleId: string, projectDeploymentRuleRequest?: ProjectDeploymentRuleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('editProjectDeployemtnRule', 'projectId', projectId)
            // verify required parameter 'deploymentRuleId' is not null or undefined
            assertParamExists('editProjectDeployemtnRule', 'deploymentRuleId', deploymentRuleId)
            const localVarPath = `/project/{projectId}/deploymentRule/{deploymentRuleId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"deploymentRuleId"}}`, encodeURIComponent(String(deploymentRuleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectDeploymentRuleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a project deployment rule
         * @summary Get a project deployment rule
         * @param {string} projectId Project ID
         * @param {string} deploymentRuleId Deployment Rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectDeploymentRule: async (projectId: string, deploymentRuleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getProjectDeploymentRule', 'projectId', projectId)
            // verify required parameter 'deploymentRuleId' is not null or undefined
            assertParamExists('getProjectDeploymentRule', 'deploymentRuleId', deploymentRuleId)
            const localVarPath = `/project/{projectId}/deploymentRule/{deploymentRuleId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"deploymentRuleId"}}`, encodeURIComponent(String(deploymentRuleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List project deployment rules
         * @summary List project deployment rules
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectDeploymentRules: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('listProjectDeploymentRules', 'projectId', projectId)
            const localVarPath = `/project/{projectId}/deploymentRule`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update deployment rules priority order
         * @summary Update deployment rules priority order
         * @param {string} projectId Project ID
         * @param {ProjectDeploymentRulesPriorityOrderRequest} [projectDeploymentRulesPriorityOrderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeploymentRulesPriorityOrder: async (projectId: string, projectDeploymentRulesPriorityOrderRequest?: ProjectDeploymentRulesPriorityOrderRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateDeploymentRulesPriorityOrder', 'projectId', projectId)
            const localVarPath = `/project/{projectId}/deploymentRule/order`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectDeploymentRulesPriorityOrderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectDeploymentRuleApi - functional programming interface
 * @export
 */
export const ProjectDeploymentRuleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectDeploymentRuleApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a deployment rule
         * @summary Create a deployment rule
         * @param {string} projectId Project ID
         * @param {ProjectDeploymentRuleRequest} [projectDeploymentRuleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDeploymentRule(projectId: string, projectDeploymentRuleRequest?: ProjectDeploymentRuleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectDeploymentRule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDeploymentRule(projectId, projectDeploymentRuleRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectDeploymentRuleApi.createDeploymentRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a project deployment rule
         * @summary Delete a project deployment rule
         * @param {string} projectId Project ID
         * @param {string} deploymentRuleId Deployment Rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProjectDeploymentRule(projectId: string, deploymentRuleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProjectDeploymentRule(projectId, deploymentRuleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectDeploymentRuleApi.deleteProjectDeploymentRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Edit a project deployment rule
         * @summary Edit a project deployment rule
         * @param {string} projectId Project ID
         * @param {string} deploymentRuleId Deployment Rule ID
         * @param {ProjectDeploymentRuleRequest} [projectDeploymentRuleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editProjectDeployemtnRule(projectId: string, deploymentRuleId: string, projectDeploymentRuleRequest?: ProjectDeploymentRuleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectDeploymentRule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editProjectDeployemtnRule(projectId, deploymentRuleId, projectDeploymentRuleRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectDeploymentRuleApi.editProjectDeployemtnRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a project deployment rule
         * @summary Get a project deployment rule
         * @param {string} projectId Project ID
         * @param {string} deploymentRuleId Deployment Rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjectDeploymentRule(projectId: string, deploymentRuleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectDeploymentRule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectDeploymentRule(projectId, deploymentRuleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectDeploymentRuleApi.getProjectDeploymentRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List project deployment rules
         * @summary List project deployment rules
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProjectDeploymentRules(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectDeploymentRuleResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProjectDeploymentRules(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectDeploymentRuleApi.listProjectDeploymentRules']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update deployment rules priority order
         * @summary Update deployment rules priority order
         * @param {string} projectId Project ID
         * @param {ProjectDeploymentRulesPriorityOrderRequest} [projectDeploymentRulesPriorityOrderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDeploymentRulesPriorityOrder(projectId: string, projectDeploymentRulesPriorityOrderRequest?: ProjectDeploymentRulesPriorityOrderRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDeploymentRulesPriorityOrder(projectId, projectDeploymentRulesPriorityOrderRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectDeploymentRuleApi.updateDeploymentRulesPriorityOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProjectDeploymentRuleApi - factory interface
 * @export
 */
export const ProjectDeploymentRuleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectDeploymentRuleApiFp(configuration)
    return {
        /**
         * Create a deployment rule
         * @summary Create a deployment rule
         * @param {string} projectId Project ID
         * @param {ProjectDeploymentRuleRequest} [projectDeploymentRuleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeploymentRule(projectId: string, projectDeploymentRuleRequest?: ProjectDeploymentRuleRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProjectDeploymentRule> {
            return localVarFp.createDeploymentRule(projectId, projectDeploymentRuleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a project deployment rule
         * @summary Delete a project deployment rule
         * @param {string} projectId Project ID
         * @param {string} deploymentRuleId Deployment Rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectDeploymentRule(projectId: string, deploymentRuleId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteProjectDeploymentRule(projectId, deploymentRuleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit a project deployment rule
         * @summary Edit a project deployment rule
         * @param {string} projectId Project ID
         * @param {string} deploymentRuleId Deployment Rule ID
         * @param {ProjectDeploymentRuleRequest} [projectDeploymentRuleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editProjectDeployemtnRule(projectId: string, deploymentRuleId: string, projectDeploymentRuleRequest?: ProjectDeploymentRuleRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProjectDeploymentRule> {
            return localVarFp.editProjectDeployemtnRule(projectId, deploymentRuleId, projectDeploymentRuleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a project deployment rule
         * @summary Get a project deployment rule
         * @param {string} projectId Project ID
         * @param {string} deploymentRuleId Deployment Rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectDeploymentRule(projectId: string, deploymentRuleId: string, options?: RawAxiosRequestConfig): AxiosPromise<ProjectDeploymentRule> {
            return localVarFp.getProjectDeploymentRule(projectId, deploymentRuleId, options).then((request) => request(axios, basePath));
        },
        /**
         * List project deployment rules
         * @summary List project deployment rules
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectDeploymentRules(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<ProjectDeploymentRuleResponseList> {
            return localVarFp.listProjectDeploymentRules(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update deployment rules priority order
         * @summary Update deployment rules priority order
         * @param {string} projectId Project ID
         * @param {ProjectDeploymentRulesPriorityOrderRequest} [projectDeploymentRulesPriorityOrderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeploymentRulesPriorityOrder(projectId: string, projectDeploymentRulesPriorityOrderRequest?: ProjectDeploymentRulesPriorityOrderRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateDeploymentRulesPriorityOrder(projectId, projectDeploymentRulesPriorityOrderRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectDeploymentRuleApi - object-oriented interface
 * @export
 * @class ProjectDeploymentRuleApi
 * @extends {BaseAPI}
 */
export class ProjectDeploymentRuleApi extends BaseAPI {
    /**
     * Create a deployment rule
     * @summary Create a deployment rule
     * @param {string} projectId Project ID
     * @param {ProjectDeploymentRuleRequest} [projectDeploymentRuleRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDeploymentRuleApi
     */
    public createDeploymentRule(projectId: string, projectDeploymentRuleRequest?: ProjectDeploymentRuleRequest, options?: RawAxiosRequestConfig) {
        return ProjectDeploymentRuleApiFp(this.configuration).createDeploymentRule(projectId, projectDeploymentRuleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a project deployment rule
     * @summary Delete a project deployment rule
     * @param {string} projectId Project ID
     * @param {string} deploymentRuleId Deployment Rule ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDeploymentRuleApi
     */
    public deleteProjectDeploymentRule(projectId: string, deploymentRuleId: string, options?: RawAxiosRequestConfig) {
        return ProjectDeploymentRuleApiFp(this.configuration).deleteProjectDeploymentRule(projectId, deploymentRuleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit a project deployment rule
     * @summary Edit a project deployment rule
     * @param {string} projectId Project ID
     * @param {string} deploymentRuleId Deployment Rule ID
     * @param {ProjectDeploymentRuleRequest} [projectDeploymentRuleRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDeploymentRuleApi
     */
    public editProjectDeployemtnRule(projectId: string, deploymentRuleId: string, projectDeploymentRuleRequest?: ProjectDeploymentRuleRequest, options?: RawAxiosRequestConfig) {
        return ProjectDeploymentRuleApiFp(this.configuration).editProjectDeployemtnRule(projectId, deploymentRuleId, projectDeploymentRuleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a project deployment rule
     * @summary Get a project deployment rule
     * @param {string} projectId Project ID
     * @param {string} deploymentRuleId Deployment Rule ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDeploymentRuleApi
     */
    public getProjectDeploymentRule(projectId: string, deploymentRuleId: string, options?: RawAxiosRequestConfig) {
        return ProjectDeploymentRuleApiFp(this.configuration).getProjectDeploymentRule(projectId, deploymentRuleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List project deployment rules
     * @summary List project deployment rules
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDeploymentRuleApi
     */
    public listProjectDeploymentRules(projectId: string, options?: RawAxiosRequestConfig) {
        return ProjectDeploymentRuleApiFp(this.configuration).listProjectDeploymentRules(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update deployment rules priority order
     * @summary Update deployment rules priority order
     * @param {string} projectId Project ID
     * @param {ProjectDeploymentRulesPriorityOrderRequest} [projectDeploymentRulesPriorityOrderRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDeploymentRuleApi
     */
    public updateDeploymentRulesPriorityOrder(projectId: string, projectDeploymentRulesPriorityOrderRequest?: ProjectDeploymentRulesPriorityOrderRequest, options?: RawAxiosRequestConfig) {
        return ProjectDeploymentRuleApiFp(this.configuration).updateDeploymentRulesPriorityOrder(projectId, projectDeploymentRulesPriorityOrderRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProjectEnvironmentVariableApi - axios parameter creator
 * @export
 */
export const ProjectEnvironmentVariableApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * - Add an environment variable to the project.   - If the environment variable key already exists, then it will be replaced by the new one.   - If the environment variable value points toward an existing environment variable key, it will be considered as an alias. 
         * @summary Add an environment variable to the project
         * @param {string} projectId Project ID
         * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectEnvironmentVariable: async (projectId: string, environmentVariableRequest?: EnvironmentVariableRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createProjectEnvironmentVariable', 'projectId', projectId)
            const localVarPath = `/project/{projectId}/environmentVariable`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentVariableRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to add an alias at project level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at project level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - You can\'t create an alias on an alias 
         * @summary Create an environment variable alias at the project level
         * @param {string} projectId Project ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectEnvironmentVariableAlias: async (projectId: string, environmentVariableId: string, key?: Key, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createProjectEnvironmentVariableAlias', 'projectId', projectId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('createProjectEnvironmentVariableAlias', 'environmentVariableId', environmentVariableId)
            const localVarPath = `/project/{projectId}/environmentVariable/{environmentVariableId}/alias`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(key, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to override at project level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at project level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
         * @summary Create an environment variable override at the project level
         * @param {string} projectId Project ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectEnvironmentVariableOverride: async (projectId: string, environmentVariableId: string, value?: Value, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createProjectEnvironmentVariableOverride', 'projectId', projectId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('createProjectEnvironmentVariableOverride', 'environmentVariableId', environmentVariableId)
            const localVarPath = `/project/{projectId}/environmentVariable/{environmentVariableId}/override`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(value, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - To delete an environment variable you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete an environment variable from a project
         * @param {string} projectId Project ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectEnvironmentVariable: async (projectId: string, environmentVariableId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteProjectEnvironmentVariable', 'projectId', projectId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('deleteProjectEnvironmentVariable', 'environmentVariableId', environmentVariableId)
            const localVarPath = `/project/{projectId}/environmentVariable/{environmentVariableId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit an environment variable belonging to the project
         * @param {string} projectId Project ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editProjectEnvironmentVariable: async (projectId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('editProjectEnvironmentVariable', 'projectId', projectId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('editProjectEnvironmentVariable', 'environmentVariableId', environmentVariableId)
            // verify required parameter 'environmentVariableEditRequest' is not null or undefined
            assertParamExists('editProjectEnvironmentVariable', 'environmentVariableEditRequest', environmentVariableEditRequest)
            const localVarPath = `/project/{projectId}/environmentVariable/{environmentVariableId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentVariableEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List project environment variables
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectEnvironmentVariable: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('listProjectEnvironmentVariable', 'projectId', projectId)
            const localVarPath = `/project/{projectId}/environmentVariable`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectEnvironmentVariableApi - functional programming interface
 * @export
 */
export const ProjectEnvironmentVariableApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectEnvironmentVariableApiAxiosParamCreator(configuration)
    return {
        /**
         * - Add an environment variable to the project.   - If the environment variable key already exists, then it will be replaced by the new one.   - If the environment variable value points toward an existing environment variable key, it will be considered as an alias. 
         * @summary Add an environment variable to the project
         * @param {string} projectId Project ID
         * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProjectEnvironmentVariable(projectId: string, environmentVariableRequest?: EnvironmentVariableRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProjectEnvironmentVariable(projectId, environmentVariableRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectEnvironmentVariableApi.createProjectEnvironmentVariable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - Allows you to add an alias at project level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at project level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - You can\'t create an alias on an alias 
         * @summary Create an environment variable alias at the project level
         * @param {string} projectId Project ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProjectEnvironmentVariableAlias(projectId: string, environmentVariableId: string, key?: Key, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProjectEnvironmentVariableAlias(projectId, environmentVariableId, key, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectEnvironmentVariableApi.createProjectEnvironmentVariableAlias']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - Allows you to override at project level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at project level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
         * @summary Create an environment variable override at the project level
         * @param {string} projectId Project ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProjectEnvironmentVariableOverride(projectId: string, environmentVariableId: string, value?: Value, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProjectEnvironmentVariableOverride(projectId, environmentVariableId, value, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectEnvironmentVariableApi.createProjectEnvironmentVariableOverride']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - To delete an environment variable you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete an environment variable from a project
         * @param {string} projectId Project ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProjectEnvironmentVariable(projectId: string, environmentVariableId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProjectEnvironmentVariable(projectId, environmentVariableId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectEnvironmentVariableApi.deleteProjectEnvironmentVariable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit an environment variable belonging to the project
         * @param {string} projectId Project ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editProjectEnvironmentVariable(projectId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editProjectEnvironmentVariable(projectId, environmentVariableId, environmentVariableEditRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectEnvironmentVariableApi.editProjectEnvironmentVariable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List project environment variables
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProjectEnvironmentVariable(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariableResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProjectEnvironmentVariable(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectEnvironmentVariableApi.listProjectEnvironmentVariable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProjectEnvironmentVariableApi - factory interface
 * @export
 */
export const ProjectEnvironmentVariableApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectEnvironmentVariableApiFp(configuration)
    return {
        /**
         * - Add an environment variable to the project.   - If the environment variable key already exists, then it will be replaced by the new one.   - If the environment variable value points toward an existing environment variable key, it will be considered as an alias. 
         * @summary Add an environment variable to the project
         * @param {string} projectId Project ID
         * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectEnvironmentVariable(projectId: string, environmentVariableRequest?: EnvironmentVariableRequest, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentVariable> {
            return localVarFp.createProjectEnvironmentVariable(projectId, environmentVariableRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to add an alias at project level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at project level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - You can\'t create an alias on an alias 
         * @summary Create an environment variable alias at the project level
         * @param {string} projectId Project ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectEnvironmentVariableAlias(projectId: string, environmentVariableId: string, key?: Key, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentVariable> {
            return localVarFp.createProjectEnvironmentVariableAlias(projectId, environmentVariableId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to override at project level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at project level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
         * @summary Create an environment variable override at the project level
         * @param {string} projectId Project ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectEnvironmentVariableOverride(projectId: string, environmentVariableId: string, value?: Value, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentVariable> {
            return localVarFp.createProjectEnvironmentVariableOverride(projectId, environmentVariableId, value, options).then((request) => request(axios, basePath));
        },
        /**
         * - To delete an environment variable you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete an environment variable from a project
         * @param {string} projectId Project ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectEnvironmentVariable(projectId: string, environmentVariableId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteProjectEnvironmentVariable(projectId, environmentVariableId, options).then((request) => request(axios, basePath));
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit an environment variable belonging to the project
         * @param {string} projectId Project ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editProjectEnvironmentVariable(projectId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentVariable> {
            return localVarFp.editProjectEnvironmentVariable(projectId, environmentVariableId, environmentVariableEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List project environment variables
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectEnvironmentVariable(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentVariableResponseList> {
            return localVarFp.listProjectEnvironmentVariable(projectId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectEnvironmentVariableApi - object-oriented interface
 * @export
 * @class ProjectEnvironmentVariableApi
 * @extends {BaseAPI}
 */
export class ProjectEnvironmentVariableApi extends BaseAPI {
    /**
     * - Add an environment variable to the project.   - If the environment variable key already exists, then it will be replaced by the new one.   - If the environment variable value points toward an existing environment variable key, it will be considered as an alias. 
     * @summary Add an environment variable to the project
     * @param {string} projectId Project ID
     * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectEnvironmentVariableApi
     */
    public createProjectEnvironmentVariable(projectId: string, environmentVariableRequest?: EnvironmentVariableRequest, options?: RawAxiosRequestConfig) {
        return ProjectEnvironmentVariableApiFp(this.configuration).createProjectEnvironmentVariable(projectId, environmentVariableRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to add an alias at project level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at project level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - You can\'t create an alias on an alias 
     * @summary Create an environment variable alias at the project level
     * @param {string} projectId Project ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {Key} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectEnvironmentVariableApi
     */
    public createProjectEnvironmentVariableAlias(projectId: string, environmentVariableId: string, key?: Key, options?: RawAxiosRequestConfig) {
        return ProjectEnvironmentVariableApiFp(this.configuration).createProjectEnvironmentVariableAlias(projectId, environmentVariableId, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to override at project level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at project level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
     * @summary Create an environment variable override at the project level
     * @param {string} projectId Project ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {Value} [value] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectEnvironmentVariableApi
     */
    public createProjectEnvironmentVariableOverride(projectId: string, environmentVariableId: string, value?: Value, options?: RawAxiosRequestConfig) {
        return ProjectEnvironmentVariableApiFp(this.configuration).createProjectEnvironmentVariableOverride(projectId, environmentVariableId, value, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - To delete an environment variable you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
     * @summary Delete an environment variable from a project
     * @param {string} projectId Project ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectEnvironmentVariableApi
     */
    public deleteProjectEnvironmentVariable(projectId: string, environmentVariableId: string, options?: RawAxiosRequestConfig) {
        return ProjectEnvironmentVariableApiFp(this.configuration).deleteProjectEnvironmentVariable(projectId, environmentVariableId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
     * @summary Edit an environment variable belonging to the project
     * @param {string} projectId Project ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectEnvironmentVariableApi
     */
    public editProjectEnvironmentVariable(projectId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options?: RawAxiosRequestConfig) {
        return ProjectEnvironmentVariableApiFp(this.configuration).editProjectEnvironmentVariable(projectId, environmentVariableId, environmentVariableEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List project environment variables
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectEnvironmentVariableApi
     */
    public listProjectEnvironmentVariable(projectId: string, options?: RawAxiosRequestConfig) {
        return ProjectEnvironmentVariableApiFp(this.configuration).listProjectEnvironmentVariable(projectId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProjectMainCallsApi - axios parameter creator
 * @export
 */
export const ProjectMainCallsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * To delete a project you must have the admin permission
         * @summary Delete a project
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteProject', 'projectId', projectId)
            const localVarPath = `/project/{projectId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To edit a project you must have the admin permission
         * @summary Edit a project
         * @param {string} projectId Project ID
         * @param {ProjectRequest} [projectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editProject: async (projectId: string, projectRequest?: ProjectRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('editProject', 'projectId', projectId)
            const localVarPath = `/project/{projectId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get project by ID
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getProject', 'projectId', projectId)
            const localVarPath = `/project/{projectId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectMainCallsApi - functional programming interface
 * @export
 */
export const ProjectMainCallsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectMainCallsApiAxiosParamCreator(configuration)
    return {
        /**
         * To delete a project you must have the admin permission
         * @summary Delete a project
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProject(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProject(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectMainCallsApi.deleteProject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * To edit a project you must have the admin permission
         * @summary Edit a project
         * @param {string} projectId Project ID
         * @param {ProjectRequest} [projectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editProject(projectId: string, projectRequest?: ProjectRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editProject(projectId, projectRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectMainCallsApi.editProject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get project by ID
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProject(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProject(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectMainCallsApi.getProject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProjectMainCallsApi - factory interface
 * @export
 */
export const ProjectMainCallsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectMainCallsApiFp(configuration)
    return {
        /**
         * To delete a project you must have the admin permission
         * @summary Delete a project
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteProject(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * To edit a project you must have the admin permission
         * @summary Edit a project
         * @param {string} projectId Project ID
         * @param {ProjectRequest} [projectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editProject(projectId: string, projectRequest?: ProjectRequest, options?: RawAxiosRequestConfig): AxiosPromise<Project> {
            return localVarFp.editProject(projectId, projectRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get project by ID
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<Project> {
            return localVarFp.getProject(projectId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectMainCallsApi - object-oriented interface
 * @export
 * @class ProjectMainCallsApi
 * @extends {BaseAPI}
 */
export class ProjectMainCallsApi extends BaseAPI {
    /**
     * To delete a project you must have the admin permission
     * @summary Delete a project
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectMainCallsApi
     */
    public deleteProject(projectId: string, options?: RawAxiosRequestConfig) {
        return ProjectMainCallsApiFp(this.configuration).deleteProject(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To edit a project you must have the admin permission
     * @summary Edit a project
     * @param {string} projectId Project ID
     * @param {ProjectRequest} [projectRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectMainCallsApi
     */
    public editProject(projectId: string, projectRequest?: ProjectRequest, options?: RawAxiosRequestConfig) {
        return ProjectMainCallsApiFp(this.configuration).editProject(projectId, projectRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get project by ID
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectMainCallsApi
     */
    public getProject(projectId: string, options?: RawAxiosRequestConfig) {
        return ProjectMainCallsApiFp(this.configuration).getProject(projectId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProjectSecretApi - axios parameter creator
 * @export
 */
export const ProjectSecretApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * - Add a secret to the project.   - If the secret key already exists, then it will be replaced by the new one.   - If the secret value points toward an existing secret key, it will be considered as an alias. 
         * @summary Add a secret to the project
         * @param {string} projectId Project ID
         * @param {SecretRequest} [secretRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectSecret: async (projectId: string, secretRequest?: SecretRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createProjectSecret', 'projectId', projectId)
            const localVarPath = `/project/{projectId}/secret`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(secretRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to add an alias at project level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at project level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - You can\'t create an alias on an alias 
         * @summary Create a secret alias at the project level
         * @param {string} projectId Project ID
         * @param {string} secretId Secret ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectSecretAlias: async (projectId: string, secretId: string, key?: Key, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createProjectSecretAlias', 'projectId', projectId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('createProjectSecretAlias', 'secretId', secretId)
            const localVarPath = `/project/{projectId}/secret/{secretId}/alias`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(key, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to override at project level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at project level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
         * @summary Create a secret override at the project level
         * @param {string} projectId Project ID
         * @param {string} secretId Secret ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectSecretOverride: async (projectId: string, secretId: string, value?: Value, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createProjectSecretOverride', 'projectId', projectId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('createProjectSecretOverride', 'secretId', secretId)
            const localVarPath = `/project/{projectId}/secret/{secretId}/override`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(value, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well  operationId: deleteProjectSecret 
         * @summary Delete a secret from a project
         * @param {string} projectId Project ID
         * @param {string} secretId Secret ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectSecret: async (projectId: string, secretId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteProjectSecret', 'projectId', projectId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('deleteProjectSecret', 'secretId', secretId)
            const localVarPath = `/project/{projectId}/secret/{secretId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit a secret belonging to the project
         * @param {string} projectId Project ID
         * @param {string} secretId Secret ID
         * @param {SecretEditRequest} secretEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editProjectSecret: async (projectId: string, secretId: string, secretEditRequest: SecretEditRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('editProjectSecret', 'projectId', projectId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('editProjectSecret', 'secretId', secretId)
            // verify required parameter 'secretEditRequest' is not null or undefined
            assertParamExists('editProjectSecret', 'secretEditRequest', secretEditRequest)
            const localVarPath = `/project/{projectId}/secret/{secretId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(secretEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List project secrets
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectSecrets: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('listProjectSecrets', 'projectId', projectId)
            const localVarPath = `/project/{projectId}/secret`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectSecretApi - functional programming interface
 * @export
 */
export const ProjectSecretApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectSecretApiAxiosParamCreator(configuration)
    return {
        /**
         * - Add a secret to the project.   - If the secret key already exists, then it will be replaced by the new one.   - If the secret value points toward an existing secret key, it will be considered as an alias. 
         * @summary Add a secret to the project
         * @param {string} projectId Project ID
         * @param {SecretRequest} [secretRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProjectSecret(projectId: string, secretRequest?: SecretRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProjectSecret(projectId, secretRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectSecretApi.createProjectSecret']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - Allows you to add an alias at project level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at project level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - You can\'t create an alias on an alias 
         * @summary Create a secret alias at the project level
         * @param {string} projectId Project ID
         * @param {string} secretId Secret ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProjectSecretAlias(projectId: string, secretId: string, key?: Key, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProjectSecretAlias(projectId, secretId, key, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectSecretApi.createProjectSecretAlias']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - Allows you to override at project level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at project level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
         * @summary Create a secret override at the project level
         * @param {string} projectId Project ID
         * @param {string} secretId Secret ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProjectSecretOverride(projectId: string, secretId: string, value?: Value, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProjectSecretOverride(projectId, secretId, value, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectSecretApi.createProjectSecretOverride']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well  operationId: deleteProjectSecret 
         * @summary Delete a secret from a project
         * @param {string} projectId Project ID
         * @param {string} secretId Secret ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProjectSecret(projectId: string, secretId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProjectSecret(projectId, secretId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectSecretApi.deleteProjectSecret']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit a secret belonging to the project
         * @param {string} projectId Project ID
         * @param {string} secretId Secret ID
         * @param {SecretEditRequest} secretEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editProjectSecret(projectId: string, secretId: string, secretEditRequest: SecretEditRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editProjectSecret(projectId, secretId, secretEditRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectSecretApi.editProjectSecret']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List project secrets
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProjectSecrets(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecretResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProjectSecrets(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectSecretApi.listProjectSecrets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProjectSecretApi - factory interface
 * @export
 */
export const ProjectSecretApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectSecretApiFp(configuration)
    return {
        /**
         * - Add a secret to the project.   - If the secret key already exists, then it will be replaced by the new one.   - If the secret value points toward an existing secret key, it will be considered as an alias. 
         * @summary Add a secret to the project
         * @param {string} projectId Project ID
         * @param {SecretRequest} [secretRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectSecret(projectId: string, secretRequest?: SecretRequest, options?: RawAxiosRequestConfig): AxiosPromise<Secret> {
            return localVarFp.createProjectSecret(projectId, secretRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to add an alias at project level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at project level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - You can\'t create an alias on an alias 
         * @summary Create a secret alias at the project level
         * @param {string} projectId Project ID
         * @param {string} secretId Secret ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectSecretAlias(projectId: string, secretId: string, key?: Key, options?: RawAxiosRequestConfig): AxiosPromise<Secret> {
            return localVarFp.createProjectSecretAlias(projectId, secretId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to override at project level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at project level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
         * @summary Create a secret override at the project level
         * @param {string} projectId Project ID
         * @param {string} secretId Secret ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectSecretOverride(projectId: string, secretId: string, value?: Value, options?: RawAxiosRequestConfig): AxiosPromise<Secret> {
            return localVarFp.createProjectSecretOverride(projectId, secretId, value, options).then((request) => request(axios, basePath));
        },
        /**
         * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well  operationId: deleteProjectSecret 
         * @summary Delete a secret from a project
         * @param {string} projectId Project ID
         * @param {string} secretId Secret ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectSecret(projectId: string, secretId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteProjectSecret(projectId, secretId, options).then((request) => request(axios, basePath));
        },
        /**
         * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit a secret belonging to the project
         * @param {string} projectId Project ID
         * @param {string} secretId Secret ID
         * @param {SecretEditRequest} secretEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editProjectSecret(projectId: string, secretId: string, secretEditRequest: SecretEditRequest, options?: RawAxiosRequestConfig): AxiosPromise<Secret> {
            return localVarFp.editProjectSecret(projectId, secretId, secretEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List project secrets
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectSecrets(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<SecretResponseList> {
            return localVarFp.listProjectSecrets(projectId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectSecretApi - object-oriented interface
 * @export
 * @class ProjectSecretApi
 * @extends {BaseAPI}
 */
export class ProjectSecretApi extends BaseAPI {
    /**
     * - Add a secret to the project.   - If the secret key already exists, then it will be replaced by the new one.   - If the secret value points toward an existing secret key, it will be considered as an alias. 
     * @summary Add a secret to the project
     * @param {string} projectId Project ID
     * @param {SecretRequest} [secretRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSecretApi
     */
    public createProjectSecret(projectId: string, secretRequest?: SecretRequest, options?: RawAxiosRequestConfig) {
        return ProjectSecretApiFp(this.configuration).createProjectSecret(projectId, secretRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to add an alias at project level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at project level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - You can\'t create an alias on an alias 
     * @summary Create a secret alias at the project level
     * @param {string} projectId Project ID
     * @param {string} secretId Secret ID
     * @param {Key} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSecretApi
     */
    public createProjectSecretAlias(projectId: string, secretId: string, key?: Key, options?: RawAxiosRequestConfig) {
        return ProjectSecretApiFp(this.configuration).createProjectSecretAlias(projectId, secretId, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to override at project level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at project level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
     * @summary Create a secret override at the project level
     * @param {string} projectId Project ID
     * @param {string} secretId Secret ID
     * @param {Value} [value] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSecretApi
     */
    public createProjectSecretOverride(projectId: string, secretId: string, value?: Value, options?: RawAxiosRequestConfig) {
        return ProjectSecretApiFp(this.configuration).createProjectSecretOverride(projectId, secretId, value, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well  operationId: deleteProjectSecret 
     * @summary Delete a secret from a project
     * @param {string} projectId Project ID
     * @param {string} secretId Secret ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSecretApi
     */
    public deleteProjectSecret(projectId: string, secretId: string, options?: RawAxiosRequestConfig) {
        return ProjectSecretApiFp(this.configuration).deleteProjectSecret(projectId, secretId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
     * @summary Edit a secret belonging to the project
     * @param {string} projectId Project ID
     * @param {string} secretId Secret ID
     * @param {SecretEditRequest} secretEditRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSecretApi
     */
    public editProjectSecret(projectId: string, secretId: string, secretEditRequest: SecretEditRequest, options?: RawAxiosRequestConfig) {
        return ProjectSecretApiFp(this.configuration).editProjectSecret(projectId, secretId, secretEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List project secrets
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSecretApi
     */
    public listProjectSecrets(projectId: string, options?: RawAxiosRequestConfig) {
        return ProjectSecretApiFp(this.configuration).listProjectSecrets(projectId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProjectsApi - axios parameter creator
 * @export
 */
export const ProjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a project
         * @param {string} organizationId Organization ID
         * @param {ProjectRequest} [projectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject: async (organizationId: string, projectRequest?: ProjectRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createProject', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/project`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of project ids, and for each its total numberof services and environments
         * @summary List total number of services and environments for each project of the organization
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationProjectStats: async (organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationProjectStats', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/project/stats`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List projects
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProject: async (organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listProject', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/project`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsApi - functional programming interface
 * @export
 */
export const ProjectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a project
         * @param {string} organizationId Organization ID
         * @param {ProjectRequest} [projectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProject(organizationId: string, projectRequest?: ProjectRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProject(organizationId, projectRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.createProject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of project ids, and for each its total numberof services and environments
         * @summary List total number of services and environments for each project of the organization
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationProjectStats(organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectStatsResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationProjectStats(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.getOrganizationProjectStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List projects
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProject(organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProject(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.listProject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProjectsApi - factory interface
 * @export
 */
export const ProjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a project
         * @param {string} organizationId Organization ID
         * @param {ProjectRequest} [projectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject(organizationId: string, projectRequest?: ProjectRequest, options?: RawAxiosRequestConfig): AxiosPromise<Project> {
            return localVarFp.createProject(organizationId, projectRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of project ids, and for each its total numberof services and environments
         * @summary List total number of services and environments for each project of the organization
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationProjectStats(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise<ProjectStatsResponseList> {
            return localVarFp.getOrganizationProjectStats(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List projects
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProject(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise<ProjectResponseList> {
            return localVarFp.listProject(organizationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectsApi - object-oriented interface
 * @export
 * @class ProjectsApi
 * @extends {BaseAPI}
 */
export class ProjectsApi extends BaseAPI {
    /**
     * 
     * @summary Create a project
     * @param {string} organizationId Organization ID
     * @param {ProjectRequest} [projectRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public createProject(organizationId: string, projectRequest?: ProjectRequest, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).createProject(organizationId, projectRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of project ids, and for each its total numberof services and environments
     * @summary List total number of services and environments for each project of the organization
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getOrganizationProjectStats(organizationId: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).getOrganizationProjectStats(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List projects
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public listProject(organizationId: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).listProject(organizationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReferralRewardsApi - axios parameter creator
 * @export
 */
export const ReferralRewardsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get your referral information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountReferral: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/referral`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A same code can be claimed only 3 times at max
         * @summary Claim a reward
         * @param {RewardClaim} [rewardClaim] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAccountRewardClaim: async (rewardClaim?: RewardClaim, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/rewardClaim`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rewardClaim, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReferralRewardsApi - functional programming interface
 * @export
 */
export const ReferralRewardsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReferralRewardsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get your referral information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountReferral(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Referral>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountReferral(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReferralRewardsApi.getAccountReferral']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * A same code can be claimed only 3 times at max
         * @summary Claim a reward
         * @param {RewardClaim} [rewardClaim] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAccountRewardClaim(rewardClaim?: RewardClaim, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postAccountRewardClaim(rewardClaim, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReferralRewardsApi.postAccountRewardClaim']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReferralRewardsApi - factory interface
 * @export
 */
export const ReferralRewardsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReferralRewardsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get your referral information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountReferral(options?: RawAxiosRequestConfig): AxiosPromise<Referral> {
            return localVarFp.getAccountReferral(options).then((request) => request(axios, basePath));
        },
        /**
         * A same code can be claimed only 3 times at max
         * @summary Claim a reward
         * @param {RewardClaim} [rewardClaim] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAccountRewardClaim(rewardClaim?: RewardClaim, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postAccountRewardClaim(rewardClaim, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReferralRewardsApi - object-oriented interface
 * @export
 * @class ReferralRewardsApi
 * @extends {BaseAPI}
 */
export class ReferralRewardsApi extends BaseAPI {
    /**
     * 
     * @summary Get your referral information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferralRewardsApi
     */
    public getAccountReferral(options?: RawAxiosRequestConfig) {
        return ReferralRewardsApiFp(this.configuration).getAccountReferral(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A same code can be claimed only 3 times at max
     * @summary Claim a reward
     * @param {RewardClaim} [rewardClaim] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferralRewardsApi
     */
    public postAccountRewardClaim(rewardClaim?: RewardClaim, options?: RawAxiosRequestConfig) {
        return ReferralRewardsApiFp(this.configuration).postAccountRewardClaim(rewardClaim, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ServiceStatusApi - axios parameter creator
 * @export
 */
export const ServiceStatusApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Ingress Deployment Status By Service
         * @param {GetIngressDeploymentStatusServiceTypeEnum} serviceType 
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIngressDeploymentStatus: async (serviceType: GetIngressDeploymentStatusServiceTypeEnum, serviceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceType' is not null or undefined
            assertParamExists('getIngressDeploymentStatus', 'serviceType', serviceType)
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('getIngressDeploymentStatus', 'serviceId', serviceId)
            const localVarPath = `/{serviceType}/{serviceId}/ingressDeploymentStatus`
                .replace(`{${"serviceType"}}`, encodeURIComponent(String(serviceType)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServiceStatusApi - functional programming interface
 * @export
 */
export const ServiceStatusApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServiceStatusApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Ingress Deployment Status By Service
         * @param {GetIngressDeploymentStatusServiceTypeEnum} serviceType 
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIngressDeploymentStatus(serviceType: GetIngressDeploymentStatusServiceTypeEnum, serviceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IngressDeploymentStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIngressDeploymentStatus(serviceType, serviceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServiceStatusApi.getIngressDeploymentStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ServiceStatusApi - factory interface
 * @export
 */
export const ServiceStatusApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServiceStatusApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Ingress Deployment Status By Service
         * @param {GetIngressDeploymentStatusServiceTypeEnum} serviceType 
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIngressDeploymentStatus(serviceType: GetIngressDeploymentStatusServiceTypeEnum, serviceId: string, options?: RawAxiosRequestConfig): AxiosPromise<IngressDeploymentStatusResponse> {
            return localVarFp.getIngressDeploymentStatus(serviceType, serviceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServiceStatusApi - object-oriented interface
 * @export
 * @class ServiceStatusApi
 * @extends {BaseAPI}
 */
export class ServiceStatusApi extends BaseAPI {
    /**
     * 
     * @summary Get Ingress Deployment Status By Service
     * @param {GetIngressDeploymentStatusServiceTypeEnum} serviceType 
     * @param {string} serviceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceStatusApi
     */
    public getIngressDeploymentStatus(serviceType: GetIngressDeploymentStatusServiceTypeEnum, serviceId: string, options?: RawAxiosRequestConfig) {
        return ServiceStatusApiFp(this.configuration).getIngressDeploymentStatus(serviceType, serviceId, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetIngressDeploymentStatusServiceTypeEnum = {
    CONTAINER: 'CONTAINER',
    APPLICATION: 'APPLICATION',
    HELM: 'HELM'
} as const;
export type GetIngressDeploymentStatusServiceTypeEnum = typeof GetIngressDeploymentStatusServiceTypeEnum[keyof typeof GetIngressDeploymentStatusServiceTypeEnum];


/**
 * TerraformActionsApi - axios parameter creator
 * @export
 */
export const TerraformActionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * You must provide a git commit id.
         * @summary Deploy terraform
         * @param {string} terraformId Terraform ID
         * @param {TerraformDeployRequest} [terraformDeployRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployTerraform: async (terraformId: string, terraformDeployRequest?: TerraformDeployRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'terraformId' is not null or undefined
            assertParamExists('deployTerraform', 'terraformId', terraformId)
            const localVarPath = `/terraform/{terraformId}/deploy`
                .replace(`{${"terraformId"}}`, encodeURIComponent(String(terraformId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(terraformDeployRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Redeploy terraform
         * @param {string} terraformId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeployTerraform: async (terraformId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'terraformId' is not null or undefined
            assertParamExists('redeployTerraform', 'terraformId', terraformId)
            const localVarPath = `/terraform/{terraformId}/redeploy`
                .replace(`{${"terraformId"}}`, encodeURIComponent(String(terraformId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the resources of the terraform but keep Qovery configuration
         * @summary Uninstall terraform
         * @param {string} terraformId Terraform ID
         * @param {DeleteTerraformAction} [forceTerraformAction] Force a specific action to be executed by Terraform during uninstall.
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uninstallTerraform: async (terraformId: string, forceTerraformAction?: DeleteTerraformAction, body?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'terraformId' is not null or undefined
            assertParamExists('uninstallTerraform', 'terraformId', terraformId)
            const localVarPath = `/terraform/{terraformId}/uninstall`
                .replace(`{${"terraformId"}}`, encodeURIComponent(String(terraformId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (forceTerraformAction !== undefined) {
                localVarQueryParameter['force_terraform_action'] = forceTerraformAction;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TerraformActionsApi - functional programming interface
 * @export
 */
export const TerraformActionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TerraformActionsApiAxiosParamCreator(configuration)
    return {
        /**
         * You must provide a git commit id.
         * @summary Deploy terraform
         * @param {string} terraformId Terraform ID
         * @param {TerraformDeployRequest} [terraformDeployRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployTerraform(terraformId: string, terraformDeployRequest?: TerraformDeployRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployTerraform(terraformId, terraformDeployRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TerraformActionsApi.deployTerraform']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Redeploy terraform
         * @param {string} terraformId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async redeployTerraform(terraformId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.redeployTerraform(terraformId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TerraformActionsApi.redeployTerraform']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete the resources of the terraform but keep Qovery configuration
         * @summary Uninstall terraform
         * @param {string} terraformId Terraform ID
         * @param {DeleteTerraformAction} [forceTerraformAction] Force a specific action to be executed by Terraform during uninstall.
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uninstallTerraform(terraformId: string, forceTerraformAction?: DeleteTerraformAction, body?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uninstallTerraform(terraformId, forceTerraformAction, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TerraformActionsApi.uninstallTerraform']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TerraformActionsApi - factory interface
 * @export
 */
export const TerraformActionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TerraformActionsApiFp(configuration)
    return {
        /**
         * You must provide a git commit id.
         * @summary Deploy terraform
         * @param {string} terraformId Terraform ID
         * @param {TerraformDeployRequest} [terraformDeployRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployTerraform(terraformId: string, terraformDeployRequest?: TerraformDeployRequest, options?: RawAxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.deployTerraform(terraformId, terraformDeployRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Redeploy terraform
         * @param {string} terraformId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeployTerraform(terraformId: string, options?: RawAxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.redeployTerraform(terraformId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete the resources of the terraform but keep Qovery configuration
         * @summary Uninstall terraform
         * @param {string} terraformId Terraform ID
         * @param {DeleteTerraformAction} [forceTerraformAction] Force a specific action to be executed by Terraform during uninstall.
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uninstallTerraform(terraformId: string, forceTerraformAction?: DeleteTerraformAction, body?: object, options?: RawAxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.uninstallTerraform(terraformId, forceTerraformAction, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TerraformActionsApi - object-oriented interface
 * @export
 * @class TerraformActionsApi
 * @extends {BaseAPI}
 */
export class TerraformActionsApi extends BaseAPI {
    /**
     * You must provide a git commit id.
     * @summary Deploy terraform
     * @param {string} terraformId Terraform ID
     * @param {TerraformDeployRequest} [terraformDeployRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TerraformActionsApi
     */
    public deployTerraform(terraformId: string, terraformDeployRequest?: TerraformDeployRequest, options?: RawAxiosRequestConfig) {
        return TerraformActionsApiFp(this.configuration).deployTerraform(terraformId, terraformDeployRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Redeploy terraform
     * @param {string} terraformId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TerraformActionsApi
     */
    public redeployTerraform(terraformId: string, options?: RawAxiosRequestConfig) {
        return TerraformActionsApiFp(this.configuration).redeployTerraform(terraformId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete the resources of the terraform but keep Qovery configuration
     * @summary Uninstall terraform
     * @param {string} terraformId Terraform ID
     * @param {DeleteTerraformAction} [forceTerraformAction] Force a specific action to be executed by Terraform during uninstall.
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TerraformActionsApi
     */
    public uninstallTerraform(terraformId: string, forceTerraformAction?: DeleteTerraformAction, body?: object, options?: RawAxiosRequestConfig) {
        return TerraformActionsApiFp(this.configuration).uninstallTerraform(terraformId, forceTerraformAction, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TerraformConfigurationApi - axios parameter creator
 * @export
 */
export const TerraformConfigurationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Edit Advanced settings
         * @param {string} terraformId 
         * @param {TerraformAdvancedSettings} [terraformAdvancedSettings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editTerraformAdvancedSettings: async (terraformId: string, terraformAdvancedSettings?: TerraformAdvancedSettings, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'terraformId' is not null or undefined
            assertParamExists('editTerraformAdvancedSettings', 'terraformId', terraformId)
            const localVarPath = `/terraform/{terraformId}/advancedSettings`
                .replace(`{${"terraformId"}}`, encodeURIComponent(String(terraformId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(terraformAdvancedSettings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Advanced settings
         * @param {string} terraformId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTerraformAdvancedSettings: async (terraformId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'terraformId' is not null or undefined
            assertParamExists('getTerraformAdvancedSettings', 'terraformId', terraformId)
            const localVarPath = `/terraform/{terraformId}/advancedSettings`
                .replace(`{${"terraformId"}}`, encodeURIComponent(String(terraformId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TerraformConfigurationApi - functional programming interface
 * @export
 */
export const TerraformConfigurationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TerraformConfigurationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Edit Advanced settings
         * @param {string} terraformId 
         * @param {TerraformAdvancedSettings} [terraformAdvancedSettings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editTerraformAdvancedSettings(terraformId: string, terraformAdvancedSettings?: TerraformAdvancedSettings, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TerraformAdvancedSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editTerraformAdvancedSettings(terraformId, terraformAdvancedSettings, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TerraformConfigurationApi.editTerraformAdvancedSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Advanced settings
         * @param {string} terraformId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTerraformAdvancedSettings(terraformId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TerraformAdvancedSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTerraformAdvancedSettings(terraformId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TerraformConfigurationApi.getTerraformAdvancedSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TerraformConfigurationApi - factory interface
 * @export
 */
export const TerraformConfigurationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TerraformConfigurationApiFp(configuration)
    return {
        /**
         * 
         * @summary Edit Advanced settings
         * @param {string} terraformId 
         * @param {TerraformAdvancedSettings} [terraformAdvancedSettings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editTerraformAdvancedSettings(terraformId: string, terraformAdvancedSettings?: TerraformAdvancedSettings, options?: RawAxiosRequestConfig): AxiosPromise<TerraformAdvancedSettings> {
            return localVarFp.editTerraformAdvancedSettings(terraformId, terraformAdvancedSettings, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Advanced settings
         * @param {string} terraformId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTerraformAdvancedSettings(terraformId: string, options?: RawAxiosRequestConfig): AxiosPromise<TerraformAdvancedSettings> {
            return localVarFp.getTerraformAdvancedSettings(terraformId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TerraformConfigurationApi - object-oriented interface
 * @export
 * @class TerraformConfigurationApi
 * @extends {BaseAPI}
 */
export class TerraformConfigurationApi extends BaseAPI {
    /**
     * 
     * @summary Edit Advanced settings
     * @param {string} terraformId 
     * @param {TerraformAdvancedSettings} [terraformAdvancedSettings] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TerraformConfigurationApi
     */
    public editTerraformAdvancedSettings(terraformId: string, terraformAdvancedSettings?: TerraformAdvancedSettings, options?: RawAxiosRequestConfig) {
        return TerraformConfigurationApiFp(this.configuration).editTerraformAdvancedSettings(terraformId, terraformAdvancedSettings, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Advanced settings
     * @param {string} terraformId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TerraformConfigurationApi
     */
    public getTerraformAdvancedSettings(terraformId: string, options?: RawAxiosRequestConfig) {
        return TerraformConfigurationApiFp(this.configuration).getTerraformAdvancedSettings(terraformId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TerraformDeploymentHistoryApi - axios parameter creator
 * @export
 */
export const TerraformDeploymentHistoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the 20 last terraform deployments
         * @summary List terraform deployments
         * @param {string} terraformId 
         * @param {number | null} [pageSize] The number of deployments to return in the current page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTerraformDeploymentHistoryV2: async (terraformId: string, pageSize?: number | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'terraformId' is not null or undefined
            assertParamExists('listTerraformDeploymentHistoryV2', 'terraformId', terraformId)
            const localVarPath = `/terraform/{terraformId}/deploymentHistoryV2`
                .replace(`{${"terraformId"}}`, encodeURIComponent(String(terraformId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TerraformDeploymentHistoryApi - functional programming interface
 * @export
 */
export const TerraformDeploymentHistoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TerraformDeploymentHistoryApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the 20 last terraform deployments
         * @summary List terraform deployments
         * @param {string} terraformId 
         * @param {number | null} [pageSize] The number of deployments to return in the current page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTerraformDeploymentHistoryV2(terraformId: string, pageSize?: number | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentHistoryServicePaginatedResponseListV2>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTerraformDeploymentHistoryV2(terraformId, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TerraformDeploymentHistoryApi.listTerraformDeploymentHistoryV2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TerraformDeploymentHistoryApi - factory interface
 * @export
 */
export const TerraformDeploymentHistoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TerraformDeploymentHistoryApiFp(configuration)
    return {
        /**
         * Returns the 20 last terraform deployments
         * @summary List terraform deployments
         * @param {string} terraformId 
         * @param {number | null} [pageSize] The number of deployments to return in the current page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTerraformDeploymentHistoryV2(terraformId: string, pageSize?: number | null, options?: RawAxiosRequestConfig): AxiosPromise<DeploymentHistoryServicePaginatedResponseListV2> {
            return localVarFp.listTerraformDeploymentHistoryV2(terraformId, pageSize, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TerraformDeploymentHistoryApi - object-oriented interface
 * @export
 * @class TerraformDeploymentHistoryApi
 * @extends {BaseAPI}
 */
export class TerraformDeploymentHistoryApi extends BaseAPI {
    /**
     * Returns the 20 last terraform deployments
     * @summary List terraform deployments
     * @param {string} terraformId 
     * @param {number | null} [pageSize] The number of deployments to return in the current page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TerraformDeploymentHistoryApi
     */
    public listTerraformDeploymentHistoryV2(terraformId: string, pageSize?: number | null, options?: RawAxiosRequestConfig) {
        return TerraformDeploymentHistoryApiFp(this.configuration).listTerraformDeploymentHistoryV2(terraformId, pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TerraformDeploymentRestrictionApi - axios parameter creator
 * @export
 */
export const TerraformDeploymentRestrictionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a terraform deployment restriction
         * @summary Create a terraform deployment restriction
         * @param {string} terraformId 
         * @param {TerraformDeploymentRestrictionRequest} [terraformDeploymentRestrictionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTerraformDeploymentRestriction: async (terraformId: string, terraformDeploymentRestrictionRequest?: TerraformDeploymentRestrictionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'terraformId' is not null or undefined
            assertParamExists('createTerraformDeploymentRestriction', 'terraformId', terraformId)
            const localVarPath = `/terraform/{terraformId}/deploymentRestriction`
                .replace(`{${"terraformId"}}`, encodeURIComponent(String(terraformId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(terraformDeploymentRestrictionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a terraform deployment restriction
         * @summary Delete a terraform deployment restriction
         * @param {string} terraformId 
         * @param {string} deploymentRestrictionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTerraformDeploymentRestriction: async (terraformId: string, deploymentRestrictionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'terraformId' is not null or undefined
            assertParamExists('deleteTerraformDeploymentRestriction', 'terraformId', terraformId)
            // verify required parameter 'deploymentRestrictionId' is not null or undefined
            assertParamExists('deleteTerraformDeploymentRestriction', 'deploymentRestrictionId', deploymentRestrictionId)
            const localVarPath = `/terraform/{terraformId}/deploymentRestriction/{deploymentRestrictionId}`
                .replace(`{${"terraformId"}}`, encodeURIComponent(String(terraformId)))
                .replace(`{${"deploymentRestrictionId"}}`, encodeURIComponent(String(deploymentRestrictionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit a terraform deployment restriction
         * @summary Edit a terraform deployment restriction
         * @param {string} terraformId 
         * @param {string} deploymentRestrictionId 
         * @param {TerraformDeploymentRestrictionRequest} [terraformDeploymentRestrictionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editTerraformDeploymentRestriction: async (terraformId: string, deploymentRestrictionId: string, terraformDeploymentRestrictionRequest?: TerraformDeploymentRestrictionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'terraformId' is not null or undefined
            assertParamExists('editTerraformDeploymentRestriction', 'terraformId', terraformId)
            // verify required parameter 'deploymentRestrictionId' is not null or undefined
            assertParamExists('editTerraformDeploymentRestriction', 'deploymentRestrictionId', deploymentRestrictionId)
            const localVarPath = `/terraform/{terraformId}/deploymentRestriction/{deploymentRestrictionId}`
                .replace(`{${"terraformId"}}`, encodeURIComponent(String(terraformId)))
                .replace(`{${"deploymentRestrictionId"}}`, encodeURIComponent(String(deploymentRestrictionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(terraformDeploymentRestrictionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get terraform deployment restrictions
         * @summary Get terraform deployment restrictions
         * @param {string} terraformId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTerraformDeploymentRestrictions: async (terraformId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'terraformId' is not null or undefined
            assertParamExists('getTerraformDeploymentRestrictions', 'terraformId', terraformId)
            const localVarPath = `/terraform/{terraformId}/deploymentRestriction`
                .replace(`{${"terraformId"}}`, encodeURIComponent(String(terraformId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TerraformDeploymentRestrictionApi - functional programming interface
 * @export
 */
export const TerraformDeploymentRestrictionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TerraformDeploymentRestrictionApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a terraform deployment restriction
         * @summary Create a terraform deployment restriction
         * @param {string} terraformId 
         * @param {TerraformDeploymentRestrictionRequest} [terraformDeploymentRestrictionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTerraformDeploymentRestriction(terraformId: string, terraformDeploymentRestrictionRequest?: TerraformDeploymentRestrictionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TerraformDeploymentRestrictionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTerraformDeploymentRestriction(terraformId, terraformDeploymentRestrictionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TerraformDeploymentRestrictionApi.createTerraformDeploymentRestriction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a terraform deployment restriction
         * @summary Delete a terraform deployment restriction
         * @param {string} terraformId 
         * @param {string} deploymentRestrictionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTerraformDeploymentRestriction(terraformId: string, deploymentRestrictionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTerraformDeploymentRestriction(terraformId, deploymentRestrictionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TerraformDeploymentRestrictionApi.deleteTerraformDeploymentRestriction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Edit a terraform deployment restriction
         * @summary Edit a terraform deployment restriction
         * @param {string} terraformId 
         * @param {string} deploymentRestrictionId 
         * @param {TerraformDeploymentRestrictionRequest} [terraformDeploymentRestrictionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editTerraformDeploymentRestriction(terraformId: string, deploymentRestrictionId: string, terraformDeploymentRestrictionRequest?: TerraformDeploymentRestrictionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TerraformDeploymentRestrictionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editTerraformDeploymentRestriction(terraformId, deploymentRestrictionId, terraformDeploymentRestrictionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TerraformDeploymentRestrictionApi.editTerraformDeploymentRestriction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get terraform deployment restrictions
         * @summary Get terraform deployment restrictions
         * @param {string} terraformId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTerraformDeploymentRestrictions(terraformId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TerraformDeploymentRestrictionResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTerraformDeploymentRestrictions(terraformId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TerraformDeploymentRestrictionApi.getTerraformDeploymentRestrictions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TerraformDeploymentRestrictionApi - factory interface
 * @export
 */
export const TerraformDeploymentRestrictionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TerraformDeploymentRestrictionApiFp(configuration)
    return {
        /**
         * Create a terraform deployment restriction
         * @summary Create a terraform deployment restriction
         * @param {string} terraformId 
         * @param {TerraformDeploymentRestrictionRequest} [terraformDeploymentRestrictionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTerraformDeploymentRestriction(terraformId: string, terraformDeploymentRestrictionRequest?: TerraformDeploymentRestrictionRequest, options?: RawAxiosRequestConfig): AxiosPromise<TerraformDeploymentRestrictionResponse> {
            return localVarFp.createTerraformDeploymentRestriction(terraformId, terraformDeploymentRestrictionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a terraform deployment restriction
         * @summary Delete a terraform deployment restriction
         * @param {string} terraformId 
         * @param {string} deploymentRestrictionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTerraformDeploymentRestriction(terraformId: string, deploymentRestrictionId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteTerraformDeploymentRestriction(terraformId, deploymentRestrictionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit a terraform deployment restriction
         * @summary Edit a terraform deployment restriction
         * @param {string} terraformId 
         * @param {string} deploymentRestrictionId 
         * @param {TerraformDeploymentRestrictionRequest} [terraformDeploymentRestrictionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editTerraformDeploymentRestriction(terraformId: string, deploymentRestrictionId: string, terraformDeploymentRestrictionRequest?: TerraformDeploymentRestrictionRequest, options?: RawAxiosRequestConfig): AxiosPromise<TerraformDeploymentRestrictionResponse> {
            return localVarFp.editTerraformDeploymentRestriction(terraformId, deploymentRestrictionId, terraformDeploymentRestrictionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get terraform deployment restrictions
         * @summary Get terraform deployment restrictions
         * @param {string} terraformId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTerraformDeploymentRestrictions(terraformId: string, options?: RawAxiosRequestConfig): AxiosPromise<TerraformDeploymentRestrictionResponseList> {
            return localVarFp.getTerraformDeploymentRestrictions(terraformId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TerraformDeploymentRestrictionApi - object-oriented interface
 * @export
 * @class TerraformDeploymentRestrictionApi
 * @extends {BaseAPI}
 */
export class TerraformDeploymentRestrictionApi extends BaseAPI {
    /**
     * Create a terraform deployment restriction
     * @summary Create a terraform deployment restriction
     * @param {string} terraformId 
     * @param {TerraformDeploymentRestrictionRequest} [terraformDeploymentRestrictionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TerraformDeploymentRestrictionApi
     */
    public createTerraformDeploymentRestriction(terraformId: string, terraformDeploymentRestrictionRequest?: TerraformDeploymentRestrictionRequest, options?: RawAxiosRequestConfig) {
        return TerraformDeploymentRestrictionApiFp(this.configuration).createTerraformDeploymentRestriction(terraformId, terraformDeploymentRestrictionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a terraform deployment restriction
     * @summary Delete a terraform deployment restriction
     * @param {string} terraformId 
     * @param {string} deploymentRestrictionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TerraformDeploymentRestrictionApi
     */
    public deleteTerraformDeploymentRestriction(terraformId: string, deploymentRestrictionId: string, options?: RawAxiosRequestConfig) {
        return TerraformDeploymentRestrictionApiFp(this.configuration).deleteTerraformDeploymentRestriction(terraformId, deploymentRestrictionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit a terraform deployment restriction
     * @summary Edit a terraform deployment restriction
     * @param {string} terraformId 
     * @param {string} deploymentRestrictionId 
     * @param {TerraformDeploymentRestrictionRequest} [terraformDeploymentRestrictionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TerraformDeploymentRestrictionApi
     */
    public editTerraformDeploymentRestriction(terraformId: string, deploymentRestrictionId: string, terraformDeploymentRestrictionRequest?: TerraformDeploymentRestrictionRequest, options?: RawAxiosRequestConfig) {
        return TerraformDeploymentRestrictionApiFp(this.configuration).editTerraformDeploymentRestriction(terraformId, deploymentRestrictionId, terraformDeploymentRestrictionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get terraform deployment restrictions
     * @summary Get terraform deployment restrictions
     * @param {string} terraformId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TerraformDeploymentRestrictionApi
     */
    public getTerraformDeploymentRestrictions(terraformId: string, options?: RawAxiosRequestConfig) {
        return TerraformDeploymentRestrictionApiFp(this.configuration).getTerraformDeploymentRestrictions(terraformId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TerraformMainCallsApi - axios parameter creator
 * @export
 */
export const TerraformMainCallsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete Terraform
         * @param {string} terraformId Terraform ID
         * @param {boolean} [resourcesOnly] When true, only resources are deleted and Qovery configuration is kept.
         * @param {DeleteTerraformAction} [forceTerraformAction] Force a specific action to be executed by Terraform during deletion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTerraform: async (terraformId: string, resourcesOnly?: boolean, forceTerraformAction?: DeleteTerraformAction, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'terraformId' is not null or undefined
            assertParamExists('deleteTerraform', 'terraformId', terraformId)
            const localVarPath = `/terraform/{terraformId}`
                .replace(`{${"terraformId"}}`, encodeURIComponent(String(terraformId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (resourcesOnly !== undefined) {
                localVarQueryParameter['resources_only'] = resourcesOnly;
            }

            if (forceTerraformAction !== undefined) {
                localVarQueryParameter['force_terraform_action'] = forceTerraformAction;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit Terraform
         * @param {string} terraformId Terraform ID
         * @param {TerraformRequest} [terraformRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editTerraform: async (terraformId: string, terraformRequest?: TerraformRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'terraformId' is not null or undefined
            assertParamExists('editTerraform', 'terraformId', terraformId)
            const localVarPath = `/terraform/{terraformId}`
                .replace(`{${"terraformId"}}`, encodeURIComponent(String(terraformId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(terraformRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get terraform by ID
         * @param {string} terraformId Terraform ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTerraform: async (terraformId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'terraformId' is not null or undefined
            assertParamExists('getTerraform', 'terraformId', terraformId)
            const localVarPath = `/terraform/{terraformId}`
                .replace(`{${"terraformId"}}`, encodeURIComponent(String(terraformId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns list of the last 100 commits made on the repository linked to the terraform service
         * @summary List last commits
         * @param {string} terraformId Terraform ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTerraformCommit: async (terraformId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'terraformId' is not null or undefined
            assertParamExists('listTerraformCommit', 'terraformId', terraformId)
            const localVarPath = `/terraform/{terraformId}/commit`
                .replace(`{${"terraformId"}}`, encodeURIComponent(String(terraformId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List available Terraform versions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTerraformVersions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/terraform/availableVersion`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TerraformMainCallsApi - functional programming interface
 * @export
 */
export const TerraformMainCallsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TerraformMainCallsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete Terraform
         * @param {string} terraformId Terraform ID
         * @param {boolean} [resourcesOnly] When true, only resources are deleted and Qovery configuration is kept.
         * @param {DeleteTerraformAction} [forceTerraformAction] Force a specific action to be executed by Terraform during deletion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTerraform(terraformId: string, resourcesOnly?: boolean, forceTerraformAction?: DeleteTerraformAction, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTerraform(terraformId, resourcesOnly, forceTerraformAction, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TerraformMainCallsApi.deleteTerraform']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Edit Terraform
         * @param {string} terraformId Terraform ID
         * @param {TerraformRequest} [terraformRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editTerraform(terraformId: string, terraformRequest?: TerraformRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TerraformResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editTerraform(terraformId, terraformRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TerraformMainCallsApi.editTerraform']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get terraform by ID
         * @param {string} terraformId Terraform ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTerraform(terraformId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TerraformResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTerraform(terraformId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TerraformMainCallsApi.getTerraform']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns list of the last 100 commits made on the repository linked to the terraform service
         * @summary List last commits
         * @param {string} terraformId Terraform ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTerraformCommit(terraformId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommitResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTerraformCommit(terraformId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TerraformMainCallsApi.listTerraformCommit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List available Terraform versions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTerraformVersions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TerraformVersionResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTerraformVersions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TerraformMainCallsApi.listTerraformVersions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TerraformMainCallsApi - factory interface
 * @export
 */
export const TerraformMainCallsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TerraformMainCallsApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete Terraform
         * @param {string} terraformId Terraform ID
         * @param {boolean} [resourcesOnly] When true, only resources are deleted and Qovery configuration is kept.
         * @param {DeleteTerraformAction} [forceTerraformAction] Force a specific action to be executed by Terraform during deletion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTerraform(terraformId: string, resourcesOnly?: boolean, forceTerraformAction?: DeleteTerraformAction, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteTerraform(terraformId, resourcesOnly, forceTerraformAction, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit Terraform
         * @param {string} terraformId Terraform ID
         * @param {TerraformRequest} [terraformRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editTerraform(terraformId: string, terraformRequest?: TerraformRequest, options?: RawAxiosRequestConfig): AxiosPromise<TerraformResponse> {
            return localVarFp.editTerraform(terraformId, terraformRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get terraform by ID
         * @param {string} terraformId Terraform ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTerraform(terraformId: string, options?: RawAxiosRequestConfig): AxiosPromise<TerraformResponse> {
            return localVarFp.getTerraform(terraformId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns list of the last 100 commits made on the repository linked to the terraform service
         * @summary List last commits
         * @param {string} terraformId Terraform ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTerraformCommit(terraformId: string, options?: RawAxiosRequestConfig): AxiosPromise<CommitResponseList> {
            return localVarFp.listTerraformCommit(terraformId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List available Terraform versions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTerraformVersions(options?: RawAxiosRequestConfig): AxiosPromise<TerraformVersionResponseList> {
            return localVarFp.listTerraformVersions(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TerraformMainCallsApi - object-oriented interface
 * @export
 * @class TerraformMainCallsApi
 * @extends {BaseAPI}
 */
export class TerraformMainCallsApi extends BaseAPI {
    /**
     * 
     * @summary Delete Terraform
     * @param {string} terraformId Terraform ID
     * @param {boolean} [resourcesOnly] When true, only resources are deleted and Qovery configuration is kept.
     * @param {DeleteTerraformAction} [forceTerraformAction] Force a specific action to be executed by Terraform during deletion.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TerraformMainCallsApi
     */
    public deleteTerraform(terraformId: string, resourcesOnly?: boolean, forceTerraformAction?: DeleteTerraformAction, options?: RawAxiosRequestConfig) {
        return TerraformMainCallsApiFp(this.configuration).deleteTerraform(terraformId, resourcesOnly, forceTerraformAction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit Terraform
     * @param {string} terraformId Terraform ID
     * @param {TerraformRequest} [terraformRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TerraformMainCallsApi
     */
    public editTerraform(terraformId: string, terraformRequest?: TerraformRequest, options?: RawAxiosRequestConfig) {
        return TerraformMainCallsApiFp(this.configuration).editTerraform(terraformId, terraformRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get terraform by ID
     * @param {string} terraformId Terraform ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TerraformMainCallsApi
     */
    public getTerraform(terraformId: string, options?: RawAxiosRequestConfig) {
        return TerraformMainCallsApiFp(this.configuration).getTerraform(terraformId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns list of the last 100 commits made on the repository linked to the terraform service
     * @summary List last commits
     * @param {string} terraformId Terraform ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TerraformMainCallsApi
     */
    public listTerraformCommit(terraformId: string, options?: RawAxiosRequestConfig) {
        return TerraformMainCallsApiFp(this.configuration).listTerraformCommit(terraformId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List available Terraform versions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TerraformMainCallsApi
     */
    public listTerraformVersions(options?: RawAxiosRequestConfig) {
        return TerraformMainCallsApiFp(this.configuration).listTerraformVersions(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TerraformsApi - axios parameter creator
 * @export
 */
export const TerraformsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This will create a new terraform with the same configuration on the targeted environment Id.
         * @summary Clone terraform
         * @param {string} terraformId Terraform ID
         * @param {CloneServiceRequest} [cloneServiceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneTerraform: async (terraformId: string, cloneServiceRequest?: CloneServiceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'terraformId' is not null or undefined
            assertParamExists('cloneTerraform', 'terraformId', terraformId)
            const localVarPath = `/terraform/{terraformId}/clone`
                .replace(`{${"terraformId"}}`, encodeURIComponent(String(terraformId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloneServiceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a terraform
         * @param {string} environmentId 
         * @param {TerraformRequest} [terraformRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTerraform: async (environmentId: string, terraformRequest?: TerraformRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('createTerraform', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/terraform`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(terraformRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List default terraform advanced settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultTerraformAdvancedSettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/defaultTerraformAdvancedSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List terraforms
         * @param {string} environmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTerraforms: async (environmentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('listTerraforms', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/terraform`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TerraformsApi - functional programming interface
 * @export
 */
export const TerraformsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TerraformsApiAxiosParamCreator(configuration)
    return {
        /**
         * This will create a new terraform with the same configuration on the targeted environment Id.
         * @summary Clone terraform
         * @param {string} terraformId Terraform ID
         * @param {CloneServiceRequest} [cloneServiceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloneTerraform(terraformId: string, cloneServiceRequest?: CloneServiceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TerraformResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cloneTerraform(terraformId, cloneServiceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TerraformsApi.cloneTerraform']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a terraform
         * @param {string} environmentId 
         * @param {TerraformRequest} [terraformRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTerraform(environmentId: string, terraformRequest?: TerraformRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TerraformResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTerraform(environmentId, terraformRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TerraformsApi.createTerraform']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List default terraform advanced settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDefaultTerraformAdvancedSettings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TerraformAdvancedSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDefaultTerraformAdvancedSettings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TerraformsApi.getDefaultTerraformAdvancedSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List terraforms
         * @param {string} environmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTerraforms(environmentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TerraformResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTerraforms(environmentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TerraformsApi.listTerraforms']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TerraformsApi - factory interface
 * @export
 */
export const TerraformsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TerraformsApiFp(configuration)
    return {
        /**
         * This will create a new terraform with the same configuration on the targeted environment Id.
         * @summary Clone terraform
         * @param {string} terraformId Terraform ID
         * @param {CloneServiceRequest} [cloneServiceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneTerraform(terraformId: string, cloneServiceRequest?: CloneServiceRequest, options?: RawAxiosRequestConfig): AxiosPromise<TerraformResponse> {
            return localVarFp.cloneTerraform(terraformId, cloneServiceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a terraform
         * @param {string} environmentId 
         * @param {TerraformRequest} [terraformRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTerraform(environmentId: string, terraformRequest?: TerraformRequest, options?: RawAxiosRequestConfig): AxiosPromise<TerraformResponse> {
            return localVarFp.createTerraform(environmentId, terraformRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List default terraform advanced settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultTerraformAdvancedSettings(options?: RawAxiosRequestConfig): AxiosPromise<TerraformAdvancedSettings> {
            return localVarFp.getDefaultTerraformAdvancedSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List terraforms
         * @param {string} environmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTerraforms(environmentId: string, options?: RawAxiosRequestConfig): AxiosPromise<TerraformResponseList> {
            return localVarFp.listTerraforms(environmentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TerraformsApi - object-oriented interface
 * @export
 * @class TerraformsApi
 * @extends {BaseAPI}
 */
export class TerraformsApi extends BaseAPI {
    /**
     * This will create a new terraform with the same configuration on the targeted environment Id.
     * @summary Clone terraform
     * @param {string} terraformId Terraform ID
     * @param {CloneServiceRequest} [cloneServiceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TerraformsApi
     */
    public cloneTerraform(terraformId: string, cloneServiceRequest?: CloneServiceRequest, options?: RawAxiosRequestConfig) {
        return TerraformsApiFp(this.configuration).cloneTerraform(terraformId, cloneServiceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a terraform
     * @param {string} environmentId 
     * @param {TerraformRequest} [terraformRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TerraformsApi
     */
    public createTerraform(environmentId: string, terraformRequest?: TerraformRequest, options?: RawAxiosRequestConfig) {
        return TerraformsApiFp(this.configuration).createTerraform(environmentId, terraformRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List default terraform advanced settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TerraformsApi
     */
    public getDefaultTerraformAdvancedSettings(options?: RawAxiosRequestConfig) {
        return TerraformsApiFp(this.configuration).getDefaultTerraformAdvancedSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List terraforms
     * @param {string} environmentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TerraformsApi
     */
    public listTerraforms(environmentId: string, options?: RawAxiosRequestConfig) {
        return TerraformsApiFp(this.configuration).listTerraforms(environmentId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserSignUpApi - axios parameter creator
 * @export
 */
export const UserSignUpApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Send a Sign Up request containing the user information
         * @summary Send Sign Up request
         * @param {SignUpRequest} [signUpRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserSignUp: async (signUpRequest?: SignUpRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/userSignUp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signUpRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the Sign Up information of the user
         * @summary Get Sign up information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSignUp: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/userSignUp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserSignUpApi - functional programming interface
 * @export
 */
export const UserSignUpApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserSignUpApiAxiosParamCreator(configuration)
    return {
        /**
         * Send a Sign Up request containing the user information
         * @summary Send Sign Up request
         * @param {SignUpRequest} [signUpRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserSignUp(signUpRequest?: SignUpRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserSignUp(signUpRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserSignUpApi.createUserSignUp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the Sign Up information of the user
         * @summary Get Sign up information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserSignUp(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignUp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserSignUp(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserSignUpApi.getUserSignUp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserSignUpApi - factory interface
 * @export
 */
export const UserSignUpApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserSignUpApiFp(configuration)
    return {
        /**
         * Send a Sign Up request containing the user information
         * @summary Send Sign Up request
         * @param {SignUpRequest} [signUpRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserSignUp(signUpRequest?: SignUpRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createUserSignUp(signUpRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the Sign Up information of the user
         * @summary Get Sign up information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSignUp(options?: RawAxiosRequestConfig): AxiosPromise<SignUp> {
            return localVarFp.getUserSignUp(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserSignUpApi - object-oriented interface
 * @export
 * @class UserSignUpApi
 * @extends {BaseAPI}
 */
export class UserSignUpApi extends BaseAPI {
    /**
     * Send a Sign Up request containing the user information
     * @summary Send Sign Up request
     * @param {SignUpRequest} [signUpRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSignUpApi
     */
    public createUserSignUp(signUpRequest?: SignUpRequest, options?: RawAxiosRequestConfig) {
        return UserSignUpApiFp(this.configuration).createUserSignUp(signUpRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the Sign Up information of the user
     * @summary Get Sign up information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSignUpApi
     */
    public getUserSignUp(options?: RawAxiosRequestConfig) {
        return UserSignUpApiFp(this.configuration).getUserSignUp(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VariableMainCallsApi - axios parameter creator
 * @export
 */
export const VariableMainCallsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * - Create a variable with the scope defined in the request body. 
         * @summary Create a variable
         * @param {VariableRequest} [variableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVariable: async (variableRequest?: VariableRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/variable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(variableRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to create an alias of one of the existing variables. - You have to specify an alias (key) in the request body, the scope and the parent id of the alias (project id, environment id or service id) - The system will create a new variable at the requested level with the same value as the one corresponding to the variable id passed as path parameter. - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" or in the \"aliased_secret\" field of the newly created variable - You can\'t create an alias on an alias 
         * @summary Create a variable alias
         * @param {string} variableId Variable ID
         * @param {VariableAliasRequest} [variableAliasRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVariableAlias: async (variableId: string, variableAliasRequest?: VariableAliasRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'variableId' is not null or undefined
            assertParamExists('createVariableAlias', 'variableId', variableId)
            const localVarPath = `/variable/{variableId}/alias`
                .replace(`{${"variableId"}}`, encodeURIComponent(String(variableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(variableAliasRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to override a variable that has a higher scope. - You have to specify a value (override) in the request body and the scope and the parent id of the variable to override (project id, environment id or service id) - The system will create a new environment variable at the requested level with the same key as the one corresponding to the variable id passed as path parameter. - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" or in the \"overridden_secret\" field of the newly created variable 
         * @summary Create a variable override
         * @param {string} variableId Variable ID
         * @param {VariableOverrideRequest} [variableOverrideRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVariableOverride: async (variableId: string, variableOverrideRequest?: VariableOverrideRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'variableId' is not null or undefined
            assertParamExists('createVariableOverride', 'variableId', variableId)
            const localVarPath = `/variable/{variableId}/override`
                .replace(`{${"variableId"}}`, encodeURIComponent(String(variableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(variableOverrideRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - To delete a variable - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete a variable
         * @param {string} variableId Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVariable: async (variableId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'variableId' is not null or undefined
            assertParamExists('deleteVariable', 'variableId', variableId)
            const localVarPath = `/variable/{variableId}`
                .replace(`{${"variableId"}}`, encodeURIComponent(String(variableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value 
         * @summary Edit a variable
         * @param {string} variableId Variable ID
         * @param {VariableEditRequest} variableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editVariable: async (variableId: string, variableEditRequest: VariableEditRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'variableId' is not null or undefined
            assertParamExists('editVariable', 'variableId', variableId)
            // verify required parameter 'variableEditRequest' is not null or undefined
            assertParamExists('editVariable', 'variableEditRequest', variableEditRequest)
            const localVarPath = `/variable/{variableId}`
                .replace(`{${"variableId"}}`, encodeURIComponent(String(variableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(variableEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Import environment variables in a defined scope, with a defined visibility.
         * @summary Import variables
         * @param {string} serviceId service id
         * @param {ServiceTypeForVariableEnum} serviceType service type
         * @param {VariableImportRequest} [variableImportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importEnvironmentVariables: async (serviceId: string, serviceType: ServiceTypeForVariableEnum, variableImportRequest?: VariableImportRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('importEnvironmentVariables', 'serviceId', serviceId)
            // verify required parameter 'serviceType' is not null or undefined
            assertParamExists('importEnvironmentVariables', 'serviceType', serviceType)
            const localVarPath = `/variable/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (serviceId !== undefined) {
                localVarQueryParameter['service_id'] = serviceId;
            }

            if (serviceType !== undefined) {
                localVarQueryParameter['service_type'] = serviceType;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(variableImportRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of variables. The result can be filtered by using the query parameters.
         * @summary List variables
         * @param {string} parentId it filters the list by returning only the variables accessible by the selected parent_id. This field shall contain the id of a project, environment or service depending on the selected scope. Example, if scope &#x3D; APPLICATION and parent_id&#x3D;&lt;application_id&gt;, the result will contain any variable accessible by the application. The result will contain also any variable declared at an higher scope.
         * @param {APIVariableScopeEnum} scope the type of the parent_id (application, project, environment etc..).
         * @param {boolean | null} [isSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVariables: async (parentId: string, scope: APIVariableScopeEnum, isSecret?: boolean | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'parentId' is not null or undefined
            assertParamExists('listVariables', 'parentId', parentId)
            // verify required parameter 'scope' is not null or undefined
            assertParamExists('listVariables', 'scope', scope)
            const localVarPath = `/variable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (parentId !== undefined) {
                localVarQueryParameter['parent_id'] = parentId;
            }

            if (scope !== undefined) {
                localVarQueryParameter['scope'] = scope;
            }

            if (isSecret !== undefined) {
                localVarQueryParameter['is_secret'] = isSecret;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VariableMainCallsApi - functional programming interface
 * @export
 */
export const VariableMainCallsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VariableMainCallsApiAxiosParamCreator(configuration)
    return {
        /**
         * - Create a variable with the scope defined in the request body. 
         * @summary Create a variable
         * @param {VariableRequest} [variableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVariable(variableRequest?: VariableRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariableResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVariable(variableRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariableMainCallsApi.createVariable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - Allows you to create an alias of one of the existing variables. - You have to specify an alias (key) in the request body, the scope and the parent id of the alias (project id, environment id or service id) - The system will create a new variable at the requested level with the same value as the one corresponding to the variable id passed as path parameter. - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" or in the \"aliased_secret\" field of the newly created variable - You can\'t create an alias on an alias 
         * @summary Create a variable alias
         * @param {string} variableId Variable ID
         * @param {VariableAliasRequest} [variableAliasRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVariableAlias(variableId: string, variableAliasRequest?: VariableAliasRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariableResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVariableAlias(variableId, variableAliasRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariableMainCallsApi.createVariableAlias']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - Allows you to override a variable that has a higher scope. - You have to specify a value (override) in the request body and the scope and the parent id of the variable to override (project id, environment id or service id) - The system will create a new environment variable at the requested level with the same key as the one corresponding to the variable id passed as path parameter. - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" or in the \"overridden_secret\" field of the newly created variable 
         * @summary Create a variable override
         * @param {string} variableId Variable ID
         * @param {VariableOverrideRequest} [variableOverrideRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVariableOverride(variableId: string, variableOverrideRequest?: VariableOverrideRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariableResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVariableOverride(variableId, variableOverrideRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariableMainCallsApi.createVariableOverride']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - To delete a variable - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete a variable
         * @param {string} variableId Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteVariable(variableId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteVariable(variableId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariableMainCallsApi.deleteVariable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value 
         * @summary Edit a variable
         * @param {string} variableId Variable ID
         * @param {VariableEditRequest} variableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editVariable(variableId: string, variableEditRequest: VariableEditRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariableResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editVariable(variableId, variableEditRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariableMainCallsApi.editVariable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Import environment variables in a defined scope, with a defined visibility.
         * @summary Import variables
         * @param {string} serviceId service id
         * @param {ServiceTypeForVariableEnum} serviceType service type
         * @param {VariableImportRequest} [variableImportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importEnvironmentVariables(serviceId: string, serviceType: ServiceTypeForVariableEnum, variableImportRequest?: VariableImportRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariableImport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importEnvironmentVariables(serviceId, serviceType, variableImportRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariableMainCallsApi.importEnvironmentVariables']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of variables. The result can be filtered by using the query parameters.
         * @summary List variables
         * @param {string} parentId it filters the list by returning only the variables accessible by the selected parent_id. This field shall contain the id of a project, environment or service depending on the selected scope. Example, if scope &#x3D; APPLICATION and parent_id&#x3D;&lt;application_id&gt;, the result will contain any variable accessible by the application. The result will contain also any variable declared at an higher scope.
         * @param {APIVariableScopeEnum} scope the type of the parent_id (application, project, environment etc..).
         * @param {boolean | null} [isSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listVariables(parentId: string, scope: APIVariableScopeEnum, isSecret?: boolean | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariableResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listVariables(parentId, scope, isSecret, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariableMainCallsApi.listVariables']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VariableMainCallsApi - factory interface
 * @export
 */
export const VariableMainCallsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VariableMainCallsApiFp(configuration)
    return {
        /**
         * - Create a variable with the scope defined in the request body. 
         * @summary Create a variable
         * @param {VariableRequest} [variableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVariable(variableRequest?: VariableRequest, options?: RawAxiosRequestConfig): AxiosPromise<VariableResponse> {
            return localVarFp.createVariable(variableRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to create an alias of one of the existing variables. - You have to specify an alias (key) in the request body, the scope and the parent id of the alias (project id, environment id or service id) - The system will create a new variable at the requested level with the same value as the one corresponding to the variable id passed as path parameter. - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" or in the \"aliased_secret\" field of the newly created variable - You can\'t create an alias on an alias 
         * @summary Create a variable alias
         * @param {string} variableId Variable ID
         * @param {VariableAliasRequest} [variableAliasRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVariableAlias(variableId: string, variableAliasRequest?: VariableAliasRequest, options?: RawAxiosRequestConfig): AxiosPromise<VariableResponse> {
            return localVarFp.createVariableAlias(variableId, variableAliasRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to override a variable that has a higher scope. - You have to specify a value (override) in the request body and the scope and the parent id of the variable to override (project id, environment id or service id) - The system will create a new environment variable at the requested level with the same key as the one corresponding to the variable id passed as path parameter. - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" or in the \"overridden_secret\" field of the newly created variable 
         * @summary Create a variable override
         * @param {string} variableId Variable ID
         * @param {VariableOverrideRequest} [variableOverrideRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVariableOverride(variableId: string, variableOverrideRequest?: VariableOverrideRequest, options?: RawAxiosRequestConfig): AxiosPromise<VariableResponse> {
            return localVarFp.createVariableOverride(variableId, variableOverrideRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * - To delete a variable - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete a variable
         * @param {string} variableId Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVariable(variableId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteVariable(variableId, options).then((request) => request(axios, basePath));
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value 
         * @summary Edit a variable
         * @param {string} variableId Variable ID
         * @param {VariableEditRequest} variableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editVariable(variableId: string, variableEditRequest: VariableEditRequest, options?: RawAxiosRequestConfig): AxiosPromise<VariableResponse> {
            return localVarFp.editVariable(variableId, variableEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Import environment variables in a defined scope, with a defined visibility.
         * @summary Import variables
         * @param {string} serviceId service id
         * @param {ServiceTypeForVariableEnum} serviceType service type
         * @param {VariableImportRequest} [variableImportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importEnvironmentVariables(serviceId: string, serviceType: ServiceTypeForVariableEnum, variableImportRequest?: VariableImportRequest, options?: RawAxiosRequestConfig): AxiosPromise<VariableImport> {
            return localVarFp.importEnvironmentVariables(serviceId, serviceType, variableImportRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of variables. The result can be filtered by using the query parameters.
         * @summary List variables
         * @param {string} parentId it filters the list by returning only the variables accessible by the selected parent_id. This field shall contain the id of a project, environment or service depending on the selected scope. Example, if scope &#x3D; APPLICATION and parent_id&#x3D;&lt;application_id&gt;, the result will contain any variable accessible by the application. The result will contain also any variable declared at an higher scope.
         * @param {APIVariableScopeEnum} scope the type of the parent_id (application, project, environment etc..).
         * @param {boolean | null} [isSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVariables(parentId: string, scope: APIVariableScopeEnum, isSecret?: boolean | null, options?: RawAxiosRequestConfig): AxiosPromise<VariableResponseList> {
            return localVarFp.listVariables(parentId, scope, isSecret, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VariableMainCallsApi - object-oriented interface
 * @export
 * @class VariableMainCallsApi
 * @extends {BaseAPI}
 */
export class VariableMainCallsApi extends BaseAPI {
    /**
     * - Create a variable with the scope defined in the request body. 
     * @summary Create a variable
     * @param {VariableRequest} [variableRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariableMainCallsApi
     */
    public createVariable(variableRequest?: VariableRequest, options?: RawAxiosRequestConfig) {
        return VariableMainCallsApiFp(this.configuration).createVariable(variableRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to create an alias of one of the existing variables. - You have to specify an alias (key) in the request body, the scope and the parent id of the alias (project id, environment id or service id) - The system will create a new variable at the requested level with the same value as the one corresponding to the variable id passed as path parameter. - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" or in the \"aliased_secret\" field of the newly created variable - You can\'t create an alias on an alias 
     * @summary Create a variable alias
     * @param {string} variableId Variable ID
     * @param {VariableAliasRequest} [variableAliasRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariableMainCallsApi
     */
    public createVariableAlias(variableId: string, variableAliasRequest?: VariableAliasRequest, options?: RawAxiosRequestConfig) {
        return VariableMainCallsApiFp(this.configuration).createVariableAlias(variableId, variableAliasRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to override a variable that has a higher scope. - You have to specify a value (override) in the request body and the scope and the parent id of the variable to override (project id, environment id or service id) - The system will create a new environment variable at the requested level with the same key as the one corresponding to the variable id passed as path parameter. - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" or in the \"overridden_secret\" field of the newly created variable 
     * @summary Create a variable override
     * @param {string} variableId Variable ID
     * @param {VariableOverrideRequest} [variableOverrideRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariableMainCallsApi
     */
    public createVariableOverride(variableId: string, variableOverrideRequest?: VariableOverrideRequest, options?: RawAxiosRequestConfig) {
        return VariableMainCallsApiFp(this.configuration).createVariableOverride(variableId, variableOverrideRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - To delete a variable - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
     * @summary Delete a variable
     * @param {string} variableId Variable ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariableMainCallsApi
     */
    public deleteVariable(variableId: string, options?: RawAxiosRequestConfig) {
        return VariableMainCallsApiFp(this.configuration).deleteVariable(variableId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value 
     * @summary Edit a variable
     * @param {string} variableId Variable ID
     * @param {VariableEditRequest} variableEditRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariableMainCallsApi
     */
    public editVariable(variableId: string, variableEditRequest: VariableEditRequest, options?: RawAxiosRequestConfig) {
        return VariableMainCallsApiFp(this.configuration).editVariable(variableId, variableEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Import environment variables in a defined scope, with a defined visibility.
     * @summary Import variables
     * @param {string} serviceId service id
     * @param {ServiceTypeForVariableEnum} serviceType service type
     * @param {VariableImportRequest} [variableImportRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariableMainCallsApi
     */
    public importEnvironmentVariables(serviceId: string, serviceType: ServiceTypeForVariableEnum, variableImportRequest?: VariableImportRequest, options?: RawAxiosRequestConfig) {
        return VariableMainCallsApiFp(this.configuration).importEnvironmentVariables(serviceId, serviceType, variableImportRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of variables. The result can be filtered by using the query parameters.
     * @summary List variables
     * @param {string} parentId it filters the list by returning only the variables accessible by the selected parent_id. This field shall contain the id of a project, environment or service depending on the selected scope. Example, if scope &#x3D; APPLICATION and parent_id&#x3D;&lt;application_id&gt;, the result will contain any variable accessible by the application. The result will contain also any variable declared at an higher scope.
     * @param {APIVariableScopeEnum} scope the type of the parent_id (application, project, environment etc..).
     * @param {boolean | null} [isSecret] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariableMainCallsApi
     */
    public listVariables(parentId: string, scope: APIVariableScopeEnum, isSecret?: boolean | null, options?: RawAxiosRequestConfig) {
        return VariableMainCallsApiFp(this.configuration).listVariables(parentId, scope, isSecret, options).then((request) => request(this.axios, this.basePath));
    }
}



