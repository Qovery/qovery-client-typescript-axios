/* tslint:disable */
/* eslint-disable */
/**
 * Qovery API
 * - Qovery is the fastest way to deploy your full-stack apps on any Cloud provider. - ℹ️ The API is stable and still in development. 
 *
 * The version of the OpenAPI document: 1.0.3
 * Contact: support+api+documentation@qovery.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @enum {string}
 */

export const APIVariableScopeEnum = {
    APPLICATION: 'APPLICATION',
    BUILT_IN: 'BUILT_IN',
    ENVIRONMENT: 'ENVIRONMENT',
    PROJECT: 'PROJECT',
    CONTAINER: 'CONTAINER',
    JOB: 'JOB',
    HELM: 'HELM'
} as const;

export type APIVariableScopeEnum = typeof APIVariableScopeEnum[keyof typeof APIVariableScopeEnum];


/**
 * type of the environment variable (VALUE, FILE, ALIAS, OVERRIDE or BUIT_IN)  
 * @export
 * @enum {string}
 */

export const APIVariableTypeEnum = {
    VALUE: 'VALUE',
    ALIAS: 'ALIAS',
    OVERRIDE: 'OVERRIDE',
    BUILT_IN: 'BUILT_IN',
    FILE: 'FILE'
} as const;

export type APIVariableTypeEnum = typeof APIVariableTypeEnum[keyof typeof APIVariableTypeEnum];


/**
 * 
 * @export
 * @interface AccountInfo
 */
export interface AccountInfo {
    /**
     * 
     * @type {string}
     * @memberof AccountInfo
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountInfo
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountInfo
     */
    'nickname'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountInfo
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountInfo
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountInfo
     */
    'profile_picture_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountInfo
     */
    'communication_email'?: string;
}
/**
 * 
 * @export
 * @interface AccountInfoEditRequest
 */
export interface AccountInfoEditRequest {
    /**
     * The email to be used for official Qovery communications
     * @type {string}
     * @memberof AccountInfoEditRequest
     */
    'communication_email'?: string;
}
/**
 * 
 * @export
 * @interface Annotation
 */
export interface Annotation {
    /**
     * 
     * @type {string}
     * @memberof Annotation
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof Annotation
     */
    'value': string;
}
/**
 * Annotations Group Associated Item Type
 * @export
 * @enum {string}
 */

export const AnnotationsGroupAssociatedItemType = {
    APPLICATION: 'APPLICATION',
    DATABASE: 'DATABASE',
    CONTAINER: 'CONTAINER',
    LIFECYCLE: 'LIFECYCLE',
    ENVIRONMENT: 'ENVIRONMENT',
    CLUSTER: 'CLUSTER',
    CRON: 'CRON'
} as const;

export type AnnotationsGroupAssociatedItemType = typeof AnnotationsGroupAssociatedItemType[keyof typeof AnnotationsGroupAssociatedItemType];


/**
 * 
 * @export
 * @interface Application
 */
export interface Application {
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    'updated_at'?: string;
    /**
     * 
     * @type {Array<ServiceStorageStorageInner>}
     * @memberof Application
     */
    'storage'?: Array<ServiceStorageStorageInner>;
    /**
     * 
     * @type {ReferenceObject}
     * @memberof Application
     */
    'environment': ReferenceObject;
    /**
     * 
     * @type {ApplicationGitRepository}
     * @memberof Application
     */
    'git_repository'?: ApplicationGitRepository;
    /**
     * Maximum cpu that can be allocated to the application based on organization cluster configuration. unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof Application
     */
    'maximum_cpu'?: number;
    /**
     * Maximum memory that can be allocated to the application based on organization cluster configuration. unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof Application
     */
    'maximum_memory'?: number;
    /**
     * name is case insensitive
     * @type {string}
     * @memberof Application
     */
    'name': string;
    /**
     * give a description to this application
     * @type {string}
     * @memberof Application
     */
    'description'?: string;
    /**
     * 
     * @type {BuildModeEnum}
     * @memberof Application
     */
    'build_mode'?: BuildModeEnum;
    /**
     * The path of the associated Dockerfile. Only if you are using build_mode = DOCKER
     * @type {string}
     * @memberof Application
     */
    'dockerfile_path'?: string | null;
    /**
     * 
     * @type {BuildPackLanguageEnum}
     * @memberof Application
     */
    'buildpack_language'?: BuildPackLanguageEnum | null;
    /**
     * unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof Application
     */
    'cpu'?: number;
    /**
     * unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof Application
     */
    'memory'?: number;
    /**
     * Minimum number of instances running. This resource auto-scale based on the CPU and Memory consumption. Note: 0 means that there is no application running. 
     * @type {number}
     * @memberof Application
     */
    'min_running_instances'?: number;
    /**
     * Maximum number of instances running. This resource auto-scale based on the CPU and Memory consumption. Note: -1 means that there is no limit. 
     * @type {number}
     * @memberof Application
     */
    'max_running_instances'?: number;
    /**
     * 
     * @type {Healthcheck}
     * @memberof Application
     */
    'healthchecks': Healthcheck;
    /**
     * Specify if the environment preview option is activated or not for this application.   If activated, a preview environment will be automatically cloned at each pull request.   If not specified, it takes the value of the `auto_preview` property from the associated environment. 
     * @type {boolean}
     * @memberof Application
     */
    'auto_preview'?: boolean;
    /**
     * 
     * @type {Array<ServicePort>}
     * @memberof Application
     */
    'ports'?: Array<ServicePort>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Application
     */
    'arguments'?: Array<string>;
    /**
     * optional entrypoint when launching container
     * @type {string}
     * @memberof Application
     */
    'entrypoint'?: string;
    /**
     * Specify if the application will be automatically updated after receiving a new commit.
     * @type {boolean}
     * @memberof Application
     */
    'auto_deploy'?: boolean;
    /**
     * 
     * @type {Array<OrganizationAnnotationsGroupResponse>}
     * @memberof Application
     */
    'annotations_groups'?: Array<OrganizationAnnotationsGroupResponse>;
    /**
     * 
     * @type {Array<OrganizationLabelsGroupResponse>}
     * @memberof Application
     */
    'labels_groups'?: Array<OrganizationLabelsGroupResponse>;
    /**
     * Icon URI representing the application.
     * @type {string}
     * @memberof Application
     */
    'icon_uri': string;
}


/**
 * 
 * @export
 * @interface ApplicationAdvancedSettings
 */
export interface ApplicationAdvancedSettings {
    /**
     * disable custom domain check when deploying an application
     * @type {boolean}
     * @memberof ApplicationAdvancedSettings
     */
    'deployment.custom_domain_check_enabled'?: boolean;
    /**
     * define how long in seconds an application is supposed to be stopped gracefully
     * @type {number}
     * @memberof ApplicationAdvancedSettings
     */
    'deployment.termination_grace_period_seconds'?: number;
    /**
     * Set pod placement on specific Kubernetes nodes labels
     * @type {{ [key: string]: string; }}
     * @memberof ApplicationAdvancedSettings
     */
    'deployment.affinity.node.required'?: { [key: string]: string; };
    /**
     * Define how you want pods affinity to behave: * `Preferred` allows, but does not require, pods of a given service are not co-located (or co-hosted) on a single node * `Requirred` ensures that the pods of a given service are not co-located (or co-hosted) on a single node (safer in term of availability but can be expensive depending on the number of replicas) 
     * @type {string}
     * @memberof ApplicationAdvancedSettings
     */
    'deployment.antiaffinity.pod'?: ApplicationAdvancedSettingsDeploymentAntiaffinityPodEnum;
    /**
     * Allows you to run a command after the application is started. The command should be a shell command or script.
     * @type {Array<string>}
     * @memberof ApplicationAdvancedSettings
     */
    'deployment.lifecycle.post_start_exec_command'?: Array<string>;
    /**
     * Allows you to run a command before the application is stopped. The command should be a shell command or script. Qovery requires the sh shell by default and sets a sleep of 15 seconds to let Nginx update its config. Avoiding error codes returned during a rolling update.
     * @type {Array<string>}
     * @memberof ApplicationAdvancedSettings
     */
    'deployment.lifecycle.pre_stop_exec_command'?: Array<string>;
    /**
     * * `RollingUpdate` gracefully rollout new versions, and automatically rollback if the new version fails to start * `Recreate` stop all current versions and create new ones once all old ones have been shutdown 
     * @type {string}
     * @memberof ApplicationAdvancedSettings
     */
    'deployment.update_strategy.type'?: ApplicationAdvancedSettingsDeploymentUpdateStrategyTypeEnum;
    /**
     * Define the percentage of a maximum number of pods that can be unavailable during the update process
     * @type {number}
     * @memberof ApplicationAdvancedSettings
     */
    'deployment.update_strategy.rolling_update.max_unavailable_percent'?: number;
    /**
     * Define the percentage of the maximum number of pods that can be created over the desired number of pods
     * @type {number}
     * @memberof ApplicationAdvancedSettings
     */
    'deployment.update_strategy.rolling_update.max_surge_percent'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApplicationAdvancedSettings
     */
    'build.timeout_max_sec'?: number;
    /**
     * define the max cpu resources (in milli)
     * @type {number}
     * @memberof ApplicationAdvancedSettings
     */
    'build.cpu_max_in_milli'?: number;
    /**
     * define the max ram resources (in gib)
     * @type {number}
     * @memberof ApplicationAdvancedSettings
     */
    'build.ram_max_in_gib'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApplicationAdvancedSettings
     */
    'network.ingress.proxy_body_size_mb'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationAdvancedSettings
     */
    'network.ingress.enable_cors'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ApplicationAdvancedSettings
     */
    'network.ingress.cors_allow_origin'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationAdvancedSettings
     */
    'network.ingress.cors_allow_methods'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationAdvancedSettings
     */
    'network.ingress.cors_allow_headers'?: string;
    /**
     * header buffer size used while reading response header from upstream
     * @type {number}
     * @memberof ApplicationAdvancedSettings
     */
    'network.ingress.proxy_buffer_size_kb'?: number;
    /**
     * Limits the maximum time (in seconds) during which requests can be processed through one keepalive connection
     * @type {number}
     * @memberof ApplicationAdvancedSettings
     */
    'network.ingress.keepalive_time_seconds'?: number;
    /**
     * Sets a timeout (in seconds) during which an idle keepalive connection to an upstream server will stay open.
     * @type {number}
     * @memberof ApplicationAdvancedSettings
     */
    'network.ingress.keepalive_timeout_seconds'?: number;
    /**
     * Sets a timeout (in seconds) for transmitting a response to the client
     * @type {number}
     * @memberof ApplicationAdvancedSettings
     */
    'network.ingress.send_timeout_seconds'?: number;
    /**
     * Sets a timeout (in seconds) for establishing a connection to a proxied server
     * @type {number}
     * @memberof ApplicationAdvancedSettings
     */
    'network.ingress.proxy_connect_timeout_seconds'?: number;
    /**
     * Sets a timeout (in seconds) for transmitting a request to the proxied server
     * @type {number}
     * @memberof ApplicationAdvancedSettings
     */
    'network.ingress.proxy_send_timeout_seconds'?: number;
    /**
     * Sets a timeout (in seconds) for reading a response from the proxied server
     * @type {number}
     * @memberof ApplicationAdvancedSettings
     */
    'network.ingress.proxy_read_timeout_seconds'?: number;
    /**
     * Allows to enable or disable nginx `proxy-request-buffering`
     * @type {string}
     * @memberof ApplicationAdvancedSettings
     */
    'network.ingress.proxy_buffering'?: string;
    /**
     * list of source ranges to allow access to ingress proxy.  This property can be used to whitelist source IP ranges for ingress proxy. The value is a comma separated list of CIDRs, e.g. 10.0.0.0/24,172.10.0.1 To allow all source ranges, set 0.0.0.0/0. 
     * @type {string}
     * @memberof ApplicationAdvancedSettings
     */
    'network.ingress.whitelist_source_range'?: string;
    /**
     * list of source ranges to deny access to ingress proxy.  This property can be used to blacklist source IP ranges for ingress proxy. The value is a comma separated list of CIDRs, e.g. 10.0.0.0/24,172.10.0.1 
     * @type {string}
     * @memberof ApplicationAdvancedSettings
     */
    'network.ingress.denylist_source_range'?: string;
    /**
     * Set the name of an environment variable to use as a basic authentication (`login:crypted_password`) from `htpasswd` command. 
     * @type {string}
     * @memberof ApplicationAdvancedSettings
     */
    'network.ingress.basic_auth_env_var'?: string;
    /**
     * Enable the load balancer to bind a user\'s session to a specific target. This ensures that all requests from the user during the session are sent to the same target 
     * @type {boolean}
     * @memberof ApplicationAdvancedSettings
     */
    'network.ingress.enable_sticky_session'?: boolean;
    /**
     * Sets a timeout (in seconds) for transmitting a request to the grpc server
     * @type {number}
     * @memberof ApplicationAdvancedSettings
     */
    'network.ingress.grpc_send_timeout_seconds'?: number;
    /**
     * Sets a timeout (in seconds) for transmitting a request to the grpc server
     * @type {number}
     * @memberof ApplicationAdvancedSettings
     */
    'network.ingress.grpc_read_timeout_seconds'?: number;
    /**
     * Allows to define response headers
     * @type {string}
     * @memberof ApplicationAdvancedSettings
     */
    'network.ingress.extra_headers'?: string;
    /**
     * Percentage value of cpu usage at which point pods should scale up.
     * @type {number}
     * @memberof ApplicationAdvancedSettings
     */
    'hpa.cpu.average_utilization_percent'?: number;
    /**
     * Allows you to set an existing Kubernetes service account name 
     * @type {string}
     * @memberof ApplicationAdvancedSettings
     */
    'security.service_account_name'?: string;
    /**
     * Automount Kubernetes service account token to have access to Kubernetes API from pods 
     * @type {boolean}
     * @memberof ApplicationAdvancedSettings
     */
    'security.automount_service_account_token'?: boolean;
    /**
     * Mounts the container\'s root filesystem as read-only 
     * @type {boolean}
     * @memberof ApplicationAdvancedSettings
     */
    'security.read_only_root_filesystem'?: boolean;
}

export const ApplicationAdvancedSettingsDeploymentAntiaffinityPodEnum = {
    PREFERRED: 'Preferred',
    REQUIRRED: 'Requirred'
} as const;

export type ApplicationAdvancedSettingsDeploymentAntiaffinityPodEnum = typeof ApplicationAdvancedSettingsDeploymentAntiaffinityPodEnum[keyof typeof ApplicationAdvancedSettingsDeploymentAntiaffinityPodEnum];
export const ApplicationAdvancedSettingsDeploymentUpdateStrategyTypeEnum = {
    ROLLING_UPDATE: 'RollingUpdate',
    RECREATE: 'Recreate'
} as const;

export type ApplicationAdvancedSettingsDeploymentUpdateStrategyTypeEnum = typeof ApplicationAdvancedSettingsDeploymentUpdateStrategyTypeEnum[keyof typeof ApplicationAdvancedSettingsDeploymentUpdateStrategyTypeEnum];

/**
 * 
 * @export
 * @interface ApplicationDeploymentRestriction
 */
export interface ApplicationDeploymentRestriction {
    /**
     * 
     * @type {string}
     * @memberof ApplicationDeploymentRestriction
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationDeploymentRestriction
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationDeploymentRestriction
     */
    'updated_at'?: string;
    /**
     * 
     * @type {DeploymentRestrictionModeEnum}
     * @memberof ApplicationDeploymentRestriction
     */
    'mode': DeploymentRestrictionModeEnum;
    /**
     * 
     * @type {DeploymentRestrictionTypeEnum}
     * @memberof ApplicationDeploymentRestriction
     */
    'type': DeploymentRestrictionTypeEnum;
    /**
     * For `PATH` restrictions, the value must not start with `/`
     * @type {string}
     * @memberof ApplicationDeploymentRestriction
     */
    'value': string;
}


/**
 * 
 * @export
 * @interface ApplicationDeploymentRestrictionRequest
 */
export interface ApplicationDeploymentRestrictionRequest {
    /**
     * 
     * @type {DeploymentRestrictionModeEnum}
     * @memberof ApplicationDeploymentRestrictionRequest
     */
    'mode': DeploymentRestrictionModeEnum;
    /**
     * 
     * @type {DeploymentRestrictionTypeEnum}
     * @memberof ApplicationDeploymentRestrictionRequest
     */
    'type': DeploymentRestrictionTypeEnum;
    /**
     * For `PATH` restrictions, the value must not start with `/`
     * @type {string}
     * @memberof ApplicationDeploymentRestrictionRequest
     */
    'value': string;
}


/**
 * 
 * @export
 * @interface ApplicationDeploymentRestrictionResponseList
 */
export interface ApplicationDeploymentRestrictionResponseList {
    /**
     * 
     * @type {Array<ApplicationDeploymentRestriction>}
     * @memberof ApplicationDeploymentRestrictionResponseList
     */
    'results'?: Array<ApplicationDeploymentRestriction>;
}
/**
 * 
 * @export
 * @interface ApplicationEditRequest
 */
export interface ApplicationEditRequest {
    /**
     * 
     * @type {Array<ServiceStorageRequestStorageInner>}
     * @memberof ApplicationEditRequest
     */
    'storage'?: Array<ServiceStorageRequestStorageInner>;
    /**
     * name is case insensitive
     * @type {string}
     * @memberof ApplicationEditRequest
     */
    'name'?: string;
    /**
     * give a description to this application
     * @type {string}
     * @memberof ApplicationEditRequest
     */
    'description'?: string;
    /**
     * 
     * @type {ApplicationGitRepositoryRequest}
     * @memberof ApplicationEditRequest
     */
    'git_repository'?: ApplicationGitRepositoryRequest;
    /**
     * 
     * @type {BuildModeEnum}
     * @memberof ApplicationEditRequest
     */
    'build_mode'?: BuildModeEnum;
    /**
     * The path of the associated Dockerfile
     * @type {string}
     * @memberof ApplicationEditRequest
     */
    'dockerfile_path'?: string | null;
    /**
     * 
     * @type {BuildPackLanguageEnum}
     * @memberof ApplicationEditRequest
     */
    'buildpack_language'?: BuildPackLanguageEnum | null;
    /**
     * unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof ApplicationEditRequest
     */
    'cpu'?: number;
    /**
     * unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof ApplicationEditRequest
     */
    'memory'?: number;
    /**
     * Minimum number of instances running. This resource auto-scale based on the CPU and Memory consumption. Note: 0 means that there is no application running. 
     * @type {number}
     * @memberof ApplicationEditRequest
     */
    'min_running_instances'?: number;
    /**
     * Maximum number of instances running. This resource auto-scale based on the CPU and Memory consumption. Note: -1 means that there is no limit. 
     * @type {number}
     * @memberof ApplicationEditRequest
     */
    'max_running_instances'?: number;
    /**
     * 
     * @type {Healthcheck}
     * @memberof ApplicationEditRequest
     */
    'healthchecks': Healthcheck;
    /**
     * Specify if the environment preview option is activated or not for this application.   If activated, a preview environment will be automatically cloned at each pull request.   If not specified, it takes the value of the `auto_preview` property from the associated environment. 
     * @type {boolean}
     * @memberof ApplicationEditRequest
     */
    'auto_preview'?: boolean;
    /**
     * 
     * @type {Array<ServicePort>}
     * @memberof ApplicationEditRequest
     */
    'ports'?: Array<ServicePort>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApplicationEditRequest
     */
    'arguments'?: Array<string>;
    /**
     * optional entrypoint when launching container
     * @type {string}
     * @memberof ApplicationEditRequest
     */
    'entrypoint'?: string;
    /**
     * Specify if the application will be automatically updated after receiving a new commit.
     * @type {boolean}
     * @memberof ApplicationEditRequest
     */
    'auto_deploy'?: boolean | null;
    /**
     * 
     * @type {Array<ServiceAnnotationRequest>}
     * @memberof ApplicationEditRequest
     */
    'annotations_groups'?: Array<ServiceAnnotationRequest>;
    /**
     * 
     * @type {Array<ServiceLabelRequest>}
     * @memberof ApplicationEditRequest
     */
    'labels_groups'?: Array<ServiceLabelRequest>;
    /**
     * Icon URI representing the application.
     * @type {string}
     * @memberof ApplicationEditRequest
     */
    'icon_uri'?: string;
}


/**
 * 
 * @export
 * @interface ApplicationGitRepository
 */
export interface ApplicationGitRepository {
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationGitRepository
     */
    'has_access'?: boolean;
    /**
     * 
     * @type {GitProviderEnum}
     * @memberof ApplicationGitRepository
     */
    'provider': GitProviderEnum;
    /**
     * 
     * @type {string}
     * @memberof ApplicationGitRepository
     */
    'owner': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationGitRepository
     */
    'url': string;
    /**
     * repository name
     * @type {string}
     * @memberof ApplicationGitRepository
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationGitRepository
     */
    'branch'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationGitRepository
     */
    'root_path'?: string;
    /**
     * Git commit ID corresponding to the deployed version of the app
     * @type {string}
     * @memberof ApplicationGitRepository
     */
    'deployed_commit_id'?: string;
    /**
     * Git commit date corresponding to the deployed version of the app
     * @type {string}
     * @memberof ApplicationGitRepository
     */
    'deployed_commit_date'?: string;
    /**
     * Git commit user corresponding to the deployed version of the app
     * @type {string}
     * @memberof ApplicationGitRepository
     */
    'deployed_commit_contributor'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationGitRepository
     */
    'deployed_commit_tag'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationGitRepository
     */
    'git_token_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApplicationGitRepository
     */
    'git_token_name'?: string | null;
}


/**
 * 
 * @export
 * @interface ApplicationGitRepositoryRequest
 */
export interface ApplicationGitRepositoryRequest {
    /**
     * application git repository URL
     * @type {string}
     * @memberof ApplicationGitRepositoryRequest
     */
    'url': string;
    /**
     * Name of the branch to use. This is optional If not specified, then the branch used is the `main` or `master` one 
     * @type {string}
     * @memberof ApplicationGitRepositoryRequest
     */
    'branch'?: string;
    /**
     * indicates the root path of the application.
     * @type {string}
     * @memberof ApplicationGitRepositoryRequest
     */
    'root_path'?: string;
    /**
     * The git token id on Qovery side
     * @type {string}
     * @memberof ApplicationGitRepositoryRequest
     */
    'git_token_id'?: string | null;
}
/**
 * 
 * @export
 * @interface ApplicationNetwork
 */
export interface ApplicationNetwork {
    /**
     * Specify if the sticky session option (also called persistant session) is activated or not for this application. If activated, user will be redirected by the load balancer to the same instance each time he access to the application.  
     * @type {boolean}
     * @memberof ApplicationNetwork
     */
    'sticky_session'?: boolean;
}
/**
 * 
 * @export
 * @interface ApplicationNetworkRequest
 */
export interface ApplicationNetworkRequest {
    /**
     * Specify if the sticky session option (also called persistant session) is activated or not for this application. If activated, user will be redirected by the load balancer to the same instance each time he access to the application.  
     * @type {boolean}
     * @memberof ApplicationNetworkRequest
     */
    'sticky_session'?: boolean;
}
/**
 * 
 * @export
 * @interface ApplicationRequest
 */
export interface ApplicationRequest {
    /**
     * 
     * @type {Array<ServiceStorageRequestStorageInner>}
     * @memberof ApplicationRequest
     */
    'storage'?: Array<ServiceStorageRequestStorageInner>;
    /**
     * 
     * @type {Array<ServicePortRequestPortsInner>}
     * @memberof ApplicationRequest
     */
    'ports'?: Array<ServicePortRequestPortsInner>;
    /**
     * name is case insensitive
     * @type {string}
     * @memberof ApplicationRequest
     */
    'name': string;
    /**
     * give a description to this application
     * @type {string}
     * @memberof ApplicationRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {ApplicationGitRepositoryRequest}
     * @memberof ApplicationRequest
     */
    'git_repository': ApplicationGitRepositoryRequest;
    /**
     * 
     * @type {BuildModeEnum}
     * @memberof ApplicationRequest
     */
    'build_mode'?: BuildModeEnum;
    /**
     * The path of the associated Dockerfile. Only if you are using build_mode = DOCKER
     * @type {string}
     * @memberof ApplicationRequest
     */
    'dockerfile_path'?: string | null;
    /**
     * 
     * @type {BuildPackLanguageEnum}
     * @memberof ApplicationRequest
     */
    'buildpack_language'?: BuildPackLanguageEnum | null;
    /**
     * unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof ApplicationRequest
     */
    'cpu'?: number;
    /**
     * unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof ApplicationRequest
     */
    'memory'?: number;
    /**
     * Minimum number of instances running. This resource auto-scale based on the CPU and Memory consumption. Note: 0 means that there is no application running. 
     * @type {number}
     * @memberof ApplicationRequest
     */
    'min_running_instances'?: number;
    /**
     * Maximum number of instances running. This resource auto-scale based on the CPU and Memory consumption. Note: -1 means that there is no limit. 
     * @type {number}
     * @memberof ApplicationRequest
     */
    'max_running_instances'?: number;
    /**
     * 
     * @type {Healthcheck}
     * @memberof ApplicationRequest
     */
    'healthchecks': Healthcheck;
    /**
     * Specify if the environment preview option is activated or not for this application.   If activated, a preview environment will be automatically cloned at each pull request.   If not specified, it takes the value of the `auto_preview` property from the associated environment. 
     * @type {boolean}
     * @memberof ApplicationRequest
     */
    'auto_preview'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApplicationRequest
     */
    'arguments'?: Array<string>;
    /**
     * optional entrypoint when launching container
     * @type {string}
     * @memberof ApplicationRequest
     */
    'entrypoint'?: string;
    /**
     * Specify if the application will be automatically updated after receiving a new commit.
     * @type {boolean}
     * @memberof ApplicationRequest
     */
    'auto_deploy'?: boolean | null;
    /**
     * 
     * @type {Array<ServiceAnnotationRequest>}
     * @memberof ApplicationRequest
     */
    'annotations_groups'?: Array<ServiceAnnotationRequest>;
    /**
     * 
     * @type {Array<ServiceLabelRequest>}
     * @memberof ApplicationRequest
     */
    'labels_groups'?: Array<ServiceLabelRequest>;
    /**
     * Icon URI representing the application.
     * @type {string}
     * @memberof ApplicationRequest
     */
    'icon_uri'?: string;
}


/**
 * 
 * @export
 * @interface ApplicationResponseList
 */
export interface ApplicationResponseList {
    /**
     * 
     * @type {Array<Application>}
     * @memberof ApplicationResponseList
     */
    'results'?: Array<Application>;
}
/**
 * 
 * @export
 * @interface AvailableContainerRegistryResponse
 */
export interface AvailableContainerRegistryResponse {
    /**
     * 
     * @type {ContainerRegistryKindEnum}
     * @memberof AvailableContainerRegistryResponse
     */
    'kind': ContainerRegistryKindEnum;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof AvailableContainerRegistryResponse
     */
    'required_config': { [key: string]: any; };
    /**
     * 
     * @type {boolean}
     * @memberof AvailableContainerRegistryResponse
     */
    'is_mandatory': boolean;
}


/**
 * 
 * @export
 * @interface AvailableContainerRegistryResponseList
 */
export interface AvailableContainerRegistryResponseList {
    /**
     * 
     * @type {Array<AvailableContainerRegistryResponse>}
     * @memberof AvailableContainerRegistryResponseList
     */
    'results'?: Array<AvailableContainerRegistryResponse>;
}
/**
 * 
 * @export
 * @interface AvailableHelmRepositoryResponse
 */
export interface AvailableHelmRepositoryResponse {
    /**
     * 
     * @type {HelmRepositoryKindEnum}
     * @memberof AvailableHelmRepositoryResponse
     */
    'kind': HelmRepositoryKindEnum;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof AvailableHelmRepositoryResponse
     */
    'required_config': { [key: string]: any; };
    /**
     * 
     * @type {boolean}
     * @memberof AvailableHelmRepositoryResponse
     */
    'is_mandatory': boolean;
}


/**
 * 
 * @export
 * @interface AvailableHelmRepositoryResponseList
 */
export interface AvailableHelmRepositoryResponseList {
    /**
     * 
     * @type {Array<AvailableHelmRepositoryResponse>}
     * @memberof AvailableHelmRepositoryResponseList
     */
    'results'?: Array<AvailableHelmRepositoryResponse>;
}
/**
 * 
 * @export
 * @interface AwsCredentialsRequest
 */
export interface AwsCredentialsRequest {
    /**
     * 
     * @type {string}
     * @memberof AwsCredentialsRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AwsCredentialsRequest
     */
    'access_key_id': string;
    /**
     * 
     * @type {string}
     * @memberof AwsCredentialsRequest
     */
    'secret_access_key': string;
}
/**
 * 
 * @export
 * @interface Backup
 */
export interface Backup {
    /**
     * 
     * @type {string}
     * @memberof Backup
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Backup
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Backup
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Backup
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Backup
     */
    'message': string;
    /**
     * 
     * @type {Status}
     * @memberof Backup
     */
    'status'?: Status;
}
/**
 * 
 * @export
 * @interface BackupPaginatedResponseList
 */
export interface BackupPaginatedResponseList {
    /**
     * 
     * @type {number}
     * @memberof BackupPaginatedResponseList
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof BackupPaginatedResponseList
     */
    'page_size': number;
    /**
     * 
     * @type {Array<Backup>}
     * @memberof BackupPaginatedResponseList
     */
    'results'?: Array<Backup>;
}
/**
 * 
 * @export
 * @interface BackupRequest
 */
export interface BackupRequest {
    /**
     * 
     * @type {string}
     * @memberof BackupRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BackupRequest
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface BackupResponseList
 */
export interface BackupResponseList {
    /**
     * 
     * @type {Array<Backup>}
     * @memberof BackupResponseList
     */
    'results'?: Array<Backup>;
}
/**
 * 
 * @export
 * @interface Base
 */
export interface Base {
    /**
     * 
     * @type {string}
     * @memberof Base
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Base
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Base
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface BaseJobResponse
 */
export interface BaseJobResponse {
    /**
     * 
     * @type {string}
     * @memberof BaseJobResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BaseJobResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof BaseJobResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {ReferenceObject}
     * @memberof BaseJobResponse
     */
    'environment': ReferenceObject;
    /**
     * Maximum cpu that can be allocated to the job based on organization cluster configuration. unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof BaseJobResponse
     */
    'maximum_cpu': number;
    /**
     * Maximum memory that can be allocated to the job based on organization cluster configuration. unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof BaseJobResponse
     */
    'maximum_memory': number;
    /**
     * name is case insensitive
     * @type {string}
     * @memberof BaseJobResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BaseJobResponse
     */
    'description'?: string;
    /**
     * unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof BaseJobResponse
     */
    'cpu': number;
    /**
     * unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof BaseJobResponse
     */
    'memory': number;
    /**
     * Maximum number of restart allowed before the job is considered as failed 0 means that no restart/crash of the job is allowed 
     * @type {number}
     * @memberof BaseJobResponse
     */
    'max_nb_restart'?: number;
    /**
     * Maximum number of seconds allowed for the job to run before killing it and mark it as failed 
     * @type {number}
     * @memberof BaseJobResponse
     */
    'max_duration_seconds'?: number;
    /**
     * Indicates if the \'environment preview option\' is enabled for this container.   If enabled, a preview environment will be automatically cloned when `/preview` endpoint is called.   If not specified, it takes the value of the `auto_preview` property from the associated environment. 
     * @type {boolean}
     * @memberof BaseJobResponse
     */
    'auto_preview': boolean;
    /**
     * Port where to run readiness and liveliness probes checks. The port will not be exposed externally
     * @type {number}
     * @memberof BaseJobResponse
     */
    'port'?: number | null;
    /**
     * 
     * @type {BaseJobResponseAllOfSource}
     * @memberof BaseJobResponse
     */
    'source': BaseJobResponseAllOfSource;
    /**
     * 
     * @type {Healthcheck}
     * @memberof BaseJobResponse
     */
    'healthchecks': Healthcheck;
    /**
     * Specify if the job will be automatically updated after receiving a new image tag or a new commit according to the source type.  The new image tag shall be communicated via the \"Auto Deploy job\" endpoint https://api-doc.qovery.com/#tag/Jobs/operation/autoDeployJobEnvironments 
     * @type {boolean}
     * @memberof BaseJobResponse
     */
    'auto_deploy'?: boolean;
    /**
     * Icon URI representing the job.
     * @type {string}
     * @memberof BaseJobResponse
     */
    'icon_uri': string;
}
/**
 * @type BaseJobResponseAllOfSource
 * @export
 */
export type BaseJobResponseAllOfSource = BaseJobResponseAllOfSourceOneOf | BaseJobResponseAllOfSourceOneOf1;

/**
 * 
 * @export
 * @interface BaseJobResponseAllOfSourceOneOf
 */
export interface BaseJobResponseAllOfSourceOneOf {
    /**
     * 
     * @type {ContainerSource}
     * @memberof BaseJobResponseAllOfSourceOneOf
     */
    'image': ContainerSource;
}
/**
 * 
 * @export
 * @interface BaseJobResponseAllOfSourceOneOf1
 */
export interface BaseJobResponseAllOfSourceOneOf1 {
    /**
     * 
     * @type {JobSourceDockerResponse}
     * @memberof BaseJobResponseAllOfSourceOneOf1
     */
    'docker': JobSourceDockerResponse;
}
/**
 * 
 * @export
 * @interface BillingExternalId
 */
export interface BillingExternalId {
    /**
     * 
     * @type {string}
     * @memberof BillingExternalId
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface BillingInfo
 */
export interface BillingInfo {
    /**
     * 
     * @type {string}
     * @memberof BillingInfo
     */
    'first_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BillingInfo
     */
    'last_name'?: string | null;
    /**
     * email used for billing, and to receive all invoices by email
     * @type {string}
     * @memberof BillingInfo
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BillingInfo
     */
    'address'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BillingInfo
     */
    'city'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BillingInfo
     */
    'zip'?: string | null;
    /**
     * only for US
     * @type {string}
     * @memberof BillingInfo
     */
    'state'?: string | null;
    /**
     * ISO code of the country
     * @type {string}
     * @memberof BillingInfo
     */
    'country_code'?: string | null;
    /**
     * name of the company to bill
     * @type {string}
     * @memberof BillingInfo
     */
    'company'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BillingInfo
     */
    'vat_number'?: string | null;
}
/**
 * 
 * @export
 * @interface BillingInfoRequest
 */
export interface BillingInfoRequest {
    /**
     * 
     * @type {string}
     * @memberof BillingInfoRequest
     */
    'first_name': string;
    /**
     * 
     * @type {string}
     * @memberof BillingInfoRequest
     */
    'last_name': string;
    /**
     * email used for billing, and to receive all invoices by email
     * @type {string}
     * @memberof BillingInfoRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof BillingInfoRequest
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof BillingInfoRequest
     */
    'city': string;
    /**
     * 
     * @type {string}
     * @memberof BillingInfoRequest
     */
    'zip': string;
    /**
     * only for US
     * @type {string}
     * @memberof BillingInfoRequest
     */
    'state'?: string;
    /**
     * ISO code of the country
     * @type {string}
     * @memberof BillingInfoRequest
     */
    'country_code': string;
    /**
     * name of the company to bill
     * @type {string}
     * @memberof BillingInfoRequest
     */
    'company'?: string;
    /**
     * 
     * @type {string}
     * @memberof BillingInfoRequest
     */
    'vat_number'?: string;
}
/**
 * 
 * @export
 * @interface BillingStatus
 */
export interface BillingStatus {
    /**
     * 
     * @type {boolean}
     * @memberof BillingStatus
     */
    'is_valid'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof BillingStatus
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface Budget
 */
export interface Budget {
    /**
     * 
     * @type {number}
     * @memberof Budget
     */
    'total_in_cents'?: number;
    /**
     * 
     * @type {number}
     * @memberof Budget
     */
    'total'?: number;
    /**
     * 
     * @type {string}
     * @memberof Budget
     */
    'currency_code'?: string;
}
/**
 * `DOCKER` requires `dockerfile_path` `BUILDPACKS` does not require any `dockerfile_path` 
 * @export
 * @enum {string}
 */

export const BuildModeEnum = {
    BUILDPACKS: 'BUILDPACKS',
    DOCKER: 'DOCKER'
} as const;

export type BuildModeEnum = typeof BuildModeEnum[keyof typeof BuildModeEnum];


/**
 * Development language of the application
 * @export
 * @enum {string}
 */

export const BuildPackLanguageEnum = {
    CLOJURE: 'CLOJURE',
    GO: 'GO',
    GRADLE: 'GRADLE',
    GRAILS: 'GRAILS',
    JAVA: 'JAVA',
    JVM: 'JVM',
    NODE_JS: 'NODE_JS',
    PHP: 'PHP',
    PLAY: 'PLAY',
    PYTHON: 'PYTHON',
    SCALA: 'SCALA'
} as const;

export type BuildPackLanguageEnum = typeof BuildPackLanguageEnum[keyof typeof BuildPackLanguageEnum];


/**
 * 
 * @export
 * @interface CancelEnvironmentDeploymentRequest
 */
export interface CancelEnvironmentDeploymentRequest {
    /**
     * Force cancel everything running in this environment if set to true (e.q lifecycle jobs triggered during the deployment).
     * @type {boolean}
     * @memberof CancelEnvironmentDeploymentRequest
     */
    'force_cancel'?: boolean;
}
/**
 * 
 * @export
 * @interface CleanFailedJob200Response
 */
export interface CleanFailedJob200Response {
    /**
     * 
     * @type {Array<string>}
     * @memberof CleanFailedJob200Response
     */
    'clean_kubernetes_jobs'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CleanFailedJobs200Response
 */
export interface CleanFailedJobs200Response {
    /**
     * 
     * @type {Array<string>}
     * @memberof CleanFailedJobs200Response
     */
    'clean_job_ids'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CleanFailedJobs200Response
     */
    'clean_kubernetes_jobs'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CleanFailedJobsRequest
 */
export interface CleanFailedJobsRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof CleanFailedJobsRequest
     */
    'job_ids'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CloneEnvironmentRequest
 */
export interface CloneEnvironmentRequest {
    /**
     * name is case insensitive
     * @type {string}
     * @memberof CloneEnvironmentRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CloneEnvironmentRequest
     */
    'cluster_id'?: string;
    /**
     * 
     * @type {EnvironmentModeEnum}
     * @memberof CloneEnvironmentRequest
     */
    'mode'?: EnvironmentModeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof CloneEnvironmentRequest
     */
    'apply_deployment_rule'?: boolean;
}


/**
 * 
 * @export
 * @interface CloneServiceRequest
 */
export interface CloneServiceRequest {
    /**
     * 
     * @type {string}
     * @memberof CloneServiceRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CloneServiceRequest
     */
    'environment_id': string;
}
/**
 * 
 * @export
 * @interface CloudProvider
 */
export interface CloudProvider {
    /**
     * 
     * @type {string}
     * @memberof CloudProvider
     */
    'short_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CloudProvider
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CloudProvider
     */
    'logo_url'?: string;
    /**
     * 
     * @type {Array<ClusterRegion>}
     * @memberof CloudProvider
     */
    'regions'?: Array<ClusterRegion>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CloudProviderEnum = {
    AWS: 'AWS',
    SCW: 'SCW',
    GCP: 'GCP',
    ON_PREMISE: 'ON_PREMISE'
} as const;

export type CloudProviderEnum = typeof CloudProviderEnum[keyof typeof CloudProviderEnum];


/**
 * 
 * @export
 * @interface CloudProviderResponseList
 */
export interface CloudProviderResponseList {
    /**
     * 
     * @type {Array<CloudProvider>}
     * @memberof CloudProviderResponseList
     */
    'results'?: Array<CloudProvider>;
}
/**
 * 
 * @export
 * @interface Cluster
 */
export interface Cluster {
    /**
     * 
     * @type {string}
     * @memberof Cluster
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Cluster
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Cluster
     */
    'updated_at'?: string;
    /**
     * 
     * @type {ReferenceObject}
     * @memberof Cluster
     */
    'organization': ReferenceObject;
    /**
     * name is case-insensitive
     * @type {string}
     * @memberof Cluster
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Cluster
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Cluster
     */
    'region': string;
    /**
     * 
     * @type {CloudProviderEnum}
     * @memberof Cluster
     */
    'cloud_provider': CloudProviderEnum;
    /**
     * 
     * @type {number}
     * @memberof Cluster
     */
    'min_running_nodes'?: number;
    /**
     * 
     * @type {number}
     * @memberof Cluster
     */
    'max_running_nodes'?: number;
    /**
     * Unit is in GB. The disk size to be used for the node configuration
     * @type {number}
     * @memberof Cluster
     */
    'disk_size'?: number;
    /**
     * the instance type to be used for this cluster. The list of values can be retrieved via the endpoint /{CloudProvider}/instanceType
     * @type {string}
     * @memberof Cluster
     */
    'instance_type'?: string;
    /**
     * 
     * @type {KubernetesEnum}
     * @memberof Cluster
     */
    'kubernetes'?: KubernetesEnum;
    /**
     * unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof Cluster
     */
    'cpu'?: number;
    /**
     * unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof Cluster
     */
    'memory'?: number;
    /**
     * This is an estimation of the cost this cluster will represent on your cloud proider bill, based on your current configuration
     * @type {number}
     * @memberof Cluster
     */
    'estimated_cloud_provider_cost'?: number;
    /**
     * 
     * @type {ClusterStateEnum}
     * @memberof Cluster
     */
    'status'?: ClusterStateEnum;
    /**
     * 
     * @type {boolean}
     * @memberof Cluster
     */
    'has_access'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Cluster
     */
    'version'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Cluster
     */
    'is_default'?: boolean;
    /**
     * specific flag to indicate that this cluster is a demo one
     * @type {boolean}
     * @memberof Cluster
     */
    'is_demo'?: boolean;
    /**
     * specific flag to indicate that this cluster is a production one
     * @type {boolean}
     * @memberof Cluster
     */
    'production'?: boolean;
    /**
     * Indicate your public ssh_key to remotely connect to your EC2 instance.
     * @type {Array<string>}
     * @memberof Cluster
     */
    'ssh_keys'?: Array<string>;
    /**
     * 
     * @type {Array<ClusterFeatureResponse>}
     * @memberof Cluster
     */
    'features'?: Array<ClusterFeatureResponse>;
    /**
     * 
     * @type {ClusterDeploymentStatusEnum}
     * @memberof Cluster
     */
    'deployment_status'?: ClusterDeploymentStatusEnum;
}


/**
 * 
 * @export
 * @interface ClusterAdvancedSettings
 */
export interface ClusterAdvancedSettings {
    /**
     * Set the number of retention days for EKS Cloudwatch logs
     * @type {number}
     * @memberof ClusterAdvancedSettings
     */
    'aws.cloudwatch.eks_logs_retention_days'?: number;
    /**
     * Enable flow logs for on the VPC and store them in an S3 bucket
     * @type {boolean}
     * @memberof ClusterAdvancedSettings
     */
    'aws.vpc.enable_s3_flow_logs'?: boolean;
    /**
     * Set the number of retention days for flow logs. Disable with value \"0\"
     * @type {number}
     * @memberof ClusterAdvancedSettings
     */
    'aws.vpc.flow_logs_retention_days'?: number;
    /**
     * For how long in week loki is going to keep logs of your applications
     * @type {number}
     * @memberof ClusterAdvancedSettings
     */
    'loki.log_retention_in_week'?: number;
    /**
     * Configure the number of seconds before cleaning images in the registry
     * @type {number}
     * @memberof ClusterAdvancedSettings
     */
    'registry.image_retention_time'?: number;
    /**
     * Add additional tags on the cluster dedicated registry
     * @type {{ [key: string]: string; }}
     * @memberof ClusterAdvancedSettings
     */
    'cloud_provider.container_registry.tags'?: { [key: string]: string; };
    /**
     * Select the size of the main load_balancer (only effective for Scaleway)
     * @type {string}
     * @memberof ClusterAdvancedSettings
     */
    'load_balancer.size'?: string;
    /**
     * Deny public access to any PostgreSQL database
     * @type {boolean}
     * @memberof ClusterAdvancedSettings
     */
    'database.postgresql.deny_public_access'?: boolean;
    /**
     * List of CIDRs allowed to access the PostgreSQL database
     * @type {Array<string>}
     * @memberof ClusterAdvancedSettings
     */
    'database.postgresql.allowed_cidrs'?: Array<string>;
    /**
     * Deny public access to any MySql database
     * @type {boolean}
     * @memberof ClusterAdvancedSettings
     */
    'database.mysql.deny_public_access'?: boolean;
    /**
     * List of CIDRs allowed to access the MySql database
     * @type {Array<string>}
     * @memberof ClusterAdvancedSettings
     */
    'database.mysql.allowed_cidrs'?: Array<string>;
    /**
     * Deny public access to any MongoDB/DocumentDB database
     * @type {boolean}
     * @memberof ClusterAdvancedSettings
     */
    'database.mongodb.deny_public_access'?: boolean;
    /**
     * List of CIDRs allowed to access the MongoDB/DocumentDB database
     * @type {Array<string>}
     * @memberof ClusterAdvancedSettings
     */
    'database.mongodb.allowed_cidrs'?: Array<string>;
    /**
     * Deny public access to any Redis database
     * @type {boolean}
     * @memberof ClusterAdvancedSettings
     */
    'database.redis.deny_public_access'?: boolean;
    /**
     * List of CIDRs allowed to access the Redis database
     * @type {Array<string>}
     * @memberof ClusterAdvancedSettings
     */
    'database.redis.allowed_cidrs'?: Array<string>;
    /**
     * AWS IAM group name with cluster access
     * @type {string}
     * @memberof ClusterAdvancedSettings
     */
    'aws.iam.admin_group'?: string;
    /**
     * Specify the [IMDS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html) version you want to use:   * `required`: IMDS V2 only   * `optional`: IMDS V1 + V2 
     * @type {string}
     * @memberof ClusterAdvancedSettings
     */
    'aws.eks.ec2.metadata_imds'?: ClusterAdvancedSettingsAwsEksEc2MetadataImdsEnum;
    /**
     * 
     * @type {number}
     * @memberof ClusterAdvancedSettings
     * @deprecated
     */
    'pleco.resources_ttl'?: number;
    /**
     * 
     * @type {RegistryMirroringModeEnum}
     * @memberof ClusterAdvancedSettings
     */
    'registry.mirroring_mode'?: RegistryMirroringModeEnum;
    /**
     * vcpu request in millicores
     * @type {number}
     * @memberof ClusterAdvancedSettings
     */
    'nginx.vcpu.request_in_milli_cpu'?: number;
    /**
     * vcpu limit in millicores
     * @type {number}
     * @memberof ClusterAdvancedSettings
     */
    'nginx.vcpu.limit_in_milli_cpu'?: number;
    /**
     * memory request in MiB
     * @type {number}
     * @memberof ClusterAdvancedSettings
     */
    'nginx.memory.request_in_mib'?: number;
    /**
     * memory limit in MiB
     * @type {number}
     * @memberof ClusterAdvancedSettings
     */
    'nginx.memory.limit_in_mib'?: number;
    /**
     * hpa cpu threshold in percentage
     * @type {number}
     * @memberof ClusterAdvancedSettings
     */
    'nginx.hpa.cpu_utilization_percentage_threshold'?: number;
    /**
     * hpa minimum number of instances
     * @type {number}
     * @memberof ClusterAdvancedSettings
     */
    'nginx.hpa.min_number_instances'?: number;
    /**
     * hpa maximum number of instances
     * @type {number}
     * @memberof ClusterAdvancedSettings
     */
    'nginx.hpa.max_number_instances'?: number;
    /**
     * storage class name to use to provision pvc
     * @type {string}
     * @memberof ClusterAdvancedSettings
     */
    'storageclass.fast_ssd'?: string;
}

export const ClusterAdvancedSettingsAwsEksEc2MetadataImdsEnum = {
    OPTIONAL: 'optional',
    REQUIRED: 'required'
} as const;

export type ClusterAdvancedSettingsAwsEksEc2MetadataImdsEnum = typeof ClusterAdvancedSettingsAwsEksEc2MetadataImdsEnum[keyof typeof ClusterAdvancedSettingsAwsEksEc2MetadataImdsEnum];

/**
 * 
 * @export
 * @interface ClusterCloudProviderInfo
 */
export interface ClusterCloudProviderInfo {
    /**
     * 
     * @type {CloudProviderEnum}
     * @memberof ClusterCloudProviderInfo
     */
    'cloud_provider'?: CloudProviderEnum;
    /**
     * 
     * @type {ClusterCloudProviderInfoCredentials}
     * @memberof ClusterCloudProviderInfo
     */
    'credentials'?: ClusterCloudProviderInfoCredentials;
    /**
     * 
     * @type {string}
     * @memberof ClusterCloudProviderInfo
     */
    'region'?: string;
}


/**
 * 
 * @export
 * @interface ClusterCloudProviderInfoCredentials
 */
export interface ClusterCloudProviderInfoCredentials {
    /**
     * 
     * @type {string}
     * @memberof ClusterCloudProviderInfoCredentials
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterCloudProviderInfoCredentials
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface ClusterCloudProviderInfoRequest
 */
export interface ClusterCloudProviderInfoRequest {
    /**
     * 
     * @type {CloudProviderEnum}
     * @memberof ClusterCloudProviderInfoRequest
     */
    'cloud_provider'?: CloudProviderEnum;
    /**
     * 
     * @type {ClusterCloudProviderInfoCredentials}
     * @memberof ClusterCloudProviderInfoRequest
     */
    'credentials'?: ClusterCloudProviderInfoCredentials;
    /**
     * 
     * @type {string}
     * @memberof ClusterCloudProviderInfoRequest
     */
    'region'?: string;
}


/**
 * 
 * @export
 * @interface ClusterCredentials
 */
export interface ClusterCredentials {
    /**
     * 
     * @type {string}
     * @memberof ClusterCredentials
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ClusterCredentials
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ClusterCredentialsResponseList
 */
export interface ClusterCredentialsResponseList {
    /**
     * 
     * @type {Array<ClusterCredentials>}
     * @memberof ClusterCredentialsResponseList
     */
    'results'?: Array<ClusterCredentials>;
}
/**
 * Indicates the mode to apply on cluster deletion   **\"hard delete\"** means that we delete directly from our database, this is different from a **\"trigger delete\"** that cleans the resource - `DEFAULT`: this is the normal way, trigger delete the cluster only if no environment linked to this cluster remains - `DELETE_CLUSTER_AND_QOVERY_CONFIG`: hard delete environments linked to this cluster then trigger delete the cluster - `DELETE_QOVERY_CONFIG`: ⚠️ ⚠️ ⚠️ hard delete environments linked to this cluster then hard delete the cluster - whole cluster ressources **are not deleted** on our side and must be deleted on your side 
 * @export
 * @enum {string}
 */

export const ClusterDeleteMode = {
    DEFAULT: 'DEFAULT',
    DELETE_CLUSTER_AND_QOVERY_CONFIG: 'DELETE_CLUSTER_AND_QOVERY_CONFIG',
    DELETE_QOVERY_CONFIG: 'DELETE_QOVERY_CONFIG'
} as const;

export type ClusterDeleteMode = typeof ClusterDeleteMode[keyof typeof ClusterDeleteMode];


/**
 * 
 * @export
 * @enum {string}
 */

export const ClusterDeploymentStatusEnum = {
    NEVER_DEPLOYED: 'NEVER_DEPLOYED',
    OUT_OF_DATE: 'OUT_OF_DATE',
    UP_TO_DATE: 'UP_TO_DATE'
} as const;

export type ClusterDeploymentStatusEnum = typeof ClusterDeploymentStatusEnum[keyof typeof ClusterDeploymentStatusEnum];


/**
 * 
 * @export
 * @interface ClusterFeatureAwsExistingVpc
 */
export interface ClusterFeatureAwsExistingVpc {
    /**
     * 
     * @type {string}
     * @memberof ClusterFeatureAwsExistingVpc
     */
    'aws_vpc_eks_id': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClusterFeatureAwsExistingVpc
     */
    'eks_subnets_zone_a_ids': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClusterFeatureAwsExistingVpc
     */
    'eks_subnets_zone_b_ids': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClusterFeatureAwsExistingVpc
     */
    'eks_subnets_zone_c_ids': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClusterFeatureAwsExistingVpc
     */
    'documentdb_subnets_zone_a_ids'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClusterFeatureAwsExistingVpc
     */
    'documentdb_subnets_zone_b_ids'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClusterFeatureAwsExistingVpc
     */
    'documentdb_subnets_zone_c_ids'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClusterFeatureAwsExistingVpc
     */
    'elasticache_subnets_zone_a_ids'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClusterFeatureAwsExistingVpc
     */
    'elasticache_subnets_zone_b_ids'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClusterFeatureAwsExistingVpc
     */
    'elasticache_subnets_zone_c_ids'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClusterFeatureAwsExistingVpc
     */
    'rds_subnets_zone_a_ids'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClusterFeatureAwsExistingVpc
     */
    'rds_subnets_zone_b_ids'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClusterFeatureAwsExistingVpc
     */
    'rds_subnets_zone_c_ids'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClusterFeatureAwsExistingVpc
     */
    'eks_karpenter_fargate_subnets_zone_a_ids'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClusterFeatureAwsExistingVpc
     */
    'eks_karpenter_fargate_subnets_zone_b_ids'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClusterFeatureAwsExistingVpc
     */
    'eks_karpenter_fargate_subnets_zone_c_ids'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface ClusterFeatureAwsExistingVpcResponse
 */
export interface ClusterFeatureAwsExistingVpcResponse {
    /**
     * 
     * @type {ClusterFeatureResponseTypeEnum}
     * @memberof ClusterFeatureAwsExistingVpcResponse
     */
    'type': ClusterFeatureResponseTypeEnum;
    /**
     * 
     * @type {ClusterFeatureAwsExistingVpc}
     * @memberof ClusterFeatureAwsExistingVpcResponse
     */
    'value': ClusterFeatureAwsExistingVpc;
}


/**
 * 
 * @export
 * @interface ClusterFeatureBooleanResponse
 */
export interface ClusterFeatureBooleanResponse {
    /**
     * 
     * @type {ClusterFeatureResponseTypeEnum}
     * @memberof ClusterFeatureBooleanResponse
     */
    'type': ClusterFeatureResponseTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof ClusterFeatureBooleanResponse
     */
    'value': boolean;
}


/**
 * 
 * @export
 * @interface ClusterFeatureGcpExistingVpc
 */
export interface ClusterFeatureGcpExistingVpc {
    /**
     * 
     * @type {string}
     * @memberof ClusterFeatureGcpExistingVpc
     */
    'vpc_name': string;
    /**
     * 
     * @type {string}
     * @memberof ClusterFeatureGcpExistingVpc
     */
    'vpc_project_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ClusterFeatureGcpExistingVpc
     */
    'subnetwork_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ClusterFeatureGcpExistingVpc
     */
    'ip_range_services_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ClusterFeatureGcpExistingVpc
     */
    'ip_range_pods_name'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClusterFeatureGcpExistingVpc
     */
    'additional_ip_range_pods_names'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ClusterFeatureGcpExistingVpcResponse
 */
export interface ClusterFeatureGcpExistingVpcResponse {
    /**
     * 
     * @type {ClusterFeatureResponseTypeEnum}
     * @memberof ClusterFeatureGcpExistingVpcResponse
     */
    'type': ClusterFeatureResponseTypeEnum;
    /**
     * 
     * @type {ClusterFeatureGcpExistingVpc}
     * @memberof ClusterFeatureGcpExistingVpcResponse
     */
    'value': ClusterFeatureGcpExistingVpc;
}


/**
 * 
 * @export
 * @interface ClusterFeatureKarpenterParameters
 */
export interface ClusterFeatureKarpenterParameters {
    /**
     * 
     * @type {boolean}
     * @memberof ClusterFeatureKarpenterParameters
     */
    'spot_enabled': boolean;
    /**
     * 
     * @type {number}
     * @memberof ClusterFeatureKarpenterParameters
     */
    'disk_size_in_gib': number;
    /**
     * 
     * @type {CpuArchitectureEnum}
     * @memberof ClusterFeatureKarpenterParameters
     */
    'default_service_architecture': CpuArchitectureEnum;
}


/**
 * 
 * @export
 * @interface ClusterFeatureKarpenterParametersResponse
 */
export interface ClusterFeatureKarpenterParametersResponse {
    /**
     * 
     * @type {ClusterFeatureResponseTypeEnum}
     * @memberof ClusterFeatureKarpenterParametersResponse
     */
    'type': ClusterFeatureResponseTypeEnum;
    /**
     * 
     * @type {ClusterFeatureKarpenterParameters}
     * @memberof ClusterFeatureKarpenterParametersResponse
     */
    'value': ClusterFeatureKarpenterParameters;
}


/**
 * 
 * @export
 * @interface ClusterFeatureResponse
 */
export interface ClusterFeatureResponse {
    /**
     * 
     * @type {string}
     * @memberof ClusterFeatureResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterFeatureResponse
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterFeatureResponse
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ClusterFeatureResponse
     * @deprecated
     */
    'cost_per_month_in_cents'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ClusterFeatureResponse
     * @deprecated
     */
    'cost_per_month'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ClusterFeatureResponse
     * @deprecated
     */
    'currency_code'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ClusterFeatureResponse
     */
    'is_cloud_provider_paying_feature'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ClusterFeatureResponse
     */
    'cloud_provider_feature_documentation'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ClusterFeatureResponse
     */
    'is_qovery_paying_feature'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ClusterFeatureResponse
     */
    'qovery_feature_documentation'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ClusterFeatureResponse
     */
    'value_type'?: ClusterFeatureResponseValueTypeEnum;
    /**
     * 
     * @type {ClusterFeatureResponseValueObject}
     * @memberof ClusterFeatureResponse
     */
    'value_object'?: ClusterFeatureResponseValueObject | null;
    /**
     * 
     * @type {boolean}
     * @memberof ClusterFeatureResponse
     */
    'is_value_updatable'?: boolean;
    /**
     * 
     * @type {Array<ClusterFeatureResponseAcceptedValuesInner>}
     * @memberof ClusterFeatureResponse
     */
    'accepted_values'?: Array<ClusterFeatureResponseAcceptedValuesInner>;
}

export const ClusterFeatureResponseValueTypeEnum = {
    BOOLEAN: 'BOOLEAN'
} as const;

export type ClusterFeatureResponseValueTypeEnum = typeof ClusterFeatureResponseValueTypeEnum[keyof typeof ClusterFeatureResponseValueTypeEnum];

/**
 * @type ClusterFeatureResponseAcceptedValuesInner
 * @export
 */
export type ClusterFeatureResponseAcceptedValuesInner = boolean | string;

/**
 * 
 * @export
 * @interface ClusterFeatureResponseList
 */
export interface ClusterFeatureResponseList {
    /**
     * 
     * @type {Array<ClusterFeatureResponse>}
     * @memberof ClusterFeatureResponseList
     */
    'results'?: Array<ClusterFeatureResponse>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ClusterFeatureResponseTypeEnum = {
    STRING: 'STRING',
    BOOLEAN: 'BOOLEAN',
    AWS_USER_PROVIDED_NETWORK: 'AWS_USER_PROVIDED_NETWORK',
    GCP_USER_PROVIDED_NETWORK: 'GCP_USER_PROVIDED_NETWORK',
    KARPENTER: 'KARPENTER'
} as const;

export type ClusterFeatureResponseTypeEnum = typeof ClusterFeatureResponseTypeEnum[keyof typeof ClusterFeatureResponseTypeEnum];


/**
 * @type ClusterFeatureResponseValueObject
 * @export
 */
export type ClusterFeatureResponseValueObject = { type: 'AWS_USER_PROVIDED_NETWORK' } & ClusterFeatureAwsExistingVpcResponse | { type: 'BOOLEAN' } & ClusterFeatureBooleanResponse | { type: 'GCP_USER_PROVIDED_NETWORK' } & ClusterFeatureGcpExistingVpcResponse | { type: 'KARPENTER' } & ClusterFeatureKarpenterParametersResponse | { type: 'STRING' } & ClusterFeatureStringResponse;

/**
 * 
 * @export
 * @interface ClusterFeatureStringResponse
 */
export interface ClusterFeatureStringResponse {
    /**
     * 
     * @type {ClusterFeatureResponseTypeEnum}
     * @memberof ClusterFeatureStringResponse
     */
    'type': ClusterFeatureResponseTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ClusterFeatureStringResponse
     */
    'value': string;
}


/**
 * 
 * @export
 * @interface ClusterInstanceTypeResponseList
 */
export interface ClusterInstanceTypeResponseList {
    /**
     * 
     * @type {Array<ClusterInstanceTypeResponseListResultsInner>}
     * @memberof ClusterInstanceTypeResponseList
     */
    'results'?: Array<ClusterInstanceTypeResponseListResultsInner>;
}
/**
 * 
 * @export
 * @interface ClusterInstanceTypeResponseListResultsInner
 */
export interface ClusterInstanceTypeResponseListResultsInner {
    /**
     * 
     * @type {string}
     * @memberof ClusterInstanceTypeResponseListResultsInner
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof ClusterInstanceTypeResponseListResultsInner
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof ClusterInstanceTypeResponseListResultsInner
     */
    'cpu': number;
    /**
     * 
     * @type {number}
     * @memberof ClusterInstanceTypeResponseListResultsInner
     */
    'ram_in_gb': number;
    /**
     * 
     * @type {string}
     * @memberof ClusterInstanceTypeResponseListResultsInner
     */
    'bandwidth_in_gbps': string;
    /**
     * 
     * @type {string}
     * @memberof ClusterInstanceTypeResponseListResultsInner
     */
    'bandwidth_guarantee': string;
    /**
     * 
     * @type {string}
     * @memberof ClusterInstanceTypeResponseListResultsInner
     */
    'architecture'?: string;
}
/**
 * 
 * @export
 * @interface ClusterLogs
 */
export interface ClusterLogs {
    /**
     * log level
     * @type {string}
     * @memberof ClusterLogs
     */
    'type'?: string;
    /**
     * log date creation
     * @type {string}
     * @memberof ClusterLogs
     */
    'timestamp'?: string;
    /**
     * log step
     * @type {string}
     * @memberof ClusterLogs
     */
    'step'?: ClusterLogsStepEnum;
    /**
     * 
     * @type {ClusterLogsMessage}
     * @memberof ClusterLogs
     */
    'message'?: ClusterLogsMessage;
    /**
     * 
     * @type {ClusterLogsError}
     * @memberof ClusterLogs
     */
    'error'?: ClusterLogsError;
    /**
     * 
     * @type {ClusterLogsDetails}
     * @memberof ClusterLogs
     */
    'details'?: ClusterLogsDetails;
}

export const ClusterLogsStepEnum = {
    LOAD_CONFIGURATION: 'LoadConfiguration',
    CREATE: 'Create',
    CREATED: 'Created',
    CREATE_ERROR: 'CreateError',
    PAUSE: 'Pause',
    PAUSED: 'Paused',
    PAUSE_ERROR: 'PauseError',
    DELETE: 'Delete',
    DELETED: 'Deleted',
    DELETE_ERROR: 'DeleteError',
    RETRIEVE_CLUSTER_CONFIG: 'RetrieveClusterConfig',
    RETRIEVE_CLUSTER_RESOURCES: 'RetrieveClusterResources',
    VALIDATE_SYSTEM_REQUIREMENTS: 'ValidateSystemRequirements',
    UNDER_MIGRATION: 'UnderMigration',
    UNKNOWN: 'Unknown'
} as const;

export type ClusterLogsStepEnum = typeof ClusterLogsStepEnum[keyof typeof ClusterLogsStepEnum];

/**
 * Present only for `info`, `warning` and `debug` logs
 * @export
 * @interface ClusterLogsDetails
 */
export interface ClusterLogsDetails {
    /**
     * cloud provider used
     * @type {string}
     * @memberof ClusterLogsDetails
     */
    'provider_kind'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterLogsDetails
     */
    'region'?: string;
    /**
     * 
     * @type {ClusterLogsErrorEventDetailsTransmitter}
     * @memberof ClusterLogsDetails
     */
    'transmitter'?: ClusterLogsErrorEventDetailsTransmitter;
}
/**
 * Present only for `error` log
 * @export
 * @interface ClusterLogsError
 */
export interface ClusterLogsError {
    /**
     * log error tag
     * @type {string}
     * @memberof ClusterLogsError
     */
    'tag'?: string;
    /**
     * log details about the error
     * @type {string}
     * @memberof ClusterLogsError
     */
    'user_log_message'?: string;
    /**
     * link to our documentation
     * @type {string}
     * @memberof ClusterLogsError
     */
    'link'?: string;
    /**
     * hint the user can follow
     * @type {string}
     * @memberof ClusterLogsError
     */
    'hint_message'?: string;
    /**
     * 
     * @type {ClusterLogsErrorEventDetails}
     * @memberof ClusterLogsError
     */
    'event_details'?: ClusterLogsErrorEventDetails;
    /**
     * 
     * @type {ClusterLogsErrorUnderlyingError}
     * @memberof ClusterLogsError
     */
    'underlying_error'?: ClusterLogsErrorUnderlyingError;
}
/**
 * 
 * @export
 * @interface ClusterLogsErrorEventDetails
 */
export interface ClusterLogsErrorEventDetails {
    /**
     * cloud provider used
     * @type {string}
     * @memberof ClusterLogsErrorEventDetails
     */
    'provider_kind'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterLogsErrorEventDetails
     */
    'region'?: string;
    /**
     * 
     * @type {ClusterLogsErrorEventDetailsTransmitter}
     * @memberof ClusterLogsErrorEventDetails
     */
    'transmitter'?: ClusterLogsErrorEventDetailsTransmitter;
}
/**
 * 
 * @export
 * @interface ClusterLogsErrorEventDetailsTransmitter
 */
export interface ClusterLogsErrorEventDetailsTransmitter {
    /**
     * 
     * @type {string}
     * @memberof ClusterLogsErrorEventDetailsTransmitter
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterLogsErrorEventDetailsTransmitter
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterLogsErrorEventDetailsTransmitter
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface ClusterLogsErrorUnderlyingError
 */
export interface ClusterLogsErrorUnderlyingError {
    /**
     * technical details about the error
     * @type {string}
     * @memberof ClusterLogsErrorUnderlyingError
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ClusterLogsMessage
 */
export interface ClusterLogsMessage {
    /**
     * log global message
     * @type {string}
     * @memberof ClusterLogsMessage
     */
    'safe_message'?: string;
}
/**
 * 
 * @export
 * @interface ClusterLogsResponseList
 */
export interface ClusterLogsResponseList {
    /**
     * 
     * @type {Array<ClusterLogs>}
     * @memberof ClusterLogsResponseList
     */
    'results'?: Array<ClusterLogs>;
}
/**
 * 
 * @export
 * @interface ClusterReadinessStatus
 */
export interface ClusterReadinessStatus {
    /**
     * 
     * @type {boolean}
     * @memberof ClusterReadinessStatus
     */
    'is_ready'?: boolean;
}
/**
 * 
 * @export
 * @interface ClusterRegion
 */
export interface ClusterRegion {
    /**
     * 
     * @type {string}
     * @memberof ClusterRegion
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ClusterRegion
     */
    'country_code': string;
    /**
     * 
     * @type {string}
     * @memberof ClusterRegion
     */
    'country': string;
    /**
     * 
     * @type {string}
     * @memberof ClusterRegion
     */
    'city': string;
}
/**
 * 
 * @export
 * @interface ClusterRegionResponseList
 */
export interface ClusterRegionResponseList {
    /**
     * 
     * @type {Array<ClusterRegion>}
     * @memberof ClusterRegionResponseList
     */
    'results'?: Array<ClusterRegion>;
}
/**
 * 
 * @export
 * @interface ClusterRequest
 */
export interface ClusterRequest {
    /**
     * name is case-insensitive
     * @type {string}
     * @memberof ClusterRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ClusterRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterRequest
     */
    'region': string;
    /**
     * 
     * @type {CloudProviderEnum}
     * @memberof ClusterRequest
     */
    'cloud_provider': CloudProviderEnum;
    /**
     * 
     * @type {ClusterCloudProviderInfoRequest}
     * @memberof ClusterRequest
     */
    'cloud_provider_credentials'?: ClusterCloudProviderInfoRequest;
    /**
     * 
     * @type {number}
     * @memberof ClusterRequest
     */
    'min_running_nodes'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterRequest
     */
    'max_running_nodes'?: number;
    /**
     * Unit is in GB. The disk size to be used for the node configuration
     * @type {number}
     * @memberof ClusterRequest
     */
    'disk_size'?: number;
    /**
     * the instance type to be used for this cluster. The list of values can be retrieved via the endpoint /{CloudProvider}/instanceType
     * @type {string}
     * @memberof ClusterRequest
     */
    'instance_type'?: string;
    /**
     * 
     * @type {KubernetesEnum}
     * @memberof ClusterRequest
     */
    'kubernetes'?: KubernetesEnum;
    /**
     * specific flag to indicate that this cluster is a production one
     * @type {boolean}
     * @memberof ClusterRequest
     */
    'production'?: boolean;
    /**
     * Indicate your public ssh_key to remotely connect to your EC2 instance.
     * @type {Array<string>}
     * @memberof ClusterRequest
     */
    'ssh_keys'?: Array<string>;
    /**
     * 
     * @type {Array<ClusterRequestFeaturesInner>}
     * @memberof ClusterRequest
     */
    'features'?: Array<ClusterRequestFeaturesInner>;
}


/**
 * 
 * @export
 * @interface ClusterRequestFeaturesInner
 */
export interface ClusterRequestFeaturesInner {
    /**
     * 
     * @type {string}
     * @memberof ClusterRequestFeaturesInner
     */
    'id'?: string;
    /**
     * 
     * @type {ClusterRequestFeaturesInnerValue}
     * @memberof ClusterRequestFeaturesInner
     */
    'value'?: ClusterRequestFeaturesInnerValue | null;
}
/**
 * @type ClusterRequestFeaturesInnerValue
 * @export
 */
export type ClusterRequestFeaturesInnerValue = ClusterFeatureAwsExistingVpc | ClusterFeatureGcpExistingVpc | ClusterFeatureKarpenterParameters | boolean | string;

/**
 * 
 * @export
 * @interface ClusterResponseList
 */
export interface ClusterResponseList {
    /**
     * 
     * @type {Array<Cluster>}
     * @memberof ClusterResponseList
     */
    'results'?: Array<Cluster>;
}
/**
 * 
 * @export
 * @interface ClusterRoutingTable
 */
export interface ClusterRoutingTable {
    /**
     * 
     * @type {Array<ClusterRoutingTableResultsInner>}
     * @memberof ClusterRoutingTable
     */
    'results'?: Array<ClusterRoutingTableResultsInner>;
}
/**
 * 
 * @export
 * @interface ClusterRoutingTableRequest
 */
export interface ClusterRoutingTableRequest {
    /**
     * 
     * @type {Array<ClusterRoutingTableResultsInner>}
     * @memberof ClusterRoutingTableRequest
     */
    'routes': Array<ClusterRoutingTableResultsInner>;
}
/**
 * 
 * @export
 * @interface ClusterRoutingTableResultsInner
 */
export interface ClusterRoutingTableResultsInner {
    /**
     * 
     * @type {string}
     * @memberof ClusterRoutingTableResultsInner
     */
    'destination': string;
    /**
     * 
     * @type {string}
     * @memberof ClusterRoutingTableResultsInner
     */
    'target': string;
    /**
     * 
     * @type {string}
     * @memberof ClusterRoutingTableResultsInner
     */
    'description': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ClusterStateEnum = {
    BUILDING: 'BUILDING',
    BUILD_ERROR: 'BUILD_ERROR',
    CANCELED: 'CANCELED',
    CANCELING: 'CANCELING',
    DELETED: 'DELETED',
    DELETE_ERROR: 'DELETE_ERROR',
    DELETE_QUEUED: 'DELETE_QUEUED',
    DELETING: 'DELETING',
    DEPLOYED: 'DEPLOYED',
    DEPLOYING: 'DEPLOYING',
    DEPLOYMENT_ERROR: 'DEPLOYMENT_ERROR',
    DEPLOYMENT_QUEUED: 'DEPLOYMENT_QUEUED',
    QUEUED: 'QUEUED',
    READY: 'READY',
    STOPPED: 'STOPPED',
    STOPPING: 'STOPPING',
    STOP_ERROR: 'STOP_ERROR',
    STOP_QUEUED: 'STOP_QUEUED',
    RESTART_QUEUED: 'RESTART_QUEUED',
    RESTARTING: 'RESTARTING',
    RESTARTED: 'RESTARTED',
    RESTART_ERROR: 'RESTART_ERROR',
    INVALID_CREDENTIALS: 'INVALID_CREDENTIALS'
} as const;

export type ClusterStateEnum = typeof ClusterStateEnum[keyof typeof ClusterStateEnum];


/**
 * 
 * @export
 * @interface ClusterStatus
 */
export interface ClusterStatus {
    /**
     * 
     * @type {string}
     * @memberof ClusterStatus
     */
    'cluster_id'?: string;
    /**
     * 
     * @type {ClusterStateEnum}
     * @memberof ClusterStatus
     */
    'status'?: ClusterStateEnum;
    /**
     * 
     * @type {boolean}
     * @memberof ClusterStatus
     */
    'is_deployed'?: boolean;
}


/**
 * 
 * @export
 * @interface ClusterStatusGet
 */
export interface ClusterStatusGet {
    /**
     * 
     * @type {string}
     * @memberof ClusterStatusGet
     */
    'cluster_id'?: string;
    /**
     * 
     * @type {ClusterStateEnum}
     * @memberof ClusterStatusGet
     */
    'status'?: ClusterStateEnum;
    /**
     * 
     * @type {boolean}
     * @memberof ClusterStatusGet
     */
    'is_deployed'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ClusterStatusGet
     */
    'last_execution_id'?: string;
}


/**
 * 
 * @export
 * @interface ClusterStatusResponseList
 */
export interface ClusterStatusResponseList {
    /**
     * 
     * @type {Array<ClusterStatusGet>}
     * @memberof ClusterStatusResponseList
     */
    'results'?: Array<ClusterStatusGet>;
}
/**
 * 
 * @export
 * @interface Commit
 */
export interface Commit {
    /**
     * 
     * @type {string}
     * @memberof Commit
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Commit
     */
    'git_commit_id': string;
    /**
     * 
     * @type {string}
     * @memberof Commit
     */
    'tag': string;
    /**
     * 
     * @type {string}
     * @memberof Commit
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof Commit
     */
    'author_name': string;
    /**
     * 
     * @type {string}
     * @memberof Commit
     */
    'author_avatar_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof Commit
     */
    'commit_page_url'?: string;
}
/**
 * 
 * @export
 * @interface CommitResponseList
 */
export interface CommitResponseList {
    /**
     * 
     * @type {Array<Commit>}
     * @memberof CommitResponseList
     */
    'results'?: Array<Commit>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CompanySizeEnum = {
    _1_10: '1-10',
    _11_50: '11-50',
    _51_200: '51-200',
    _201_500: '201-500',
    _500: '500+'
} as const;

export type CompanySizeEnum = typeof CompanySizeEnum[keyof typeof CompanySizeEnum];


/**
 * 
 * @export
 * @interface ContainerAdvancedSettings
 */
export interface ContainerAdvancedSettings {
    /**
     * disable custom domain check when deploying an application
     * @type {boolean}
     * @memberof ContainerAdvancedSettings
     */
    'deployment.custom_domain_check_enabled'?: boolean;
    /**
     * define how long in seconds an application is supposed to be stopped gracefully
     * @type {number}
     * @memberof ContainerAdvancedSettings
     */
    'deployment.termination_grace_period_seconds'?: number;
    /**
     * Set pod placement on specific Kubernetes nodes labels
     * @type {{ [key: string]: string; }}
     * @memberof ContainerAdvancedSettings
     */
    'deployment.affinity.node.required'?: { [key: string]: string; };
    /**
     * Define how you want pods affinity to behave: * `Preferred` allows, but does not require, pods of a given service are not co-located (or co-hosted) on a single node * `Requirred` ensures that the pods of a given service are not co-located (or co-hosted) on a single node (safer in term of availability but can be expensive depending on the number of replicas) 
     * @type {string}
     * @memberof ContainerAdvancedSettings
     */
    'deployment.antiaffinity.pod'?: ContainerAdvancedSettingsDeploymentAntiaffinityPodEnum;
    /**
     * * `RollingUpdate` gracefully rollout new versions, and automatically rollback if the new version fails to start * `Recreate` stop all current versions and create new ones once all old ones have been shutdown 
     * @type {string}
     * @memberof ContainerAdvancedSettings
     */
    'deployment.update_strategy.type'?: ContainerAdvancedSettingsDeploymentUpdateStrategyTypeEnum;
    /**
     * Define the percentage of a maximum number of pods that can be unavailable during the update process
     * @type {number}
     * @memberof ContainerAdvancedSettings
     */
    'deployment.update_strategy.rolling_update.max_unavailable_percent'?: number;
    /**
     * Define the percentage of the maximum number of pods that can be created over the desired number of pods
     * @type {number}
     * @memberof ContainerAdvancedSettings
     */
    'deployment.update_strategy.rolling_update.max_surge_percent'?: number;
    /**
     * 
     * @type {number}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.proxy_body_size_mb'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.enable_cors'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.cors_allow_origin'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.cors_allow_methods'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.cors_allow_headers'?: string;
    /**
     * header buffer size used while reading response header from upstream
     * @type {number}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.proxy_buffer_size_kb'?: number;
    /**
     * Limits the maximum time (in seconds) during which requests can be processed through one keepalive connection
     * @type {number}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.keepalive_time_seconds'?: number;
    /**
     * Sets a timeout (in seconds) during which an idle keepalive connection to an upstream server will stay open.
     * @type {number}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.keepalive_timeout_seconds'?: number;
    /**
     * Sets a timeout (in seconds) for transmitting a response to the client
     * @type {number}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.send_timeout_seconds'?: number;
    /**
     * Sets a timeout (in seconds) for establishing a connection to a proxied server
     * @type {number}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.proxy_connect_timeout_seconds'?: number;
    /**
     * Sets a timeout (in seconds) for transmitting a request to the proxied server
     * @type {number}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.proxy_send_timeout_seconds'?: number;
    /**
     * Sets a timeout (in seconds) for reading a response from the proxied server
     * @type {number}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.proxy_read_timeout_seconds'?: number;
    /**
     * Allows to enable or disable nginx `proxy-buffering`
     * @type {string}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.proxy_buffering'?: string;
    /**
     * Allows to enable or disable nginx `proxy-request-buffering`
     * @type {string}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.proxy_request_buffering'?: string;
    /**
     * Sets a timeout (in seconds) for transmitting a request to the grpc server
     * @type {number}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.grpc_send_timeout_seconds'?: number;
    /**
     * Sets a timeout (in seconds) for transmitting a request to the grpc server
     * @type {number}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.grpc_read_timeout_seconds'?: number;
    /**
     * list of source ranges to allow access to ingress proxy.  This property can be used to whitelist source IP ranges for ingress proxy. The value is a comma separated list of CIDRs, e.g. 10.0.0.0/24,172.10.0.1 To allow all source ranges, set 0.0.0.0/0. 
     * @type {string}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.whitelist_source_range'?: string;
    /**
     * list of source ranges to deny access to ingress proxy.  This property can be used to blacklist source IP ranges for ingress proxy. The value is a comma separated list of CIDRs, e.g. 10.0.0.0/24,172.10.0.1 
     * @type {string}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.denylist_source_range'?: string;
    /**
     * Allows to define response headers
     * @type {string}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.extra_headers'?: string;
    /**
     * Set the name of an environment variable to use as a basic authentication (`login:crypted_password`) from `htpasswd` command. You can add multiples comma separated values. 
     * @type {string}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.basic_auth_env_var'?: string;
    /**
     * Enable the load balancer to bind a user\'s session to a specific target. This ensures that all requests from the user during the session are sent to the same target 
     * @type {boolean}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.enable_sticky_session'?: boolean;
    /**
     * Allows you to set an existing Kubernetes service account name 
     * @type {string}
     * @memberof ContainerAdvancedSettings
     */
    'security.service_account_name'?: string;
    /**
     * Percentage value of cpu usage at which point pods should scale up.
     * @type {number}
     * @memberof ContainerAdvancedSettings
     */
    'hpa.cpu.average_utilization_percent'?: number;
    /**
     * Automount Kubernetes service account token to have access to Kubernetes API from pods 
     * @type {boolean}
     * @memberof ContainerAdvancedSettings
     */
    'security.automount_service_account_token'?: boolean;
    /**
     * Mounts the container\'s root filesystem as read-only 
     * @type {boolean}
     * @memberof ContainerAdvancedSettings
     */
    'security.read_only_root_filesystem'?: boolean;
}

export const ContainerAdvancedSettingsDeploymentAntiaffinityPodEnum = {
    PREFERRED: 'Preferred',
    REQUIRRED: 'Requirred'
} as const;

export type ContainerAdvancedSettingsDeploymentAntiaffinityPodEnum = typeof ContainerAdvancedSettingsDeploymentAntiaffinityPodEnum[keyof typeof ContainerAdvancedSettingsDeploymentAntiaffinityPodEnum];
export const ContainerAdvancedSettingsDeploymentUpdateStrategyTypeEnum = {
    ROLLING_UPDATE: 'RollingUpdate',
    RECREATE: 'Recreate'
} as const;

export type ContainerAdvancedSettingsDeploymentUpdateStrategyTypeEnum = typeof ContainerAdvancedSettingsDeploymentUpdateStrategyTypeEnum[keyof typeof ContainerAdvancedSettingsDeploymentUpdateStrategyTypeEnum];

/**
 * 
 * @export
 * @interface ContainerDeployRequest
 */
export interface ContainerDeployRequest {
    /**
     * Image tag to deploy
     * @type {string}
     * @memberof ContainerDeployRequest
     */
    'image_tag': string;
}
/**
 * 
 * @export
 * @interface ContainerImageCheckRequest
 */
export interface ContainerImageCheckRequest {
    /**
     * 
     * @type {string}
     * @memberof ContainerImageCheckRequest
     */
    'registry_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerImageCheckRequest
     */
    'image_name': string;
    /**
     * 
     * @type {string}
     * @memberof ContainerImageCheckRequest
     */
    'tag': string;
}
/**
 * 
 * @export
 * @interface ContainerNetwork
 */
export interface ContainerNetwork {
    /**
     * Specify if the sticky session option (also called persistant session) is activated or not for this container. If activated, user will be redirected by the load balancer to the same instance each time he access to the container.  
     * @type {boolean}
     * @memberof ContainerNetwork
     */
    'sticky_session'?: boolean;
}
/**
 * 
 * @export
 * @interface ContainerNetworkRequest
 */
export interface ContainerNetworkRequest {
    /**
     * Specify if the sticky session option (also called persistant session) is activated or not for this container. If activated, user will be redirected by the load balancer to the same instance each time he access to the container.  
     * @type {boolean}
     * @memberof ContainerNetworkRequest
     */
    'sticky_session'?: boolean;
}
/**
 * The type of your container registry
 * @export
 * @enum {string}
 */

export const ContainerRegistryKindEnum = {
    ECR: 'ECR',
    SCALEWAY_CR: 'SCALEWAY_CR',
    DOCKER_HUB: 'DOCKER_HUB',
    GITHUB_CR: 'GITHUB_CR',
    GITLAB_CR: 'GITLAB_CR',
    PUBLIC_ECR: 'PUBLIC_ECR',
    DOCR: 'DOCR',
    GENERIC_CR: 'GENERIC_CR',
    GCP_ARTIFACT_REGISTRY: 'GCP_ARTIFACT_REGISTRY'
} as const;

export type ContainerRegistryKindEnum = typeof ContainerRegistryKindEnum[keyof typeof ContainerRegistryKindEnum];


/**
 * 
 * @export
 * @interface ContainerRegistryProviderDetailsResponse
 */
export interface ContainerRegistryProviderDetailsResponse {
    /**
     * 
     * @type {string}
     * @memberof ContainerRegistryProviderDetailsResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ContainerRegistryProviderDetailsResponse
     */
    'name': string;
    /**
     * URL of the container registry
     * @type {string}
     * @memberof ContainerRegistryProviderDetailsResponse
     */
    'url': string;
    /**
     * 
     * @type {ContainerRegistryKindEnum}
     * @memberof ContainerRegistryProviderDetailsResponse
     */
    'kind': ContainerRegistryKindEnum;
}


/**
 * 
 * @export
 * @interface ContainerRegistryRequest
 */
export interface ContainerRegistryRequest {
    /**
     * 
     * @type {string}
     * @memberof ContainerRegistryRequest
     */
    'name': string;
    /**
     * 
     * @type {ContainerRegistryKindEnum}
     * @memberof ContainerRegistryRequest
     */
    'kind': ContainerRegistryKindEnum;
    /**
     * 
     * @type {string}
     * @memberof ContainerRegistryRequest
     */
    'description'?: string;
    /**
     * URL of the container registry: * For `DOCKER_HUB`: it must be `https://docker.io` (default with \'https://docker.io\' if no url provided for `DOCKER_HUB`) * For `GITHUB_CR`: it must be `https://ghcr.io` (default with \'https://ghcr.io\' if no url provided for `GITHUB_CR`) * For `GITLAB_CR`: it must be `https://registry.gitlab.com` (default with \'https://registry.gitlab.com\' if no url provided for `GITLAB_CR`) * For others: it\'s required and must start by `https://` 
     * @type {string}
     * @memberof ContainerRegistryRequest
     */
    'url'?: string;
    /**
     * 
     * @type {ContainerRegistryRequestConfig}
     * @memberof ContainerRegistryRequest
     */
    'config': ContainerRegistryRequestConfig;
}


/**
 * This field is dependent of the container registry kind: * `ECR` needs in the config: region, access_key_id, secret_access_key * `SCALEWAY_CR` needs in the config: region, scaleway_access_key, scaleway_secret_key * `GCP_ARTIFACT_REGISTRY` needs in the config: region, json_credentials * `DOCKER_HUB` needs in the config (optional): username, password * `GITHUB_CR` needs in the config (optional): username, password * `GITLAB_CR` needs in the config (optional): username, password * `PUBLIC_ECR` doesn\'t need credentials info * `GENERIC_CR` needs in the config (optional): username, password * `DOCR` is not supported anymore 
 * @export
 * @interface ContainerRegistryRequestConfig
 */
export interface ContainerRegistryRequestConfig {
    /**
     * Required if kind is `ECR` or `PUBLIC_ECR`
     * @type {string}
     * @memberof ContainerRegistryRequestConfig
     */
    'access_key_id'?: string;
    /**
     * Required if kind is `ECR` or `PUBLIC_ECR`
     * @type {string}
     * @memberof ContainerRegistryRequestConfig
     */
    'secret_access_key'?: string;
    /**
     * Required if kind is `ECR` or `SCALEWAY_CR`
     * @type {string}
     * @memberof ContainerRegistryRequestConfig
     */
    'region'?: string;
    /**
     * Required if kind is `SCALEWAY_CR`
     * @type {string}
     * @memberof ContainerRegistryRequestConfig
     */
    'scaleway_access_key'?: string;
    /**
     * Required if kind is `SCALEWAY_CR`
     * @type {string}
     * @memberof ContainerRegistryRequestConfig
     */
    'scaleway_secret_key'?: string;
    /**
     * Required if kind is `GCP_ARTIFACT_REGISTRY`
     * @type {string}
     * @memberof ContainerRegistryRequestConfig
     */
    'json_credentials'?: string;
    /**
     * optional, for kind `DOCKER_HUB`   We encourage you to set credentials for Docker Hub due to the limits on the pull rate 
     * @type {string}
     * @memberof ContainerRegistryRequestConfig
     */
    'username'?: string;
    /**
     * optional, for kind `DOCKER_HUB`   We encourage you to set credentials for Docker Hub due to the limits on the pull rate 
     * @type {string}
     * @memberof ContainerRegistryRequestConfig
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface ContainerRegistryResponse
 */
export interface ContainerRegistryResponse {
    /**
     * 
     * @type {string}
     * @memberof ContainerRegistryResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ContainerRegistryResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ContainerRegistryResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerRegistryResponse
     */
    'name'?: string;
    /**
     * 
     * @type {ContainerRegistryKindEnum}
     * @memberof ContainerRegistryResponse
     */
    'kind'?: ContainerRegistryKindEnum;
    /**
     * 
     * @type {string}
     * @memberof ContainerRegistryResponse
     */
    'description'?: string;
    /**
     * URL of the container registry
     * @type {string}
     * @memberof ContainerRegistryResponse
     */
    'url'?: string;
    /**
     * 
     * @type {ContainerRegistryResponseAllOfCluster}
     * @memberof ContainerRegistryResponse
     */
    'cluster'?: ContainerRegistryResponseAllOfCluster;
}


/**
 * 
 * @export
 * @interface ContainerRegistryResponseAllOfCluster
 */
export interface ContainerRegistryResponseAllOfCluster {
    /**
     * 
     * @type {string}
     * @memberof ContainerRegistryResponseAllOfCluster
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ContainerRegistryResponseAllOfCluster
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ContainerRegistryResponseList
 */
export interface ContainerRegistryResponseList {
    /**
     * 
     * @type {Array<ContainerRegistryResponse>}
     * @memberof ContainerRegistryResponseList
     */
    'results'?: Array<ContainerRegistryResponse>;
}
/**
 * 
 * @export
 * @interface ContainerRequest
 */
export interface ContainerRequest {
    /**
     * 
     * @type {Array<ServiceStorageRequestStorageInner>}
     * @memberof ContainerRequest
     */
    'storage'?: Array<ServiceStorageRequestStorageInner>;
    /**
     * 
     * @type {Array<ServicePortRequestPortsInner>}
     * @memberof ContainerRequest
     */
    'ports'?: Array<ServicePortRequestPortsInner>;
    /**
     * name is case insensitive
     * @type {string}
     * @memberof ContainerRequest
     */
    'name': string;
    /**
     * give a description to this container
     * @type {string}
     * @memberof ContainerRequest
     */
    'description'?: string;
    /**
     * id of the linked registry
     * @type {string}
     * @memberof ContainerRequest
     */
    'registry_id': string;
    /**
     * The image name pattern differs according to chosen container registry provider:   * `ECR`: `repository` * `SCALEWAY_CR`: `namespace/image` * `DOCKER_HUB`: `image` or `repository/image` * `PUBLIC_ECR`: `registry_alias/repository` 
     * @type {string}
     * @memberof ContainerRequest
     */
    'image_name': string;
    /**
     * tag of the image container
     * @type {string}
     * @memberof ContainerRequest
     */
    'tag': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ContainerRequest
     */
    'arguments'?: Array<string>;
    /**
     * optional entrypoint when launching container
     * @type {string}
     * @memberof ContainerRequest
     */
    'entrypoint'?: string;
    /**
     * unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof ContainerRequest
     */
    'cpu'?: number;
    /**
     * unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof ContainerRequest
     */
    'memory'?: number;
    /**
     * Minimum number of instances running. This resource auto-scale based on the CPU and Memory consumption. Note: 0 means that there is no container running. 
     * @type {number}
     * @memberof ContainerRequest
     */
    'min_running_instances'?: number;
    /**
     * Maximum number of instances running. This resource auto-scale based on the CPU and Memory consumption. Note: -1 means that there is no limit. 
     * @type {number}
     * @memberof ContainerRequest
     */
    'max_running_instances'?: number;
    /**
     * 
     * @type {Healthcheck}
     * @memberof ContainerRequest
     */
    'healthchecks': Healthcheck;
    /**
     * Indicates if the \'environment preview option\' is enabled for this container.   If enabled, a preview environment will be automatically cloned when `/preview` endpoint is called.   If not specified, it takes the value of the `auto_preview` property from the associated environment. 
     * @type {boolean}
     * @memberof ContainerRequest
     */
    'auto_preview'?: boolean;
    /**
     * Specify if the container will be automatically updated after receiving a new image tag.  The new image tag shall be communicated via the \"Auto Deploy container\" endpoint https://api-doc.qovery.com/#tag/Containers/operation/autoDeployContainerEnvironments 
     * @type {boolean}
     * @memberof ContainerRequest
     */
    'auto_deploy'?: boolean | null;
    /**
     * 
     * @type {Array<ServiceAnnotationRequest>}
     * @memberof ContainerRequest
     */
    'annotations_groups'?: Array<ServiceAnnotationRequest>;
    /**
     * 
     * @type {Array<ServiceLabelRequest>}
     * @memberof ContainerRequest
     */
    'labels_groups'?: Array<ServiceLabelRequest>;
    /**
     * Icon URI representing the container.
     * @type {string}
     * @memberof ContainerRequest
     */
    'icon_uri'?: string;
}
/**
 * 
 * @export
 * @interface ContainerResponse
 */
export interface ContainerResponse {
    /**
     * 
     * @type {string}
     * @memberof ContainerResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ContainerResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ContainerResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {Array<ServiceStorageStorageInner>}
     * @memberof ContainerResponse
     */
    'storage'?: Array<ServiceStorageStorageInner>;
    /**
     * The image name pattern differs according to chosen container registry provider: * `ECR`: `repository` * `SCALEWAY_CR`: `namespace/image` * `DOCKER_HUB`: `image` or `repository/image` * `PUBLIC_ECR`: `registry_alias/repository` 
     * @type {string}
     * @memberof ContainerResponse
     */
    'image_name': string;
    /**
     * tag of the image container
     * @type {string}
     * @memberof ContainerResponse
     */
    'tag': string;
    /**
     * tag of the image container
     * @type {string}
     * @memberof ContainerResponse
     */
    'registry_id'?: string;
    /**
     * 
     * @type {ContainerRegistryProviderDetailsResponse}
     * @memberof ContainerResponse
     */
    'registry': ContainerRegistryProviderDetailsResponse;
    /**
     * 
     * @type {ReferenceObject}
     * @memberof ContainerResponse
     */
    'environment': ReferenceObject;
    /**
     * Maximum cpu that can be allocated to the container based on organization cluster configuration. unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof ContainerResponse
     */
    'maximum_cpu': number;
    /**
     * Maximum memory that can be allocated to the container based on organization cluster configuration. unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof ContainerResponse
     */
    'maximum_memory': number;
    /**
     * name is case insensitive
     * @type {string}
     * @memberof ContainerResponse
     */
    'name': string;
    /**
     * give a description to this container
     * @type {string}
     * @memberof ContainerResponse
     */
    'description'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ContainerResponse
     */
    'arguments'?: Array<string>;
    /**
     * optional entrypoint when launching container
     * @type {string}
     * @memberof ContainerResponse
     */
    'entrypoint'?: string;
    /**
     * unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof ContainerResponse
     */
    'cpu': number;
    /**
     * unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof ContainerResponse
     */
    'memory': number;
    /**
     * Minimum number of instances running. This resource auto-scale based on the CPU and Memory consumption. Note: 0 means that there is no container running. 
     * @type {number}
     * @memberof ContainerResponse
     */
    'min_running_instances': number;
    /**
     * Maximum number of instances running. This resource auto-scale based on the CPU and Memory consumption. Note: -1 means that there is no limit. 
     * @type {number}
     * @memberof ContainerResponse
     */
    'max_running_instances': number;
    /**
     * 
     * @type {Healthcheck}
     * @memberof ContainerResponse
     */
    'healthchecks': Healthcheck;
    /**
     * Indicates if the \'environment preview option\' is enabled for this container.   If enabled, a preview environment will be automatically cloned when `/preview` endpoint is called.   If not specified, it takes the value of the `auto_preview` property from the associated environment. 
     * @type {boolean}
     * @memberof ContainerResponse
     */
    'auto_preview': boolean;
    /**
     * 
     * @type {Array<ServicePort>}
     * @memberof ContainerResponse
     */
    'ports'?: Array<ServicePort>;
    /**
     * Specify if the container will be automatically updated after receiving a new image tag.  The new image tag shall be communicated via the \"Auto Deploy container\" endpoint https://api-doc.qovery.com/#tag/Containers/operation/autoDeployContainerEnvironments 
     * @type {boolean}
     * @memberof ContainerResponse
     */
    'auto_deploy'?: boolean;
    /**
     * 
     * @type {Array<OrganizationAnnotationsGroupResponse>}
     * @memberof ContainerResponse
     */
    'annotations_groups'?: Array<OrganizationAnnotationsGroupResponse>;
    /**
     * 
     * @type {Array<OrganizationLabelsGroupResponse>}
     * @memberof ContainerResponse
     */
    'labels_groups'?: Array<OrganizationLabelsGroupResponse>;
    /**
     * Icon URI representing the container.
     * @type {string}
     * @memberof ContainerResponse
     */
    'icon_uri': string;
}
/**
 * 
 * @export
 * @interface ContainerResponseList
 */
export interface ContainerResponseList {
    /**
     * 
     * @type {Array<ContainerResponse>}
     * @memberof ContainerResponseList
     */
    'results'?: Array<ContainerResponse>;
}
/**
 * 
 * @export
 * @interface ContainerSource
 */
export interface ContainerSource {
    /**
     * The image name pattern differs according to chosen container registry provider: * `ECR`: `repository` * `SCALEWAY_CR`: `namespace/image` * `DOCKER_HUB`: `image` or `repository/image` * `PUBLIC_ECR`: `registry_alias/repository` 
     * @type {string}
     * @memberof ContainerSource
     */
    'image_name': string;
    /**
     * tag of the image container
     * @type {string}
     * @memberof ContainerSource
     */
    'tag': string;
    /**
     * tag of the image container
     * @type {string}
     * @memberof ContainerSource
     */
    'registry_id'?: string;
    /**
     * 
     * @type {ContainerRegistryProviderDetailsResponse}
     * @memberof ContainerSource
     */
    'registry': ContainerRegistryProviderDetailsResponse;
}
/**
 * 
 * @export
 * @interface ContainerVersionResponse
 */
export interface ContainerVersionResponse {
    /**
     * 
     * @type {string}
     * @memberof ContainerVersionResponse
     */
    'image_name'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ContainerVersionResponse
     */
    'versions'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ContainerVersionResponseList
 */
export interface ContainerVersionResponseList {
    /**
     * 
     * @type {Array<ContainerVersionResponse>}
     * @memberof ContainerVersionResponseList
     */
    'results'?: Array<ContainerVersionResponse>;
}
/**
 * 
 * @export
 * @interface Cost
 */
export interface Cost {
    /**
     * 
     * @type {number}
     * @memberof Cost
     */
    'total_in_cents': number;
    /**
     * 
     * @type {number}
     * @memberof Cost
     */
    'total': number;
    /**
     * 
     * @type {string}
     * @memberof Cost
     */
    'currency_code': string;
}
/**
 * 
 * @export
 * @interface CostRange
 */
export interface CostRange {
    /**
     * 
     * @type {number}
     * @memberof CostRange
     */
    'min_cost_in_cents'?: number;
    /**
     * 
     * @type {number}
     * @memberof CostRange
     */
    'min_cost'?: number;
    /**
     * 
     * @type {number}
     * @memberof CostRange
     */
    'max_cost_in_cents'?: number;
    /**
     * 
     * @type {number}
     * @memberof CostRange
     */
    'max_cost'?: number;
    /**
     * 
     * @type {string}
     * @memberof CostRange
     */
    'currency_code': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CpuArchitectureEnum = {
    AMD64: 'AMD64',
    ARM64: 'ARM64'
} as const;

export type CpuArchitectureEnum = typeof CpuArchitectureEnum[keyof typeof CpuArchitectureEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const CreateEnvironmentModeEnum = {
    DEVELOPMENT: 'DEVELOPMENT',
    PRODUCTION: 'PRODUCTION',
    STAGING: 'STAGING'
} as const;

export type CreateEnvironmentModeEnum = typeof CreateEnvironmentModeEnum[keyof typeof CreateEnvironmentModeEnum];


/**
 * 
 * @export
 * @interface CreateEnvironmentRequest
 */
export interface CreateEnvironmentRequest {
    /**
     * name is case insensitive
     * @type {string}
     * @memberof CreateEnvironmentRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateEnvironmentRequest
     */
    'cluster'?: string;
    /**
     * 
     * @type {CreateEnvironmentModeEnum}
     * @memberof CreateEnvironmentRequest
     */
    'mode'?: CreateEnvironmentModeEnum;
}


/**
 * 
 * @export
 * @interface Credentials
 */
export interface Credentials {
    /**
     * 
     * @type {string}
     * @memberof Credentials
     */
    'host': string;
    /**
     * 
     * @type {number}
     * @memberof Credentials
     */
    'port': number;
    /**
     * 
     * @type {string}
     * @memberof Credentials
     */
    'login': string;
    /**
     * 
     * @type {string}
     * @memberof Credentials
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface CredentialsRequest
 */
export interface CredentialsRequest {
    /**
     * 
     * @type {string}
     * @memberof CredentialsRequest
     */
    'login': string;
    /**
     * 
     * @type {string}
     * @memberof CredentialsRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface CreditCard
 */
export interface CreditCard {
    /**
     * 
     * @type {string}
     * @memberof CreditCard
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CreditCard
     */
    'created_at': string;
    /**
     * 
     * @type {number}
     * @memberof CreditCard
     */
    'expiry_month': number;
    /**
     * 
     * @type {number}
     * @memberof CreditCard
     */
    'expiry_year': number;
    /**
     * 
     * @type {string}
     * @memberof CreditCard
     */
    'last_digit': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreditCard
     */
    'is_expired': boolean;
    /**
     * 
     * @type {string}
     * @memberof CreditCard
     */
    'brand': string;
}
/**
 * 
 * @export
 * @interface CreditCardRequest
 */
export interface CreditCardRequest {
    /**
     * 
     * @type {string}
     * @memberof CreditCardRequest
     */
    'number': string;
    /**
     * 
     * @type {string}
     * @memberof CreditCardRequest
     */
    'cvv': string;
    /**
     * 
     * @type {number}
     * @memberof CreditCardRequest
     */
    'expiry_month': number;
    /**
     * 
     * @type {number}
     * @memberof CreditCardRequest
     */
    'expiry_year': number;
}
/**
 * 
 * @export
 * @interface CreditCardResponseList
 */
export interface CreditCardResponseList {
    /**
     * 
     * @type {Array<CreditCard>}
     * @memberof CreditCardResponseList
     */
    'results'?: Array<CreditCard>;
}
/**
 * 
 * @export
 * @interface CronJobResponse
 */
export interface CronJobResponse {
    /**
     * 
     * @type {string}
     * @memberof CronJobResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CronJobResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof CronJobResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {ReferenceObject}
     * @memberof CronJobResponse
     */
    'environment': ReferenceObject;
    /**
     * Maximum cpu that can be allocated to the job based on organization cluster configuration. unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof CronJobResponse
     */
    'maximum_cpu': number;
    /**
     * Maximum memory that can be allocated to the job based on organization cluster configuration. unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof CronJobResponse
     */
    'maximum_memory': number;
    /**
     * name is case insensitive
     * @type {string}
     * @memberof CronJobResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CronJobResponse
     */
    'description'?: string;
    /**
     * unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof CronJobResponse
     */
    'cpu': number;
    /**
     * unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof CronJobResponse
     */
    'memory': number;
    /**
     * Maximum number of restart allowed before the job is considered as failed 0 means that no restart/crash of the job is allowed 
     * @type {number}
     * @memberof CronJobResponse
     */
    'max_nb_restart'?: number;
    /**
     * Maximum number of seconds allowed for the job to run before killing it and mark it as failed 
     * @type {number}
     * @memberof CronJobResponse
     */
    'max_duration_seconds'?: number;
    /**
     * Indicates if the \'environment preview option\' is enabled for this container.   If enabled, a preview environment will be automatically cloned when `/preview` endpoint is called.   If not specified, it takes the value of the `auto_preview` property from the associated environment. 
     * @type {boolean}
     * @memberof CronJobResponse
     */
    'auto_preview': boolean;
    /**
     * Port where to run readiness and liveliness probes checks. The port will not be exposed externally
     * @type {number}
     * @memberof CronJobResponse
     */
    'port'?: number | null;
    /**
     * 
     * @type {BaseJobResponseAllOfSource}
     * @memberof CronJobResponse
     */
    'source': BaseJobResponseAllOfSource;
    /**
     * 
     * @type {Healthcheck}
     * @memberof CronJobResponse
     */
    'healthchecks': Healthcheck;
    /**
     * Specify if the job will be automatically updated after receiving a new image tag or a new commit according to the source type.  The new image tag shall be communicated via the \"Auto Deploy job\" endpoint https://api-doc.qovery.com/#tag/Jobs/operation/autoDeployJobEnvironments 
     * @type {boolean}
     * @memberof CronJobResponse
     */
    'auto_deploy'?: boolean;
    /**
     * Icon URI representing the job.
     * @type {string}
     * @memberof CronJobResponse
     */
    'icon_uri': string;
    /**
     * 
     * @type {string}
     * @memberof CronJobResponse
     */
    'job_type': CronJobResponseJobTypeEnum;
    /**
     * 
     * @type {CronJobResponseAllOfSchedule}
     * @memberof CronJobResponse
     */
    'schedule': CronJobResponseAllOfSchedule;
    /**
     * 
     * @type {Array<OrganizationAnnotationsGroupResponse>}
     * @memberof CronJobResponse
     */
    'annotations_groups'?: Array<OrganizationAnnotationsGroupResponse>;
    /**
     * 
     * @type {Array<OrganizationLabelsGroupResponse>}
     * @memberof CronJobResponse
     */
    'labels_groups'?: Array<OrganizationLabelsGroupResponse>;
}

export const CronJobResponseJobTypeEnum = {
    CRON: 'CRON'
} as const;

export type CronJobResponseJobTypeEnum = typeof CronJobResponseJobTypeEnum[keyof typeof CronJobResponseJobTypeEnum];

/**
 * 
 * @export
 * @interface CronJobResponseAllOfSchedule
 */
export interface CronJobResponseAllOfSchedule {
    /**
     * 
     * @type {CronJobResponseAllOfScheduleCronjob}
     * @memberof CronJobResponseAllOfSchedule
     */
    'cronjob': CronJobResponseAllOfScheduleCronjob;
}
/**
 * 
 * @export
 * @interface CronJobResponseAllOfScheduleCronjob
 */
export interface CronJobResponseAllOfScheduleCronjob {
    /**
     * 
     * @type {Array<string>}
     * @memberof CronJobResponseAllOfScheduleCronjob
     */
    'arguments'?: Array<string>;
    /**
     * optional entrypoint when launching container
     * @type {string}
     * @memberof CronJobResponseAllOfScheduleCronjob
     */
    'entrypoint'?: string;
    /**
     * tz identifier at which the schedule at will be executed
     * @type {string}
     * @memberof CronJobResponseAllOfScheduleCronjob
     */
    'timezone': string;
    /**
     * Can only be set if the event is CRON.   Represent the cron format for the job schedule without seconds.   For example: `* * * * *` represent the cron to launch the job every minute.   See https://crontab.guru/ to WISIWIG interface.   Timezone is UT 
     * @type {string}
     * @memberof CronJobResponseAllOfScheduleCronjob
     */
    'scheduled_at': string;
}
/**
 * 
 * @export
 * @interface CurrentCost
 */
export interface CurrentCost {
    /**
     * 
     * @type {PlanEnum}
     * @memberof CurrentCost
     */
    'plan'?: PlanEnum;
    /**
     * number of days remaining before the end of the trial period
     * @type {number}
     * @memberof CurrentCost
     */
    'remaining_trial_day'?: number;
    /**
     * date when the current plan will be renewed
     * @type {string}
     * @memberof CurrentCost
     */
    'renewal_at'?: string | null;
    /**
     * 
     * @type {Cost}
     * @memberof CurrentCost
     */
    'cost'?: Cost;
}


/**
 * 
 * @export
 * @interface CustomDomain
 */
export interface CustomDomain {
    /**
     * 
     * @type {string}
     * @memberof CustomDomain
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CustomDomain
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof CustomDomain
     */
    'updated_at'?: string;
    /**
     * your custom domain
     * @type {string}
     * @memberof CustomDomain
     */
    'domain': string;
    /**
     * to control if a certificate has to be generated for this custom domain by Qovery. The default value is `true`. This flag should be set to `false` if a CDN or other entities are managing the certificate for the specified domain and the traffic is proxied by the CDN to Qovery.
     * @type {boolean}
     * @memberof CustomDomain
     */
    'generate_certificate': boolean;
    /**
     * URL provided by Qovery. You must create a CNAME on your DNS provider using that URL
     * @type {string}
     * @memberof CustomDomain
     */
    'validation_domain'?: string;
    /**
     * 
     * @type {CustomDomainStatusEnum}
     * @memberof CustomDomain
     */
    'status'?: CustomDomainStatusEnum;
}


/**
 * 
 * @export
 * @interface CustomDomainRequest
 */
export interface CustomDomainRequest {
    /**
     * your custom domain
     * @type {string}
     * @memberof CustomDomainRequest
     */
    'domain': string;
    /**
     * to control if a certificate has to be generated for this custom domain by Qovery. The default value is `true`. This flag should be set to `false` if a CDN or other entities are managing the certificate for the specified domain and the traffic is proxied by the CDN to Qovery.
     * @type {boolean}
     * @memberof CustomDomainRequest
     */
    'generate_certificate': boolean;
}
/**
 * 
 * @export
 * @interface CustomDomainResponseList
 */
export interface CustomDomainResponseList {
    /**
     * 
     * @type {Array<CustomDomain>}
     * @memberof CustomDomainResponseList
     */
    'results'?: Array<CustomDomain>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CustomDomainStatusEnum = {
    VALIDATION_PENDING: 'VALIDATION_PENDING'
} as const;

export type CustomDomainStatusEnum = typeof CustomDomainStatusEnum[keyof typeof CustomDomainStatusEnum];


/**
 * 
 * @export
 * @interface Database
 */
export interface Database {
    /**
     * 
     * @type {string}
     * @memberof Database
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Database
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Database
     */
    'updated_at'?: string;
    /**
     * name is case insensitive
     * @type {string}
     * @memberof Database
     */
    'name': string;
    /**
     * give a description to this database
     * @type {string}
     * @memberof Database
     */
    'description'?: string;
    /**
     * 
     * @type {DatabaseTypeEnum}
     * @memberof Database
     */
    'type': DatabaseTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Database
     */
    'version': string;
    /**
     * 
     * @type {DatabaseModeEnum}
     * @memberof Database
     */
    'mode': DatabaseModeEnum;
    /**
     * 
     * @type {DatabaseAccessibilityEnum}
     * @memberof Database
     */
    'accessibility'?: DatabaseAccessibilityEnum;
    /**
     * unit is millicores (m). 1000m = 1 cpu This field will be ignored for managed DB (instance type will be used instead). 
     * @type {number}
     * @memberof Database
     */
    'cpu'?: number;
    /**
     * Database instance type to be used for this database. The list of values can be retrieved via the endpoint /{CloudProvider}/managedDatabase/instanceType/{region}/{dbType}. This field is null for container DB.
     * @type {string}
     * @memberof Database
     */
    'instance_type'?: string;
    /**
     * unit is MB. 1024 MB = 1GB This field will be ignored for managed DB (instance type will be used instead). Default value is linked to the database type: - MANAGED: `100` - CONTAINER   - POSTGRES: `100`   - REDIS: `100`   - MYSQL: `512`   - MONGODB: `256` 
     * @type {number}
     * @memberof Database
     */
    'memory'?: number;
    /**
     * unit is GB
     * @type {number}
     * @memberof Database
     */
    'storage'?: number;
    /**
     * 
     * @type {Array<OrganizationAnnotationsGroupResponse>}
     * @memberof Database
     */
    'annotations_groups'?: Array<OrganizationAnnotationsGroupResponse>;
    /**
     * 
     * @type {Array<OrganizationLabelsGroupResponse>}
     * @memberof Database
     */
    'labels_groups'?: Array<OrganizationLabelsGroupResponse>;
    /**
     * Icon URI representing the database.
     * @type {string}
     * @memberof Database
     */
    'icon_uri': string;
    /**
     * 
     * @type {ReferenceObject}
     * @memberof Database
     */
    'environment': ReferenceObject;
    /**
     * 
     * @type {string}
     * @memberof Database
     */
    'host'?: string;
    /**
     * 
     * @type {number}
     * @memberof Database
     */
    'port'?: number;
    /**
     * Maximum cpu that can be allocated to the database based on organization cluster configuration. unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof Database
     */
    'maximum_cpu'?: number;
    /**
     * Maximum memory that can be allocated to the database based on organization cluster configuration. unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof Database
     */
    'maximum_memory'?: number;
    /**
     * indicates if the database disk is encrypted or not
     * @type {boolean}
     * @memberof Database
     */
    'disk_encrypted'?: boolean;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const DatabaseAccessibilityEnum = {
    PRIVATE: 'PRIVATE',
    PUBLIC: 'PUBLIC'
} as const;

export type DatabaseAccessibilityEnum = typeof DatabaseAccessibilityEnum[keyof typeof DatabaseAccessibilityEnum];


/**
 * 
 * @export
 * @interface DatabaseConfiguration
 */
export interface DatabaseConfiguration {
    /**
     * 
     * @type {DatabaseTypeEnum}
     * @memberof DatabaseConfiguration
     */
    'database_type'?: DatabaseTypeEnum;
    /**
     * 
     * @type {Array<DatabaseVersionMode>}
     * @memberof DatabaseConfiguration
     */
    'version'?: Array<DatabaseVersionMode>;
}


/**
 * 
 * @export
 * @interface DatabaseConfigurationResponseList
 */
export interface DatabaseConfigurationResponseList {
    /**
     * 
     * @type {Array<DatabaseConfiguration>}
     * @memberof DatabaseConfigurationResponseList
     */
    'results'?: Array<DatabaseConfiguration>;
}
/**
 * 
 * @export
 * @interface DatabaseEditRequest
 */
export interface DatabaseEditRequest {
    /**
     * name is case-insensitive
     * @type {string}
     * @memberof DatabaseEditRequest
     */
    'name'?: string;
    /**
     * give a description to this database
     * @type {string}
     * @memberof DatabaseEditRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof DatabaseEditRequest
     */
    'version'?: string;
    /**
     * 
     * @type {DatabaseAccessibilityEnum}
     * @memberof DatabaseEditRequest
     */
    'accessibility'?: DatabaseAccessibilityEnum;
    /**
     * unit is millicores (m). 1000m = 1 cpu. This field will be ignored for managed DB (instance type will be used instead). 
     * @type {number}
     * @memberof DatabaseEditRequest
     */
    'cpu'?: number;
    /**
     * unit is MB. 1024 MB = 1GB This field will be ignored for managed DB (instance type will be used instead). Default value is linked to the database type: - MANAGED: 100 - CONTAINER   - POSTGRES: 100   - REDIS: 100   - MYSQL: 512   - MONGODB: 256 
     * @type {number}
     * @memberof DatabaseEditRequest
     */
    'memory'?: number;
    /**
     * unit is GB
     * @type {number}
     * @memberof DatabaseEditRequest
     */
    'storage'?: number;
    /**
     * Database instance type to be used for this database. The list of values can be retrieved via the endpoint /{CloudProvider}/managedDatabase/instanceType/{region}/{dbType}. This field SHOULD NOT be set for container DB.
     * @type {string}
     * @memberof DatabaseEditRequest
     */
    'instance_type'?: string;
    /**
     * 
     * @type {Array<ServiceAnnotationRequest>}
     * @memberof DatabaseEditRequest
     */
    'annotations_groups'?: Array<ServiceAnnotationRequest>;
    /**
     * 
     * @type {Array<ServiceLabelRequest>}
     * @memberof DatabaseEditRequest
     */
    'labels_groups'?: Array<ServiceLabelRequest>;
    /**
     * Icon URI representing the database.
     * @type {string}
     * @memberof DatabaseEditRequest
     */
    'icon_uri'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const DatabaseModeEnum = {
    CONTAINER: 'CONTAINER',
    MANAGED: 'MANAGED'
} as const;

export type DatabaseModeEnum = typeof DatabaseModeEnum[keyof typeof DatabaseModeEnum];


/**
 * 
 * @export
 * @interface DatabaseRequest
 */
export interface DatabaseRequest {
    /**
     * name is case insensitive
     * @type {string}
     * @memberof DatabaseRequest
     */
    'name': string;
    /**
     * give a description to this database
     * @type {string}
     * @memberof DatabaseRequest
     */
    'description'?: string;
    /**
     * 
     * @type {DatabaseTypeEnum}
     * @memberof DatabaseRequest
     */
    'type': DatabaseTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof DatabaseRequest
     */
    'version': string;
    /**
     * 
     * @type {DatabaseModeEnum}
     * @memberof DatabaseRequest
     */
    'mode': DatabaseModeEnum;
    /**
     * 
     * @type {DatabaseAccessibilityEnum}
     * @memberof DatabaseRequest
     */
    'accessibility'?: DatabaseAccessibilityEnum;
    /**
     * unit is millicores (m). 1000m = 1 cpu This field will be ignored for managed DB (instance type will be used instead). 
     * @type {number}
     * @memberof DatabaseRequest
     */
    'cpu'?: number;
    /**
     * Database instance type to be used for this database. The list of values can be retrieved via the endpoint /{CloudProvider}/managedDatabase/instanceType/{region}/{dbType}. This field SHOULD NOT be set for container DB.
     * @type {string}
     * @memberof DatabaseRequest
     */
    'instance_type'?: string;
    /**
     * unit is MB. 1024 MB = 1GB This field will be ignored for managed DB (instance type will be used instead). Default value is linked to the database type: - MANAGED: `100` - CONTAINER   - POSTGRES: `100`   - REDIS: `100`   - MYSQL: `512`   - MONGODB: `256` 
     * @type {number}
     * @memberof DatabaseRequest
     */
    'memory'?: number;
    /**
     * unit is GB
     * @type {number}
     * @memberof DatabaseRequest
     */
    'storage'?: number;
    /**
     * 
     * @type {Array<ServiceAnnotationRequest>}
     * @memberof DatabaseRequest
     */
    'annotations_groups'?: Array<ServiceAnnotationRequest>;
    /**
     * 
     * @type {Array<ServiceLabelRequest>}
     * @memberof DatabaseRequest
     */
    'labels_groups'?: Array<ServiceLabelRequest>;
    /**
     * Icon URI representing the database.
     * @type {string}
     * @memberof DatabaseRequest
     */
    'icon_uri'?: string;
}


/**
 * 
 * @export
 * @interface DatabaseResponseList
 */
export interface DatabaseResponseList {
    /**
     * 
     * @type {Array<Database>}
     * @memberof DatabaseResponseList
     */
    'results'?: Array<Database>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const DatabaseTypeEnum = {
    MONGODB: 'MONGODB',
    MYSQL: 'MYSQL',
    POSTGRESQL: 'POSTGRESQL',
    REDIS: 'REDIS'
} as const;

export type DatabaseTypeEnum = typeof DatabaseTypeEnum[keyof typeof DatabaseTypeEnum];


/**
 * 
 * @export
 * @interface DatabaseVersionMode
 */
export interface DatabaseVersionMode {
    /**
     * 
     * @type {string}
     * @memberof DatabaseVersionMode
     */
    'name'?: string;
    /**
     * 
     * @type {DatabaseModeEnum}
     * @memberof DatabaseVersionMode
     */
    'supported_mode'?: DatabaseModeEnum;
}


/**
 * 
 * @export
 * @interface DeleteMemberRequest
 */
export interface DeleteMemberRequest {
    /**
     * 
     * @type {string}
     * @memberof DeleteMemberRequest
     */
    'user_id': string;
}
/**
 * 
 * @export
 * @interface DeployAllRequest
 */
export interface DeployAllRequest {
    /**
     * 
     * @type {Array<DeployAllRequestApplicationsInner>}
     * @memberof DeployAllRequest
     */
    'applications'?: Array<DeployAllRequestApplicationsInner>;
    /**
     * 
     * @type {Array<string>}
     * @memberof DeployAllRequest
     */
    'databases'?: Array<string>;
    /**
     * 
     * @type {Array<DeployAllRequestContainersInner>}
     * @memberof DeployAllRequest
     */
    'containers'?: Array<DeployAllRequestContainersInner>;
    /**
     * 
     * @type {Array<DeployAllRequestJobsInner>}
     * @memberof DeployAllRequest
     */
    'jobs'?: Array<DeployAllRequestJobsInner>;
    /**
     * 
     * @type {Array<DeployAllRequestHelmsInner>}
     * @memberof DeployAllRequest
     */
    'helms'?: Array<DeployAllRequestHelmsInner>;
}
/**
 * 
 * @export
 * @interface DeployAllRequestApplicationsInner
 */
export interface DeployAllRequestApplicationsInner {
    /**
     * id of the application to be deployed.
     * @type {string}
     * @memberof DeployAllRequestApplicationsInner
     */
    'application_id': string;
    /**
     * Commit ID to deploy. Can be empty only if the service has been already deployed (in this case the service version won\'t be changed)
     * @type {string}
     * @memberof DeployAllRequestApplicationsInner
     */
    'git_commit_id'?: string;
}
/**
 * 
 * @export
 * @interface DeployAllRequestContainersInner
 */
export interface DeployAllRequestContainersInner {
    /**
     * id of the container to be updated.
     * @type {string}
     * @memberof DeployAllRequestContainersInner
     */
    'id': string;
    /**
     * new tag for the container. Can be empty only if the service has been already deployed (in this case the service version won\'t be changed)
     * @type {string}
     * @memberof DeployAllRequestContainersInner
     */
    'image_tag'?: string;
}
/**
 * 
 * @export
 * @interface DeployAllRequestHelmsInner
 */
export interface DeployAllRequestHelmsInner {
    /**
     * id of the helm to be updated.
     * @type {string}
     * @memberof DeployAllRequestHelmsInner
     */
    'id'?: string;
    /**
     * The new chart version for the Helm source. Use this only if the helm has a Helm repository source.
     * @type {string}
     * @memberof DeployAllRequestHelmsInner
     */
    'chart_version'?: string;
    /**
     * The commit Id to deploy. Use this only if the helm has a Git repository source.
     * @type {string}
     * @memberof DeployAllRequestHelmsInner
     */
    'git_commit_id'?: string;
    /**
     * The commit Id of the override values to deploy. Use only if the helm has a Git override values repository.
     * @type {string}
     * @memberof DeployAllRequestHelmsInner
     */
    'values_override_git_commit_id'?: string;
}
/**
 * 
 * @export
 * @interface DeployAllRequestJobsInner
 */
export interface DeployAllRequestJobsInner {
    /**
     * id of the job to be updated.
     * @type {string}
     * @memberof DeployAllRequestJobsInner
     */
    'id'?: string;
    /**
     * new tag for the job image. Use only if job is an image source. Can be empty only if the service has been already deployed (in this case the service version won\'t be changed)
     * @type {string}
     * @memberof DeployAllRequestJobsInner
     */
    'image_tag'?: string;
    /**
     * Commit ID to deploy. Use only if job is a repository source. Can be empty only if the service has been already deployed (in this case the service version won\'t be changed)
     * @type {string}
     * @memberof DeployAllRequestJobsInner
     */
    'git_commit_id'?: string;
}
/**
 * 
 * @export
 * @interface DeployRequest
 */
export interface DeployRequest {
    /**
     * Commit ID to deploy
     * @type {string}
     * @memberof DeployRequest
     */
    'git_commit_id': string;
}
/**
 * 
 * @export
 * @interface DeploymentHistory
 */
export interface DeploymentHistory {
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistory
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistory
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistory
     */
    'updated_at'?: string;
    /**
     * name of the service
     * @type {string}
     * @memberof DeploymentHistory
     */
    'name'?: string;
    /**
     * 
     * @type {Commit}
     * @memberof DeploymentHistory
     */
    'commit'?: Commit | null;
    /**
     * 
     * @type {DeploymentHistoryStatusEnum}
     * @memberof DeploymentHistory
     */
    'status'?: DeploymentHistoryStatusEnum;
}


/**
 * 
 * @export
 * @interface DeploymentHistoryApplication
 */
export interface DeploymentHistoryApplication {
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryApplication
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryApplication
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryApplication
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryApplication
     */
    'name'?: string;
    /**
     * 
     * @type {Commit}
     * @memberof DeploymentHistoryApplication
     */
    'commit'?: Commit | null;
    /**
     * 
     * @type {StateEnum}
     * @memberof DeploymentHistoryApplication
     */
    'status'?: StateEnum;
}


/**
 * 
 * @export
 * @interface DeploymentHistoryContainer
 */
export interface DeploymentHistoryContainer {
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryContainer
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryContainer
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryContainer
     */
    'updated_at'?: string;
    /**
     * name of the container
     * @type {string}
     * @memberof DeploymentHistoryContainer
     */
    'name'?: string;
    /**
     * 
     * @type {StateEnum}
     * @memberof DeploymentHistoryContainer
     */
    'status'?: StateEnum;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryContainer
     */
    'image_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryContainer
     */
    'tag'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DeploymentHistoryContainer
     */
    'arguments'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryContainer
     */
    'entrypoint'?: string;
}


/**
 * 
 * @export
 * @interface DeploymentHistoryDatabase
 */
export interface DeploymentHistoryDatabase {
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryDatabase
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryDatabase
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryDatabase
     */
    'updated_at'?: string;
    /**
     * name of the service
     * @type {string}
     * @memberof DeploymentHistoryDatabase
     */
    'name'?: string;
    /**
     * 
     * @type {StateEnum}
     * @memberof DeploymentHistoryDatabase
     */
    'status'?: StateEnum;
}


/**
 * 
 * @export
 * @interface DeploymentHistoryEnvironment
 */
export interface DeploymentHistoryEnvironment {
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryEnvironment
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryEnvironment
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryEnvironment
     */
    'updated_at'?: string;
    /**
     * 
     * @type {StateEnum}
     * @memberof DeploymentHistoryEnvironment
     */
    'status'?: StateEnum;
    /**
     * 
     * @type {OrganizationEventOrigin}
     * @memberof DeploymentHistoryEnvironment
     */
    'origin'?: OrganizationEventOrigin;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryEnvironment
     */
    'triggered_by'?: string;
    /**
     * 
     * @type {Array<DeploymentHistoryApplication>}
     * @memberof DeploymentHistoryEnvironment
     */
    'applications'?: Array<DeploymentHistoryApplication>;
    /**
     * 
     * @type {Array<DeploymentHistoryContainer>}
     * @memberof DeploymentHistoryEnvironment
     */
    'containers'?: Array<DeploymentHistoryContainer>;
    /**
     * 
     * @type {Array<DeploymentHistoryDatabase>}
     * @memberof DeploymentHistoryEnvironment
     */
    'databases'?: Array<DeploymentHistoryDatabase>;
    /**
     * 
     * @type {Array<DeploymentHistoryJobResponse>}
     * @memberof DeploymentHistoryEnvironment
     */
    'jobs'?: Array<DeploymentHistoryJobResponse>;
    /**
     * 
     * @type {Array<DeploymentHistoryHelmResponse>}
     * @memberof DeploymentHistoryEnvironment
     */
    'helms'?: Array<DeploymentHistoryHelmResponse>;
}


/**
 * 
 * @export
 * @interface DeploymentHistoryEnvironmentPaginatedResponseList
 */
export interface DeploymentHistoryEnvironmentPaginatedResponseList {
    /**
     * 
     * @type {number}
     * @memberof DeploymentHistoryEnvironmentPaginatedResponseList
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof DeploymentHistoryEnvironmentPaginatedResponseList
     */
    'page_size': number;
    /**
     * 
     * @type {Array<DeploymentHistoryEnvironment>}
     * @memberof DeploymentHistoryEnvironmentPaginatedResponseList
     */
    'results'?: Array<DeploymentHistoryEnvironment>;
}
/**
 * 
 * @export
 * @interface DeploymentHistoryHelmResponse
 */
export interface DeploymentHistoryHelmResponse {
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryHelmResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryHelmResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryHelmResponse
     */
    'updated_at'?: string;
    /**
     * name of the helm
     * @type {string}
     * @memberof DeploymentHistoryHelmResponse
     */
    'name'?: string;
    /**
     * 
     * @type {StateEnum}
     * @memberof DeploymentHistoryHelmResponse
     */
    'status'?: StateEnum;
    /**
     * 
     * @type {Commit}
     * @memberof DeploymentHistoryHelmResponse
     */
    'commit'?: Commit | null;
    /**
     * 
     * @type {DeploymentHistoryHelmResponseAllOfRepository}
     * @memberof DeploymentHistoryHelmResponse
     */
    'repository'?: DeploymentHistoryHelmResponseAllOfRepository | null;
}


/**
 * If the chart source if from a repository, the chart name and its version
 * @export
 * @interface DeploymentHistoryHelmResponseAllOfRepository
 */
export interface DeploymentHistoryHelmResponseAllOfRepository {
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryHelmResponseAllOfRepository
     */
    'chart_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryHelmResponseAllOfRepository
     */
    'chart_version'?: string;
}
/**
 * 
 * @export
 * @interface DeploymentHistoryJobResponse
 */
export interface DeploymentHistoryJobResponse {
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryJobResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryJobResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryJobResponse
     */
    'updated_at'?: string;
    /**
     * name of the job
     * @type {string}
     * @memberof DeploymentHistoryJobResponse
     */
    'name'?: string;
    /**
     * 
     * @type {StateEnum}
     * @memberof DeploymentHistoryJobResponse
     */
    'status'?: StateEnum;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryJobResponse
     */
    'image_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryJobResponse
     */
    'tag'?: string;
    /**
     * 
     * @type {Commit}
     * @memberof DeploymentHistoryJobResponse
     */
    'commit'?: Commit | null;
    /**
     * 
     * @type {DeploymentHistoryJobResponseAllOfSchedule}
     * @memberof DeploymentHistoryJobResponse
     */
    'schedule'?: DeploymentHistoryJobResponseAllOfSchedule;
    /**
     * 
     * @type {Array<string>}
     * @memberof DeploymentHistoryJobResponse
     */
    'arguments'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryJobResponse
     */
    'entrypoint'?: string;
}


/**
 * 
 * @export
 * @interface DeploymentHistoryJobResponseAllOfSchedule
 */
export interface DeploymentHistoryJobResponseAllOfSchedule {
    /**
     * 
     * @type {JobScheduleEvent}
     * @memberof DeploymentHistoryJobResponseAllOfSchedule
     */
    'event'?: JobScheduleEvent;
    /**
     * Can only be set if the event is CRON. Represent the cron format for the job schedule without seconds. For example: `* * * * *` represent the cron to launch the job every minute. See https://crontab.guru/ to WISIWIG interface. Timezone is UTC 
     * @type {string}
     * @memberof DeploymentHistoryJobResponseAllOfSchedule
     */
    'schedule_at'?: string | null;
}


/**
 * 
 * @export
 * @interface DeploymentHistoryPaginatedResponseList
 */
export interface DeploymentHistoryPaginatedResponseList {
    /**
     * 
     * @type {number}
     * @memberof DeploymentHistoryPaginatedResponseList
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof DeploymentHistoryPaginatedResponseList
     */
    'page_size': number;
    /**
     * 
     * @type {Array<DeploymentHistory>}
     * @memberof DeploymentHistoryPaginatedResponseList
     */
    'results'?: Array<DeploymentHistory>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const DeploymentHistoryStatusEnum = {
    FAILED: 'FAILED',
    SUCCESS: 'SUCCESS'
} as const;

export type DeploymentHistoryStatusEnum = typeof DeploymentHistoryStatusEnum[keyof typeof DeploymentHistoryStatusEnum];


/**
 * Match mode will rebuild app only if specified items are updated. Exclude mode will not rebuild app if specified items are updated.
 * @export
 * @enum {string}
 */

export const DeploymentRestrictionModeEnum = {
    EXCLUDE: 'EXCLUDE',
    MATCH: 'MATCH'
} as const;

export type DeploymentRestrictionModeEnum = typeof DeploymentRestrictionModeEnum[keyof typeof DeploymentRestrictionModeEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const DeploymentRestrictionTypeEnum = {
    PATH: 'PATH'
} as const;

export type DeploymentRestrictionTypeEnum = typeof DeploymentRestrictionTypeEnum[keyof typeof DeploymentRestrictionTypeEnum];


/**
 * 
 * @export
 * @interface DeploymentStageRequest
 */
export interface DeploymentStageRequest {
    /**
     * The name of the deployment stage
     * @type {string}
     * @memberof DeploymentStageRequest
     */
    'name': string;
    /**
     * free test describing this stage
     * @type {string}
     * @memberof DeploymentStageRequest
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface DeploymentStageResponse
 */
export interface DeploymentStageResponse {
    /**
     * 
     * @type {string}
     * @memberof DeploymentStageResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentStageResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentStageResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {ReferenceObject}
     * @memberof DeploymentStageResponse
     */
    'environment': ReferenceObject;
    /**
     * name is case insensitive
     * @type {string}
     * @memberof DeploymentStageResponse
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentStageResponse
     */
    'description'?: string;
    /**
     * Position of the deployment stage within the environment
     * @type {number}
     * @memberof DeploymentStageResponse
     */
    'deployment_order'?: number;
    /**
     * 
     * @type {Array<DeploymentStageServiceResponse>}
     * @memberof DeploymentStageResponse
     */
    'services'?: Array<DeploymentStageServiceResponse>;
}
/**
 * 
 * @export
 * @interface DeploymentStageResponseList
 */
export interface DeploymentStageResponseList {
    /**
     * 
     * @type {Array<DeploymentStageResponse>}
     * @memberof DeploymentStageResponseList
     */
    'results'?: Array<DeploymentStageResponse>;
}
/**
 * 
 * @export
 * @interface DeploymentStageServiceResponse
 */
export interface DeploymentStageServiceResponse {
    /**
     * 
     * @type {string}
     * @memberof DeploymentStageServiceResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentStageServiceResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentStageServiceResponse
     */
    'updated_at'?: string;
    /**
     * id of the service attached to the stage
     * @type {string}
     * @memberof DeploymentStageServiceResponse
     */
    'service_id'?: string;
    /**
     * type of the service (i.e APPLICATION, JOB, DATABASE, ...)
     * @type {string}
     * @memberof DeploymentStageServiceResponse
     */
    'service_type'?: string;
}
/**
 * 
 * @export
 * @interface DeploymentStageWithServicesStatuses
 */
export interface DeploymentStageWithServicesStatuses {
    /**
     * 
     * @type {Array<Status>}
     * @memberof DeploymentStageWithServicesStatuses
     */
    'applications'?: Array<Status>;
    /**
     * 
     * @type {Array<Status>}
     * @memberof DeploymentStageWithServicesStatuses
     */
    'containers'?: Array<Status>;
    /**
     * 
     * @type {Array<Status>}
     * @memberof DeploymentStageWithServicesStatuses
     */
    'jobs'?: Array<Status>;
    /**
     * 
     * @type {Array<Status>}
     * @memberof DeploymentStageWithServicesStatuses
     */
    'databases'?: Array<Status>;
    /**
     * 
     * @type {Array<Status>}
     * @memberof DeploymentStageWithServicesStatuses
     */
    'helms'?: Array<Status>;
    /**
     * 
     * @type {Stage}
     * @memberof DeploymentStageWithServicesStatuses
     */
    'stage'?: Stage;
}
/**
 * 
 * @export
 * @interface DockerfileCheckRequest
 */
export interface DockerfileCheckRequest {
    /**
     * 
     * @type {ApplicationGitRepositoryRequest}
     * @memberof DockerfileCheckRequest
     */
    'git_repository': ApplicationGitRepositoryRequest;
    /**
     * path of the dockerfile with root_path as base path
     * @type {string}
     * @memberof DockerfileCheckRequest
     */
    'dockerfile_path': string;
}
/**
 * 
 * @export
 * @interface DockerfileCheckResponse
 */
export interface DockerfileCheckResponse {
    /**
     * 
     * @type {string}
     * @memberof DockerfileCheckResponse
     */
    'dockerfile_path': string;
    /**
     * All ARG variable declared in the Dockerfile
     * @type {Array<string>}
     * @memberof DockerfileCheckResponse
     */
    'arg'?: Array<string>;
    /**
     * All image repositories we found declared in the Dockerfile
     * @type {Array<string>}
     * @memberof DockerfileCheckResponse
     */
    'repositories'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Environment
 */
export interface Environment {
    /**
     * 
     * @type {string}
     * @memberof Environment
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Environment
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Environment
     */
    'updated_at'?: string;
    /**
     * name is case insensitive
     * @type {string}
     * @memberof Environment
     */
    'name': string;
    /**
     * 
     * @type {ReferenceObject}
     * @memberof Environment
     */
    'organization': ReferenceObject;
    /**
     * 
     * @type {ReferenceObject}
     * @memberof Environment
     */
    'project': ReferenceObject;
    /**
     * uuid of the user that made the last update
     * @type {string}
     * @memberof Environment
     */
    'last_updated_by'?: string;
    /**
     * 
     * @type {EnvironmentAllOfCloudProvider}
     * @memberof Environment
     */
    'cloud_provider': EnvironmentAllOfCloudProvider;
    /**
     * 
     * @type {EnvironmentModeEnum}
     * @memberof Environment
     */
    'mode': EnvironmentModeEnum;
    /**
     * 
     * @type {string}
     * @memberof Environment
     */
    'cluster_id': string;
    /**
     * 
     * @type {string}
     * @memberof Environment
     */
    'cluster_name'?: string;
}


/**
 * 
 * @export
 * @interface EnvironmentAllOfCloudProvider
 */
export interface EnvironmentAllOfCloudProvider {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentAllOfCloudProvider
     */
    'provider'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentAllOfCloudProvider
     */
    'cluster'?: string;
}
/**
 * 
 * @export
 * @interface EnvironmentApplicationsSupportedLanguage
 */
export interface EnvironmentApplicationsSupportedLanguage {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentApplicationsSupportedLanguage
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface EnvironmentApplicationsSupportedLanguageList
 */
export interface EnvironmentApplicationsSupportedLanguageList {
    /**
     * 
     * @type {Array<EnvironmentApplicationsSupportedLanguage>}
     * @memberof EnvironmentApplicationsSupportedLanguageList
     */
    'results'?: Array<EnvironmentApplicationsSupportedLanguage>;
}
/**
 * 
 * @export
 * @interface EnvironmentDeploymentRule
 */
export interface EnvironmentDeploymentRule {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentDeploymentRule
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentDeploymentRule
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentDeploymentRule
     */
    'updated_at'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EnvironmentDeploymentRule
     */
    'on_demand_preview'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EnvironmentDeploymentRule
     */
    'auto_stop'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EnvironmentDeploymentRule
     */
    'auto_preview'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentDeploymentRule
     */
    'timezone': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentDeploymentRule
     */
    'start_time': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentDeploymentRule
     */
    'stop_time': string;
    /**
     * 
     * @type {Array<WeekdayEnum>}
     * @memberof EnvironmentDeploymentRule
     */
    'weekdays': Array<WeekdayEnum>;
}
/**
 * 
 * @export
 * @interface EnvironmentDeploymentRuleEditRequest
 */
export interface EnvironmentDeploymentRuleEditRequest {
    /**
     * 
     * @type {boolean}
     * @memberof EnvironmentDeploymentRuleEditRequest
     */
    'on_demand_preview'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EnvironmentDeploymentRuleEditRequest
     */
    'auto_preview'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EnvironmentDeploymentRuleEditRequest
     */
    'auto_stop'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentDeploymentRuleEditRequest
     */
    'timezone': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentDeploymentRuleEditRequest
     */
    'start_time': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentDeploymentRuleEditRequest
     */
    'stop_time': string;
    /**
     * 
     * @type {Array<WeekdayEnum>}
     * @memberof EnvironmentDeploymentRuleEditRequest
     */
    'weekdays': Array<WeekdayEnum>;
}
/**
 * 
 * @export
 * @interface EnvironmentEditRequest
 */
export interface EnvironmentEditRequest {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentEditRequest
     */
    'name'?: string;
    /**
     * 
     * @type {CreateEnvironmentModeEnum}
     * @memberof EnvironmentEditRequest
     */
    'mode'?: CreateEnvironmentModeEnum;
}


/**
 * 
 * @export
 * @interface EnvironmentLog
 */
export interface EnvironmentLog {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLog
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLog
     */
    'created_at': string;
    /**
     * 
     * @type {EnvironmentLogScope}
     * @memberof EnvironmentLog
     */
    'scope'?: EnvironmentLogScope;
    /**
     * 
     * @type {StatusKindEnum}
     * @memberof EnvironmentLog
     */
    'state'?: StatusKindEnum;
    /**
     * Log message
     * @type {string}
     * @memberof EnvironmentLog
     */
    'message': string | null;
    /**
     * Only for errors. Helps Qovery team to investigate.
     * @type {string}
     * @memberof EnvironmentLog
     */
    'execution_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLog
     */
    'hint'?: string;
}


/**
 * 
 * @export
 * @interface EnvironmentLogResponseList
 */
export interface EnvironmentLogResponseList {
    /**
     * 
     * @type {Array<EnvironmentLog>}
     * @memberof EnvironmentLogResponseList
     */
    'results'?: Array<EnvironmentLog>;
}
/**
 * 
 * @export
 * @interface EnvironmentLogScope
 */
export interface EnvironmentLogScope {
    /**
     * 
     * @type {EnvironmentLogTypeEnum}
     * @memberof EnvironmentLogScope
     */
    'type'?: EnvironmentLogTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogScope
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogScope
     */
    'id'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const EnvironmentLogTypeEnum = {
    APPLICATION: 'APPLICATION',
    DATABASE: 'DATABASE',
    ENVIRONMENT: 'ENVIRONMENT'
} as const;

export type EnvironmentLogTypeEnum = typeof EnvironmentLogTypeEnum[keyof typeof EnvironmentLogTypeEnum];


/**
 * 
 * @export
 * @interface EnvironmentLogs
 */
export interface EnvironmentLogs {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogs
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogs
     */
    'timestamp': string;
    /**
     * 
     * @type {EnvironmentLogsDetails}
     * @memberof EnvironmentLogs
     */
    'details': EnvironmentLogsDetails;
    /**
     * 
     * @type {EnvironmentLogsError}
     * @memberof EnvironmentLogs
     */
    'error'?: EnvironmentLogsError | null;
    /**
     * 
     * @type {EnvironmentLogsMessage}
     * @memberof EnvironmentLogs
     */
    'message'?: EnvironmentLogsMessage | null;
}
/**
 * 
 * @export
 * @interface EnvironmentLogsDetails
 */
export interface EnvironmentLogsDetails {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogsDetails
     */
    'organization_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogsDetails
     */
    'cluster_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogsDetails
     */
    'execution_id'?: string;
    /**
     * 
     * @type {EnvironmentLogsDetailsTransmitter}
     * @memberof EnvironmentLogsDetails
     */
    'transmitter'?: EnvironmentLogsDetailsTransmitter;
    /**
     * 
     * @type {EnvironmentLogsDetailsStage}
     * @memberof EnvironmentLogsDetails
     */
    'stage'?: EnvironmentLogsDetailsStage;
}
/**
 * 
 * @export
 * @interface EnvironmentLogsDetailsStage
 */
export interface EnvironmentLogsDetailsStage {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogsDetailsStage
     */
    'step'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogsDetailsStage
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogsDetailsStage
     */
    'name'?: string | null;
}
/**
 * 
 * @export
 * @interface EnvironmentLogsDetailsTransmitter
 */
export interface EnvironmentLogsDetailsTransmitter {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogsDetailsTransmitter
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogsDetailsTransmitter
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogsDetailsTransmitter
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface EnvironmentLogsError
 */
export interface EnvironmentLogsError {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogsError
     */
    'tag'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogsError
     */
    'user_log_message'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogsError
     */
    'link'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogsError
     */
    'hint_message'?: string;
    /**
     * 
     * @type {EnvironmentLogsErrorUnderlyingError}
     * @memberof EnvironmentLogsError
     */
    'underlying_error'?: EnvironmentLogsErrorUnderlyingError;
}
/**
 * 
 * @export
 * @interface EnvironmentLogsErrorUnderlyingError
 */
export interface EnvironmentLogsErrorUnderlyingError {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogsErrorUnderlyingError
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogsErrorUnderlyingError
     */
    'full_details'?: string;
}
/**
 * 
 * @export
 * @interface EnvironmentLogsMessage
 */
export interface EnvironmentLogsMessage {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogsMessage
     */
    'safe_message'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogsMessage
     */
    'full_details'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const EnvironmentModeEnum = {
    DEVELOPMENT: 'DEVELOPMENT',
    PREVIEW: 'PREVIEW',
    PRODUCTION: 'PRODUCTION',
    STAGING: 'STAGING'
} as const;

export type EnvironmentModeEnum = typeof EnvironmentModeEnum[keyof typeof EnvironmentModeEnum];


/**
 * 
 * @export
 * @interface EnvironmentResponseList
 */
export interface EnvironmentResponseList {
    /**
     * 
     * @type {Array<Environment>}
     * @memberof EnvironmentResponseList
     */
    'results'?: Array<Environment>;
}
/**
 * 
 * @export
 * @interface EnvironmentServiceIdsAllRequest
 */
export interface EnvironmentServiceIdsAllRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof EnvironmentServiceIdsAllRequest
     */
    'application_ids'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof EnvironmentServiceIdsAllRequest
     */
    'container_ids'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof EnvironmentServiceIdsAllRequest
     */
    'database_ids'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof EnvironmentServiceIdsAllRequest
     */
    'job_ids'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof EnvironmentServiceIdsAllRequest
     */
    'helm_ids'?: Array<string>;
}
/**
 * 
 * @export
 * @interface EnvironmentStats
 */
export interface EnvironmentStats {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentStats
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentStats
     */
    'service_total_number'?: number;
}
/**
 * 
 * @export
 * @interface EnvironmentStatsResponseList
 */
export interface EnvironmentStatsResponseList {
    /**
     * 
     * @type {Array<EnvironmentStats>}
     * @memberof EnvironmentStatsResponseList
     */
    'results'?: Array<EnvironmentStats>;
}
/**
 * 
 * @export
 * @interface EnvironmentStatus
 */
export interface EnvironmentStatus {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentStatus
     */
    'id': string;
    /**
     * 
     * @type {StateEnum}
     * @memberof EnvironmentStatus
     */
    'state': StateEnum;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentStatus
     */
    'last_deployment_date'?: string | null;
    /**
     * 
     * @type {StateEnum}
     * @memberof EnvironmentStatus
     */
    'last_deployment_state': StateEnum;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentStatus
     */
    'last_deployment_id'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentStatus
     */
    'total_deployment_duration_in_seconds'?: number | null;
    /**
     * 
     * @type {EnvironmentStatusEventOriginEnum}
     * @memberof EnvironmentStatus
     */
    'origin'?: EnvironmentStatusEventOriginEnum | null;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentStatus
     */
    'triggered_by'?: string | null;
}


/**
 * Origin of the organization event
 * @export
 * @enum {string}
 */

export const EnvironmentStatusEventOriginEnum = {
    API: 'API',
    CLI: 'CLI',
    CONSOLE: 'CONSOLE',
    GIT: 'GIT',
    QOVERY_INTERNAL: 'QOVERY_INTERNAL',
    TERRAFORM_PROVIDER: 'TERRAFORM_PROVIDER'
} as const;

export type EnvironmentStatusEventOriginEnum = typeof EnvironmentStatusEventOriginEnum[keyof typeof EnvironmentStatusEventOriginEnum];


/**
 * 
 * @export
 * @interface EnvironmentStatusList
 */
export interface EnvironmentStatusList {
    /**
     * 
     * @type {Array<EnvironmentStatus>}
     * @memberof EnvironmentStatusList
     */
    'results'?: Array<EnvironmentStatus>;
}
/**
 * 
 * @export
 * @interface EnvironmentStatuses
 */
export interface EnvironmentStatuses {
    /**
     * 
     * @type {EnvironmentStatus}
     * @memberof EnvironmentStatuses
     */
    'environment'?: EnvironmentStatus;
    /**
     * 
     * @type {Array<Status>}
     * @memberof EnvironmentStatuses
     */
    'applications'?: Array<Status>;
    /**
     * 
     * @type {Array<Status>}
     * @memberof EnvironmentStatuses
     */
    'containers'?: Array<Status>;
    /**
     * 
     * @type {Array<Status>}
     * @memberof EnvironmentStatuses
     */
    'jobs'?: Array<Status>;
    /**
     * 
     * @type {Array<Status>}
     * @memberof EnvironmentStatuses
     */
    'databases'?: Array<Status>;
    /**
     * 
     * @type {Array<Status>}
     * @memberof EnvironmentStatuses
     */
    'helms'?: Array<Status>;
}
/**
 * 
 * @export
 * @interface EnvironmentStatusesWithStages
 */
export interface EnvironmentStatusesWithStages {
    /**
     * 
     * @type {EnvironmentStatus}
     * @memberof EnvironmentStatusesWithStages
     */
    'environment'?: EnvironmentStatus;
    /**
     * 
     * @type {Array<DeploymentStageWithServicesStatuses>}
     * @memberof EnvironmentStatusesWithStages
     */
    'stages'?: Array<DeploymentStageWithServicesStatuses>;
}
/**
 * 
 * @export
 * @interface EnvironmentTotalNumber
 */
export interface EnvironmentTotalNumber {
    /**
     * 
     * @type {number}
     * @memberof EnvironmentTotalNumber
     */
    'environment_total_number'?: number;
}
/**
 * 
 * @export
 * @interface EnvironmentVariable
 */
export interface EnvironmentVariable {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentVariable
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentVariable
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentVariable
     */
    'updated_at'?: string;
    /**
     * key is case sensitive.
     * @type {string}
     * @memberof EnvironmentVariable
     */
    'key': string;
    /**
     * value of the env variable.
     * @type {string}
     * @memberof EnvironmentVariable
     */
    'value'?: string;
    /**
     * should be set for file only. variable mount path makes variable a file (where file should be mounted).
     * @type {string}
     * @memberof EnvironmentVariable
     */
    'mount_path'?: string | null;
    /**
     * optional variable description (255 characters maximum)
     * @type {string}
     * @memberof EnvironmentVariable
     */
    'description'?: string | null;
    /**
     * 
     * @type {EnvironmentVariableOverride}
     * @memberof EnvironmentVariable
     */
    'overridden_variable'?: EnvironmentVariableOverride;
    /**
     * 
     * @type {EnvironmentVariableAlias}
     * @memberof EnvironmentVariable
     */
    'aliased_variable'?: EnvironmentVariableAlias;
    /**
     * 
     * @type {APIVariableScopeEnum}
     * @memberof EnvironmentVariable
     */
    'scope': APIVariableScopeEnum;
    /**
     * 
     * @type {APIVariableTypeEnum}
     * @memberof EnvironmentVariable
     */
    'variable_type': APIVariableTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentVariable
     */
    'service_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentVariable
     */
    'service_name'?: string;
    /**
     * 
     * @type {LinkedServiceTypeEnum}
     * @memberof EnvironmentVariable
     */
    'service_type'?: LinkedServiceTypeEnum;
    /**
     * Entity that created/own the variable (i.e: Qovery, Doppler)
     * @type {string}
     * @memberof EnvironmentVariable
     */
    'owned_by'?: string;
}


/**
 * 
 * @export
 * @interface EnvironmentVariableAlias
 */
export interface EnvironmentVariableAlias {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentVariableAlias
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentVariableAlias
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentVariableAlias
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentVariableAlias
     */
    'mount_path': string;
    /**
     * 
     * @type {APIVariableScopeEnum}
     * @memberof EnvironmentVariableAlias
     */
    'scope': APIVariableScopeEnum;
    /**
     * 
     * @type {APIVariableTypeEnum}
     * @memberof EnvironmentVariableAlias
     */
    'variable_type': APIVariableTypeEnum;
}


/**
 * 
 * @export
 * @interface EnvironmentVariableEditRequest
 */
export interface EnvironmentVariableEditRequest {
    /**
     * key is case sensitive
     * @type {string}
     * @memberof EnvironmentVariableEditRequest
     */
    'key': string;
    /**
     * value of the env variable.
     * @type {string}
     * @memberof EnvironmentVariableEditRequest
     */
    'value'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentVariableEditRequest
     */
    'mount_path'?: string | null;
    /**
     * optional variable description (255 characters maximum)
     * @type {string}
     * @memberof EnvironmentVariableEditRequest
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface EnvironmentVariableOverride
 */
export interface EnvironmentVariableOverride {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentVariableOverride
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentVariableOverride
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentVariableOverride
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentVariableOverride
     */
    'mount_path': string;
    /**
     * 
     * @type {APIVariableScopeEnum}
     * @memberof EnvironmentVariableOverride
     */
    'scope': APIVariableScopeEnum;
    /**
     * 
     * @type {APIVariableTypeEnum}
     * @memberof EnvironmentVariableOverride
     */
    'variable_type': APIVariableTypeEnum;
}


/**
 * 
 * @export
 * @interface EnvironmentVariableRequest
 */
export interface EnvironmentVariableRequest {
    /**
     * key is case sensitive.
     * @type {string}
     * @memberof EnvironmentVariableRequest
     */
    'key': string;
    /**
     * value of the env variable.
     * @type {string}
     * @memberof EnvironmentVariableRequest
     */
    'value'?: string;
    /**
     * should be set for file only. variable mount path makes variable a file (where file should be mounted).
     * @type {string}
     * @memberof EnvironmentVariableRequest
     */
    'mount_path'?: string | null;
    /**
     * optional variable description (255 characters maximum)
     * @type {string}
     * @memberof EnvironmentVariableRequest
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface EnvironmentVariableResponseList
 */
export interface EnvironmentVariableResponseList {
    /**
     * 
     * @type {Array<EnvironmentVariable>}
     * @memberof EnvironmentVariableResponseList
     */
    'results'?: Array<EnvironmentVariable>;
}
/**
 * 
 * @export
 * @interface GcpCredentialsRequest
 */
export interface GcpCredentialsRequest {
    /**
     * 
     * @type {string}
     * @memberof GcpCredentialsRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GcpCredentialsRequest
     */
    'gcp_credentials': string;
}
/**
 * 
 * @export
 * @interface GenericObjectCurrentCost
 */
export interface GenericObjectCurrentCost {
    /**
     * 
     * @type {string}
     * @memberof GenericObjectCurrentCost
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GenericObjectCurrentCost
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof GenericObjectCurrentCost
     */
    'consumed_time_in_seconds': number;
    /**
     * 
     * @type {Cost}
     * @memberof GenericObjectCurrentCost
     */
    'cost': Cost;
}
/**
 * 
 * @export
 * @interface GitAuthProvider
 */
export interface GitAuthProvider {
    /**
     * 
     * @type {string}
     * @memberof GitAuthProvider
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GitAuthProvider
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GitAuthProvider
     */
    'owner': string;
    /**
     * 
     * @type {boolean}
     * @memberof GitAuthProvider
     */
    'use_bot'?: boolean;
}
/**
 * 
 * @export
 * @interface GitAuthProviderResponseList
 */
export interface GitAuthProviderResponseList {
    /**
     * 
     * @type {Array<GitAuthProvider>}
     * @memberof GitAuthProviderResponseList
     */
    'results'?: Array<GitAuthProvider>;
}
/**
 * 
 * @export
 * @interface GitFileCheckRequest
 */
export interface GitFileCheckRequest {
    /**
     * 
     * @type {HelmGitRepositoryRequest}
     * @memberof GitFileCheckRequest
     */
    'git_repository': HelmGitRepositoryRequest;
    /**
     * 
     * @type {Array<string>}
     * @memberof GitFileCheckRequest
     */
    'files': Array<string>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const GitProviderEnum = {
    BITBUCKET: 'BITBUCKET',
    GITHUB: 'GITHUB',
    GITLAB: 'GITLAB'
} as const;

export type GitProviderEnum = typeof GitProviderEnum[keyof typeof GitProviderEnum];


/**
 * 
 * @export
 * @interface GitRepository
 */
export interface GitRepository {
    /**
     * 
     * @type {string}
     * @memberof GitRepository
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GitRepository
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GitRepository
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof GitRepository
     */
    'default_branch'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GitRepository
     */
    'is_private'?: boolean;
}
/**
 * 
 * @export
 * @interface GitRepositoryBranch
 */
export interface GitRepositoryBranch {
    /**
     * 
     * @type {string}
     * @memberof GitRepositoryBranch
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface GitRepositoryBranchResponseList
 */
export interface GitRepositoryBranchResponseList {
    /**
     * 
     * @type {Array<GitRepositoryBranch>}
     * @memberof GitRepositoryBranchResponseList
     */
    'results'?: Array<GitRepositoryBranch>;
}
/**
 * 
 * @export
 * @interface GitRepositoryResponseList
 */
export interface GitRepositoryResponseList {
    /**
     * 
     * @type {Array<GitRepository>}
     * @memberof GitRepositoryResponseList
     */
    'results'?: Array<GitRepository>;
}
/**
 * 
 * @export
 * @interface GitTokenAssociatedServiceResponse
 */
export interface GitTokenAssociatedServiceResponse {
    /**
     * 
     * @type {string}
     * @memberof GitTokenAssociatedServiceResponse
     */
    'project_id': string;
    /**
     * 
     * @type {string}
     * @memberof GitTokenAssociatedServiceResponse
     */
    'project_name': string;
    /**
     * 
     * @type {string}
     * @memberof GitTokenAssociatedServiceResponse
     */
    'environment_id': string;
    /**
     * 
     * @type {string}
     * @memberof GitTokenAssociatedServiceResponse
     */
    'environment_name': string;
    /**
     * 
     * @type {string}
     * @memberof GitTokenAssociatedServiceResponse
     */
    'service_id': string;
    /**
     * 
     * @type {string}
     * @memberof GitTokenAssociatedServiceResponse
     */
    'service_name': string;
    /**
     * 
     * @type {GitTokenAssociatedServiceType}
     * @memberof GitTokenAssociatedServiceResponse
     */
    'service_type': GitTokenAssociatedServiceType;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const GitTokenAssociatedServiceType = {
    APPLICATION: 'APPLICATION',
    CRON: 'CRON',
    LIFECYCLE: 'LIFECYCLE',
    HELM: 'HELM'
} as const;

export type GitTokenAssociatedServiceType = typeof GitTokenAssociatedServiceType[keyof typeof GitTokenAssociatedServiceType];


/**
 * 
 * @export
 * @interface GitTokenAssociatedServicesResponseList
 */
export interface GitTokenAssociatedServicesResponseList {
    /**
     * 
     * @type {Array<GitTokenAssociatedServiceResponse>}
     * @memberof GitTokenAssociatedServicesResponseList
     */
    'results'?: Array<GitTokenAssociatedServiceResponse>;
}
/**
 * 
 * @export
 * @interface GitTokenRequest
 */
export interface GitTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof GitTokenRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GitTokenRequest
     */
    'description'?: string;
    /**
     * 
     * @type {GitProviderEnum}
     * @memberof GitTokenRequest
     */
    'type': GitProviderEnum;
    /**
     * The token from your git provider side
     * @type {string}
     * @memberof GitTokenRequest
     */
    'token': string;
    /**
     * Mandatory only for BITBUCKET git provider, to allow us to fetch repositories at creation/edition of a service
     * @type {string}
     * @memberof GitTokenRequest
     */
    'workspace'?: string;
}


/**
 * 
 * @export
 * @interface GitTokenResponse
 */
export interface GitTokenResponse {
    /**
     * 
     * @type {string}
     * @memberof GitTokenResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GitTokenResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof GitTokenResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof GitTokenResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GitTokenResponse
     */
    'description'?: string;
    /**
     * 
     * @type {GitProviderEnum}
     * @memberof GitTokenResponse
     */
    'type': GitProviderEnum;
    /**
     * 
     * @type {string}
     * @memberof GitTokenResponse
     */
    'expired_at'?: string;
    /**
     * Mandatory only for BITBUCKET git provider
     * @type {string}
     * @memberof GitTokenResponse
     */
    'workspace'?: string;
    /**
     * The number of services using this git token
     * @type {number}
     * @memberof GitTokenResponse
     */
    'associated_services_count': number;
}


/**
 * 
 * @export
 * @interface GitTokenResponseList
 */
export interface GitTokenResponseList {
    /**
     * 
     * @type {Array<GitTokenResponse>}
     * @memberof GitTokenResponseList
     */
    'results'?: Array<GitTokenResponse>;
}
/**
 * 
 * @export
 * @interface Healthcheck
 */
export interface Healthcheck {
    /**
     * 
     * @type {Probe}
     * @memberof Healthcheck
     */
    'readiness_probe'?: Probe | null;
    /**
     * 
     * @type {Probe}
     * @memberof Healthcheck
     */
    'liveness_probe'?: Probe | null;
}
/**
 * 
 * @export
 * @interface HelmAdvancedSettings
 */
export interface HelmAdvancedSettings {
    /**
     * disable custom domain check when deploying a helm
     * @type {boolean}
     * @memberof HelmAdvancedSettings
     */
    'deployment.custom_domain_check_enabled'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof HelmAdvancedSettings
     */
    'network.ingress.proxy_body_size_mb'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof HelmAdvancedSettings
     */
    'network.ingress.enable_cors'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof HelmAdvancedSettings
     */
    'network.ingress.cors_allow_origin'?: string;
    /**
     * 
     * @type {string}
     * @memberof HelmAdvancedSettings
     */
    'network.ingress.cors_allow_methods'?: string;
    /**
     * 
     * @type {string}
     * @memberof HelmAdvancedSettings
     */
    'network.ingress.cors_allow_headers'?: string;
    /**
     * header buffer size used while reading response header from upstream
     * @type {number}
     * @memberof HelmAdvancedSettings
     */
    'network.ingress.proxy_buffer_size_kb'?: number;
    /**
     * Limits the maximum time (in seconds) during which requests can be processed through one keepalive connection
     * @type {number}
     * @memberof HelmAdvancedSettings
     */
    'network.ingress.keepalive_time_seconds'?: number;
    /**
     * Sets a timeout (in seconds) during which an idle keepalive connection to an upstream server will stay open.
     * @type {number}
     * @memberof HelmAdvancedSettings
     */
    'network.ingress.keepalive_timeout_seconds'?: number;
    /**
     * Sets a timeout (in seconds) for transmitting a response to the client
     * @type {number}
     * @memberof HelmAdvancedSettings
     */
    'network.ingress.send_timeout_seconds'?: number;
    /**
     * Sets a timeout (in seconds) for establishing a connection to a proxied server
     * @type {number}
     * @memberof HelmAdvancedSettings
     */
    'network.ingress.proxy_connect_timeout_seconds'?: number;
    /**
     * Sets a timeout (in seconds) for transmitting a request to the proxied server
     * @type {number}
     * @memberof HelmAdvancedSettings
     */
    'network.ingress.proxy_send_timeout_seconds'?: number;
    /**
     * Sets a timeout (in seconds) for reading a response from the proxied server
     * @type {number}
     * @memberof HelmAdvancedSettings
     */
    'network.ingress.proxy_read_timeout_seconds'?: number;
    /**
     * Allows to enable or disable nginx `proxy-buffering`
     * @type {string}
     * @memberof HelmAdvancedSettings
     */
    'network.ingress.proxy_buffering'?: string;
    /**
     * Allows to enable or disable nginx `proxy-request-buffering`
     * @type {string}
     * @memberof HelmAdvancedSettings
     */
    'network.ingress.proxy_request_buffering'?: string;
    /**
     * Sets a timeout (in seconds) for transmitting a request to the grpc server
     * @type {number}
     * @memberof HelmAdvancedSettings
     */
    'network.ingress.grpc_send_timeout_seconds'?: number;
    /**
     * Sets a timeout (in seconds) for transmitting a request to the grpc server
     * @type {number}
     * @memberof HelmAdvancedSettings
     */
    'network.ingress.grpc_read_timeout_seconds'?: number;
    /**
     * list of source ranges to allow access to ingress proxy.  This property can be used to whitelist source IP ranges for ingress proxy. The value is a comma separated list of CIDRs, e.g. 10.0.0.0/24,172.10.0.1 To allow all source ranges, set 0.0.0.0/0. 
     * @type {string}
     * @memberof HelmAdvancedSettings
     */
    'network.ingress.whitelist_source_range'?: string;
    /**
     * list of source ranges to deny access to ingress proxy.  This property can be used to blacklist source IP ranges for ingress proxy. The value is a comma separated list of CIDRs, e.g. 10.0.0.0/24,172.10.0.1 
     * @type {string}
     * @memberof HelmAdvancedSettings
     */
    'network.ingress.denylist_source_range'?: string;
    /**
     * Allows to define response headers
     * @type {string}
     * @memberof HelmAdvancedSettings
     */
    'network.ingress.extra_headers'?: string;
    /**
     * Set the name of an environment variable to use as a basic authentication (`login:crypted_password`) from `htpasswd` command. You can add multiples comma separated values. 
     * @type {string}
     * @memberof HelmAdvancedSettings
     */
    'network.ingress.basic_auth_env_var'?: string;
    /**
     * Enable the load balancer to bind a user\'s session to a specific target. This ensures that all requests from the user during the session are sent to the same target 
     * @type {boolean}
     * @memberof HelmAdvancedSettings
     */
    'network.ingress.enable_sticky_session'?: boolean;
}
/**
 * 
 * @export
 * @interface HelmCheckRequest
 */
export interface HelmCheckRequest {
    /**
     * 
     * @type {HelmGitRepositoryRequest}
     * @memberof HelmCheckRequest
     */
    'git_repository': HelmGitRepositoryRequest;
}
/**
 * 
 * @export
 * @interface HelmDefaultValuesRequest
 */
export interface HelmDefaultValuesRequest {
    /**
     * 
     * @type {HelmRequestAllOfSource}
     * @memberof HelmDefaultValuesRequest
     */
    'source': HelmRequestAllOfSource;
}
/**
 * 
 * @export
 * @interface HelmDeployRequest
 */
export interface HelmDeployRequest {
    /**
     * version of the chart to deploy. Cannot be set if `git_commit_id` is defined 
     * @type {string}
     * @memberof HelmDeployRequest
     */
    'chart_version'?: string;
    /**
     * Commit to deploy for chart source. Cannot be set if `version` is defined 
     * @type {string}
     * @memberof HelmDeployRequest
     */
    'git_commit_id'?: string;
    /**
     * Commit to deploy for values override 
     * @type {string}
     * @memberof HelmDeployRequest
     */
    'values_override_git_commit_id'?: string;
}
/**
 * 
 * @export
 * @interface HelmDeploymentRestrictionRequest
 */
export interface HelmDeploymentRestrictionRequest {
    /**
     * 
     * @type {DeploymentRestrictionModeEnum}
     * @memberof HelmDeploymentRestrictionRequest
     */
    'mode': DeploymentRestrictionModeEnum;
    /**
     * 
     * @type {DeploymentRestrictionTypeEnum}
     * @memberof HelmDeploymentRestrictionRequest
     */
    'type': DeploymentRestrictionTypeEnum;
    /**
     * For `PATH` restrictions, the value must not start with `/`
     * @type {string}
     * @memberof HelmDeploymentRestrictionRequest
     */
    'value': string;
}


/**
 * 
 * @export
 * @interface HelmDeploymentRestrictionResponse
 */
export interface HelmDeploymentRestrictionResponse {
    /**
     * 
     * @type {string}
     * @memberof HelmDeploymentRestrictionResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof HelmDeploymentRestrictionResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof HelmDeploymentRestrictionResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {DeploymentRestrictionModeEnum}
     * @memberof HelmDeploymentRestrictionResponse
     */
    'mode': DeploymentRestrictionModeEnum;
    /**
     * 
     * @type {DeploymentRestrictionTypeEnum}
     * @memberof HelmDeploymentRestrictionResponse
     */
    'type': DeploymentRestrictionTypeEnum;
    /**
     * For `PATH` restrictions, the value must not start with `/`
     * @type {string}
     * @memberof HelmDeploymentRestrictionResponse
     */
    'value': string;
}


/**
 * 
 * @export
 * @interface HelmDeploymentRestrictionResponseList
 */
export interface HelmDeploymentRestrictionResponseList {
    /**
     * 
     * @type {Array<HelmDeploymentRestrictionResponse>}
     * @memberof HelmDeploymentRestrictionResponseList
     */
    'results'?: Array<HelmDeploymentRestrictionResponse>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const HelmForceEvent = {
    DIFF: 'DIFF'
} as const;

export type HelmForceEvent = typeof HelmForceEvent[keyof typeof HelmForceEvent];


/**
 * 
 * @export
 * @interface HelmGitRepositoryRequest
 */
export interface HelmGitRepositoryRequest {
    /**
     * application git repository URL
     * @type {string}
     * @memberof HelmGitRepositoryRequest
     */
    'url': string;
    /**
     * Name of the branch to use. This is optional If not specified, then the branch used is the `main` or `master` one 
     * @type {string}
     * @memberof HelmGitRepositoryRequest
     */
    'branch'?: string;
    /**
     * indicates the root path of the application.
     * @type {string}
     * @memberof HelmGitRepositoryRequest
     */
    'root_path'?: string;
    /**
     * The git token id on Qovery side
     * @type {string}
     * @memberof HelmGitRepositoryRequest
     */
    'git_token_id'?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const HelmPortProtocolEnum = {
    HTTP: 'HTTP',
    GRPC: 'GRPC'
} as const;

export type HelmPortProtocolEnum = typeof HelmPortProtocolEnum[keyof typeof HelmPortProtocolEnum];


/**
 * 
 * @export
 * @interface HelmPortRequest
 */
export interface HelmPortRequest {
    /**
     * 
     * @type {Array<HelmPortRequestPortsInner>}
     * @memberof HelmPortRequest
     */
    'ports'?: Array<HelmPortRequestPortsInner>;
}
/**
 * 
 * @export
 * @interface HelmPortRequestPortsInner
 */
export interface HelmPortRequestPortsInner {
    /**
     * 
     * @type {string}
     * @memberof HelmPortRequestPortsInner
     */
    'name'?: string;
    /**
     * The listening port of your service.
     * @type {number}
     * @memberof HelmPortRequestPortsInner
     */
    'internal_port': number;
    /**
     * The exposed port for your service. This is optional. If not set a default port will be used.
     * @type {number}
     * @memberof HelmPortRequestPortsInner
     */
    'external_port'?: number;
    /**
     * 
     * @type {string}
     * @memberof HelmPortRequestPortsInner
     */
    'service_name': string;
    /**
     * 
     * @type {string}
     * @memberof HelmPortRequestPortsInner
     */
    'namespace'?: string;
    /**
     * 
     * @type {HelmPortProtocolEnum}
     * @memberof HelmPortRequestPortsInner
     */
    'protocol'?: HelmPortProtocolEnum;
    /**
     * is the default port to use for domain
     * @type {boolean}
     * @memberof HelmPortRequestPortsInner
     */
    'is_default'?: boolean;
}


/**
 * The type of your helm repository
 * @export
 * @enum {string}
 */

export const HelmRepositoryKindEnum = {
    HTTPS: 'HTTPS',
    OCI_ECR: 'OCI_ECR',
    OCI_SCALEWAY_CR: 'OCI_SCALEWAY_CR',
    OCI_DOCKER_HUB: 'OCI_DOCKER_HUB',
    OCI_PUBLIC_ECR: 'OCI_PUBLIC_ECR',
    OCI_GENERIC_CR: 'OCI_GENERIC_CR',
    OCI_GITHUB_CR: 'OCI_GITHUB_CR',
    OCI_GITLAB_CR: 'OCI_GITLAB_CR'
} as const;

export type HelmRepositoryKindEnum = typeof HelmRepositoryKindEnum[keyof typeof HelmRepositoryKindEnum];


/**
 * 
 * @export
 * @interface HelmRepositoryRequest
 */
export interface HelmRepositoryRequest {
    /**
     * 
     * @type {string}
     * @memberof HelmRepositoryRequest
     */
    'name': string;
    /**
     * 
     * @type {HelmRepositoryKindEnum}
     * @memberof HelmRepositoryRequest
     */
    'kind': HelmRepositoryKindEnum;
    /**
     * 
     * @type {string}
     * @memberof HelmRepositoryRequest
     */
    'description'?: string;
    /**
     * URL of the helm chart repository: * For `OCI`: it must start by oci:// * For `HTTPS`: it must be start by https:// 
     * @type {string}
     * @memberof HelmRepositoryRequest
     */
    'url'?: string;
    /**
     * Bypass tls certificate verification when connecting to repository
     * @type {boolean}
     * @memberof HelmRepositoryRequest
     */
    'skip_tls_verification': boolean;
    /**
     * 
     * @type {HelmRepositoryRequestConfig}
     * @memberof HelmRepositoryRequest
     */
    'config': HelmRepositoryRequestConfig;
}


/**
 * 
 * @export
 * @interface HelmRepositoryRequestConfig
 */
export interface HelmRepositoryRequestConfig {
    /**
     * Required if the repository is private
     * @type {string}
     * @memberof HelmRepositoryRequestConfig
     */
    'username'?: string;
    /**
     * Required if the repository is private
     * @type {string}
     * @memberof HelmRepositoryRequestConfig
     */
    'password'?: string;
    /**
     * Required if kind is `ECR` or `PUBLIC_ECR`
     * @type {string}
     * @memberof HelmRepositoryRequestConfig
     */
    'access_key_id'?: string;
    /**
     * Required if kind is `ECR` or `PUBLIC_ECR`
     * @type {string}
     * @memberof HelmRepositoryRequestConfig
     */
    'secret_access_key'?: string;
    /**
     * Required if kind is `ECR` or `SCALEWAY_CR`
     * @type {string}
     * @memberof HelmRepositoryRequestConfig
     */
    'region'?: string;
    /**
     * Required if kind is `SCALEWAY_CR`
     * @type {string}
     * @memberof HelmRepositoryRequestConfig
     */
    'scaleway_access_key'?: string;
    /**
     * Required if kind is `SCALEWAY_CR`
     * @type {string}
     * @memberof HelmRepositoryRequestConfig
     */
    'scaleway_secret_key'?: string;
}
/**
 * 
 * @export
 * @interface HelmRepositoryResponse
 */
export interface HelmRepositoryResponse {
    /**
     * 
     * @type {string}
     * @memberof HelmRepositoryResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof HelmRepositoryResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof HelmRepositoryResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof HelmRepositoryResponse
     */
    'name': string;
    /**
     * 
     * @type {HelmRepositoryKindEnum}
     * @memberof HelmRepositoryResponse
     */
    'kind'?: HelmRepositoryKindEnum;
    /**
     * 
     * @type {string}
     * @memberof HelmRepositoryResponse
     */
    'description'?: string;
    /**
     * URL of the helm repository
     * @type {string}
     * @memberof HelmRepositoryResponse
     */
    'url'?: string;
    /**
     * Bypass tls certificate verification when connecting to repository
     * @type {boolean}
     * @memberof HelmRepositoryResponse
     */
    'skip_tls_verification'?: boolean;
}


/**
 * 
 * @export
 * @interface HelmRepositoryResponseList
 */
export interface HelmRepositoryResponseList {
    /**
     * 
     * @type {Array<HelmRepositoryResponse>}
     * @memberof HelmRepositoryResponseList
     */
    'results'?: Array<HelmRepositoryResponse>;
}
/**
 * 
 * @export
 * @interface HelmRequest
 */
export interface HelmRequest {
    /**
     * 
     * @type {Array<HelmPortRequestPortsInner>}
     * @memberof HelmRequest
     */
    'ports'?: Array<HelmPortRequestPortsInner>;
    /**
     * name is case insensitive
     * @type {string}
     * @memberof HelmRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof HelmRequest
     */
    'description'?: string;
    /**
     * Maximum number of seconds allowed for helm to run before killing it and mark it as failed 
     * @type {number}
     * @memberof HelmRequest
     */
    'timeout_sec'?: number;
    /**
     * Indicates if the \'environment preview option\' is enabled.   If enabled, a preview environment will be automatically cloned when `/preview` endpoint is called or when a new commit is updated. If not specified, it takes the value of the `auto_preview` property from the associated environment. 
     * @type {boolean}
     * @memberof HelmRequest
     */
    'auto_preview'?: boolean | null;
    /**
     * Specify if the helm will be automatically updated after receiving a new image tag or a new commit according to the source type.  
     * @type {boolean}
     * @memberof HelmRequest
     */
    'auto_deploy': boolean;
    /**
     * 
     * @type {HelmRequestAllOfSource}
     * @memberof HelmRequest
     */
    'source': HelmRequestAllOfSource;
    /**
     * The extra arguments to pass to helm
     * @type {Array<string>}
     * @memberof HelmRequest
     */
    'arguments': Array<string>;
    /**
     * If we should allow the chart to deploy object outside his specified namespace. Setting this flag to true, requires special rights 
     * @type {boolean}
     * @memberof HelmRequest
     */
    'allow_cluster_wide_resources'?: boolean;
    /**
     * 
     * @type {HelmRequestAllOfValuesOverride}
     * @memberof HelmRequest
     */
    'values_override': HelmRequestAllOfValuesOverride;
    /**
     * Icon URI representing the helm service.
     * @type {string}
     * @memberof HelmRequest
     */
    'icon_uri'?: string;
}
/**
 * @type HelmRequestAllOfSource
 * @export
 */
export type HelmRequestAllOfSource = HelmRequestAllOfSourceOneOf | HelmRequestAllOfSourceOneOf1;

/**
 * 
 * @export
 * @interface HelmRequestAllOfSourceOneOf
 */
export interface HelmRequestAllOfSourceOneOf {
    /**
     * 
     * @type {HelmGitRepositoryRequest}
     * @memberof HelmRequestAllOfSourceOneOf
     */
    'git_repository'?: HelmGitRepositoryRequest;
}
/**
 * 
 * @export
 * @interface HelmRequestAllOfSourceOneOf1
 */
export interface HelmRequestAllOfSourceOneOf1 {
    /**
     * 
     * @type {HelmRequestAllOfSourceOneOf1HelmRepository}
     * @memberof HelmRequestAllOfSourceOneOf1
     */
    'helm_repository'?: HelmRequestAllOfSourceOneOf1HelmRepository;
}
/**
 * 
 * @export
 * @interface HelmRequestAllOfSourceOneOf1HelmRepository
 */
export interface HelmRequestAllOfSourceOneOf1HelmRepository {
    /**
     * The id of the helm repository
     * @type {string}
     * @memberof HelmRequestAllOfSourceOneOf1HelmRepository
     */
    'repository'?: string | null;
    /**
     * The name of the chart in the repository
     * @type {string}
     * @memberof HelmRequestAllOfSourceOneOf1HelmRepository
     */
    'chart_name'?: string;
    /**
     * The version of the chart to use
     * @type {string}
     * @memberof HelmRequestAllOfSourceOneOf1HelmRepository
     */
    'chart_version'?: string;
}
/**
 * Specify helm values you want to set or override 
 * @export
 * @interface HelmRequestAllOfValuesOverride
 */
export interface HelmRequestAllOfValuesOverride {
    /**
     * The input is in json array format: [ [$KEY,$VALUE], [...] ]
     * @type {Array<Array<string>>}
     * @memberof HelmRequestAllOfValuesOverride
     */
    'set'?: Array<Array<string>>;
    /**
     * The input is in json array format: [ [$KEY,$VALUE], [...] ]
     * @type {Array<Array<string>>}
     * @memberof HelmRequestAllOfValuesOverride
     */
    'set_string'?: Array<Array<string>>;
    /**
     * The input is in json array format: [ [$KEY,$VALUE], [...] ]
     * @type {Array<Array<string>>}
     * @memberof HelmRequestAllOfValuesOverride
     */
    'set_json'?: Array<Array<string>>;
    /**
     * 
     * @type {HelmRequestAllOfValuesOverrideFile}
     * @memberof HelmRequestAllOfValuesOverride
     */
    'file'?: HelmRequestAllOfValuesOverrideFile | null;
}
/**
 * 
 * @export
 * @interface HelmRequestAllOfValuesOverrideFile
 */
export interface HelmRequestAllOfValuesOverrideFile {
    /**
     * 
     * @type {HelmRequestAllOfValuesOverrideFileGit}
     * @memberof HelmRequestAllOfValuesOverrideFile
     */
    'git'?: HelmRequestAllOfValuesOverrideFileGit | null;
    /**
     * 
     * @type {HelmRequestAllOfValuesOverrideFileRaw}
     * @memberof HelmRequestAllOfValuesOverrideFile
     */
    'raw'?: HelmRequestAllOfValuesOverrideFileRaw | null;
}
/**
 * 
 * @export
 * @interface HelmRequestAllOfValuesOverrideFileGit
 */
export interface HelmRequestAllOfValuesOverrideFileGit {
    /**
     * 
     * @type {ApplicationGitRepositoryRequest}
     * @memberof HelmRequestAllOfValuesOverrideFileGit
     */
    'git_repository': ApplicationGitRepositoryRequest;
    /**
     * List of path inside your git repository to locate values file. Must start by a /
     * @type {Array<string>}
     * @memberof HelmRequestAllOfValuesOverrideFileGit
     */
    'paths': Array<string>;
}
/**
 * 
 * @export
 * @interface HelmRequestAllOfValuesOverrideFileRaw
 */
export interface HelmRequestAllOfValuesOverrideFileRaw {
    /**
     * 
     * @type {Array<HelmRequestAllOfValuesOverrideFileRawValues>}
     * @memberof HelmRequestAllOfValuesOverrideFileRaw
     */
    'values'?: Array<HelmRequestAllOfValuesOverrideFileRawValues>;
}
/**
 * 
 * @export
 * @interface HelmRequestAllOfValuesOverrideFileRawValues
 */
export interface HelmRequestAllOfValuesOverrideFileRawValues {
    /**
     * The name of the value file
     * @type {string}
     * @memberof HelmRequestAllOfValuesOverrideFileRawValues
     */
    'name'?: string;
    /**
     * The content of the value file
     * @type {string}
     * @memberof HelmRequestAllOfValuesOverrideFileRawValues
     */
    'content'?: string;
}
/**
 * 
 * @export
 * @interface HelmResponse
 */
export interface HelmResponse {
    /**
     * 
     * @type {string}
     * @memberof HelmResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof HelmResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof HelmResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {ReferenceObject}
     * @memberof HelmResponse
     */
    'environment': ReferenceObject;
    /**
     * name is case insensitive
     * @type {string}
     * @memberof HelmResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof HelmResponse
     */
    'description'?: string;
    /**
     * Maximum number of seconds allowed for helm to run before killing it and mark it as failed 
     * @type {number}
     * @memberof HelmResponse
     */
    'timeout_sec'?: number;
    /**
     * Indicates if the \'environment preview option\' is enabled.   If enabled, a preview environment will be automatically cloned when `/preview` endpoint is called.   If not specified, it takes the value of the `auto_preview` property from the associated environment. 
     * @type {boolean}
     * @memberof HelmResponse
     */
    'auto_preview': boolean;
    /**
     * Specify if the service will be automatically updated after receiving a new image tag or a new commit according to the source type. 
     * @type {boolean}
     * @memberof HelmResponse
     */
    'auto_deploy': boolean;
    /**
     * 
     * @type {Array<HelmResponseAllOfPorts>}
     * @memberof HelmResponse
     */
    'ports'?: Array<HelmResponseAllOfPorts>;
    /**
     * 
     * @type {HelmResponseAllOfSource}
     * @memberof HelmResponse
     */
    'source': HelmResponseAllOfSource;
    /**
     * The extra arguments to pass to helm
     * @type {Array<string>}
     * @memberof HelmResponse
     */
    'arguments': Array<string>;
    /**
     * If we should allow the chart to deploy object outside his specified namespace. Setting this flag to true, requires special rights 
     * @type {boolean}
     * @memberof HelmResponse
     */
    'allow_cluster_wide_resources': boolean;
    /**
     * 
     * @type {HelmResponseAllOfValuesOverride}
     * @memberof HelmResponse
     */
    'values_override': HelmResponseAllOfValuesOverride;
    /**
     * Icon URI representing the helm service.
     * @type {string}
     * @memberof HelmResponse
     */
    'icon_uri': string;
}
/**
 * 
 * @export
 * @interface HelmResponseAllOfPorts
 */
export interface HelmResponseAllOfPorts {
    /**
     * 
     * @type {string}
     * @memberof HelmResponseAllOfPorts
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof HelmResponseAllOfPorts
     */
    'name'?: string;
    /**
     * The listening port of your service.
     * @type {number}
     * @memberof HelmResponseAllOfPorts
     */
    'internal_port': number;
    /**
     * The exposed port for your service. This is optional. If not set a default port will be used.
     * @type {number}
     * @memberof HelmResponseAllOfPorts
     */
    'external_port'?: number;
    /**
     * 
     * @type {string}
     * @memberof HelmResponseAllOfPorts
     */
    'service_name': string;
    /**
     * 
     * @type {string}
     * @memberof HelmResponseAllOfPorts
     */
    'namespace'?: string;
    /**
     * 
     * @type {HelmPortProtocolEnum}
     * @memberof HelmResponseAllOfPorts
     */
    'protocol': HelmPortProtocolEnum;
    /**
     * is the default port to use for domain
     * @type {boolean}
     * @memberof HelmResponseAllOfPorts
     */
    'is_default'?: boolean;
}


/**
 * @type HelmResponseAllOfSource
 * @export
 */
export type HelmResponseAllOfSource = HelmResponseAllOfSourceOneOf | HelmResponseAllOfSourceOneOf1;

/**
 * 
 * @export
 * @interface HelmResponseAllOfSourceOneOf
 */
export interface HelmResponseAllOfSourceOneOf {
    /**
     * 
     * @type {HelmSourceGitResponse}
     * @memberof HelmResponseAllOfSourceOneOf
     */
    'git': HelmSourceGitResponse;
}
/**
 * 
 * @export
 * @interface HelmResponseAllOfSourceOneOf1
 */
export interface HelmResponseAllOfSourceOneOf1 {
    /**
     * 
     * @type {HelmSourceRepositoryResponse}
     * @memberof HelmResponseAllOfSourceOneOf1
     */
    'repository': HelmSourceRepositoryResponse;
}
/**
 * Specify helm values you want to set or override 
 * @export
 * @interface HelmResponseAllOfValuesOverride
 */
export interface HelmResponseAllOfValuesOverride {
    /**
     * The input is in json array format: [ [$KEY,$VALUE], [...] ]
     * @type {Array<Array<string>>}
     * @memberof HelmResponseAllOfValuesOverride
     */
    'set'?: Array<Array<string>>;
    /**
     * The input is in json array format: [ [$KEY,$VALUE], [...] ]
     * @type {Array<Array<string>>}
     * @memberof HelmResponseAllOfValuesOverride
     */
    'set_string'?: Array<Array<string>>;
    /**
     * The input is in json array format: [ [$KEY,$VALUE], [...] ]
     * @type {Array<Array<string>>}
     * @memberof HelmResponseAllOfValuesOverride
     */
    'set_json'?: Array<Array<string>>;
    /**
     * 
     * @type {HelmResponseAllOfValuesOverrideFile}
     * @memberof HelmResponseAllOfValuesOverride
     */
    'file'?: HelmResponseAllOfValuesOverrideFile | null;
}
/**
 * 
 * @export
 * @interface HelmResponseAllOfValuesOverrideFile
 */
export interface HelmResponseAllOfValuesOverrideFile {
    /**
     * 
     * @type {HelmResponseAllOfValuesOverrideFileRaw}
     * @memberof HelmResponseAllOfValuesOverrideFile
     */
    'raw'?: HelmResponseAllOfValuesOverrideFileRaw | null;
    /**
     * 
     * @type {HelmResponseAllOfValuesOverrideFileGit}
     * @memberof HelmResponseAllOfValuesOverrideFile
     */
    'git'?: HelmResponseAllOfValuesOverrideFileGit | null;
}
/**
 * 
 * @export
 * @interface HelmResponseAllOfValuesOverrideFileGit
 */
export interface HelmResponseAllOfValuesOverrideFileGit {
    /**
     * 
     * @type {ApplicationGitRepository}
     * @memberof HelmResponseAllOfValuesOverrideFileGit
     */
    'git_repository': ApplicationGitRepository;
    /**
     * List of path inside your git repository to locate values file. Must start by a /
     * @type {Array<string>}
     * @memberof HelmResponseAllOfValuesOverrideFileGit
     */
    'paths': Array<string>;
}
/**
 * 
 * @export
 * @interface HelmResponseAllOfValuesOverrideFileRaw
 */
export interface HelmResponseAllOfValuesOverrideFileRaw {
    /**
     * 
     * @type {Array<HelmResponseAllOfValuesOverrideFileRawValues>}
     * @memberof HelmResponseAllOfValuesOverrideFileRaw
     */
    'values': Array<HelmResponseAllOfValuesOverrideFileRawValues>;
}
/**
 * 
 * @export
 * @interface HelmResponseAllOfValuesOverrideFileRawValues
 */
export interface HelmResponseAllOfValuesOverrideFileRawValues {
    /**
     * The name of the value file
     * @type {string}
     * @memberof HelmResponseAllOfValuesOverrideFileRawValues
     */
    'name': string;
    /**
     * The content of the value file
     * @type {string}
     * @memberof HelmResponseAllOfValuesOverrideFileRawValues
     */
    'content': string;
}
/**
 * 
 * @export
 * @interface HelmResponseList
 */
export interface HelmResponseList {
    /**
     * 
     * @type {Array<HelmResponse>}
     * @memberof HelmResponseList
     */
    'results'?: Array<HelmResponse>;
}
/**
 * 
 * @export
 * @interface HelmSourceGitResponse
 */
export interface HelmSourceGitResponse {
    /**
     * 
     * @type {ApplicationGitRepository}
     * @memberof HelmSourceGitResponse
     */
    'git_repository': ApplicationGitRepository;
}
/**
 * 
 * @export
 * @interface HelmSourceRepositoryResponse
 */
export interface HelmSourceRepositoryResponse {
    /**
     * 
     * @type {string}
     * @memberof HelmSourceRepositoryResponse
     */
    'chart_name': string;
    /**
     * 
     * @type {string}
     * @memberof HelmSourceRepositoryResponse
     */
    'chart_version': string;
    /**
     * 
     * @type {HelmSourceRepositoryResponseRepository}
     * @memberof HelmSourceRepositoryResponse
     */
    'repository': HelmSourceRepositoryResponseRepository;
}
/**
 * 
 * @export
 * @interface HelmSourceRepositoryResponseRepository
 */
export interface HelmSourceRepositoryResponseRepository {
    /**
     * 
     * @type {string}
     * @memberof HelmSourceRepositoryResponseRepository
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof HelmSourceRepositoryResponseRepository
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof HelmSourceRepositoryResponseRepository
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface HelmVersionResponse
 */
export interface HelmVersionResponse {
    /**
     * 
     * @type {string}
     * @memberof HelmVersionResponse
     */
    'chart_name'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof HelmVersionResponse
     */
    'versions'?: Array<string>;
}
/**
 * 
 * @export
 * @interface HelmVersionResponseList
 */
export interface HelmVersionResponseList {
    /**
     * 
     * @type {Array<HelmVersionResponse>}
     * @memberof HelmVersionResponseList
     */
    'results'?: Array<HelmVersionResponse>;
}
/**
 * 
 * @export
 * @interface InviteMember
 */
export interface InviteMember {
    /**
     * 
     * @type {string}
     * @memberof InviteMember
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof InviteMember
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof InviteMember
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof InviteMember
     */
    'email': string;
    /**
     * 
     * @type {InviteMemberRoleEnum}
     * @memberof InviteMember
     */
    'role': InviteMemberRoleEnum;
    /**
     * 
     * @type {string}
     * @memberof InviteMember
     */
    'invitation_link': string;
    /**
     * 
     * @type {InviteStatusEnum}
     * @memberof InviteMember
     */
    'invitation_status': InviteStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof InviteMember
     */
    'organization_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof InviteMember
     */
    'inviter': string;
    /**
     * 
     * @type {string}
     * @memberof InviteMember
     */
    'logo_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof InviteMember
     */
    'role_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof InviteMember
     */
    'role_name'?: string;
}


/**
 * 
 * @export
 * @interface InviteMemberRequest
 */
export interface InviteMemberRequest {
    /**
     * 
     * @type {string}
     * @memberof InviteMemberRequest
     */
    'email': string;
    /**
     * 
     * @type {InviteMemberRoleEnum}
     * @memberof InviteMemberRequest
     */
    'role'?: InviteMemberRoleEnum;
    /**
     * the target role to attribute to the new member
     * @type {string}
     * @memberof InviteMemberRequest
     */
    'role_id'?: string;
}


/**
 * 
 * @export
 * @interface InviteMemberResponseList
 */
export interface InviteMemberResponseList {
    /**
     * 
     * @type {Array<InviteMember>}
     * @memberof InviteMemberResponseList
     */
    'results'?: Array<InviteMember>;
}
/**
 * deprecated
 * @export
 * @enum {string}
 */

export const InviteMemberRoleEnum = {
    ADMIN: 'ADMIN',
    DEVELOPER: 'DEVELOPER',
    OWNER: 'OWNER',
    VIEWER: 'VIEWER'
} as const;

export type InviteMemberRoleEnum = typeof InviteMemberRoleEnum[keyof typeof InviteMemberRoleEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const InviteStatusEnum = {
    EXPIRED: 'EXPIRED',
    PENDING: 'PENDING'
} as const;

export type InviteStatusEnum = typeof InviteStatusEnum[keyof typeof InviteStatusEnum];


/**
 * 
 * @export
 * @interface Invoice
 */
export interface Invoice {
    /**
     * 
     * @type {number}
     * @memberof Invoice
     */
    'total_in_cents': number;
    /**
     * 
     * @type {number}
     * @memberof Invoice
     */
    'total': number;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'currency_code': string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'created_at': string;
    /**
     * 
     * @type {InvoiceStatusEnum}
     * @memberof Invoice
     */
    'status': InvoiceStatusEnum;
}


/**
 * 
 * @export
 * @interface InvoiceResponseList
 */
export interface InvoiceResponseList {
    /**
     * 
     * @type {Array<Invoice>}
     * @memberof InvoiceResponseList
     */
    'results'?: Array<Invoice>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const InvoiceStatusEnum = {
    NOT_PAID: 'NOT_PAID',
    PAID: 'PAID',
    PAYMENT_DUE: 'PAYMENT_DUE',
    PENDING: 'PENDING',
    POSTED: 'POSTED',
    UNKNOWN: 'UNKNOWN',
    VOIDED: 'VOIDED'
} as const;

export type InvoiceStatusEnum = typeof InvoiceStatusEnum[keyof typeof InvoiceStatusEnum];


/**
 * 
 * @export
 * @interface JobAdvancedSettings
 */
export interface JobAdvancedSettings {
    /**
     * define the max timeout for the build
     * @type {number}
     * @memberof JobAdvancedSettings
     */
    'build.timeout_max_sec'?: number;
    /**
     * define the max cpu resources (in milli)
     * @type {number}
     * @memberof JobAdvancedSettings
     */
    'build.cpu_max_in_milli'?: number;
    /**
     * define the max ram resources (in gib)
     * @type {number}
     * @memberof JobAdvancedSettings
     */
    'build.ram_max_in_gib'?: number;
    /**
     * define how long in seconds an application is supposed to be stopped gracefully
     * @type {number}
     * @memberof JobAdvancedSettings
     */
    'deployment.termination_grace_period_seconds'?: number;
    /**
     * Set pod placement on specific Kubernetes nodes labels
     * @type {{ [key: string]: string; }}
     * @memberof JobAdvancedSettings
     */
    'deployment.affinity.node.required'?: { [key: string]: string; };
    /**
     * 
     * @type {number}
     * @memberof JobAdvancedSettings
     */
    'job.delete_ttl_seconds_after_finished'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof JobAdvancedSettings
     */
    'cronjob.concurrency_policy'?: string;
    /**
     * 
     * @type {number}
     * @memberof JobAdvancedSettings
     */
    'cronjob.failed_jobs_history_limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof JobAdvancedSettings
     */
    'cronjob.success_jobs_history_limit'?: number;
    /**
     * Allows you to set an existing Kubernetes service account name 
     * @type {string}
     * @memberof JobAdvancedSettings
     */
    'security.service_account_name'?: string;
    /**
     * Automount Kubernetes service account token to have access to Kubernetes API from pods 
     * @type {boolean}
     * @memberof JobAdvancedSettings
     */
    'security.automount_service_account_token'?: boolean;
    /**
     * Mounts the container\'s root filesystem as read-only 
     * @type {boolean}
     * @memberof JobAdvancedSettings
     */
    'security.read_only_root_filesystem'?: boolean;
}
/**
 * 
 * @export
 * @interface JobDeployRequest
 */
export interface JobDeployRequest {
    /**
     * Image tag to deploy.   Cannot be set if `git_commit_id` is defined 
     * @type {string}
     * @memberof JobDeployRequest
     */
    'image_tag'?: string;
    /**
     * Commit to deploy Cannot be set if `image_tag` is defined 
     * @type {string}
     * @memberof JobDeployRequest
     */
    'git_commit_id'?: string;
}
/**
 * 
 * @export
 * @interface JobDeploymentRestrictionRequest
 */
export interface JobDeploymentRestrictionRequest {
    /**
     * 
     * @type {DeploymentRestrictionModeEnum}
     * @memberof JobDeploymentRestrictionRequest
     */
    'mode': DeploymentRestrictionModeEnum;
    /**
     * 
     * @type {DeploymentRestrictionTypeEnum}
     * @memberof JobDeploymentRestrictionRequest
     */
    'type': DeploymentRestrictionTypeEnum;
    /**
     * For `PATH` restrictions, the value must not start with `/`
     * @type {string}
     * @memberof JobDeploymentRestrictionRequest
     */
    'value': string;
}


/**
 * 
 * @export
 * @interface JobDeploymentRestrictionResponse
 */
export interface JobDeploymentRestrictionResponse {
    /**
     * 
     * @type {string}
     * @memberof JobDeploymentRestrictionResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof JobDeploymentRestrictionResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof JobDeploymentRestrictionResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {DeploymentRestrictionModeEnum}
     * @memberof JobDeploymentRestrictionResponse
     */
    'mode': DeploymentRestrictionModeEnum;
    /**
     * 
     * @type {DeploymentRestrictionTypeEnum}
     * @memberof JobDeploymentRestrictionResponse
     */
    'type': DeploymentRestrictionTypeEnum;
    /**
     * For `PATH` restrictions, the value must not start with `/`
     * @type {string}
     * @memberof JobDeploymentRestrictionResponse
     */
    'value': string;
}


/**
 * 
 * @export
 * @interface JobDeploymentRestrictionResponseList
 */
export interface JobDeploymentRestrictionResponseList {
    /**
     * 
     * @type {Array<JobDeploymentRestrictionResponse>}
     * @memberof JobDeploymentRestrictionResponseList
     */
    'results'?: Array<JobDeploymentRestrictionResponse>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const JobForceEvent = {
    START: 'START',
    STOP: 'STOP',
    DELETE: 'DELETE',
    CRON: 'CRON'
} as const;

export type JobForceEvent = typeof JobForceEvent[keyof typeof JobForceEvent];


/**
 * 
 * @export
 * @enum {string}
 */

export const JobLifecycleTypeEnum = {
    GENERIC: 'GENERIC',
    TERRAFORM: 'TERRAFORM',
    CLOUDFORMATION: 'CLOUDFORMATION'
} as const;

export type JobLifecycleTypeEnum = typeof JobLifecycleTypeEnum[keyof typeof JobLifecycleTypeEnum];


/**
 * 
 * @export
 * @interface JobRequest
 */
export interface JobRequest {
    /**
     * name is case insensitive
     * @type {string}
     * @memberof JobRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof JobRequest
     */
    'description'?: string;
    /**
     * unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof JobRequest
     */
    'cpu'?: number;
    /**
     * unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof JobRequest
     */
    'memory'?: number;
    /**
     * Maximum number of restart allowed before the job is considered as failed 0 means that no restart/crash of the job is allowed 
     * @type {number}
     * @memberof JobRequest
     */
    'max_nb_restart'?: number;
    /**
     * Maximum number of seconds allowed for the job to run before killing it and mark it as failed 
     * @type {number}
     * @memberof JobRequest
     */
    'max_duration_seconds'?: number;
    /**
     * Indicates if the \'environment preview option\' is enabled for this container.   If enabled, a preview environment will be automatically cloned when `/preview` endpoint is called.   If not specified, it takes the value of the `auto_preview` property from the associated environment. 
     * @type {boolean}
     * @memberof JobRequest
     */
    'auto_preview'?: boolean;
    /**
     * Port where to run readiness and liveliness probes checks. The port will not be exposed externally
     * @type {number}
     * @memberof JobRequest
     */
    'port'?: number | null;
    /**
     * 
     * @type {JobRequestAllOfSource}
     * @memberof JobRequest
     */
    'source'?: JobRequestAllOfSource;
    /**
     * 
     * @type {Healthcheck}
     * @memberof JobRequest
     */
    'healthchecks': Healthcheck;
    /**
     * 
     * @type {JobRequestAllOfSchedule}
     * @memberof JobRequest
     */
    'schedule'?: JobRequestAllOfSchedule;
    /**
     * Specify if the job will be automatically updated after receiving a new image tag or a new commit according to the source type.  The new image tag shall be communicated via the \"Auto Deploy job\" endpoint https://api-doc.qovery.com/#tag/Jobs/operation/autoDeployJobEnvironments 
     * @type {boolean}
     * @memberof JobRequest
     */
    'auto_deploy'?: boolean | null;
    /**
     * 
     * @type {Array<ServiceAnnotationRequest>}
     * @memberof JobRequest
     */
    'annotations_groups'?: Array<ServiceAnnotationRequest>;
    /**
     * 
     * @type {Array<ServiceLabelRequest>}
     * @memberof JobRequest
     */
    'labels_groups'?: Array<ServiceLabelRequest>;
    /**
     * Icon URI representing the job.
     * @type {string}
     * @memberof JobRequest
     */
    'icon_uri'?: string;
}
/**
 * If you want to define a Cron job, only the `cronjob` property must be filled   A Lifecycle job should contain at least one property `on_XXX` among the 3 properties: `on_start`, `on_stop`, `on_delete` 
 * @export
 * @interface JobRequestAllOfSchedule
 */
export interface JobRequestAllOfSchedule {
    /**
     * 
     * @type {JobRequestAllOfScheduleOnStart}
     * @memberof JobRequestAllOfSchedule
     */
    'on_start'?: JobRequestAllOfScheduleOnStart;
    /**
     * 
     * @type {JobRequestAllOfScheduleOnStart}
     * @memberof JobRequestAllOfSchedule
     */
    'on_stop'?: JobRequestAllOfScheduleOnStart;
    /**
     * 
     * @type {JobRequestAllOfScheduleOnStart}
     * @memberof JobRequestAllOfSchedule
     */
    'on_delete'?: JobRequestAllOfScheduleOnStart;
    /**
     * 
     * @type {JobRequestAllOfScheduleCronjob}
     * @memberof JobRequestAllOfSchedule
     */
    'cronjob'?: JobRequestAllOfScheduleCronjob;
    /**
     * 
     * @type {JobLifecycleTypeEnum}
     * @memberof JobRequestAllOfSchedule
     */
    'lifecycle_type'?: JobLifecycleTypeEnum;
}


/**
 * 
 * @export
 * @interface JobRequestAllOfScheduleCronjob
 */
export interface JobRequestAllOfScheduleCronjob {
    /**
     * 
     * @type {Array<string>}
     * @memberof JobRequestAllOfScheduleCronjob
     */
    'arguments'?: Array<string>;
    /**
     * optional entrypoint when launching container
     * @type {string}
     * @memberof JobRequestAllOfScheduleCronjob
     */
    'entrypoint'?: string;
    /**
     * Specify a timezone identifier to run the schedule at. By default Etc/UTC
     * @type {string}
     * @memberof JobRequestAllOfScheduleCronjob
     */
    'timezone'?: string;
    /**
     * Can only be set if the event is CRON.   Represent the cron format for the job schedule without seconds.   For example: `* * * * *` represent the cron to launch the job every minute.   See https://crontab.guru/ to WISIWIG interface.   Timezone is UTC 
     * @type {string}
     * @memberof JobRequestAllOfScheduleCronjob
     */
    'scheduled_at': string;
}
/**
 * 
 * @export
 * @interface JobRequestAllOfScheduleOnStart
 */
export interface JobRequestAllOfScheduleOnStart {
    /**
     * 
     * @type {Array<string>}
     * @memberof JobRequestAllOfScheduleOnStart
     */
    'arguments'?: Array<string>;
    /**
     * optional entrypoint when launching container
     * @type {string}
     * @memberof JobRequestAllOfScheduleOnStart
     */
    'entrypoint'?: string;
}
/**
 * 
 * @export
 * @interface JobRequestAllOfSource
 */
export interface JobRequestAllOfSource {
    /**
     * 
     * @type {JobRequestAllOfSourceImage}
     * @memberof JobRequestAllOfSource
     */
    'image'?: JobRequestAllOfSourceImage | null;
    /**
     * 
     * @type {JobRequestAllOfSourceDocker}
     * @memberof JobRequestAllOfSource
     */
    'docker'?: JobRequestAllOfSourceDocker | null;
}
/**
 * 
 * @export
 * @interface JobRequestAllOfSourceDocker
 */
export interface JobRequestAllOfSourceDocker {
    /**
     * 
     * @type {ApplicationGitRepositoryRequest}
     * @memberof JobRequestAllOfSourceDocker
     */
    'git_repository'?: ApplicationGitRepositoryRequest;
    /**
     * The path of the associated Dockerfile. Only if you are using build_mode = DOCKER
     * @type {string}
     * @memberof JobRequestAllOfSourceDocker
     */
    'dockerfile_path'?: string | null;
    /**
     * The content of your dockerfile if it is not stored inside your git repository
     * @type {string}
     * @memberof JobRequestAllOfSourceDocker
     */
    'dockerfile_raw'?: string | null;
}
/**
 * 
 * @export
 * @interface JobRequestAllOfSourceImage
 */
export interface JobRequestAllOfSourceImage {
    /**
     * The image name pattern differs according to chosen container registry provider:   * `ECR`: `repository` * `SCALEWAY_CR`: `namespace/image` * `DOCKER_HUB`: `image` or `repository/image` * `PUBLIC_ECR`: `registry_alias/repository` 
     * @type {string}
     * @memberof JobRequestAllOfSourceImage
     */
    'image_name'?: string;
    /**
     * tag of the image container
     * @type {string}
     * @memberof JobRequestAllOfSourceImage
     */
    'tag'?: string;
    /**
     * tag of the image container
     * @type {string}
     * @memberof JobRequestAllOfSourceImage
     */
    'registry_id'?: string;
}
/**
 * @type JobResponse
 * @export
 */
export type JobResponse = { job_type: 'CRON' } & CronJobResponse | { job_type: 'LIFECYCLE' } & LifecycleJobResponse;

/**
 * 
 * @export
 * @interface JobResponseList
 */
export interface JobResponseList {
    /**
     * 
     * @type {Array<JobResponse>}
     * @memberof JobResponseList
     */
    'results'?: Array<JobResponse>;
}
/**
 * On which event the job is going to run.   ON_START means when a deployment is requested for the environment   ON_STOP means when a stop of the environment is requested   ON_DELETE means when an environment delete is requested   CRON means at a scheduled interval   
 * @export
 * @enum {string}
 */

export const JobScheduleEvent = {
    ON_START: 'ON_START',
    ON_STOP: 'ON_STOP',
    ON_DELETE: 'ON_DELETE',
    CRON: 'CRON'
} as const;

export type JobScheduleEvent = typeof JobScheduleEvent[keyof typeof JobScheduleEvent];


/**
 * 
 * @export
 * @interface JobSourceDockerResponse
 */
export interface JobSourceDockerResponse {
    /**
     * 
     * @type {ApplicationGitRepository}
     * @memberof JobSourceDockerResponse
     */
    'git_repository'?: ApplicationGitRepository;
    /**
     * The path of the associated Dockerfile. Only if you are using build_mode = DOCKER
     * @type {string}
     * @memberof JobSourceDockerResponse
     */
    'dockerfile_path'?: string | null;
    /**
     * The content of your dockerfile if it is not stored inside your git repository
     * @type {string}
     * @memberof JobSourceDockerResponse
     */
    'dockerfile_raw'?: string | null;
}
/**
 * 
 * @export
 * @interface Key
 */
export interface Key {
    /**
     * 
     * @type {string}
     * @memberof Key
     */
    'key': string;
    /**
     * optional variable description (255 characters maximum)
     * @type {string}
     * @memberof Key
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const KubernetesEnum = {
    K3_S: 'K3S',
    MANAGED: 'MANAGED',
    SELF_MANAGED: 'SELF_MANAGED'
} as const;

export type KubernetesEnum = typeof KubernetesEnum[keyof typeof KubernetesEnum];


/**
 * 
 * @export
 * @interface Label
 */
export interface Label {
    /**
     * 
     * @type {string}
     * @memberof Label
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof Label
     */
    'value': string;
    /**
     * 
     * @type {boolean}
     * @memberof Label
     */
    'propagate_to_cloud_provider': boolean;
}
/**
 * Labels Group Associated Item Type
 * @export
 * @enum {string}
 */

export const LabelsGroupAssociatedItemType = {
    APPLICATION: 'APPLICATION',
    DATABASE: 'DATABASE',
    CONTAINER: 'CONTAINER',
    LIFECYCLE: 'LIFECYCLE',
    ENVIRONMENT: 'ENVIRONMENT',
    CLUSTER: 'CLUSTER',
    CRON: 'CRON'
} as const;

export type LabelsGroupAssociatedItemType = typeof LabelsGroupAssociatedItemType[keyof typeof LabelsGroupAssociatedItemType];


/**
 * 
 * @export
 * @interface LifecycleJobResponse
 */
export interface LifecycleJobResponse {
    /**
     * 
     * @type {string}
     * @memberof LifecycleJobResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof LifecycleJobResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof LifecycleJobResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {ReferenceObject}
     * @memberof LifecycleJobResponse
     */
    'environment': ReferenceObject;
    /**
     * Maximum cpu that can be allocated to the job based on organization cluster configuration. unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof LifecycleJobResponse
     */
    'maximum_cpu': number;
    /**
     * Maximum memory that can be allocated to the job based on organization cluster configuration. unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof LifecycleJobResponse
     */
    'maximum_memory': number;
    /**
     * name is case insensitive
     * @type {string}
     * @memberof LifecycleJobResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof LifecycleJobResponse
     */
    'description'?: string;
    /**
     * unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof LifecycleJobResponse
     */
    'cpu': number;
    /**
     * unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof LifecycleJobResponse
     */
    'memory': number;
    /**
     * Maximum number of restart allowed before the job is considered as failed 0 means that no restart/crash of the job is allowed 
     * @type {number}
     * @memberof LifecycleJobResponse
     */
    'max_nb_restart'?: number;
    /**
     * Maximum number of seconds allowed for the job to run before killing it and mark it as failed 
     * @type {number}
     * @memberof LifecycleJobResponse
     */
    'max_duration_seconds'?: number;
    /**
     * Indicates if the \'environment preview option\' is enabled for this container.   If enabled, a preview environment will be automatically cloned when `/preview` endpoint is called.   If not specified, it takes the value of the `auto_preview` property from the associated environment. 
     * @type {boolean}
     * @memberof LifecycleJobResponse
     */
    'auto_preview': boolean;
    /**
     * Port where to run readiness and liveliness probes checks. The port will not be exposed externally
     * @type {number}
     * @memberof LifecycleJobResponse
     */
    'port'?: number | null;
    /**
     * 
     * @type {BaseJobResponseAllOfSource}
     * @memberof LifecycleJobResponse
     */
    'source': BaseJobResponseAllOfSource;
    /**
     * 
     * @type {Healthcheck}
     * @memberof LifecycleJobResponse
     */
    'healthchecks': Healthcheck;
    /**
     * Specify if the job will be automatically updated after receiving a new image tag or a new commit according to the source type.  The new image tag shall be communicated via the \"Auto Deploy job\" endpoint https://api-doc.qovery.com/#tag/Jobs/operation/autoDeployJobEnvironments 
     * @type {boolean}
     * @memberof LifecycleJobResponse
     */
    'auto_deploy'?: boolean;
    /**
     * Icon URI representing the job.
     * @type {string}
     * @memberof LifecycleJobResponse
     */
    'icon_uri': string;
    /**
     * 
     * @type {string}
     * @memberof LifecycleJobResponse
     */
    'job_type': LifecycleJobResponseJobTypeEnum;
    /**
     * 
     * @type {LifecycleJobResponseAllOfSchedule}
     * @memberof LifecycleJobResponse
     */
    'schedule': LifecycleJobResponseAllOfSchedule;
    /**
     * 
     * @type {Array<OrganizationAnnotationsGroupResponse>}
     * @memberof LifecycleJobResponse
     */
    'annotations_groups'?: Array<OrganizationAnnotationsGroupResponse>;
    /**
     * 
     * @type {Array<OrganizationLabelsGroupResponse>}
     * @memberof LifecycleJobResponse
     */
    'labels_groups'?: Array<OrganizationLabelsGroupResponse>;
}

export const LifecycleJobResponseJobTypeEnum = {
    LIFECYCLE: 'LIFECYCLE'
} as const;

export type LifecycleJobResponseJobTypeEnum = typeof LifecycleJobResponseJobTypeEnum[keyof typeof LifecycleJobResponseJobTypeEnum];

/**
 * 
 * @export
 * @interface LifecycleJobResponseAllOfSchedule
 */
export interface LifecycleJobResponseAllOfSchedule {
    /**
     * 
     * @type {JobRequestAllOfScheduleOnStart}
     * @memberof LifecycleJobResponseAllOfSchedule
     */
    'on_start'?: JobRequestAllOfScheduleOnStart;
    /**
     * 
     * @type {JobRequestAllOfScheduleOnStart}
     * @memberof LifecycleJobResponseAllOfSchedule
     */
    'on_stop'?: JobRequestAllOfScheduleOnStart;
    /**
     * 
     * @type {JobRequestAllOfScheduleOnStart}
     * @memberof LifecycleJobResponseAllOfSchedule
     */
    'on_delete'?: JobRequestAllOfScheduleOnStart;
    /**
     * 
     * @type {JobLifecycleTypeEnum}
     * @memberof LifecycleJobResponseAllOfSchedule
     */
    'lifecycle_type'?: JobLifecycleTypeEnum;
}


/**
 * 
 * @export
 * @interface LifecycleTemplateListResponse
 */
export interface LifecycleTemplateListResponse {
    /**
     * 
     * @type {Array<LifecycleTemplateListResponseResultsInner>}
     * @memberof LifecycleTemplateListResponse
     */
    'results': Array<LifecycleTemplateListResponseResultsInner>;
}
/**
 * 
 * @export
 * @interface LifecycleTemplateListResponseResultsInner
 */
export interface LifecycleTemplateListResponseResultsInner {
    /**
     * 
     * @type {string}
     * @memberof LifecycleTemplateListResponseResultsInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof LifecycleTemplateListResponseResultsInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof LifecycleTemplateListResponseResultsInner
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface LifecycleTemplateResponse
 */
export interface LifecycleTemplateResponse {
    /**
     * 
     * @type {string}
     * @memberof LifecycleTemplateResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof LifecycleTemplateResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof LifecycleTemplateResponse
     */
    'description': string;
    /**
     * location of the template
     * @type {string}
     * @memberof LifecycleTemplateResponse
     */
    'sourceUrl': string;
    /**
     * 
     * @type {CloudProviderEnum}
     * @memberof LifecycleTemplateResponse
     */
    'cloud_provider': CloudProviderEnum;
    /**
     * lis of pre-defined command for each event
     * @type {Array<LifecycleTemplateResponseEventsInner>}
     * @memberof LifecycleTemplateResponse
     */
    'events': Array<LifecycleTemplateResponseEventsInner>;
    /**
     * Job max allowed duration in minutes. After this allowed time, the job is going to be killed.
     * @type {number}
     * @memberof LifecycleTemplateResponse
     */
    'max_duration_in_minutes': number;
    /**
     * 
     * @type {LifecycleTemplateResponseResources}
     * @memberof LifecycleTemplateResponse
     */
    'resources': LifecycleTemplateResponseResources;
    /**
     * 
     * @type {LifecycleTemplateResponseVariables}
     * @memberof LifecycleTemplateResponse
     */
    'variables': LifecycleTemplateResponseVariables;
}


/**
 * 
 * @export
 * @interface LifecycleTemplateResponseEventsInner
 */
export interface LifecycleTemplateResponseEventsInner {
    /**
     * 
     * @type {string}
     * @memberof LifecycleTemplateResponseEventsInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof LifecycleTemplateResponseEventsInner
     */
    'entrpoint'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof LifecycleTemplateResponseEventsInner
     */
    'command': Array<string>;
}
/**
 * 
 * @export
 * @interface LifecycleTemplateResponseResources
 */
export interface LifecycleTemplateResponseResources {
    /**
     * 
     * @type {number}
     * @memberof LifecycleTemplateResponseResources
     */
    'cpu_milli': number;
    /**
     * 
     * @type {number}
     * @memberof LifecycleTemplateResponseResources
     */
    'ram_mib': number;
}
/**
 * Variables to inject at the creation of this lifecycle job
 * @export
 * @interface LifecycleTemplateResponseVariables
 */
export interface LifecycleTemplateResponseVariables {
    /**
     * 
     * @type {string}
     * @memberof LifecycleTemplateResponseVariables
     */
    'name': string;
    /**
     * Short description to explain the purpose of the variable 
     * @type {string}
     * @memberof LifecycleTemplateResponseVariables
     */
    'description': string;
    /**
     * Default value for the variable
     * @type {string}
     * @memberof LifecycleTemplateResponseVariables
     */
    'default': string;
    /**
     * If the variable should be injected as a secret
     * @type {boolean}
     * @memberof LifecycleTemplateResponseVariables
     */
    'is_secret': boolean;
    /**
     * 
     * @type {LifecycleTemplateResponseVariablesFile}
     * @memberof LifecycleTemplateResponseVariables
     */
    'file'?: LifecycleTemplateResponseVariablesFile;
}
/**
 * If present, the variable should be a file instead of a raw value 
 * @export
 * @interface LifecycleTemplateResponseVariablesFile
 */
export interface LifecycleTemplateResponseVariablesFile {
    /**
     * 
     * @type {string}
     * @memberof LifecycleTemplateResponseVariablesFile
     */
    'path': string;
}
/**
 * 
 * @export
 * @interface Link
 */
export interface Link {
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'url'?: string;
    /**
     * The port from which the service is reachable from within the cluster
     * @type {number}
     * @memberof Link
     */
    'internal_port'?: number;
    /**
     * The port from which the service is reachable from externally (i.e: 443 for HTTPS)
     * @type {number}
     * @memberof Link
     */
    'external_port'?: number;
    /**
     * True if the domain is managed by Qovery, false if it belongs to the user
     * @type {boolean}
     * @memberof Link
     */
    'is_qovery_domain'?: boolean;
    /**
     * Indicate if the link is using the root of the domain and not one derivated from port i.e: p8080.zxxxx.jvm.worl      => is_default = false, is_qovery = true zxxxx.jvm.world           => is_default = true, is_qovery = true p8080-my-super-domain.com => is_default = false, is_qovery = false my-super-domain.com       => is_default = true, is_qovery = false 
     * @type {boolean}
     * @memberof Link
     */
    'is_default'?: boolean;
}
/**
 * 
 * @export
 * @interface LinkResponseList
 */
export interface LinkResponseList {
    /**
     * 
     * @type {Array<Link>}
     * @memberof LinkResponseList
     */
    'results'?: Array<Link>;
}
/**
 * type of the service (application, database, job, gateway...)
 * @export
 * @enum {string}
 */

export const LinkedServiceTypeEnum = {
    APPLICATION: 'APPLICATION',
    CONTAINER: 'CONTAINER',
    DATABASE: 'DATABASE',
    JOB: 'JOB',
    HELM: 'HELM'
} as const;

export type LinkedServiceTypeEnum = typeof LinkedServiceTypeEnum[keyof typeof LinkedServiceTypeEnum];


/**
 * 
 * @export
 * @interface ListContainerDeploymentHistory200Response
 */
export interface ListContainerDeploymentHistory200Response {
    /**
     * 
     * @type {number}
     * @memberof ListContainerDeploymentHistory200Response
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof ListContainerDeploymentHistory200Response
     */
    'page_size': number;
    /**
     * 
     * @type {Array<DeploymentHistoryContainer>}
     * @memberof ListContainerDeploymentHistory200Response
     */
    'results'?: Array<DeploymentHistoryContainer>;
}
/**
 * 
 * @export
 * @interface ListDatabaseDeploymentHistory200Response
 */
export interface ListDatabaseDeploymentHistory200Response {
    /**
     * 
     * @type {number}
     * @memberof ListDatabaseDeploymentHistory200Response
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof ListDatabaseDeploymentHistory200Response
     */
    'page_size': number;
    /**
     * 
     * @type {Array<DeploymentHistoryDatabase>}
     * @memberof ListDatabaseDeploymentHistory200Response
     */
    'results'?: Array<DeploymentHistoryDatabase>;
}
/**
 * 
 * @export
 * @interface ListHelmDeploymentHistory200Response
 */
export interface ListHelmDeploymentHistory200Response {
    /**
     * 
     * @type {number}
     * @memberof ListHelmDeploymentHistory200Response
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof ListHelmDeploymentHistory200Response
     */
    'page_size': number;
    /**
     * 
     * @type {Array<DeploymentHistoryHelmResponse>}
     * @memberof ListHelmDeploymentHistory200Response
     */
    'results'?: Array<DeploymentHistoryHelmResponse>;
}
/**
 * 
 * @export
 * @interface ListJobDeploymentHistory200Response
 */
export interface ListJobDeploymentHistory200Response {
    /**
     * 
     * @type {number}
     * @memberof ListJobDeploymentHistory200Response
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof ListJobDeploymentHistory200Response
     */
    'page_size': number;
    /**
     * 
     * @type {Array<DeploymentHistoryJobResponse>}
     * @memberof ListJobDeploymentHistory200Response
     */
    'results'?: Array<DeploymentHistoryJobResponse>;
}
/**
 * 
 * @export
 * @interface ListOrganizationAnnotationsGroup200Response
 */
export interface ListOrganizationAnnotationsGroup200Response {
    /**
     * 
     * @type {Array<OrganizationAnnotationsGroupEnrichedResponse>}
     * @memberof ListOrganizationAnnotationsGroup200Response
     */
    'results'?: Array<OrganizationAnnotationsGroupEnrichedResponse>;
}
/**
 * 
 * @export
 * @interface ListOrganizationLabelsGroup200Response
 */
export interface ListOrganizationLabelsGroup200Response {
    /**
     * 
     * @type {Array<OrganizationLabelsGroupEnrichedResponse>}
     * @memberof ListOrganizationLabelsGroup200Response
     */
    'results'?: Array<OrganizationLabelsGroupEnrichedResponse>;
}
/**
 * 
 * @export
 * @interface Log
 */
export interface Log {
    /**
     * 
     * @type {string}
     * @memberof Log
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Log
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Log
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof Log
     */
    'pod_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Log
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface LogResponseList
 */
export interface LogResponseList {
    /**
     * 
     * @type {Array<Log>}
     * @memberof LogResponseList
     */
    'results'?: Array<Log>;
}
/**
 * 
 * @export
 * @interface ManagedDatabaseInstanceTypeResponse
 */
export interface ManagedDatabaseInstanceTypeResponse {
    /**
     * 
     * @type {string}
     * @memberof ManagedDatabaseInstanceTypeResponse
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ManagedDatabaseInstanceTypeResponseList
 */
export interface ManagedDatabaseInstanceTypeResponseList {
    /**
     * 
     * @type {Array<ManagedDatabaseInstanceTypeResponse>}
     * @memberof ManagedDatabaseInstanceTypeResponseList
     */
    'results'?: Array<ManagedDatabaseInstanceTypeResponse>;
}
/**
 * 
 * @export
 * @interface ManagedDatabaseTypeResponse
 */
export interface ManagedDatabaseTypeResponse {
    /**
     * 
     * @type {string}
     * @memberof ManagedDatabaseTypeResponse
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ManagedDatabaseTypeResponseList
 */
export interface ManagedDatabaseTypeResponseList {
    /**
     * 
     * @type {Array<ManagedDatabaseTypeResponse>}
     * @memberof ManagedDatabaseTypeResponseList
     */
    'results'?: Array<ManagedDatabaseTypeResponse>;
}
/**
 * 
 * @export
 * @interface Member
 */
export interface Member {
    /**
     * 
     * @type {string}
     * @memberof Member
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Member
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Member
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Member
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Member
     */
    'nickname'?: string;
    /**
     * 
     * @type {string}
     * @memberof Member
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof Member
     */
    'profile_picture_url'?: string;
    /**
     * last time the user was connected
     * @type {string}
     * @memberof Member
     */
    'last_activity_at'?: string;
    /**
     * 
     * @type {InviteMemberRoleEnum}
     * @memberof Member
     */
    'role'?: InviteMemberRoleEnum;
    /**
     * the role linked to the user
     * @type {string}
     * @memberof Member
     */
    'role_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Member
     */
    'role_id'?: string;
}


/**
 * 
 * @export
 * @interface MemberResponseList
 */
export interface MemberResponseList {
    /**
     * 
     * @type {Array<Member>}
     * @memberof MemberResponseList
     */
    'results'?: Array<Member>;
}
/**
 * 
 * @export
 * @interface MemberRoleUpdateRequest
 */
export interface MemberRoleUpdateRequest {
    /**
     * specify the git provider user id
     * @type {string}
     * @memberof MemberRoleUpdateRequest
     */
    'user_id': string;
    /**
     * 
     * @type {string}
     * @memberof MemberRoleUpdateRequest
     */
    'role_id': string;
}
/**
 * 
 * @export
 * @interface OnPremiseCredentialsRequest
 */
export interface OnPremiseCredentialsRequest {
    /**
     * 
     * @type {string}
     * @memberof OnPremiseCredentialsRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface Organization
 */
export interface Organization {
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'updated_at'?: string;
    /**
     * name is case insensitive
     * @type {string}
     * @memberof Organization
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'description'?: string | null;
    /**
     * 
     * @type {PlanEnum}
     * @memberof Organization
     */
    'plan': PlanEnum;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'website_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'repository'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'logo_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'icon_url'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof Organization
     */
    'admin_emails'?: Array<string> | null;
    /**
     * uuid of the user owning the organization
     * @type {string}
     * @memberof Organization
     */
    'owner'?: string;
    /**
     * 
     * @type {OrganizationAllOfOrganizationPlan}
     * @memberof Organization
     */
    'organization_plan'?: OrganizationAllOfOrganizationPlan;
}


/**
 * 
 * @export
 * @interface OrganizationAllOfOrganizationPlan
 */
export interface OrganizationAllOfOrganizationPlan {
    /**
     * 
     * @type {PlanEnum}
     * @memberof OrganizationAllOfOrganizationPlan
     */
    'plan'?: PlanEnum;
    /**
     * audit logs maximum period available in days
     * @type {number}
     * @memberof OrganizationAllOfOrganizationPlan
     */
    'audit_logs_retention_in_days'?: number;
}


/**
 * 
 * @export
 * @interface OrganizationAnnotationsGroupAssociatedItemsResponseList
 */
export interface OrganizationAnnotationsGroupAssociatedItemsResponseList {
    /**
     * 
     * @type {Array<OrganizationAnnotationsGroupAssociatedItemsResponseListResultsInner>}
     * @memberof OrganizationAnnotationsGroupAssociatedItemsResponseList
     */
    'results'?: Array<OrganizationAnnotationsGroupAssociatedItemsResponseListResultsInner>;
}
/**
 * 
 * @export
 * @interface OrganizationAnnotationsGroupAssociatedItemsResponseListResultsInner
 */
export interface OrganizationAnnotationsGroupAssociatedItemsResponseListResultsInner {
    /**
     * 
     * @type {string}
     * @memberof OrganizationAnnotationsGroupAssociatedItemsResponseListResultsInner
     */
    'cluster_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationAnnotationsGroupAssociatedItemsResponseListResultsInner
     */
    'cluster_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationAnnotationsGroupAssociatedItemsResponseListResultsInner
     */
    'project_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationAnnotationsGroupAssociatedItemsResponseListResultsInner
     */
    'project_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationAnnotationsGroupAssociatedItemsResponseListResultsInner
     */
    'environment_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationAnnotationsGroupAssociatedItemsResponseListResultsInner
     */
    'environment_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationAnnotationsGroupAssociatedItemsResponseListResultsInner
     */
    'item_id': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationAnnotationsGroupAssociatedItemsResponseListResultsInner
     */
    'item_name': string;
    /**
     * 
     * @type {AnnotationsGroupAssociatedItemType}
     * @memberof OrganizationAnnotationsGroupAssociatedItemsResponseListResultsInner
     */
    'item_type': AnnotationsGroupAssociatedItemType;
}


/**
 * 
 * @export
 * @interface OrganizationAnnotationsGroupCreateRequest
 */
export interface OrganizationAnnotationsGroupCreateRequest {
    /**
     * name of the annotations group
     * @type {string}
     * @memberof OrganizationAnnotationsGroupCreateRequest
     */
    'name': string;
    /**
     * 
     * @type {Array<Annotation>}
     * @memberof OrganizationAnnotationsGroupCreateRequest
     */
    'annotations': Array<Annotation>;
    /**
     * 
     * @type {Array<OrganizationAnnotationsGroupScopeEnum>}
     * @memberof OrganizationAnnotationsGroupCreateRequest
     */
    'scopes': Array<OrganizationAnnotationsGroupScopeEnum>;
}
/**
 * 
 * @export
 * @interface OrganizationAnnotationsGroupEnrichedResponse
 */
export interface OrganizationAnnotationsGroupEnrichedResponse {
    /**
     * 
     * @type {string}
     * @memberof OrganizationAnnotationsGroupEnrichedResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationAnnotationsGroupEnrichedResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationAnnotationsGroupEnrichedResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationAnnotationsGroupEnrichedResponse
     */
    'name': string;
    /**
     * 
     * @type {Array<Annotation>}
     * @memberof OrganizationAnnotationsGroupEnrichedResponse
     */
    'annotations': Array<Annotation>;
    /**
     * 
     * @type {Array<OrganizationAnnotationsGroupScopeEnum>}
     * @memberof OrganizationAnnotationsGroupEnrichedResponse
     */
    'scopes': Array<OrganizationAnnotationsGroupScopeEnum>;
    /**
     * 
     * @type {number}
     * @memberof OrganizationAnnotationsGroupEnrichedResponse
     */
    'associated_items_count'?: number;
}
/**
 * 
 * @export
 * @interface OrganizationAnnotationsGroupResponse
 */
export interface OrganizationAnnotationsGroupResponse {
    /**
     * 
     * @type {string}
     * @memberof OrganizationAnnotationsGroupResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationAnnotationsGroupResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationAnnotationsGroupResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationAnnotationsGroupResponse
     */
    'name': string;
    /**
     * 
     * @type {Array<Annotation>}
     * @memberof OrganizationAnnotationsGroupResponse
     */
    'annotations': Array<Annotation>;
    /**
     * 
     * @type {Array<OrganizationAnnotationsGroupScopeEnum>}
     * @memberof OrganizationAnnotationsGroupResponse
     */
    'scopes': Array<OrganizationAnnotationsGroupScopeEnum>;
}
/**
 * Annotations Group Scope
 * @export
 * @enum {string}
 */

export const OrganizationAnnotationsGroupScopeEnum = {
    DEPLOYMENTS: 'DEPLOYMENTS',
    STATEFUL_SETS: 'STATEFUL_SETS',
    SERVICES: 'SERVICES',
    INGRESS: 'INGRESS',
    HPA: 'HPA',
    PODS: 'PODS',
    SECRETS: 'SECRETS',
    JOBS: 'JOBS',
    CRON_JOBS: 'CRON_JOBS'
} as const;

export type OrganizationAnnotationsGroupScopeEnum = typeof OrganizationAnnotationsGroupScopeEnum[keyof typeof OrganizationAnnotationsGroupScopeEnum];


/**
 * 
 * @export
 * @interface OrganizationApiToken
 */
export interface OrganizationApiToken {
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiToken
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiToken
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiToken
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiToken
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiToken
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiToken
     */
    'role_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiToken
     */
    'role_id'?: string;
}
/**
 * 
 * @export
 * @interface OrganizationApiTokenCreate
 */
export interface OrganizationApiTokenCreate {
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiTokenCreate
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiTokenCreate
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiTokenCreate
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiTokenCreate
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiTokenCreate
     */
    'description'?: string;
    /**
     * the generated token to send in \'Authorization\' header prefixed by \'Token \'
     * @type {string}
     * @memberof OrganizationApiTokenCreate
     */
    'token'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiTokenCreate
     */
    'role_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiTokenCreate
     */
    'role_id'?: string;
}
/**
 * 
 * @export
 * @interface OrganizationApiTokenCreateRequest
 */
export interface OrganizationApiTokenCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiTokenCreateRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiTokenCreateRequest
     */
    'description'?: string;
    /**
     * 
     * @type {OrganizationApiTokenScope}
     * @memberof OrganizationApiTokenCreateRequest
     */
    'scope'?: OrganizationApiTokenScope | null;
    /**
     * the roleId provided by the \"List organization custom roles\" endpoint.
     * @type {string}
     * @memberof OrganizationApiTokenCreateRequest
     */
    'role_id': string | null;
}


/**
 * 
 * @export
 * @interface OrganizationApiTokenResponseList
 */
export interface OrganizationApiTokenResponseList {
    /**
     * 
     * @type {Array<OrganizationApiToken>}
     * @memberof OrganizationApiTokenResponseList
     */
    'results'?: Array<OrganizationApiToken>;
}
/**
 * deprecated
 * @export
 * @enum {string}
 */

export const OrganizationApiTokenScope = {
    ADMIN: 'ADMIN'
} as const;

export type OrganizationApiTokenScope = typeof OrganizationApiTokenScope[keyof typeof OrganizationApiTokenScope];


/**
 * 
 * @export
 * @interface OrganizationAvailableRole
 */
export interface OrganizationAvailableRole {
    /**
     * 
     * @type {string}
     * @memberof OrganizationAvailableRole
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationAvailableRole
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface OrganizationAvailableRoleList
 */
export interface OrganizationAvailableRoleList {
    /**
     * 
     * @type {Array<OrganizationAvailableRole>}
     * @memberof OrganizationAvailableRoleList
     */
    'results'?: Array<OrganizationAvailableRole>;
}
/**
 * 
 * @export
 * @interface OrganizationBillingUsageReportRequest
 */
export interface OrganizationBillingUsageReportRequest {
    /**
     * The start date of the report
     * @type {string}
     * @memberof OrganizationBillingUsageReportRequest
     */
    'from': string;
    /**
     * The end date of the report
     * @type {string}
     * @memberof OrganizationBillingUsageReportRequest
     */
    'to': string;
    /**
     * The number of seconds the report will be publicly available
     * @type {number}
     * @memberof OrganizationBillingUsageReportRequest
     */
    'report_expiration_in_seconds': number;
}
/**
 * 
 * @export
 * @interface OrganizationBillingUsageReportResponse
 */
export interface OrganizationBillingUsageReportResponse {
    /**
     * The URL of the report
     * @type {string}
     * @memberof OrganizationBillingUsageReportResponse
     */
    'report_url'?: string;
    /**
     * The URL to delete the report. Use this URL to pro-actively delete the report before it expires
     * @type {string}
     * @memberof OrganizationBillingUsageReportResponse
     */
    'delete_report_url'?: string;
}
/**
 * 
 * @export
 * @interface OrganizationChangePlanRequest
 */
export interface OrganizationChangePlanRequest {
    /**
     * 
     * @type {string}
     * @memberof OrganizationChangePlanRequest
     */
    'plan'?: string;
}
/**
 * 
 * @export
 * @interface OrganizationContainerAutoDeployRequest
 */
export interface OrganizationContainerAutoDeployRequest {
    /**
     * the container image name to deploy
     * @type {string}
     * @memberof OrganizationContainerAutoDeployRequest
     */
    'image_name'?: string;
    /**
     * the new tag to deploy
     * @type {string}
     * @memberof OrganizationContainerAutoDeployRequest
     */
    'tag'?: string;
}
/**
 * 
 * @export
 * @interface OrganizationContainerPreviewRequest
 */
export interface OrganizationContainerPreviewRequest {
    /**
     * the container image name to trigger preview environment
     * @type {string}
     * @memberof OrganizationContainerPreviewRequest
     */
    'image_name'?: string;
    /**
     * the tag to be used in the preview environment
     * @type {string}
     * @memberof OrganizationContainerPreviewRequest
     */
    'tag'?: string;
}
/**
 * 
 * @export
 * @interface OrganizationCreditCodeRequest
 */
export interface OrganizationCreditCodeRequest {
    /**
     * 
     * @type {string}
     * @memberof OrganizationCreditCodeRequest
     */
    'code'?: string;
}
/**
 * 
 * @export
 * @interface OrganizationCurrentCost
 */
export interface OrganizationCurrentCost {
    /**
     * 
     * @type {PlanEnum}
     * @memberof OrganizationCurrentCost
     */
    'plan'?: PlanEnum;
    /**
     * number of days remaining before the end of the trial period
     * @type {number}
     * @memberof OrganizationCurrentCost
     */
    'remaining_trial_day'?: number;
    /**
     * date when the current plan will be renewed
     * @type {string}
     * @memberof OrganizationCurrentCost
     */
    'renewal_at'?: string | null;
    /**
     * 
     * @type {Cost}
     * @memberof OrganizationCurrentCost
     */
    'cost'?: Cost;
}


/**
 * 
 * @export
 * @interface OrganizationCustomRole
 */
export interface OrganizationCustomRole {
    /**
     * 
     * @type {string}
     * @memberof OrganizationCustomRole
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationCustomRole
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationCustomRole
     */
    'description'?: string;
    /**
     * 
     * @type {Array<OrganizationCustomRoleClusterPermissionsInner>}
     * @memberof OrganizationCustomRole
     */
    'cluster_permissions'?: Array<OrganizationCustomRoleClusterPermissionsInner>;
    /**
     * 
     * @type {Array<OrganizationCustomRoleProjectPermissionsInner>}
     * @memberof OrganizationCustomRole
     */
    'project_permissions'?: Array<OrganizationCustomRoleProjectPermissionsInner>;
}
/**
 * Indicates the permission for a target cluster, from the lowest to the highest: - `VIEWER` user has only read access on target cluster - `ENV_CREATOR` user can deploy on the cluster - `ADMIN` user can modify the cluster settings 
 * @export
 * @enum {string}
 */

export const OrganizationCustomRoleClusterPermission = {
    VIEWER: 'VIEWER',
    ENV_CREATOR: 'ENV_CREATOR',
    ADMIN: 'ADMIN'
} as const;

export type OrganizationCustomRoleClusterPermission = typeof OrganizationCustomRoleClusterPermission[keyof typeof OrganizationCustomRoleClusterPermission];


/**
 * 
 * @export
 * @interface OrganizationCustomRoleClusterPermissionsInner
 */
export interface OrganizationCustomRoleClusterPermissionsInner {
    /**
     * 
     * @type {string}
     * @memberof OrganizationCustomRoleClusterPermissionsInner
     */
    'cluster_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationCustomRoleClusterPermissionsInner
     */
    'cluster_name'?: string;
    /**
     * 
     * @type {OrganizationCustomRoleClusterPermission}
     * @memberof OrganizationCustomRoleClusterPermissionsInner
     */
    'permission'?: OrganizationCustomRoleClusterPermission;
}


/**
 * 
 * @export
 * @interface OrganizationCustomRoleCreateRequest
 */
export interface OrganizationCustomRoleCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof OrganizationCustomRoleCreateRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationCustomRoleCreateRequest
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface OrganizationCustomRoleList
 */
export interface OrganizationCustomRoleList {
    /**
     * 
     * @type {Array<OrganizationCustomRole>}
     * @memberof OrganizationCustomRoleList
     */
    'results'?: Array<OrganizationCustomRole>;
}
/**
 * Indicates the permission for a target project and a given environment type, from the lowest to the highest: - `NO_ACCESS` user has no access - `VIEWER` user can access the environment (and applications / containers / databases / variables) - `DEPLOYER` user can deploy the environment (dependent on the required cluster permission `ENV_CREATOR`) - `MANAGER` user can create an environment (and applications / containers / databases / variables) 
 * @export
 * @enum {string}
 */

export const OrganizationCustomRoleProjectPermission = {
    NO_ACCESS: 'NO_ACCESS',
    VIEWER: 'VIEWER',
    DEPLOYER: 'DEPLOYER',
    MANAGER: 'MANAGER'
} as const;

export type OrganizationCustomRoleProjectPermission = typeof OrganizationCustomRoleProjectPermission[keyof typeof OrganizationCustomRoleProjectPermission];


/**
 * 
 * @export
 * @interface OrganizationCustomRoleProjectPermissionsInner
 */
export interface OrganizationCustomRoleProjectPermissionsInner {
    /**
     * 
     * @type {string}
     * @memberof OrganizationCustomRoleProjectPermissionsInner
     */
    'project_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationCustomRoleProjectPermissionsInner
     */
    'project_name'?: string;
    /**
     * If `is_admin` is `true`, the user is: - automatically `MANAGER` for each environment type - allowed to manage project deployment rules - able to delete the project    Note that `permissions` can then be ignored for this project 
     * @type {boolean}
     * @memberof OrganizationCustomRoleProjectPermissionsInner
     */
    'is_admin'?: boolean;
    /**
     * 
     * @type {Array<OrganizationCustomRoleUpdateRequestProjectPermissionsInnerPermissionsInner>}
     * @memberof OrganizationCustomRoleProjectPermissionsInner
     */
    'permissions'?: Array<OrganizationCustomRoleUpdateRequestProjectPermissionsInnerPermissionsInner>;
}
/**
 * 
 * @export
 * @interface OrganizationCustomRoleUpdateRequest
 */
export interface OrganizationCustomRoleUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof OrganizationCustomRoleUpdateRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationCustomRoleUpdateRequest
     */
    'description'?: string;
    /**
     * Should contain an entry for every existing cluster
     * @type {Array<OrganizationCustomRoleUpdateRequestClusterPermissionsInner>}
     * @memberof OrganizationCustomRoleUpdateRequest
     */
    'cluster_permissions': Array<OrganizationCustomRoleUpdateRequestClusterPermissionsInner>;
    /**
     * Should contain an entry for every existing project
     * @type {Array<OrganizationCustomRoleUpdateRequestProjectPermissionsInner>}
     * @memberof OrganizationCustomRoleUpdateRequest
     */
    'project_permissions': Array<OrganizationCustomRoleUpdateRequestProjectPermissionsInner>;
}
/**
 * 
 * @export
 * @interface OrganizationCustomRoleUpdateRequestClusterPermissionsInner
 */
export interface OrganizationCustomRoleUpdateRequestClusterPermissionsInner {
    /**
     * 
     * @type {string}
     * @memberof OrganizationCustomRoleUpdateRequestClusterPermissionsInner
     */
    'cluster_id'?: string;
    /**
     * 
     * @type {OrganizationCustomRoleClusterPermission}
     * @memberof OrganizationCustomRoleUpdateRequestClusterPermissionsInner
     */
    'permission'?: OrganizationCustomRoleClusterPermission;
}


/**
 * 
 * @export
 * @interface OrganizationCustomRoleUpdateRequestProjectPermissionsInner
 */
export interface OrganizationCustomRoleUpdateRequestProjectPermissionsInner {
    /**
     * 
     * @type {string}
     * @memberof OrganizationCustomRoleUpdateRequestProjectPermissionsInner
     */
    'project_id'?: string;
    /**
     * If `is_admin` is `true`, the user is: - automatically `MANAGER` for each environment type - allowed to manage project deployment rules - able to delete the project    Note that `permissions` can then be ignored for this project 
     * @type {boolean}
     * @memberof OrganizationCustomRoleUpdateRequestProjectPermissionsInner
     */
    'is_admin'?: boolean;
    /**
     * Mandatory if `is_admin` is `false`   Should contain an entry for every environment type: - `DEVELOPMENT` - `PREVIEW` - `STAGING` - `PRODUCTION` 
     * @type {Array<OrganizationCustomRoleUpdateRequestProjectPermissionsInnerPermissionsInner>}
     * @memberof OrganizationCustomRoleUpdateRequestProjectPermissionsInner
     */
    'permissions'?: Array<OrganizationCustomRoleUpdateRequestProjectPermissionsInnerPermissionsInner>;
}
/**
 * 
 * @export
 * @interface OrganizationCustomRoleUpdateRequestProjectPermissionsInnerPermissionsInner
 */
export interface OrganizationCustomRoleUpdateRequestProjectPermissionsInnerPermissionsInner {
    /**
     * 
     * @type {EnvironmentModeEnum}
     * @memberof OrganizationCustomRoleUpdateRequestProjectPermissionsInnerPermissionsInner
     */
    'environment_type'?: EnvironmentModeEnum;
    /**
     * 
     * @type {OrganizationCustomRoleProjectPermission}
     * @memberof OrganizationCustomRoleUpdateRequestProjectPermissionsInnerPermissionsInner
     */
    'permission'?: OrganizationCustomRoleProjectPermission;
}


/**
 * 
 * @export
 * @interface OrganizationEditRequest
 */
export interface OrganizationEditRequest {
    /**
     * name is case insensitive
     * @type {string}
     * @memberof OrganizationEditRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationEditRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationEditRequest
     */
    'website_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationEditRequest
     */
    'repository'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationEditRequest
     */
    'logo_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationEditRequest
     */
    'icon_url'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof OrganizationEditRequest
     */
    'admin_emails'?: Array<string> | null;
}
/**
 * Origin of the organization event
 * @export
 * @enum {string}
 */

export const OrganizationEventOrigin = {
    API: 'API',
    CLI: 'CLI',
    CONSOLE: 'CONSOLE',
    GIT: 'GIT',
    QOVERY_INTERNAL: 'QOVERY_INTERNAL',
    TERRAFORM_PROVIDER: 'TERRAFORM_PROVIDER'
} as const;

export type OrganizationEventOrigin = typeof OrganizationEventOrigin[keyof typeof OrganizationEventOrigin];


/**
 * 
 * @export
 * @interface OrganizationEventResponse
 */
export interface OrganizationEventResponse {
    /**
     * 
     * @type {string}
     * @memberof OrganizationEventResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationEventResponse
     */
    'timestamp'?: string;
    /**
     * 
     * @type {OrganizationEventType}
     * @memberof OrganizationEventResponse
     */
    'event_type'?: OrganizationEventType;
    /**
     * 
     * @type {string}
     * @memberof OrganizationEventResponse
     */
    'target_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationEventResponse
     */
    'target_name'?: string;
    /**
     * 
     * @type {OrganizationEventTargetType}
     * @memberof OrganizationEventResponse
     */
    'target_type'?: OrganizationEventTargetType;
    /**
     * 
     * @type {OrganizationEventSubTargetType}
     * @memberof OrganizationEventResponse
     */
    'sub_target_type'?: OrganizationEventSubTargetType | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationEventResponse
     */
    'change'?: string;
    /**
     * 
     * @type {OrganizationEventOrigin}
     * @memberof OrganizationEventResponse
     */
    'origin'?: OrganizationEventOrigin;
    /**
     * 
     * @type {string}
     * @memberof OrganizationEventResponse
     */
    'triggered_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationEventResponse
     */
    'project_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationEventResponse
     */
    'project_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationEventResponse
     */
    'environment_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationEventResponse
     */
    'environment_name'?: string;
}


/**
 * 
 * @export
 * @interface OrganizationEventResponseList
 */
export interface OrganizationEventResponseList {
    /**
     * 
     * @type {OrganizationEventResponseListLinks}
     * @memberof OrganizationEventResponseList
     */
    'links'?: OrganizationEventResponseListLinks;
    /**
     * 
     * @type {Array<OrganizationEventResponse>}
     * @memberof OrganizationEventResponseList
     */
    'events'?: Array<OrganizationEventResponse>;
}
/**
 * 
 * @export
 * @interface OrganizationEventResponseListLinks
 */
export interface OrganizationEventResponseListLinks {
    /**
     * 
     * @type {string}
     * @memberof OrganizationEventResponseListLinks
     */
    'previous'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationEventResponseListLinks
     */
    'next'?: string;
}
/**
 * Type of the organization event
 * @export
 * @enum {string}
 */

export const OrganizationEventSubTargetType = {
    ADVANCED_SETTINGS: 'ADVANCED_SETTINGS',
    API_TOKEN: 'API_TOKEN',
    BILLING_INFO: 'BILLING_INFO',
    CLOUD_PROVIDER_CREDENTIALS: 'CLOUD_PROVIDER_CREDENTIALS',
    CLUSTER_CREDENTIALS: 'CLUSTER_CREDENTIALS',
    CLUSTER_ROUTING_TABLE: 'CLUSTER_ROUTING_TABLE',
    CONFIG: 'CONFIG',
    CREDIT_CARD: 'CREDIT_CARD',
    CREDIT_CODE: 'CREDIT_CODE',
    CUSTOM_DOMAIN: 'CUSTOM_DOMAIN',
    CUSTOM_ROLE: 'CUSTOM_ROLE',
    DEPLOYMENT_RULE: 'DEPLOYMENT_RULE',
    DEPLOYMENT_STAGE: 'DEPLOYMENT_STAGE',
    GITHUB_APP: 'GITHUB_APP',
    GIT_REPOSITORY: 'GIT_REPOSITORY',
    GIT_TOKEN: 'GIT_TOKEN',
    INVITATION: 'INVITATION',
    MEMBER_ROLE: 'MEMBER_ROLE',
    PLAN: 'PLAN',
    SECRET: 'SECRET',
    TERRAFORM: 'TERRAFORM',
    TRANSFER_OWNERSHIP: 'TRANSFER_OWNERSHIP',
    VARIABLE: 'VARIABLE'
} as const;

export type OrganizationEventSubTargetType = typeof OrganizationEventSubTargetType[keyof typeof OrganizationEventSubTargetType];


/**
 * 
 * @export
 * @interface OrganizationEventTargetResponseList
 */
export interface OrganizationEventTargetResponseList {
    /**
     * 
     * @type {Array<ClusterCloudProviderInfoCredentials>}
     * @memberof OrganizationEventTargetResponseList
     */
    'targets'?: Array<ClusterCloudProviderInfoCredentials>;
}
/**
 * Type of the organization event
 * @export
 * @enum {string}
 */

export const OrganizationEventTargetType = {
    APPLICATION: 'APPLICATION',
    CLUSTER: 'CLUSTER',
    CONTAINER: 'CONTAINER',
    CONTAINER_REGISTRY: 'CONTAINER_REGISTRY',
    DATABASE: 'DATABASE',
    ENVIRONMENT: 'ENVIRONMENT',
    JOB: 'JOB',
    HELM: 'HELM',
    MEMBERS_AND_ROLES: 'MEMBERS_AND_ROLES',
    ORGANIZATION: 'ORGANIZATION',
    PROJECT: 'PROJECT',
    WEBHOOK: 'WEBHOOK'
} as const;

export type OrganizationEventTargetType = typeof OrganizationEventTargetType[keyof typeof OrganizationEventTargetType];


/**
 * Type of the organization event
 * @export
 * @enum {string}
 */

export const OrganizationEventType = {
    CREATE: 'CREATE',
    UPDATE: 'UPDATE',
    DELETE: 'DELETE',
    ACCEPT: 'ACCEPT',
    EXPORT: 'EXPORT',
    TRIGGER_DEPLOY: 'TRIGGER_DEPLOY',
    TRIGGER_REDEPLOY: 'TRIGGER_REDEPLOY',
    TRIGGER_STOP: 'TRIGGER_STOP',
    TRIGGER_CANCEL: 'TRIGGER_CANCEL',
    TRIGGER_RESTART: 'TRIGGER_RESTART',
    TRIGGER_DELETE: 'TRIGGER_DELETE',
    SHELL: 'SHELL',
    PORT_FORWARD: 'PORT_FORWARD'
} as const;

export type OrganizationEventType = typeof OrganizationEventType[keyof typeof OrganizationEventType];


/**
 * 
 * @export
 * @interface OrganizationGithubAppConnectRequest
 */
export interface OrganizationGithubAppConnectRequest {
    /**
     * 
     * @type {string}
     * @memberof OrganizationGithubAppConnectRequest
     */
    'installation_id': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationGithubAppConnectRequest
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface OrganizationJobAutoDeployRequest
 */
export interface OrganizationJobAutoDeployRequest {
    /**
     * the job image name to deploy
     * @type {string}
     * @memberof OrganizationJobAutoDeployRequest
     */
    'image_name'?: string;
    /**
     * the new tag to deploy
     * @type {string}
     * @memberof OrganizationJobAutoDeployRequest
     */
    'tag'?: string;
}
/**
 * 
 * @export
 * @interface OrganizationLabelsGroupAssociatedItemsResponseList
 */
export interface OrganizationLabelsGroupAssociatedItemsResponseList {
    /**
     * 
     * @type {Array<OrganizationLabelsGroupAssociatedItemsResponseListResultsInner>}
     * @memberof OrganizationLabelsGroupAssociatedItemsResponseList
     */
    'results'?: Array<OrganizationLabelsGroupAssociatedItemsResponseListResultsInner>;
}
/**
 * 
 * @export
 * @interface OrganizationLabelsGroupAssociatedItemsResponseListResultsInner
 */
export interface OrganizationLabelsGroupAssociatedItemsResponseListResultsInner {
    /**
     * 
     * @type {string}
     * @memberof OrganizationLabelsGroupAssociatedItemsResponseListResultsInner
     */
    'cluster_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationLabelsGroupAssociatedItemsResponseListResultsInner
     */
    'cluster_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationLabelsGroupAssociatedItemsResponseListResultsInner
     */
    'project_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationLabelsGroupAssociatedItemsResponseListResultsInner
     */
    'project_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationLabelsGroupAssociatedItemsResponseListResultsInner
     */
    'environment_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationLabelsGroupAssociatedItemsResponseListResultsInner
     */
    'environment_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationLabelsGroupAssociatedItemsResponseListResultsInner
     */
    'item_id': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationLabelsGroupAssociatedItemsResponseListResultsInner
     */
    'item_name': string;
    /**
     * 
     * @type {LabelsGroupAssociatedItemType}
     * @memberof OrganizationLabelsGroupAssociatedItemsResponseListResultsInner
     */
    'item_type': LabelsGroupAssociatedItemType;
}


/**
 * 
 * @export
 * @interface OrganizationLabelsGroupCreateRequest
 */
export interface OrganizationLabelsGroupCreateRequest {
    /**
     * name of the labels group
     * @type {string}
     * @memberof OrganizationLabelsGroupCreateRequest
     */
    'name': string;
    /**
     * 
     * @type {Array<Label>}
     * @memberof OrganizationLabelsGroupCreateRequest
     */
    'labels': Array<Label>;
}
/**
 * 
 * @export
 * @interface OrganizationLabelsGroupEnrichedResponse
 */
export interface OrganizationLabelsGroupEnrichedResponse {
    /**
     * 
     * @type {string}
     * @memberof OrganizationLabelsGroupEnrichedResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationLabelsGroupEnrichedResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationLabelsGroupEnrichedResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationLabelsGroupEnrichedResponse
     */
    'name': string;
    /**
     * 
     * @type {Array<Label>}
     * @memberof OrganizationLabelsGroupEnrichedResponse
     */
    'labels': Array<Label>;
    /**
     * 
     * @type {number}
     * @memberof OrganizationLabelsGroupEnrichedResponse
     */
    'associated_items_count'?: number;
}
/**
 * 
 * @export
 * @interface OrganizationLabelsGroupResponse
 */
export interface OrganizationLabelsGroupResponse {
    /**
     * 
     * @type {string}
     * @memberof OrganizationLabelsGroupResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationLabelsGroupResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationLabelsGroupResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationLabelsGroupResponse
     */
    'name': string;
    /**
     * 
     * @type {Array<Label>}
     * @memberof OrganizationLabelsGroupResponse
     */
    'labels': Array<Label>;
}
/**
 * 
 * @export
 * @interface OrganizationRequest
 */
export interface OrganizationRequest {
    /**
     * name is case insensitive
     * @type {string}
     * @memberof OrganizationRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {PlanEnum}
     * @memberof OrganizationRequest
     */
    'plan': PlanEnum;
    /**
     * 
     * @type {string}
     * @memberof OrganizationRequest
     */
    'website_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationRequest
     */
    'repository'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationRequest
     */
    'logo_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationRequest
     */
    'icon_url'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof OrganizationRequest
     */
    'admin_emails'?: Array<string> | null;
}


/**
 * 
 * @export
 * @interface OrganizationResponseList
 */
export interface OrganizationResponseList {
    /**
     * 
     * @type {Array<Organization>}
     * @memberof OrganizationResponseList
     */
    'results'?: Array<Organization>;
}
/**
 * 
 * @export
 * @interface OrganizationWebhookCreateRequest
 */
export interface OrganizationWebhookCreateRequest {
    /**
     * 
     * @type {OrganizationWebhookKindEnum}
     * @memberof OrganizationWebhookCreateRequest
     */
    'kind': OrganizationWebhookKindEnum;
    /**
     * Set the public HTTP or HTTPS endpoint that will receive the specified events. The target URL must starts with `http://` or `https://` 
     * @type {string}
     * @memberof OrganizationWebhookCreateRequest
     */
    'target_url': string;
    /**
     * Make sure you receive a payload to sign the Qovery request with your secret. Qovery will add a HTTP header `Qovery-Signature: <Your Secret>` to every webhook requests sent to your target URL. 
     * @type {string}
     * @memberof OrganizationWebhookCreateRequest
     */
    'target_secret'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationWebhookCreateRequest
     */
    'description'?: string;
    /**
     * Turn on or off your endpoint.
     * @type {boolean}
     * @memberof OrganizationWebhookCreateRequest
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {Array<OrganizationWebhookEventEnum>}
     * @memberof OrganizationWebhookCreateRequest
     */
    'events': Array<OrganizationWebhookEventEnum>;
    /**
     * Specify the project names you want to filter to.  This webhook will be triggered only if the event is coming from the specified Project IDs. Notes: 1. Wildcard is accepted E.g. `product*`. 2. Name is case insensitive. 
     * @type {Array<string>}
     * @memberof OrganizationWebhookCreateRequest
     */
    'project_names_filter'?: Array<string>;
    /**
     * Specify the environment modes you want to filter to. This webhook will be triggered only if the event is coming from an environment with the specified mode. 
     * @type {Array<EnvironmentModeEnum>}
     * @memberof OrganizationWebhookCreateRequest
     */
    'environment_types_filter'?: Array<EnvironmentModeEnum>;
}


/**
 * 
 * @export
 * @interface OrganizationWebhookCreateResponse
 */
export interface OrganizationWebhookCreateResponse {
    /**
     * 
     * @type {string}
     * @memberof OrganizationWebhookCreateResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationWebhookCreateResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationWebhookCreateResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {OrganizationWebhookKindEnum}
     * @memberof OrganizationWebhookCreateResponse
     */
    'kind'?: OrganizationWebhookKindEnum;
    /**
     * Set the public HTTP or HTTPS endpoint that will receive the specified events. The target URL must starts with `http://` or `https://` 
     * @type {string}
     * @memberof OrganizationWebhookCreateResponse
     */
    'target_url'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationWebhookCreateResponse
     */
    'target_secret_set'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OrganizationWebhookCreateResponse
     */
    'description'?: string;
    /**
     * Turn on or off your endpoint.
     * @type {boolean}
     * @memberof OrganizationWebhookCreateResponse
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {Array<OrganizationWebhookEventEnum>}
     * @memberof OrganizationWebhookCreateResponse
     */
    'events'?: Array<OrganizationWebhookEventEnum>;
    /**
     * Specify the project names you want to filter to.  This webhook will be triggered only if the event is coming from the specified Project IDs. Notes: 1. Wildcard is accepted E.g. `product*`. 2. Name is case insensitive. 
     * @type {Array<string>}
     * @memberof OrganizationWebhookCreateResponse
     */
    'project_names_filter'?: Array<string>;
    /**
     * Specify the environment modes you want to filter to. This webhook will be triggered only if the event is coming from an environment with the specified mode. 
     * @type {Array<EnvironmentModeEnum>}
     * @memberof OrganizationWebhookCreateResponse
     */
    'environment_types_filter'?: Array<EnvironmentModeEnum>;
}


/**
 * Events to subscribe to and send to the `target_url`. - `DEPLOYMENT_STARTED` send an event when a deployment is started and going to be executed - `DEPLOYMENT_CANCELLED` send an event when a deployment is cancelled - `DEPLOYMENT_FAILURE` send an event when a deployment failed - `DEPLOYMENT_SUCCESSFUL` send an event when a deployment is successful 
 * @export
 * @enum {string}
 */

export const OrganizationWebhookEventEnum = {
    STARTED: 'DEPLOYMENT_STARTED',
    CANCELLED: 'DEPLOYMENT_CANCELLED',
    FAILURE: 'DEPLOYMENT_FAILURE',
    SUCCESSFUL: 'DEPLOYMENT_SUCCESSFUL'
} as const;

export type OrganizationWebhookEventEnum = typeof OrganizationWebhookEventEnum[keyof typeof OrganizationWebhookEventEnum];


/**
 * Define the type of the webhook. `SLACK` is a special webhook type to push notifications directly to slack. The `target_url` must be a Slack compatible endpoint.
 * @export
 * @enum {string}
 */

export const OrganizationWebhookKindEnum = {
    STANDARD: 'STANDARD',
    SLACK: 'SLACK'
} as const;

export type OrganizationWebhookKindEnum = typeof OrganizationWebhookKindEnum[keyof typeof OrganizationWebhookKindEnum];


/**
 * 
 * @export
 * @interface OrganizationWebhookResponse
 */
export interface OrganizationWebhookResponse {
    /**
     * 
     * @type {string}
     * @memberof OrganizationWebhookResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationWebhookResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationWebhookResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {OrganizationWebhookKindEnum}
     * @memberof OrganizationWebhookResponse
     */
    'kind'?: OrganizationWebhookKindEnum;
    /**
     * Set the public HTTP or HTTPS endpoint that will receive the specified events. The target URL must starts with `http://` or `https://` 
     * @type {string}
     * @memberof OrganizationWebhookResponse
     */
    'target_url'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationWebhookResponse
     */
    'target_secret_set'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OrganizationWebhookResponse
     */
    'description'?: string;
    /**
     * Turn on or off your endpoint.
     * @type {boolean}
     * @memberof OrganizationWebhookResponse
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {Array<OrganizationWebhookEventEnum>}
     * @memberof OrganizationWebhookResponse
     */
    'events'?: Array<OrganizationWebhookEventEnum>;
    /**
     * Specify the project names you want to filter to.  This webhook will be triggered only if the event is coming from the specified Project IDs. Notes: 1. Wildcard is accepted E.g. `product*`. 2. Name is case insensitive. 
     * @type {Array<string>}
     * @memberof OrganizationWebhookResponse
     */
    'project_names_filter'?: Array<string>;
    /**
     * Specify the environment modes you want to filter to. This webhook will be triggered only if the event is coming from an environment with the specified mode. 
     * @type {Array<EnvironmentModeEnum>}
     * @memberof OrganizationWebhookResponse
     */
    'environment_types_filter'?: Array<EnvironmentModeEnum>;
}


/**
 * 
 * @export
 * @interface OrganizationWebhookResponseList
 */
export interface OrganizationWebhookResponseList {
    /**
     * 
     * @type {Array<OrganizationWebhookResponse>}
     * @memberof OrganizationWebhookResponseList
     */
    'results'?: Array<OrganizationWebhookResponse>;
}
/**
 * 
 * @export
 * @interface PaginationData
 */
export interface PaginationData {
    /**
     * 
     * @type {number}
     * @memberof PaginationData
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof PaginationData
     */
    'page_size': number;
}
/**
 * BUSINESS & PROFESSIONAL are deprecated
 * @export
 * @enum {string}
 */

export const PlanEnum = {
    FREE: 'FREE',
    TEAM: 'TEAM',
    TEAM_YEARLY: 'TEAM_YEARLY',
    ENTERPRISE: 'ENTERPRISE',
    ENTERPRISE_YEARLY: 'ENTERPRISE_YEARLY',
    PROFESSIONAL: 'PROFESSIONAL',
    BUSINESS: 'BUSINESS'
} as const;

export type PlanEnum = typeof PlanEnum[keyof typeof PlanEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const PortProtocolEnum = {
    HTTP: 'HTTP',
    GRPC: 'GRPC',
    TCP: 'TCP',
    UDP: 'UDP'
} as const;

export type PortProtocolEnum = typeof PortProtocolEnum[keyof typeof PortProtocolEnum];


/**
 * 
 * @export
 * @interface Probe
 */
export interface Probe {
    /**
     * 
     * @type {ProbeType}
     * @memberof Probe
     */
    'type'?: ProbeType;
    /**
     * 
     * @type {number}
     * @memberof Probe
     */
    'initial_delay_seconds'?: number;
    /**
     * 
     * @type {number}
     * @memberof Probe
     */
    'period_seconds'?: number;
    /**
     * 
     * @type {number}
     * @memberof Probe
     */
    'timeout_seconds'?: number;
    /**
     * 
     * @type {number}
     * @memberof Probe
     */
    'success_threshold'?: number;
    /**
     * 
     * @type {number}
     * @memberof Probe
     */
    'failure_threshold'?: number;
}
/**
 * 
 * @export
 * @interface ProbeType
 */
export interface ProbeType {
    /**
     * 
     * @type {ProbeTypeTcp}
     * @memberof ProbeType
     */
    'tcp'?: ProbeTypeTcp | null;
    /**
     * 
     * @type {ProbeTypeHttp}
     * @memberof ProbeType
     */
    'http'?: ProbeTypeHttp | null;
    /**
     * 
     * @type {ProbeTypeExec}
     * @memberof ProbeType
     */
    'exec'?: ProbeTypeExec | null;
    /**
     * 
     * @type {ProbeTypeGrpc}
     * @memberof ProbeType
     */
    'grpc'?: ProbeTypeGrpc | null;
}
/**
 * 
 * @export
 * @interface ProbeTypeExec
 */
export interface ProbeTypeExec {
    /**
     * 
     * @type {Array<string>}
     * @memberof ProbeTypeExec
     */
    'command'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ProbeTypeGrpc
 */
export interface ProbeTypeGrpc {
    /**
     * 
     * @type {string}
     * @memberof ProbeTypeGrpc
     */
    'service'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ProbeTypeGrpc
     */
    'port'?: number;
}
/**
 * 
 * @export
 * @interface ProbeTypeHttp
 */
export interface ProbeTypeHttp {
    /**
     * 
     * @type {string}
     * @memberof ProbeTypeHttp
     */
    'path'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProbeTypeHttp
     */
    'scheme'?: string;
    /**
     * 
     * @type {number}
     * @memberof ProbeTypeHttp
     */
    'port'?: number;
}
/**
 * 
 * @export
 * @interface ProbeTypeTcp
 */
export interface ProbeTypeTcp {
    /**
     * 
     * @type {number}
     * @memberof ProbeTypeTcp
     */
    'port'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProbeTypeTcp
     */
    'host'?: string | null;
}
/**
 * 
 * @export
 * @interface Project
 */
export interface Project {
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'description'?: string;
    /**
     * 
     * @type {ReferenceObject}
     * @memberof Project
     */
    'organization': ReferenceObject;
}
/**
 * 
 * @export
 * @interface ProjectCurrentCost
 */
export interface ProjectCurrentCost {
    /**
     * 
     * @type {string}
     * @memberof ProjectCurrentCost
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectCurrentCost
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof ProjectCurrentCost
     */
    'consumed_time_in_seconds': number;
    /**
     * 
     * @type {Cost}
     * @memberof ProjectCurrentCost
     */
    'cost': Cost;
    /**
     * 
     * @type {Array<GenericObjectCurrentCost>}
     * @memberof ProjectCurrentCost
     */
    'environments'?: Array<GenericObjectCurrentCost>;
}
/**
 * 
 * @export
 * @interface ProjectCurrentCostResponseList
 */
export interface ProjectCurrentCostResponseList {
    /**
     * 
     * @type {Array<ProjectCurrentCost>}
     * @memberof ProjectCurrentCostResponseList
     */
    'projects'?: Array<ProjectCurrentCost>;
}
/**
 * 
 * @export
 * @interface ProjectDeploymentRule
 */
export interface ProjectDeploymentRule {
    /**
     * 
     * @type {string}
     * @memberof ProjectDeploymentRule
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectDeploymentRule
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectDeploymentRule
     */
    'updated_at'?: string;
    /**
     * name is case insensitive
     * @type {string}
     * @memberof ProjectDeploymentRule
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectDeploymentRule
     */
    'description'?: string | null;
    /**
     * 
     * @type {EnvironmentModeEnum}
     * @memberof ProjectDeploymentRule
     */
    'mode': EnvironmentModeEnum;
    /**
     * 
     * @type {string}
     * @memberof ProjectDeploymentRule
     */
    'cluster_id': string;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectDeploymentRule
     */
    'auto_stop'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ProjectDeploymentRule
     */
    'timezone': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectDeploymentRule
     */
    'start_time': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectDeploymentRule
     */
    'stop_time': string;
    /**
     * 
     * @type {Array<WeekdayEnum>}
     * @memberof ProjectDeploymentRule
     */
    'weekdays': Array<WeekdayEnum>;
    /**
     * wildcard pattern composed of \'?\' and/or \'*\' used to target new created environments
     * @type {string}
     * @memberof ProjectDeploymentRule
     */
    'wildcard': string;
    /**
     * used to select the first deployment rule to match new created environments
     * @type {number}
     * @memberof ProjectDeploymentRule
     */
    'priority_index'?: number;
}


/**
 * 
 * @export
 * @interface ProjectDeploymentRuleRequest
 */
export interface ProjectDeploymentRuleRequest {
    /**
     * name is case insensitive
     * @type {string}
     * @memberof ProjectDeploymentRuleRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectDeploymentRuleRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {EnvironmentModeEnum}
     * @memberof ProjectDeploymentRuleRequest
     */
    'mode': EnvironmentModeEnum;
    /**
     * 
     * @type {string}
     * @memberof ProjectDeploymentRuleRequest
     */
    'cluster_id': string;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectDeploymentRuleRequest
     */
    'auto_stop'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ProjectDeploymentRuleRequest
     */
    'timezone': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectDeploymentRuleRequest
     */
    'start_time': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectDeploymentRuleRequest
     */
    'stop_time': string;
    /**
     * 
     * @type {Array<WeekdayEnum>}
     * @memberof ProjectDeploymentRuleRequest
     */
    'weekdays': Array<WeekdayEnum>;
    /**
     * wildcard pattern composed of \'?\' and/or \'*\' used to target new created environments
     * @type {string}
     * @memberof ProjectDeploymentRuleRequest
     */
    'wildcard': string;
}


/**
 * 
 * @export
 * @interface ProjectDeploymentRuleResponseList
 */
export interface ProjectDeploymentRuleResponseList {
    /**
     * 
     * @type {Array<ProjectDeploymentRule>}
     * @memberof ProjectDeploymentRuleResponseList
     */
    'results'?: Array<ProjectDeploymentRule>;
}
/**
 * 
 * @export
 * @interface ProjectDeploymentRulesPriorityOrderRequest
 */
export interface ProjectDeploymentRulesPriorityOrderRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof ProjectDeploymentRulesPriorityOrderRequest
     */
    'project_deployment_rule_ids_in_order'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ProjectRequest
 */
export interface ProjectRequest {
    /**
     * name is case insensitive
     * @type {string}
     * @memberof ProjectRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectRequest
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface ProjectResponseList
 */
export interface ProjectResponseList {
    /**
     * 
     * @type {Array<Project>}
     * @memberof ProjectResponseList
     */
    'results'?: Array<Project>;
}
/**
 * 
 * @export
 * @interface ProjectStats
 */
export interface ProjectStats {
    /**
     * 
     * @type {string}
     * @memberof ProjectStats
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof ProjectStats
     */
    'service_total_number'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProjectStats
     */
    'environment_total_number'?: number;
}
/**
 * 
 * @export
 * @interface ProjectStatsResponseList
 */
export interface ProjectStatsResponseList {
    /**
     * 
     * @type {Array<ProjectStats>}
     * @memberof ProjectStatsResponseList
     */
    'results'?: Array<ProjectStats>;
}
/**
 * 
 * @export
 * @interface RebootServicesRequest
 */
export interface RebootServicesRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof RebootServicesRequest
     */
    'application_ids'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof RebootServicesRequest
     */
    'database_ids'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof RebootServicesRequest
     */
    'container_ids'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ReferenceObject
 */
export interface ReferenceObject {
    /**
     * 
     * @type {string}
     * @memberof ReferenceObject
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface ReferenceObjectStatus
 */
export interface ReferenceObjectStatus {
    /**
     * 
     * @type {string}
     * @memberof ReferenceObjectStatus
     */
    'id': string;
    /**
     * 
     * @type {StateEnum}
     * @memberof ReferenceObjectStatus
     */
    'state': StateEnum;
    /**
     * 
     * @type {ServiceDeploymentStatusEnum}
     * @memberof ReferenceObjectStatus
     */
    'service_deployment_status': ServiceDeploymentStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ReferenceObjectStatus
     */
    'last_deployment_date'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ReferenceObjectStatus
     */
    'is_part_last_deployment'?: boolean;
    /**
     * 
     * @type {ServiceStepMetrics}
     * @memberof ReferenceObjectStatus
     */
    'steps'?: ServiceStepMetrics;
}


/**
 * 
 * @export
 * @interface ReferenceObjectStatusResponseList
 */
export interface ReferenceObjectStatusResponseList {
    /**
     * 
     * @type {Array<ReferenceObjectStatus>}
     * @memberof ReferenceObjectStatusResponseList
     */
    'results'?: Array<ReferenceObjectStatus>;
}
/**
 * 
 * @export
 * @interface Referral
 */
export interface Referral {
    /**
     * 
     * @type {number}
     * @memberof Referral
     */
    'total_invited'?: number;
    /**
     * 
     * @type {string}
     * @memberof Referral
     */
    'invitation_link'?: string;
}
/**
 * Mirroring mode when deploying a service from a container registry - Cluster: This is not available on Scaleway. Images within the mirroring registry are organized by \"Qovery cluster\", meaning that the application deployed on the same cluster are all mirrored on the same repository. - Service: Images within the mirroring registry are organized by \"Qovery service\", each service has its own repository 
 * @export
 * @enum {string}
 */

export const RegistryMirroringModeEnum = {
    CLUSTER: 'Cluster',
    SERVICE: 'Service'
} as const;

export type RegistryMirroringModeEnum = typeof RegistryMirroringModeEnum[keyof typeof RegistryMirroringModeEnum];


/**
 * 
 * @export
 * @interface RewardClaim
 */
export interface RewardClaim {
    /**
     * 
     * @type {string}
     * @memberof RewardClaim
     */
    'type'?: RewardClaimTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof RewardClaim
     */
    'code'?: string;
}

export const RewardClaimTypeEnum = {
    INVITATION: 'INVITATION'
} as const;

export type RewardClaimTypeEnum = typeof RewardClaimTypeEnum[keyof typeof RewardClaimTypeEnum];

/**
 * 
 * @export
 * @interface ScalewayCredentialsRequest
 */
export interface ScalewayCredentialsRequest {
    /**
     * 
     * @type {string}
     * @memberof ScalewayCredentialsRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ScalewayCredentialsRequest
     */
    'scaleway_access_key': string;
    /**
     * 
     * @type {string}
     * @memberof ScalewayCredentialsRequest
     */
    'scaleway_secret_key': string;
    /**
     * 
     * @type {string}
     * @memberof ScalewayCredentialsRequest
     */
    'scaleway_project_id': string;
    /**
     * 
     * @type {string}
     * @memberof ScalewayCredentialsRequest
     */
    'scaleway_organization_id': string;
}
/**
 * 
 * @export
 * @interface Secret
 */
export interface Secret {
    /**
     * 
     * @type {string}
     * @memberof Secret
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Secret
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Secret
     */
    'updated_at'?: string;
    /**
     * key is case sensitive
     * @type {string}
     * @memberof Secret
     */
    'key': string;
    /**
     * 
     * @type {SecretOverride}
     * @memberof Secret
     */
    'overridden_secret'?: SecretOverride;
    /**
     * 
     * @type {SecretAlias}
     * @memberof Secret
     */
    'aliased_secret'?: SecretAlias;
    /**
     * 
     * @type {APIVariableScopeEnum}
     * @memberof Secret
     */
    'scope': APIVariableScopeEnum;
    /**
     * 
     * @type {APIVariableTypeEnum}
     * @memberof Secret
     */
    'variable_type'?: APIVariableTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Secret
     */
    'service_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Secret
     */
    'service_name'?: string;
    /**
     * 
     * @type {LinkedServiceTypeEnum}
     * @memberof Secret
     */
    'service_type'?: LinkedServiceTypeEnum;
    /**
     * Entity that created/own the variable (i.e: Qovery, Doppler)
     * @type {string}
     * @memberof Secret
     */
    'owned_by'?: string;
    /**
     * optional variable description (255 characters maximum)
     * @type {string}
     * @memberof Secret
     */
    'description'?: string | null;
}


/**
 * 
 * @export
 * @interface SecretAlias
 */
export interface SecretAlias {
    /**
     * 
     * @type {string}
     * @memberof SecretAlias
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SecretAlias
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof SecretAlias
     */
    'mount_path': string;
    /**
     * 
     * @type {APIVariableScopeEnum}
     * @memberof SecretAlias
     */
    'scope': APIVariableScopeEnum;
    /**
     * 
     * @type {APIVariableTypeEnum}
     * @memberof SecretAlias
     */
    'variable_type': APIVariableTypeEnum;
    /**
     * optional variable description (255 characters maximum)
     * @type {string}
     * @memberof SecretAlias
     */
    'description'?: string | null;
}


/**
 * 
 * @export
 * @interface SecretEditRequest
 */
export interface SecretEditRequest {
    /**
     * 
     * @type {string}
     * @memberof SecretEditRequest
     */
    'value'?: string;
    /**
     * 
     * @type {string}
     * @memberof SecretEditRequest
     */
    'key': string;
    /**
     * optional variable description (255 characters maximum)
     * @type {string}
     * @memberof SecretEditRequest
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface SecretOverride
 */
export interface SecretOverride {
    /**
     * 
     * @type {string}
     * @memberof SecretOverride
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SecretOverride
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof SecretOverride
     */
    'mount_path': string;
    /**
     * 
     * @type {APIVariableScopeEnum}
     * @memberof SecretOverride
     */
    'scope': APIVariableScopeEnum;
    /**
     * 
     * @type {APIVariableTypeEnum}
     * @memberof SecretOverride
     */
    'variable_type': APIVariableTypeEnum;
    /**
     * optional variable description (255 characters maximum)
     * @type {string}
     * @memberof SecretOverride
     */
    'description'?: string | null;
}


/**
 * 
 * @export
 * @interface SecretRequest
 */
export interface SecretRequest {
    /**
     * key is case sensitive
     * @type {string}
     * @memberof SecretRequest
     */
    'key': string;
    /**
     * value of the secret. Clear value will never be returned
     * @type {string}
     * @memberof SecretRequest
     */
    'value'?: string;
    /**
     * should be set for file only. variable mount path make secret a file (where file should be mounted).
     * @type {string}
     * @memberof SecretRequest
     */
    'mount_path'?: string | null;
    /**
     * optional variable description (255 character maximum)
     * @type {string}
     * @memberof SecretRequest
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface SecretResponseList
 */
export interface SecretResponseList {
    /**
     * 
     * @type {Array<Secret>}
     * @memberof SecretResponseList
     */
    'results'?: Array<Secret>;
}
/**
 * 
 * @export
 * @interface Service
 */
export interface Service {
    /**
     * uuid of the associated service (application, database, job, gateway...)
     * @type {string}
     * @memberof Service
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Service
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Service
     */
    'updated_at'?: string;
    /**
     * 
     * @type {ServiceTypeEnum}
     * @memberof Service
     */
    'type'?: ServiceTypeEnum;
    /**
     * name of the service
     * @type {string}
     * @memberof Service
     */
    'name'?: string;
    /**
     * Git commit ID corresponding to the deployed version of the application
     * @type {string}
     * @memberof Service
     */
    'deployed_commit_id'?: string;
    /**
     * uuid of the user that made the last update
     * @type {string}
     * @memberof Service
     */
    'last_updated_by'?: string;
    /**
     * global overview of resources consumption of the service
     * @type {number}
     * @memberof Service
     */
    'consumed_resources_in_percent'?: number;
    /**
     * describes the typology of service (container, postgresl, redis...)
     * @type {string}
     * @memberof Service
     */
    'service_typology'?: string;
    /**
     * for databases this field exposes the database version
     * @type {string}
     * @memberof Service
     */
    'service_version'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Service
     */
    'to_update'?: boolean;
}


/**
 * 
 * @export
 * @interface ServiceAnnotationRequest
 */
export interface ServiceAnnotationRequest {
    /**
     * 
     * @type {string}
     * @memberof ServiceAnnotationRequest
     */
    'id': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ServiceDeploymentStatusEnum = {
    NEVER_DEPLOYED: 'NEVER_DEPLOYED',
    OUT_OF_DATE: 'OUT_OF_DATE',
    UP_TO_DATE: 'UP_TO_DATE'
} as const;

export type ServiceDeploymentStatusEnum = typeof ServiceDeploymentStatusEnum[keyof typeof ServiceDeploymentStatusEnum];


/**
 * 
 * @export
 * @interface ServiceLabelRequest
 */
export interface ServiceLabelRequest {
    /**
     * 
     * @type {string}
     * @memberof ServiceLabelRequest
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface ServicePort
 */
export interface ServicePort {
    /**
     * 
     * @type {string}
     * @memberof ServicePort
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ServicePort
     */
    'name'?: string;
    /**
     * The listening port of your service.
     * @type {number}
     * @memberof ServicePort
     */
    'internal_port': number;
    /**
     * The exposed port for your service. This is optional. If not set a default port will be used.
     * @type {number}
     * @memberof ServicePort
     */
    'external_port'?: number;
    /**
     * Expose the port to the world
     * @type {boolean}
     * @memberof ServicePort
     */
    'publicly_accessible': boolean;
    /**
     * is the default port to use for domain
     * @type {boolean}
     * @memberof ServicePort
     */
    'is_default'?: boolean;
    /**
     * 
     * @type {PortProtocolEnum}
     * @memberof ServicePort
     */
    'protocol': PortProtocolEnum;
}


/**
 * 
 * @export
 * @interface ServicePortRequest
 */
export interface ServicePortRequest {
    /**
     * 
     * @type {Array<ServicePortRequestPortsInner>}
     * @memberof ServicePortRequest
     */
    'ports'?: Array<ServicePortRequestPortsInner>;
}
/**
 * 
 * @export
 * @interface ServicePortRequestPortsInner
 */
export interface ServicePortRequestPortsInner {
    /**
     * 
     * @type {string}
     * @memberof ServicePortRequestPortsInner
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServicePortRequestPortsInner
     */
    'name'?: string;
    /**
     * The listening port of your service.
     * @type {number}
     * @memberof ServicePortRequestPortsInner
     */
    'internal_port': number;
    /**
     * The exposed port for your service. This is optional. If not set a default port will be used.
     * @type {number}
     * @memberof ServicePortRequestPortsInner
     */
    'external_port'?: number;
    /**
     * Expose the port to the world
     * @type {boolean}
     * @memberof ServicePortRequestPortsInner
     */
    'publicly_accessible': boolean;
    /**
     * is the default port to use for domain
     * @type {boolean}
     * @memberof ServicePortRequestPortsInner
     */
    'is_default'?: boolean;
    /**
     * 
     * @type {PortProtocolEnum}
     * @memberof ServicePortRequestPortsInner
     */
    'protocol'?: PortProtocolEnum;
}


/**
 * 
 * @export
 * @interface ServiceStepMetric
 */
export interface ServiceStepMetric {
    /**
     * 
     * @type {ServiceStepMetricNameEnum}
     * @memberof ServiceStepMetric
     */
    'step_name'?: ServiceStepMetricNameEnum;
    /**
     * 
     * @type {StepMetricStatusEnum}
     * @memberof ServiceStepMetric
     */
    'status'?: StepMetricStatusEnum;
    /**
     * The duration of the step in seconds.
     * @type {number}
     * @memberof ServiceStepMetric
     */
    'duration_sec'?: number;
}


/**
 * The name of the deployment step at the service level: - REGISTRY_CREATE_REPOSITORY: The step to create the repository in the registry. - GIT_CLONE: The step to clone the source code repository.  - BUILD_QUEUEING: The queuing time preceding the actual building step. - BUILD: The step to build the source code. - DEPLOYMENT_QUEUEING: The queuing time preceding the actual deployment step. - DEPLOYMENT: The step to deploy the service.  - ROUTER_DEPLOYMENT: The step to deploy the router.  - MIRROR_IMAGE: The step to mirror the image to the private registry. 
 * @export
 * @enum {string}
 */

export const ServiceStepMetricNameEnum = {
    REGISTRY_CREATE_REPOSITORY: 'REGISTRY_CREATE_REPOSITORY',
    GIT_CLONE: 'GIT_CLONE',
    BUILD_QUEUEING: 'BUILD_QUEUEING',
    BUILD: 'BUILD',
    DEPLOYMENT_QUEUEING: 'DEPLOYMENT_QUEUEING',
    DEPLOYMENT: 'DEPLOYMENT',
    ROUTER_DEPLOYMENT: 'ROUTER_DEPLOYMENT',
    MIRROR_IMAGE: 'MIRROR_IMAGE'
} as const;

export type ServiceStepMetricNameEnum = typeof ServiceStepMetricNameEnum[keyof typeof ServiceStepMetricNameEnum];


/**
 * 
 * @export
 * @interface ServiceStepMetrics
 */
export interface ServiceStepMetrics {
    /**
     * The total duration in seconds of the service deployment or null if the deployment is not completed.
     * @type {number}
     * @memberof ServiceStepMetrics
     */
    'total_duration_sec'?: number | null;
    /**
     * The total duration in seconds of the service deployment without queuing steps.
     * @type {number}
     * @memberof ServiceStepMetrics
     */
    'total_computing_duration_sec'?: number;
    /**
     * A list of metrics for deployment steps of the service.
     * @type {Array<ServiceStepMetric>}
     * @memberof ServiceStepMetrics
     */
    'details'?: Array<ServiceStepMetric>;
}
/**
 * 
 * @export
 * @interface ServiceStorage
 */
export interface ServiceStorage {
    /**
     * 
     * @type {Array<ServiceStorageStorageInner>}
     * @memberof ServiceStorage
     */
    'storage'?: Array<ServiceStorageStorageInner>;
}
/**
 * 
 * @export
 * @interface ServiceStorageRequest
 */
export interface ServiceStorageRequest {
    /**
     * 
     * @type {Array<ServiceStorageRequestStorageInner>}
     * @memberof ServiceStorageRequest
     */
    'storage'?: Array<ServiceStorageRequestStorageInner>;
}
/**
 * 
 * @export
 * @interface ServiceStorageRequestStorageInner
 */
export interface ServiceStorageRequestStorageInner {
    /**
     * 
     * @type {string}
     * @memberof ServiceStorageRequestStorageInner
     */
    'id'?: string;
    /**
     * 
     * @type {StorageTypeEnum}
     * @memberof ServiceStorageRequestStorageInner
     */
    'type': StorageTypeEnum;
    /**
     * unit is GB Minimum size is 4 GB 
     * @type {number}
     * @memberof ServiceStorageRequestStorageInner
     */
    'size': number;
    /**
     * 
     * @type {string}
     * @memberof ServiceStorageRequestStorageInner
     */
    'mount_point': string;
}


/**
 * 
 * @export
 * @interface ServiceStorageStorageInner
 */
export interface ServiceStorageStorageInner {
    /**
     * 
     * @type {string}
     * @memberof ServiceStorageStorageInner
     */
    'id': string;
    /**
     * 
     * @type {StorageTypeEnum}
     * @memberof ServiceStorageStorageInner
     */
    'type': StorageTypeEnum;
    /**
     * unit is GB
     * @type {number}
     * @memberof ServiceStorageStorageInner
     */
    'size': number;
    /**
     * 
     * @type {string}
     * @memberof ServiceStorageStorageInner
     */
    'mount_point': string;
}


/**
 * 
 * @export
 * @interface ServiceTotalNumber
 */
export interface ServiceTotalNumber {
    /**
     * 
     * @type {number}
     * @memberof ServiceTotalNumber
     */
    'service_total_number'?: number;
}
/**
 * type of the service (application, database, job, gateway...)
 * @export
 * @enum {string}
 */

export const ServiceTypeEnum = {
    APPLICATION: 'APPLICATION',
    DATABASE: 'DATABASE'
} as const;

export type ServiceTypeEnum = typeof ServiceTypeEnum[keyof typeof ServiceTypeEnum];


/**
 * type of the service
 * @export
 * @enum {string}
 */

export const ServiceTypeForVariableEnum = {
    APPLICATION: 'APPLICATION',
    CONTAINER: 'CONTAINER',
    JOB: 'JOB',
    HELM: 'HELM'
} as const;

export type ServiceTypeForVariableEnum = typeof ServiceTypeForVariableEnum[keyof typeof ServiceTypeForVariableEnum];


/**
 * 
 * @export
 * @interface SignUp
 */
export interface SignUp {
    /**
     * 
     * @type {string}
     * @memberof SignUp
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SignUp
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof SignUp
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignUp
     */
    'first_name': string;
    /**
     * 
     * @type {string}
     * @memberof SignUp
     */
    'last_name': string;
    /**
     * 
     * @type {string}
     * @memberof SignUp
     */
    'user_email': string;
    /**
     * 
     * @type {TypeOfUseEnum}
     * @memberof SignUp
     */
    'type_of_use': TypeOfUseEnum;
    /**
     * 
     * @type {string}
     * @memberof SignUp
     */
    'qovery_usage': string;
    /**
     * 
     * @type {string}
     * @memberof SignUp
     */
    'company_name'?: string | null;
    /**
     * 
     * @type {CompanySizeEnum}
     * @memberof SignUp
     */
    'company_size'?: CompanySizeEnum;
    /**
     * 
     * @type {string}
     * @memberof SignUp
     */
    'user_role'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SignUp
     */
    'qovery_usage_other'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SignUp
     */
    'user_questions'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SignUp
     */
    'current_step'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof SignUp
     */
    'dx_auth'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof SignUp
     */
    'infrastructure_hosting'?: string | null;
}


/**
 * 
 * @export
 * @interface SignUpRequest
 */
export interface SignUpRequest {
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    'first_name': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    'last_name': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    'user_email': string;
    /**
     * 
     * @type {TypeOfUseEnum}
     * @memberof SignUpRequest
     */
    'type_of_use': TypeOfUseEnum;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    'qovery_usage': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    'company_name'?: string | null;
    /**
     * 
     * @type {CompanySizeEnum}
     * @memberof SignUpRequest
     */
    'company_size'?: CompanySizeEnum;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    'user_role'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    'qovery_usage_other'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    'user_questions'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    'current_step'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof SignUpRequest
     */
    'dx_auth'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    'infrastructure_hosting'?: string | null;
}


/**
 * 
 * @export
 * @interface Stage
 */
export interface Stage {
    /**
     * 
     * @type {string}
     * @memberof Stage
     */
    'id': string;
    /**
     * stage name
     * @type {string}
     * @memberof Stage
     */
    'name': string;
    /**
     * 
     * @type {StageStepMetrics}
     * @memberof Stage
     */
    'steps'?: StageStepMetrics;
}
/**
 * 
 * @export
 * @interface StageStepMetric
 */
export interface StageStepMetric {
    /**
     * 
     * @type {StageStepMetricNameEnum}
     * @memberof StageStepMetric
     */
    'step_name'?: StageStepMetricNameEnum;
    /**
     * 
     * @type {StepMetricStatusEnum}
     * @memberof StageStepMetric
     */
    'status'?: StepMetricStatusEnum;
    /**
     * The duration of the step in seconds.
     * @type {number}
     * @memberof StageStepMetric
     */
    'duration_sec'?: number;
}


/**
 * The name of the deployment step at the stage level: - QUEUEING: The step preceding the actual stage deployment step. - PROVISION_BUILDER: The step to provision builders before the actual build. 
 * @export
 * @enum {string}
 */

export const StageStepMetricNameEnum = {
    QUEUEING: 'QUEUEING',
    PROVISION_BUILDER: 'PROVISION_BUILDER'
} as const;

export type StageStepMetricNameEnum = typeof StageStepMetricNameEnum[keyof typeof StageStepMetricNameEnum];


/**
 * 
 * @export
 * @interface StageStepMetrics
 */
export interface StageStepMetrics {
    /**
     * The total duration in seconds of the stage deployment or null if the deployment is not completed
     * @type {number}
     * @memberof StageStepMetrics
     */
    'total_duration_sec'?: number | null;
    /**
     * A list of metrics for deployment steps of the stage.
     * @type {Array<StageStepMetric>}
     * @memberof StageStepMetrics
     */
    'details'?: Array<StageStepMetric>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const StateEnum = {
    BUILDING: 'BUILDING',
    BUILD_ERROR: 'BUILD_ERROR',
    CANCELED: 'CANCELED',
    CANCELING: 'CANCELING',
    DELETED: 'DELETED',
    DELETE_ERROR: 'DELETE_ERROR',
    DELETE_QUEUED: 'DELETE_QUEUED',
    DELETING: 'DELETING',
    DEPLOYED: 'DEPLOYED',
    DEPLOYING: 'DEPLOYING',
    DEPLOYMENT_ERROR: 'DEPLOYMENT_ERROR',
    DEPLOYMENT_QUEUED: 'DEPLOYMENT_QUEUED',
    QUEUED: 'QUEUED',
    READY: 'READY',
    RECAP: 'RECAP',
    RESTARTED: 'RESTARTED',
    RESTARTING: 'RESTARTING',
    RESTART_ERROR: 'RESTART_ERROR',
    RESTART_QUEUED: 'RESTART_QUEUED',
    STOPPED: 'STOPPED',
    STOPPING: 'STOPPING',
    STOP_ERROR: 'STOP_ERROR',
    STOP_QUEUED: 'STOP_QUEUED',
    WAITING_DELETING: 'WAITING_DELETING',
    WAITING_RESTARTING: 'WAITING_RESTARTING',
    WAITING_RUNNING: 'WAITING_RUNNING',
    WAITING_STOPPING: 'WAITING_STOPPING'
} as const;

export type StateEnum = typeof StateEnum[keyof typeof StateEnum];


/**
 * 
 * @export
 * @interface Status
 */
export interface Status {
    /**
     * 
     * @type {string}
     * @memberof Status
     */
    'id': string;
    /**
     * 
     * @type {StateEnum}
     * @memberof Status
     */
    'state': StateEnum;
    /**
     * 
     * @type {ServiceDeploymentStatusEnum}
     * @memberof Status
     */
    'service_deployment_status': ServiceDeploymentStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Status
     */
    'last_deployment_date'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Status
     */
    'is_part_last_deployment'?: boolean;
    /**
     * 
     * @type {ServiceStepMetrics}
     * @memberof Status
     */
    'steps'?: ServiceStepMetrics;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const StatusKindEnum = {
    CANCELED: 'CANCELED',
    CANCELING: 'CANCELING',
    DELETED: 'DELETED',
    DELETE_ERROR: 'DELETE_ERROR',
    DELETE_IN_PROGRESS: 'DELETE_IN_PROGRESS',
    DEPLOYED: 'DEPLOYED',
    DEPLOYMENT_ERROR: 'DEPLOYMENT_ERROR',
    DEPLOYMENT_IN_PROGRESS: 'DEPLOYMENT_IN_PROGRESS',
    ERROR: 'ERROR',
    PAUSED: 'PAUSED',
    PAUSE_ERROR: 'PAUSE_ERROR',
    PAUSE_IN_PROGRESS: 'PAUSE_IN_PROGRESS',
    WAITING: 'WAITING'
} as const;

export type StatusKindEnum = typeof StatusKindEnum[keyof typeof StatusKindEnum];


/**
 * The status of completion for the step: - SUCCESS: The step completed successfully. - ERROR: The step completed with an error. - CANCEL: The step was canceled. - SKIP: The step was skipped because it was not necessary. 
 * @export
 * @enum {string}
 */

export const StepMetricStatusEnum = {
    SUCCESS: 'SUCCESS',
    ERROR: 'ERROR',
    CANCEL: 'CANCEL',
    SKIP: 'SKIP'
} as const;

export type StepMetricStatusEnum = typeof StepMetricStatusEnum[keyof typeof StepMetricStatusEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const StorageTypeEnum = {
    FAST_SSD: 'FAST_SSD'
} as const;

export type StorageTypeEnum = typeof StorageTypeEnum[keyof typeof StorageTypeEnum];


/**
 * 
 * @export
 * @interface TransferOwnershipRequest
 */
export interface TransferOwnershipRequest {
    /**
     * 
     * @type {string}
     * @memberof TransferOwnershipRequest
     */
    'user_id': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TypeOfUseEnum = {
    PERSONAL: 'PERSONAL',
    SCHOOL: 'SCHOOL',
    WORK: 'WORK'
} as const;

export type TypeOfUseEnum = typeof TypeOfUseEnum[keyof typeof TypeOfUseEnum];


/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'profile_picture_url'?: string;
}
/**
 * 
 * @export
 * @interface UserResponseList
 */
export interface UserResponseList {
    /**
     * 
     * @type {Array<User>}
     * @memberof UserResponseList
     */
    'results'?: Array<User>;
}
/**
 * 
 * @export
 * @interface Value
 */
export interface Value {
    /**
     * 
     * @type {string}
     * @memberof Value
     */
    'value'?: string;
    /**
     * optional variable description (255 characters maximum)
     * @type {string}
     * @memberof Value
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface VariableAlias
 */
export interface VariableAlias {
    /**
     * 
     * @type {string}
     * @memberof VariableAlias
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof VariableAlias
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof VariableAlias
     */
    'value'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VariableAlias
     */
    'mount_path': string;
    /**
     * 
     * @type {APIVariableScopeEnum}
     * @memberof VariableAlias
     */
    'scope': APIVariableScopeEnum;
    /**
     * 
     * @type {APIVariableTypeEnum}
     * @memberof VariableAlias
     */
    'variable_type': APIVariableTypeEnum;
}


/**
 * 
 * @export
 * @interface VariableAliasRequest
 */
export interface VariableAliasRequest {
    /**
     * the value to be used as Alias of the targeted environment variable.
     * @type {string}
     * @memberof VariableAliasRequest
     */
    'key': string;
    /**
     * 
     * @type {APIVariableScopeEnum}
     * @memberof VariableAliasRequest
     */
    'alias_scope': APIVariableScopeEnum;
    /**
     * the id of the variable that is aliased.
     * @type {string}
     * @memberof VariableAliasRequest
     */
    'alias_parent_id': string;
    /**
     * optional variable description (255 characters maximum)
     * @type {string}
     * @memberof VariableAliasRequest
     */
    'description'?: string | null;
}


/**
 * 
 * @export
 * @interface VariableEditRequest
 */
export interface VariableEditRequest {
    /**
     * the key of the environment variable
     * @type {string}
     * @memberof VariableEditRequest
     */
    'key': string;
    /**
     * the value of the environment variable
     * @type {string}
     * @memberof VariableEditRequest
     */
    'value': string;
    /**
     * optional variable description (255 characters maximum)
     * @type {string}
     * @memberof VariableEditRequest
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface VariableImport
 */
export interface VariableImport {
    /**
     * 
     * @type {number}
     * @memberof VariableImport
     */
    'total_variables_to_import': number;
    /**
     * 
     * @type {Array<VariableImportSuccessfulImportedVariablesInner>}
     * @memberof VariableImport
     */
    'successful_imported_variables': Array<VariableImportSuccessfulImportedVariablesInner>;
}
/**
 * 
 * @export
 * @interface VariableImportRequest
 */
export interface VariableImportRequest {
    /**
     * 
     * @type {boolean}
     * @memberof VariableImportRequest
     */
    'overwrite': boolean;
    /**
     * 
     * @type {Array<VariableImportRequestVarsInner>}
     * @memberof VariableImportRequest
     */
    'vars': Array<VariableImportRequestVarsInner>;
}
/**
 * 
 * @export
 * @interface VariableImportRequestVarsInner
 */
export interface VariableImportRequestVarsInner {
    /**
     * 
     * @type {string}
     * @memberof VariableImportRequestVarsInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof VariableImportRequestVarsInner
     */
    'value': string;
    /**
     * 
     * @type {APIVariableScopeEnum}
     * @memberof VariableImportRequestVarsInner
     */
    'scope': APIVariableScopeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof VariableImportRequestVarsInner
     */
    'is_secret': boolean;
}


/**
 * 
 * @export
 * @interface VariableImportSuccessfulImportedVariablesInner
 */
export interface VariableImportSuccessfulImportedVariablesInner {
    /**
     * 
     * @type {string}
     * @memberof VariableImportSuccessfulImportedVariablesInner
     */
    'name': string;
    /**
     * Optional if the variable is secret
     * @type {string}
     * @memberof VariableImportSuccessfulImportedVariablesInner
     */
    'value'?: string;
    /**
     * 
     * @type {APIVariableScopeEnum}
     * @memberof VariableImportSuccessfulImportedVariablesInner
     */
    'scope': APIVariableScopeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof VariableImportSuccessfulImportedVariablesInner
     */
    'is_secret': boolean;
}


/**
 * 
 * @export
 * @interface VariableOverride
 */
export interface VariableOverride {
    /**
     * The id of the overriden variable
     * @type {string}
     * @memberof VariableOverride
     */
    'id': string;
    /**
     * The key of the overriden variable
     * @type {string}
     * @memberof VariableOverride
     */
    'key': string;
    /**
     * The value of the overriden variable
     * @type {string}
     * @memberof VariableOverride
     */
    'value'?: string | null;
    /**
     * The mounth path of the overriden variable (only if environment variable type is \'file\')
     * @type {string}
     * @memberof VariableOverride
     */
    'mount_path': string;
    /**
     * 
     * @type {APIVariableScopeEnum}
     * @memberof VariableOverride
     */
    'scope': APIVariableScopeEnum;
    /**
     * 
     * @type {APIVariableTypeEnum}
     * @memberof VariableOverride
     */
    'variable_type': APIVariableTypeEnum;
}


/**
 * 
 * @export
 * @interface VariableOverrideRequest
 */
export interface VariableOverrideRequest {
    /**
     * the value to be used as Override of the targeted environment variable.
     * @type {string}
     * @memberof VariableOverrideRequest
     */
    'value': string;
    /**
     * 
     * @type {APIVariableScopeEnum}
     * @memberof VariableOverrideRequest
     */
    'override_scope': APIVariableScopeEnum;
    /**
     * the id of the variable that is aliased.
     * @type {string}
     * @memberof VariableOverrideRequest
     */
    'override_parent_id': string;
    /**
     * optional variable description (255 characters maximum)
     * @type {string}
     * @memberof VariableOverrideRequest
     */
    'description'?: string | null;
}


/**
 * 
 * @export
 * @interface VariableRequest
 */
export interface VariableRequest {
    /**
     * the key of the environment variable
     * @type {string}
     * @memberof VariableRequest
     */
    'key': string;
    /**
     * the value of the environment variable
     * @type {string}
     * @memberof VariableRequest
     */
    'value': string;
    /**
     * the path where the file will be mounted (only if type =file)
     * @type {string}
     * @memberof VariableRequest
     */
    'mount_path'?: string | null;
    /**
     * if true, the variable will be considered as a secret and will not be accessible after its creation. Only your applications will be able to access its value at build and run time.
     * @type {boolean}
     * @memberof VariableRequest
     */
    'is_secret': boolean;
    /**
     * 
     * @type {APIVariableScopeEnum}
     * @memberof VariableRequest
     */
    'variable_scope': APIVariableScopeEnum;
    /**
     * based on the selected scope, it contains the ID of the service, environment or project where the variable is attached
     * @type {string}
     * @memberof VariableRequest
     */
    'variable_parent_id': string;
    /**
     * optional variable description (255 characters maximum)
     * @type {string}
     * @memberof VariableRequest
     */
    'description'?: string | null;
}


/**
 * 
 * @export
 * @interface VariableResponse
 */
export interface VariableResponse {
    /**
     * 
     * @type {string}
     * @memberof VariableResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof VariableResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof VariableResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof VariableResponse
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof VariableResponse
     */
    'value': string | null;
    /**
     * 
     * @type {string}
     * @memberof VariableResponse
     */
    'mount_path'?: string | null;
    /**
     * 
     * @type {VariableOverride}
     * @memberof VariableResponse
     */
    'overridden_variable'?: VariableOverride;
    /**
     * 
     * @type {VariableAlias}
     * @memberof VariableResponse
     */
    'aliased_variable'?: VariableAlias;
    /**
     * 
     * @type {APIVariableScopeEnum}
     * @memberof VariableResponse
     */
    'scope': APIVariableScopeEnum;
    /**
     * 
     * @type {APIVariableTypeEnum}
     * @memberof VariableResponse
     */
    'variable_type': APIVariableTypeEnum;
    /**
     * The id of the service referenced by this variable.
     * @type {string}
     * @memberof VariableResponse
     */
    'service_id'?: string;
    /**
     * The name of the service referenced by this variable.
     * @type {string}
     * @memberof VariableResponse
     */
    'service_name'?: string;
    /**
     * 
     * @type {LinkedServiceTypeEnum}
     * @memberof VariableResponse
     */
    'service_type'?: LinkedServiceTypeEnum;
    /**
     * Entity that created/own the variable (i.e: Qovery, Doppler)
     * @type {string}
     * @memberof VariableResponse
     */
    'owned_by'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof VariableResponse
     */
    'is_secret': boolean;
    /**
     * 
     * @type {string}
     * @memberof VariableResponse
     */
    'description'?: string;
}


/**
 * 
 * @export
 * @interface VariableResponseList
 */
export interface VariableResponseList {
    /**
     * 
     * @type {Array<VariableResponse>}
     * @memberof VariableResponseList
     */
    'results'?: Array<VariableResponse>;
}
/**
 * 
 * @export
 * @interface Version
 */
export interface Version {
    /**
     * 
     * @type {string}
     * @memberof Version
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface VersionResponseList
 */
export interface VersionResponseList {
    /**
     * 
     * @type {Array<Version>}
     * @memberof VersionResponseList
     */
    'results'?: Array<Version>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const WeekdayEnum = {
    MONDAY: 'MONDAY',
    TUESDAY: 'TUESDAY',
    WEDNESDAY: 'WEDNESDAY',
    THURSDAY: 'THURSDAY',
    FRIDAY: 'FRIDAY',
    SATURDAY: 'SATURDAY',
    SUNDAY: 'SUNDAY'
} as const;

export type WeekdayEnum = typeof WeekdayEnum[keyof typeof WeekdayEnum];



/**
 * AccountInfoApi - axios parameter creator
 * @export
 */
export const AccountInfoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Edit account information
         * @param {AccountInfoEditRequest} [accountInfoEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editAccountInformation: async (accountInfoEditRequest?: AccountInfoEditRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountInfoEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Account information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountInformation: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountInfoApi - functional programming interface
 * @export
 */
export const AccountInfoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountInfoApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Edit account information
         * @param {AccountInfoEditRequest} [accountInfoEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editAccountInformation(accountInfoEditRequest?: AccountInfoEditRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editAccountInformation(accountInfoEditRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Account information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountInformation(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountInformation(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountInfoApi - factory interface
 * @export
 */
export const AccountInfoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountInfoApiFp(configuration)
    return {
        /**
         * 
         * @summary Edit account information
         * @param {AccountInfoEditRequest} [accountInfoEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editAccountInformation(accountInfoEditRequest?: AccountInfoEditRequest, options?: any): AxiosPromise<AccountInfo> {
            return localVarFp.editAccountInformation(accountInfoEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Account information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountInformation(options?: any): AxiosPromise<AccountInfo> {
            return localVarFp.getAccountInformation(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountInfoApi - object-oriented interface
 * @export
 * @class AccountInfoApi
 * @extends {BaseAPI}
 */
export class AccountInfoApi extends BaseAPI {
    /**
     * 
     * @summary Edit account information
     * @param {AccountInfoEditRequest} [accountInfoEditRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountInfoApi
     */
    public editAccountInformation(accountInfoEditRequest?: AccountInfoEditRequest, options?: AxiosRequestConfig) {
        return AccountInfoApiFp(this.configuration).editAccountInformation(accountInfoEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Account information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountInfoApi
     */
    public getAccountInformation(options?: AxiosRequestConfig) {
        return AccountInfoApiFp(this.configuration).getAccountInformation(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ApplicationActionsApi - axios parameter creator
 * @export
 */
export const ApplicationActionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * You must provide a git commit id
         * @summary Deploy application
         * @param {string} applicationId Application ID
         * @param {DeployRequest} [deployRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployApplication: async (applicationId: string, deployRequest?: DeployRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('deployApplication', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/deploy`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deployRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reboot application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rebootApplication: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('rebootApplication', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/restart-service`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Redeploy application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeployApplication: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('redeployApplication', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/redeploy`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopApplication: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('stopApplication', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/stop`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationActionsApi - functional programming interface
 * @export
 */
export const ApplicationActionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationActionsApiAxiosParamCreator(configuration)
    return {
        /**
         * You must provide a git commit id
         * @summary Deploy application
         * @param {string} applicationId Application ID
         * @param {DeployRequest} [deployRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployApplication(applicationId: string, deployRequest?: DeployRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployApplication(applicationId, deployRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Reboot application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rebootApplication(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rebootApplication(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Redeploy application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async redeployApplication(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.redeployApplication(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Stop application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopApplication(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopApplication(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApplicationActionsApi - factory interface
 * @export
 */
export const ApplicationActionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationActionsApiFp(configuration)
    return {
        /**
         * You must provide a git commit id
         * @summary Deploy application
         * @param {string} applicationId Application ID
         * @param {DeployRequest} [deployRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployApplication(applicationId: string, deployRequest?: DeployRequest, options?: any): AxiosPromise<Status> {
            return localVarFp.deployApplication(applicationId, deployRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reboot application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rebootApplication(applicationId: string, options?: any): AxiosPromise<Status> {
            return localVarFp.rebootApplication(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Redeploy application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeployApplication(applicationId: string, options?: any): AxiosPromise<Status> {
            return localVarFp.redeployApplication(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Stop application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopApplication(applicationId: string, options?: any): AxiosPromise<Status> {
            return localVarFp.stopApplication(applicationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationActionsApi - object-oriented interface
 * @export
 * @class ApplicationActionsApi
 * @extends {BaseAPI}
 */
export class ApplicationActionsApi extends BaseAPI {
    /**
     * You must provide a git commit id
     * @summary Deploy application
     * @param {string} applicationId Application ID
     * @param {DeployRequest} [deployRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationActionsApi
     */
    public deployApplication(applicationId: string, deployRequest?: DeployRequest, options?: AxiosRequestConfig) {
        return ApplicationActionsApiFp(this.configuration).deployApplication(applicationId, deployRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reboot application
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationActionsApi
     */
    public rebootApplication(applicationId: string, options?: AxiosRequestConfig) {
        return ApplicationActionsApiFp(this.configuration).rebootApplication(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Redeploy application
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationActionsApi
     */
    public redeployApplication(applicationId: string, options?: AxiosRequestConfig) {
        return ApplicationActionsApiFp(this.configuration).redeployApplication(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Stop application
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationActionsApi
     */
    public stopApplication(applicationId: string, options?: AxiosRequestConfig) {
        return ApplicationActionsApiFp(this.configuration).stopApplication(applicationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ApplicationConfigurationApi - axios parameter creator
 * @export
 */
export const ApplicationConfigurationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Edit advanced settings by returning table of advanced settings.
         * @summary Edit advanced settings
         * @param {string} applicationId Application ID
         * @param {ApplicationAdvancedSettings} [applicationAdvancedSettings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editAdvancedSettings: async (applicationId: string, applicationAdvancedSettings?: ApplicationAdvancedSettings, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('editAdvancedSettings', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/advancedSettings`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(applicationAdvancedSettings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit the Network settings of the application.
         * @summary Edit Application Network
         * @param {string} applicationId Application ID
         * @param {ApplicationNetworkRequest} [applicationNetworkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editApplicationNetwork: async (applicationId: string, applicationNetworkRequest?: ApplicationNetworkRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('editApplicationNetwork', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/network`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(applicationNetworkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list and values of the advanced settings of the application. Default values for each setting are available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/advanced-settings/) 
         * @summary Get advanced settings
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdvancedSettings: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getAdvancedSettings', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/advancedSettings`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get status of the application network settings.
         * @summary Get Application Network information
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationNetwork: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getApplicationNetwork', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/network`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationConfigurationApi - functional programming interface
 * @export
 */
export const ApplicationConfigurationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationConfigurationApiAxiosParamCreator(configuration)
    return {
        /**
         * Edit advanced settings by returning table of advanced settings.
         * @summary Edit advanced settings
         * @param {string} applicationId Application ID
         * @param {ApplicationAdvancedSettings} [applicationAdvancedSettings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editAdvancedSettings(applicationId: string, applicationAdvancedSettings?: ApplicationAdvancedSettings, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationAdvancedSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editAdvancedSettings(applicationId, applicationAdvancedSettings, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Edit the Network settings of the application.
         * @summary Edit Application Network
         * @param {string} applicationId Application ID
         * @param {ApplicationNetworkRequest} [applicationNetworkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editApplicationNetwork(applicationId: string, applicationNetworkRequest?: ApplicationNetworkRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationNetwork>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editApplicationNetwork(applicationId, applicationNetworkRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get list and values of the advanced settings of the application. Default values for each setting are available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/advanced-settings/) 
         * @summary Get advanced settings
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAdvancedSettings(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationAdvancedSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAdvancedSettings(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get status of the application network settings.
         * @summary Get Application Network information
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationNetwork(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationNetwork>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationNetwork(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApplicationConfigurationApi - factory interface
 * @export
 */
export const ApplicationConfigurationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationConfigurationApiFp(configuration)
    return {
        /**
         * Edit advanced settings by returning table of advanced settings.
         * @summary Edit advanced settings
         * @param {string} applicationId Application ID
         * @param {ApplicationAdvancedSettings} [applicationAdvancedSettings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editAdvancedSettings(applicationId: string, applicationAdvancedSettings?: ApplicationAdvancedSettings, options?: any): AxiosPromise<ApplicationAdvancedSettings> {
            return localVarFp.editAdvancedSettings(applicationId, applicationAdvancedSettings, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit the Network settings of the application.
         * @summary Edit Application Network
         * @param {string} applicationId Application ID
         * @param {ApplicationNetworkRequest} [applicationNetworkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editApplicationNetwork(applicationId: string, applicationNetworkRequest?: ApplicationNetworkRequest, options?: any): AxiosPromise<ApplicationNetwork> {
            return localVarFp.editApplicationNetwork(applicationId, applicationNetworkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get list and values of the advanced settings of the application. Default values for each setting are available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/advanced-settings/) 
         * @summary Get advanced settings
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdvancedSettings(applicationId: string, options?: any): AxiosPromise<ApplicationAdvancedSettings> {
            return localVarFp.getAdvancedSettings(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get status of the application network settings.
         * @summary Get Application Network information
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationNetwork(applicationId: string, options?: any): AxiosPromise<ApplicationNetwork> {
            return localVarFp.getApplicationNetwork(applicationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationConfigurationApi - object-oriented interface
 * @export
 * @class ApplicationConfigurationApi
 * @extends {BaseAPI}
 */
export class ApplicationConfigurationApi extends BaseAPI {
    /**
     * Edit advanced settings by returning table of advanced settings.
     * @summary Edit advanced settings
     * @param {string} applicationId Application ID
     * @param {ApplicationAdvancedSettings} [applicationAdvancedSettings] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationConfigurationApi
     */
    public editAdvancedSettings(applicationId: string, applicationAdvancedSettings?: ApplicationAdvancedSettings, options?: AxiosRequestConfig) {
        return ApplicationConfigurationApiFp(this.configuration).editAdvancedSettings(applicationId, applicationAdvancedSettings, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit the Network settings of the application.
     * @summary Edit Application Network
     * @param {string} applicationId Application ID
     * @param {ApplicationNetworkRequest} [applicationNetworkRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationConfigurationApi
     */
    public editApplicationNetwork(applicationId: string, applicationNetworkRequest?: ApplicationNetworkRequest, options?: AxiosRequestConfig) {
        return ApplicationConfigurationApiFp(this.configuration).editApplicationNetwork(applicationId, applicationNetworkRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list and values of the advanced settings of the application. Default values for each setting are available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/advanced-settings/) 
     * @summary Get advanced settings
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationConfigurationApi
     */
    public getAdvancedSettings(applicationId: string, options?: AxiosRequestConfig) {
        return ApplicationConfigurationApiFp(this.configuration).getAdvancedSettings(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get status of the application network settings.
     * @summary Get Application Network information
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationConfigurationApi
     */
    public getApplicationNetwork(applicationId: string, options?: AxiosRequestConfig) {
        return ApplicationConfigurationApiFp(this.configuration).getApplicationNetwork(applicationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ApplicationDeploymentHistoryApi - axios parameter creator
 * @export
 */
export const ApplicationDeploymentHistoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter. You can also filter by status (FAILED or SUCCESS), and git_commit_id
         * @summary List application deploys
         * @param {string} applicationId Application ID
         * @param {string} [startId] Starting point after which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationDeploymentHistory: async (applicationId: string, startId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('listApplicationDeploymentHistory', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/deploymentHistory`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (startId !== undefined) {
                localVarQueryParameter['startId'] = startId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationDeploymentHistoryApi - functional programming interface
 * @export
 */
export const ApplicationDeploymentHistoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationDeploymentHistoryApiAxiosParamCreator(configuration)
    return {
        /**
         * By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter. You can also filter by status (FAILED or SUCCESS), and git_commit_id
         * @summary List application deploys
         * @param {string} applicationId Application ID
         * @param {string} [startId] Starting point after which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplicationDeploymentHistory(applicationId: string, startId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentHistoryPaginatedResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplicationDeploymentHistory(applicationId, startId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApplicationDeploymentHistoryApi - factory interface
 * @export
 */
export const ApplicationDeploymentHistoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationDeploymentHistoryApiFp(configuration)
    return {
        /**
         * By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter. You can also filter by status (FAILED or SUCCESS), and git_commit_id
         * @summary List application deploys
         * @param {string} applicationId Application ID
         * @param {string} [startId] Starting point after which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationDeploymentHistory(applicationId: string, startId?: string, options?: any): AxiosPromise<DeploymentHistoryPaginatedResponseList> {
            return localVarFp.listApplicationDeploymentHistory(applicationId, startId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationDeploymentHistoryApi - object-oriented interface
 * @export
 * @class ApplicationDeploymentHistoryApi
 * @extends {BaseAPI}
 */
export class ApplicationDeploymentHistoryApi extends BaseAPI {
    /**
     * By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter. You can also filter by status (FAILED or SUCCESS), and git_commit_id
     * @summary List application deploys
     * @param {string} applicationId Application ID
     * @param {string} [startId] Starting point after which to return results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentHistoryApi
     */
    public listApplicationDeploymentHistory(applicationId: string, startId?: string, options?: AxiosRequestConfig) {
        return ApplicationDeploymentHistoryApiFp(this.configuration).listApplicationDeploymentHistory(applicationId, startId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ApplicationDeploymentRestrictionApi - axios parameter creator
 * @export
 */
export const ApplicationDeploymentRestrictionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an application deployment restriction
         * @summary Create an application deployment restriction
         * @param {string} applicationId Application ID
         * @param {ApplicationDeploymentRestrictionRequest} [applicationDeploymentRestrictionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationDeploymentRestriction: async (applicationId: string, applicationDeploymentRestrictionRequest?: ApplicationDeploymentRestrictionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('createApplicationDeploymentRestriction', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/deploymentRestriction`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(applicationDeploymentRestrictionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an application deployment restriction
         * @summary Delete an application deployment restriction
         * @param {string} applicationId Application ID
         * @param {string} deploymentRestrictionId Deployment Restriction ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationDeploymentRestriction: async (applicationId: string, deploymentRestrictionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('deleteApplicationDeploymentRestriction', 'applicationId', applicationId)
            // verify required parameter 'deploymentRestrictionId' is not null or undefined
            assertParamExists('deleteApplicationDeploymentRestriction', 'deploymentRestrictionId', deploymentRestrictionId)
            const localVarPath = `/application/{applicationId}/deploymentRestriction/{deploymentRestrictionId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"deploymentRestrictionId"}}`, encodeURIComponent(String(deploymentRestrictionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit an application deployment restriction
         * @summary Edit an application deployment restriction
         * @param {string} applicationId Application ID
         * @param {string} deploymentRestrictionId Deployment Restriction ID
         * @param {ApplicationDeploymentRestrictionRequest} [applicationDeploymentRestrictionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editApplicationDeploymentRestriction: async (applicationId: string, deploymentRestrictionId: string, applicationDeploymentRestrictionRequest?: ApplicationDeploymentRestrictionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('editApplicationDeploymentRestriction', 'applicationId', applicationId)
            // verify required parameter 'deploymentRestrictionId' is not null or undefined
            assertParamExists('editApplicationDeploymentRestriction', 'deploymentRestrictionId', deploymentRestrictionId)
            const localVarPath = `/application/{applicationId}/deploymentRestriction/{deploymentRestrictionId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"deploymentRestrictionId"}}`, encodeURIComponent(String(deploymentRestrictionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(applicationDeploymentRestrictionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get application deployment restrictions
         * @summary Get application deployment restrictions
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationDeploymentRestrictions: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getApplicationDeploymentRestrictions', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/deploymentRestriction`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationDeploymentRestrictionApi - functional programming interface
 * @export
 */
export const ApplicationDeploymentRestrictionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationDeploymentRestrictionApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an application deployment restriction
         * @summary Create an application deployment restriction
         * @param {string} applicationId Application ID
         * @param {ApplicationDeploymentRestrictionRequest} [applicationDeploymentRestrictionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplicationDeploymentRestriction(applicationId: string, applicationDeploymentRestrictionRequest?: ApplicationDeploymentRestrictionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationDeploymentRestriction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplicationDeploymentRestriction(applicationId, applicationDeploymentRestrictionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an application deployment restriction
         * @summary Delete an application deployment restriction
         * @param {string} applicationId Application ID
         * @param {string} deploymentRestrictionId Deployment Restriction ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApplicationDeploymentRestriction(applicationId: string, deploymentRestrictionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApplicationDeploymentRestriction(applicationId, deploymentRestrictionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Edit an application deployment restriction
         * @summary Edit an application deployment restriction
         * @param {string} applicationId Application ID
         * @param {string} deploymentRestrictionId Deployment Restriction ID
         * @param {ApplicationDeploymentRestrictionRequest} [applicationDeploymentRestrictionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editApplicationDeploymentRestriction(applicationId: string, deploymentRestrictionId: string, applicationDeploymentRestrictionRequest?: ApplicationDeploymentRestrictionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationDeploymentRestriction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editApplicationDeploymentRestriction(applicationId, deploymentRestrictionId, applicationDeploymentRestrictionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get application deployment restrictions
         * @summary Get application deployment restrictions
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationDeploymentRestrictions(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationDeploymentRestrictionResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationDeploymentRestrictions(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApplicationDeploymentRestrictionApi - factory interface
 * @export
 */
export const ApplicationDeploymentRestrictionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationDeploymentRestrictionApiFp(configuration)
    return {
        /**
         * Create an application deployment restriction
         * @summary Create an application deployment restriction
         * @param {string} applicationId Application ID
         * @param {ApplicationDeploymentRestrictionRequest} [applicationDeploymentRestrictionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationDeploymentRestriction(applicationId: string, applicationDeploymentRestrictionRequest?: ApplicationDeploymentRestrictionRequest, options?: any): AxiosPromise<ApplicationDeploymentRestriction> {
            return localVarFp.createApplicationDeploymentRestriction(applicationId, applicationDeploymentRestrictionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an application deployment restriction
         * @summary Delete an application deployment restriction
         * @param {string} applicationId Application ID
         * @param {string} deploymentRestrictionId Deployment Restriction ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationDeploymentRestriction(applicationId: string, deploymentRestrictionId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteApplicationDeploymentRestriction(applicationId, deploymentRestrictionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit an application deployment restriction
         * @summary Edit an application deployment restriction
         * @param {string} applicationId Application ID
         * @param {string} deploymentRestrictionId Deployment Restriction ID
         * @param {ApplicationDeploymentRestrictionRequest} [applicationDeploymentRestrictionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editApplicationDeploymentRestriction(applicationId: string, deploymentRestrictionId: string, applicationDeploymentRestrictionRequest?: ApplicationDeploymentRestrictionRequest, options?: any): AxiosPromise<ApplicationDeploymentRestriction> {
            return localVarFp.editApplicationDeploymentRestriction(applicationId, deploymentRestrictionId, applicationDeploymentRestrictionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get application deployment restrictions
         * @summary Get application deployment restrictions
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationDeploymentRestrictions(applicationId: string, options?: any): AxiosPromise<ApplicationDeploymentRestrictionResponseList> {
            return localVarFp.getApplicationDeploymentRestrictions(applicationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationDeploymentRestrictionApi - object-oriented interface
 * @export
 * @class ApplicationDeploymentRestrictionApi
 * @extends {BaseAPI}
 */
export class ApplicationDeploymentRestrictionApi extends BaseAPI {
    /**
     * Create an application deployment restriction
     * @summary Create an application deployment restriction
     * @param {string} applicationId Application ID
     * @param {ApplicationDeploymentRestrictionRequest} [applicationDeploymentRestrictionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentRestrictionApi
     */
    public createApplicationDeploymentRestriction(applicationId: string, applicationDeploymentRestrictionRequest?: ApplicationDeploymentRestrictionRequest, options?: AxiosRequestConfig) {
        return ApplicationDeploymentRestrictionApiFp(this.configuration).createApplicationDeploymentRestriction(applicationId, applicationDeploymentRestrictionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an application deployment restriction
     * @summary Delete an application deployment restriction
     * @param {string} applicationId Application ID
     * @param {string} deploymentRestrictionId Deployment Restriction ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentRestrictionApi
     */
    public deleteApplicationDeploymentRestriction(applicationId: string, deploymentRestrictionId: string, options?: AxiosRequestConfig) {
        return ApplicationDeploymentRestrictionApiFp(this.configuration).deleteApplicationDeploymentRestriction(applicationId, deploymentRestrictionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit an application deployment restriction
     * @summary Edit an application deployment restriction
     * @param {string} applicationId Application ID
     * @param {string} deploymentRestrictionId Deployment Restriction ID
     * @param {ApplicationDeploymentRestrictionRequest} [applicationDeploymentRestrictionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentRestrictionApi
     */
    public editApplicationDeploymentRestriction(applicationId: string, deploymentRestrictionId: string, applicationDeploymentRestrictionRequest?: ApplicationDeploymentRestrictionRequest, options?: AxiosRequestConfig) {
        return ApplicationDeploymentRestrictionApiFp(this.configuration).editApplicationDeploymentRestriction(applicationId, deploymentRestrictionId, applicationDeploymentRestrictionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get application deployment restrictions
     * @summary Get application deployment restrictions
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentRestrictionApi
     */
    public getApplicationDeploymentRestrictions(applicationId: string, options?: AxiosRequestConfig) {
        return ApplicationDeploymentRestrictionApiFp(this.configuration).getApplicationDeploymentRestrictions(applicationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ApplicationEnvironmentVariableApi - axios parameter creator
 * @export
 */
export const ApplicationEnvironmentVariableApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * - Add an environment variable to the application. 
         * @summary Add an environment variable to the application
         * @param {string} applicationId Application ID
         * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationEnvironmentVariable: async (applicationId: string, environmentVariableRequest?: EnvironmentVariableRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('createApplicationEnvironmentVariable', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/environmentVariable`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentVariableRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to add an alias at application level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at application level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - You can\'t create an alias on an alias 
         * @summary Create an environment variable alias at the application level
         * @param {string} applicationId Application ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationEnvironmentVariableAlias: async (applicationId: string, environmentVariableId: string, key?: Key, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('createApplicationEnvironmentVariableAlias', 'applicationId', applicationId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('createApplicationEnvironmentVariableAlias', 'environmentVariableId', environmentVariableId)
            const localVarPath = `/application/{applicationId}/environmentVariable/{environmentVariableId}/alias`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(key, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to override at application level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at application level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
         * @summary Create an environment variable override at the application level
         * @param {string} applicationId Application ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationEnvironmentVariableOverride: async (applicationId: string, environmentVariableId: string, value?: Value, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('createApplicationEnvironmentVariableOverride', 'applicationId', applicationId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('createApplicationEnvironmentVariableOverride', 'environmentVariableId', environmentVariableId)
            const localVarPath = `/application/{applicationId}/environmentVariable/{environmentVariableId}/override`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(value, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - To delete an environment variable from an application you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete an environment variable from an application
         * @param {string} applicationId Application ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationEnvironmentVariable: async (applicationId: string, environmentVariableId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('deleteApplicationEnvironmentVariable', 'applicationId', applicationId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('deleteApplicationEnvironmentVariable', 'environmentVariableId', environmentVariableId)
            const localVarPath = `/application/{applicationId}/environmentVariable/{environmentVariableId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit an environment variable belonging to the application
         * @param {string} applicationId Application ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editApplicationEnvironmentVariable: async (applicationId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('editApplicationEnvironmentVariable', 'applicationId', applicationId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('editApplicationEnvironmentVariable', 'environmentVariableId', environmentVariableId)
            // verify required parameter 'environmentVariableEditRequest' is not null or undefined
            assertParamExists('editApplicationEnvironmentVariable', 'environmentVariableEditRequest', environmentVariableEditRequest)
            const localVarPath = `/application/{applicationId}/environmentVariable/{environmentVariableId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentVariableEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Import environment variables in a defined scope, with a defined visibility.
         * @summary Import variables
         * @param {string} applicationId Application ID
         * @param {VariableImportRequest} [variableImportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importEnvironmentVariable: async (applicationId: string, variableImportRequest?: VariableImportRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('importEnvironmentVariable', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/environmentVariable/import`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(variableImportRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List environment variables
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationEnvironmentVariable: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('listApplicationEnvironmentVariable', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/environmentVariable`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationEnvironmentVariableApi - functional programming interface
 * @export
 */
export const ApplicationEnvironmentVariableApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationEnvironmentVariableApiAxiosParamCreator(configuration)
    return {
        /**
         * - Add an environment variable to the application. 
         * @summary Add an environment variable to the application
         * @param {string} applicationId Application ID
         * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplicationEnvironmentVariable(applicationId: string, environmentVariableRequest?: EnvironmentVariableRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplicationEnvironmentVariable(applicationId, environmentVariableRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - Allows you to add an alias at application level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at application level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - You can\'t create an alias on an alias 
         * @summary Create an environment variable alias at the application level
         * @param {string} applicationId Application ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplicationEnvironmentVariableAlias(applicationId: string, environmentVariableId: string, key?: Key, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplicationEnvironmentVariableAlias(applicationId, environmentVariableId, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - Allows you to override at application level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at application level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
         * @summary Create an environment variable override at the application level
         * @param {string} applicationId Application ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplicationEnvironmentVariableOverride(applicationId: string, environmentVariableId: string, value?: Value, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplicationEnvironmentVariableOverride(applicationId, environmentVariableId, value, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - To delete an environment variable from an application you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete an environment variable from an application
         * @param {string} applicationId Application ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApplicationEnvironmentVariable(applicationId: string, environmentVariableId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApplicationEnvironmentVariable(applicationId, environmentVariableId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit an environment variable belonging to the application
         * @param {string} applicationId Application ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editApplicationEnvironmentVariable(applicationId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editApplicationEnvironmentVariable(applicationId, environmentVariableId, environmentVariableEditRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Import environment variables in a defined scope, with a defined visibility.
         * @summary Import variables
         * @param {string} applicationId Application ID
         * @param {VariableImportRequest} [variableImportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importEnvironmentVariable(applicationId: string, variableImportRequest?: VariableImportRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariableImport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importEnvironmentVariable(applicationId, variableImportRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List environment variables
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplicationEnvironmentVariable(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariableResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplicationEnvironmentVariable(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApplicationEnvironmentVariableApi - factory interface
 * @export
 */
export const ApplicationEnvironmentVariableApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationEnvironmentVariableApiFp(configuration)
    return {
        /**
         * - Add an environment variable to the application. 
         * @summary Add an environment variable to the application
         * @param {string} applicationId Application ID
         * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationEnvironmentVariable(applicationId: string, environmentVariableRequest?: EnvironmentVariableRequest, options?: any): AxiosPromise<EnvironmentVariable> {
            return localVarFp.createApplicationEnvironmentVariable(applicationId, environmentVariableRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to add an alias at application level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at application level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - You can\'t create an alias on an alias 
         * @summary Create an environment variable alias at the application level
         * @param {string} applicationId Application ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationEnvironmentVariableAlias(applicationId: string, environmentVariableId: string, key?: Key, options?: any): AxiosPromise<EnvironmentVariable> {
            return localVarFp.createApplicationEnvironmentVariableAlias(applicationId, environmentVariableId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to override at application level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at application level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
         * @summary Create an environment variable override at the application level
         * @param {string} applicationId Application ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationEnvironmentVariableOverride(applicationId: string, environmentVariableId: string, value?: Value, options?: any): AxiosPromise<EnvironmentVariable> {
            return localVarFp.createApplicationEnvironmentVariableOverride(applicationId, environmentVariableId, value, options).then((request) => request(axios, basePath));
        },
        /**
         * - To delete an environment variable from an application you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete an environment variable from an application
         * @param {string} applicationId Application ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationEnvironmentVariable(applicationId: string, environmentVariableId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteApplicationEnvironmentVariable(applicationId, environmentVariableId, options).then((request) => request(axios, basePath));
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit an environment variable belonging to the application
         * @param {string} applicationId Application ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editApplicationEnvironmentVariable(applicationId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options?: any): AxiosPromise<EnvironmentVariable> {
            return localVarFp.editApplicationEnvironmentVariable(applicationId, environmentVariableId, environmentVariableEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Import environment variables in a defined scope, with a defined visibility.
         * @summary Import variables
         * @param {string} applicationId Application ID
         * @param {VariableImportRequest} [variableImportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importEnvironmentVariable(applicationId: string, variableImportRequest?: VariableImportRequest, options?: any): AxiosPromise<VariableImport> {
            return localVarFp.importEnvironmentVariable(applicationId, variableImportRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List environment variables
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationEnvironmentVariable(applicationId: string, options?: any): AxiosPromise<EnvironmentVariableResponseList> {
            return localVarFp.listApplicationEnvironmentVariable(applicationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationEnvironmentVariableApi - object-oriented interface
 * @export
 * @class ApplicationEnvironmentVariableApi
 * @extends {BaseAPI}
 */
export class ApplicationEnvironmentVariableApi extends BaseAPI {
    /**
     * - Add an environment variable to the application. 
     * @summary Add an environment variable to the application
     * @param {string} applicationId Application ID
     * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationEnvironmentVariableApi
     */
    public createApplicationEnvironmentVariable(applicationId: string, environmentVariableRequest?: EnvironmentVariableRequest, options?: AxiosRequestConfig) {
        return ApplicationEnvironmentVariableApiFp(this.configuration).createApplicationEnvironmentVariable(applicationId, environmentVariableRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to add an alias at application level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at application level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - You can\'t create an alias on an alias 
     * @summary Create an environment variable alias at the application level
     * @param {string} applicationId Application ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {Key} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationEnvironmentVariableApi
     */
    public createApplicationEnvironmentVariableAlias(applicationId: string, environmentVariableId: string, key?: Key, options?: AxiosRequestConfig) {
        return ApplicationEnvironmentVariableApiFp(this.configuration).createApplicationEnvironmentVariableAlias(applicationId, environmentVariableId, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to override at application level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at application level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
     * @summary Create an environment variable override at the application level
     * @param {string} applicationId Application ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {Value} [value] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationEnvironmentVariableApi
     */
    public createApplicationEnvironmentVariableOverride(applicationId: string, environmentVariableId: string, value?: Value, options?: AxiosRequestConfig) {
        return ApplicationEnvironmentVariableApiFp(this.configuration).createApplicationEnvironmentVariableOverride(applicationId, environmentVariableId, value, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - To delete an environment variable from an application you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
     * @summary Delete an environment variable from an application
     * @param {string} applicationId Application ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationEnvironmentVariableApi
     */
    public deleteApplicationEnvironmentVariable(applicationId: string, environmentVariableId: string, options?: AxiosRequestConfig) {
        return ApplicationEnvironmentVariableApiFp(this.configuration).deleteApplicationEnvironmentVariable(applicationId, environmentVariableId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
     * @summary Edit an environment variable belonging to the application
     * @param {string} applicationId Application ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationEnvironmentVariableApi
     */
    public editApplicationEnvironmentVariable(applicationId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options?: AxiosRequestConfig) {
        return ApplicationEnvironmentVariableApiFp(this.configuration).editApplicationEnvironmentVariable(applicationId, environmentVariableId, environmentVariableEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Import environment variables in a defined scope, with a defined visibility.
     * @summary Import variables
     * @param {string} applicationId Application ID
     * @param {VariableImportRequest} [variableImportRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationEnvironmentVariableApi
     */
    public importEnvironmentVariable(applicationId: string, variableImportRequest?: VariableImportRequest, options?: AxiosRequestConfig) {
        return ApplicationEnvironmentVariableApiFp(this.configuration).importEnvironmentVariable(applicationId, variableImportRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List environment variables
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationEnvironmentVariableApi
     */
    public listApplicationEnvironmentVariable(applicationId: string, options?: AxiosRequestConfig) {
        return ApplicationEnvironmentVariableApiFp(this.configuration).listApplicationEnvironmentVariable(applicationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ApplicationLogsApi - axios parameter creator
 * @export
 */
export const ApplicationLogsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This will list the last 1000 logs of the application
         * @summary List logs
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationLog: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('listApplicationLog', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/log`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationLogsApi - functional programming interface
 * @export
 */
export const ApplicationLogsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationLogsApiAxiosParamCreator(configuration)
    return {
        /**
         * This will list the last 1000 logs of the application
         * @summary List logs
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplicationLog(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplicationLog(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApplicationLogsApi - factory interface
 * @export
 */
export const ApplicationLogsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationLogsApiFp(configuration)
    return {
        /**
         * This will list the last 1000 logs of the application
         * @summary List logs
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationLog(applicationId: string, options?: any): AxiosPromise<LogResponseList> {
            return localVarFp.listApplicationLog(applicationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationLogsApi - object-oriented interface
 * @export
 * @class ApplicationLogsApi
 * @extends {BaseAPI}
 */
export class ApplicationLogsApi extends BaseAPI {
    /**
     * This will list the last 1000 logs of the application
     * @summary List logs
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationLogsApi
     */
    public listApplicationLog(applicationId: string, options?: AxiosRequestConfig) {
        return ApplicationLogsApiFp(this.configuration).listApplicationLog(applicationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ApplicationMainCallsApi - axios parameter creator
 * @export
 */
export const ApplicationMainCallsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * To delete the application you must have the admin permission
         * @summary Delete application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplication: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('deleteApplication', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - To edit the application you must have the admin permission. - For port edition, if you provide a port id, we will update the corresponding port. If you don\'t we will create a new one. If you remove a port from the payload, we will delete it. - For storage edition, if you provide a storage id, we will update the corresponding storage. If you don\'t we will create a new one. If you remove a storage from the payload, we will delete it. 
         * @summary Edit application
         * @param {string} applicationId Application ID
         * @param {ApplicationEditRequest} [applicationEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editApplication: async (applicationId: string, applicationEditRequest?: ApplicationEditRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('editApplication', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(applicationEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get application by ID
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplication: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getApplication', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get application status
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationStatus: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getApplicationStatus', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/status`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns list of the last 100 commits made on the repository linked to the application
         * @summary List last commits
         * @param {string} applicationId Application ID
         * @param {string} [startId] Starting point after which to return results
         * @param {string} [gitCommitId] Git Commit ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationCommit: async (applicationId: string, startId?: string, gitCommitId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('listApplicationCommit', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/commit`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (startId !== undefined) {
                localVarQueryParameter['startId'] = startId;
            }

            if (gitCommitId !== undefined) {
                localVarQueryParameter['gitCommitId'] = gitCommitId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List contributors
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationContributor: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('listApplicationContributor', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/contributor`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This will return all the custom domains and Qovery autogenerated domain for the given application
         * @summary List all URLs of the application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationLinks: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('listApplicationLinks', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/link`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationMainCallsApi - functional programming interface
 * @export
 */
export const ApplicationMainCallsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationMainCallsApiAxiosParamCreator(configuration)
    return {
        /**
         * To delete the application you must have the admin permission
         * @summary Delete application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApplication(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApplication(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - To edit the application you must have the admin permission. - For port edition, if you provide a port id, we will update the corresponding port. If you don\'t we will create a new one. If you remove a port from the payload, we will delete it. - For storage edition, if you provide a storage id, we will update the corresponding storage. If you don\'t we will create a new one. If you remove a storage from the payload, we will delete it. 
         * @summary Edit application
         * @param {string} applicationId Application ID
         * @param {ApplicationEditRequest} [applicationEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editApplication(applicationId: string, applicationEditRequest?: ApplicationEditRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Application>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editApplication(applicationId, applicationEditRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get application by ID
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplication(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Application>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplication(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get application status
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationStatus(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationStatus(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns list of the last 100 commits made on the repository linked to the application
         * @summary List last commits
         * @param {string} applicationId Application ID
         * @param {string} [startId] Starting point after which to return results
         * @param {string} [gitCommitId] Git Commit ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplicationCommit(applicationId: string, startId?: string, gitCommitId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommitResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplicationCommit(applicationId, startId, gitCommitId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List contributors
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplicationContributor(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplicationContributor(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This will return all the custom domains and Qovery autogenerated domain for the given application
         * @summary List all URLs of the application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplicationLinks(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplicationLinks(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApplicationMainCallsApi - factory interface
 * @export
 */
export const ApplicationMainCallsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationMainCallsApiFp(configuration)
    return {
        /**
         * To delete the application you must have the admin permission
         * @summary Delete application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplication(applicationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteApplication(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * - To edit the application you must have the admin permission. - For port edition, if you provide a port id, we will update the corresponding port. If you don\'t we will create a new one. If you remove a port from the payload, we will delete it. - For storage edition, if you provide a storage id, we will update the corresponding storage. If you don\'t we will create a new one. If you remove a storage from the payload, we will delete it. 
         * @summary Edit application
         * @param {string} applicationId Application ID
         * @param {ApplicationEditRequest} [applicationEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editApplication(applicationId: string, applicationEditRequest?: ApplicationEditRequest, options?: any): AxiosPromise<Application> {
            return localVarFp.editApplication(applicationId, applicationEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get application by ID
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplication(applicationId: string, options?: any): AxiosPromise<Application> {
            return localVarFp.getApplication(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get application status
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationStatus(applicationId: string, options?: any): AxiosPromise<Status> {
            return localVarFp.getApplicationStatus(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns list of the last 100 commits made on the repository linked to the application
         * @summary List last commits
         * @param {string} applicationId Application ID
         * @param {string} [startId] Starting point after which to return results
         * @param {string} [gitCommitId] Git Commit ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationCommit(applicationId: string, startId?: string, gitCommitId?: string, options?: any): AxiosPromise<CommitResponseList> {
            return localVarFp.listApplicationCommit(applicationId, startId, gitCommitId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List contributors
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationContributor(applicationId: string, options?: any): AxiosPromise<UserResponseList> {
            return localVarFp.listApplicationContributor(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * This will return all the custom domains and Qovery autogenerated domain for the given application
         * @summary List all URLs of the application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationLinks(applicationId: string, options?: any): AxiosPromise<LinkResponseList> {
            return localVarFp.listApplicationLinks(applicationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationMainCallsApi - object-oriented interface
 * @export
 * @class ApplicationMainCallsApi
 * @extends {BaseAPI}
 */
export class ApplicationMainCallsApi extends BaseAPI {
    /**
     * To delete the application you must have the admin permission
     * @summary Delete application
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationMainCallsApi
     */
    public deleteApplication(applicationId: string, options?: AxiosRequestConfig) {
        return ApplicationMainCallsApiFp(this.configuration).deleteApplication(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - To edit the application you must have the admin permission. - For port edition, if you provide a port id, we will update the corresponding port. If you don\'t we will create a new one. If you remove a port from the payload, we will delete it. - For storage edition, if you provide a storage id, we will update the corresponding storage. If you don\'t we will create a new one. If you remove a storage from the payload, we will delete it. 
     * @summary Edit application
     * @param {string} applicationId Application ID
     * @param {ApplicationEditRequest} [applicationEditRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationMainCallsApi
     */
    public editApplication(applicationId: string, applicationEditRequest?: ApplicationEditRequest, options?: AxiosRequestConfig) {
        return ApplicationMainCallsApiFp(this.configuration).editApplication(applicationId, applicationEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get application by ID
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationMainCallsApi
     */
    public getApplication(applicationId: string, options?: AxiosRequestConfig) {
        return ApplicationMainCallsApiFp(this.configuration).getApplication(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get application status
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationMainCallsApi
     */
    public getApplicationStatus(applicationId: string, options?: AxiosRequestConfig) {
        return ApplicationMainCallsApiFp(this.configuration).getApplicationStatus(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns list of the last 100 commits made on the repository linked to the application
     * @summary List last commits
     * @param {string} applicationId Application ID
     * @param {string} [startId] Starting point after which to return results
     * @param {string} [gitCommitId] Git Commit ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationMainCallsApi
     */
    public listApplicationCommit(applicationId: string, startId?: string, gitCommitId?: string, options?: AxiosRequestConfig) {
        return ApplicationMainCallsApiFp(this.configuration).listApplicationCommit(applicationId, startId, gitCommitId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List contributors
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationMainCallsApi
     */
    public listApplicationContributor(applicationId: string, options?: AxiosRequestConfig) {
        return ApplicationMainCallsApiFp(this.configuration).listApplicationContributor(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will return all the custom domains and Qovery autogenerated domain for the given application
     * @summary List all URLs of the application
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationMainCallsApi
     */
    public listApplicationLinks(applicationId: string, options?: AxiosRequestConfig) {
        return ApplicationMainCallsApiFp(this.configuration).listApplicationLinks(applicationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ApplicationSecretApi - axios parameter creator
 * @export
 */
export const ApplicationSecretApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * - Add a secret to the application. 
         * @summary Add a secret to the application
         * @param {string} applicationId Application ID
         * @param {SecretRequest} [secretRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationSecret: async (applicationId: string, secretRequest?: SecretRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('createApplicationSecret', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/secret`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(secretRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to add an alias at application level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at application level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - You can\'t create an alias on an alias 
         * @summary Create a secret alias at the application level
         * @param {string} applicationId Application ID
         * @param {string} secretId Secret ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationSecretAlias: async (applicationId: string, secretId: string, key?: Key, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('createApplicationSecretAlias', 'applicationId', applicationId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('createApplicationSecretAlias', 'secretId', secretId)
            const localVarPath = `/application/{applicationId}/secret/{secretId}/alias`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(key, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to override at application level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at application level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
         * @summary Create a secret override at the application level
         * @param {string} applicationId Application ID
         * @param {string} secretId Secret ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationSecretOverride: async (applicationId: string, secretId: string, value?: Value, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('createApplicationSecretOverride', 'applicationId', applicationId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('createApplicationSecretOverride', 'secretId', secretId)
            const localVarPath = `/application/{applicationId}/secret/{secretId}/override`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(value, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete a secret from an application
         * @param {string} applicationId Application ID
         * @param {string} secretId Secret ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationSecret: async (applicationId: string, secretId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('deleteApplicationSecret', 'applicationId', applicationId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('deleteApplicationSecret', 'secretId', secretId)
            const localVarPath = `/application/{applicationId}/secret/{secretId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit a secret belonging to the application
         * @param {string} applicationId Application ID
         * @param {string} secretId Secret ID
         * @param {SecretEditRequest} secretEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editApplicationSecret: async (applicationId: string, secretId: string, secretEditRequest: SecretEditRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('editApplicationSecret', 'applicationId', applicationId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('editApplicationSecret', 'secretId', secretId)
            // verify required parameter 'secretEditRequest' is not null or undefined
            assertParamExists('editApplicationSecret', 'secretEditRequest', secretEditRequest)
            const localVarPath = `/application/{applicationId}/secret/{secretId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(secretEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Secrets are like environment variables, but they are secured and can\'t be revealed.
         * @summary List application secrets
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationSecrets: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('listApplicationSecrets', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/secret`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationSecretApi - functional programming interface
 * @export
 */
export const ApplicationSecretApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationSecretApiAxiosParamCreator(configuration)
    return {
        /**
         * - Add a secret to the application. 
         * @summary Add a secret to the application
         * @param {string} applicationId Application ID
         * @param {SecretRequest} [secretRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplicationSecret(applicationId: string, secretRequest?: SecretRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplicationSecret(applicationId, secretRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - Allows you to add an alias at application level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at application level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - You can\'t create an alias on an alias 
         * @summary Create a secret alias at the application level
         * @param {string} applicationId Application ID
         * @param {string} secretId Secret ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplicationSecretAlias(applicationId: string, secretId: string, key?: Key, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplicationSecretAlias(applicationId, secretId, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - Allows you to override at application level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at application level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
         * @summary Create a secret override at the application level
         * @param {string} applicationId Application ID
         * @param {string} secretId Secret ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplicationSecretOverride(applicationId: string, secretId: string, value?: Value, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplicationSecretOverride(applicationId, secretId, value, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete a secret from an application
         * @param {string} applicationId Application ID
         * @param {string} secretId Secret ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApplicationSecret(applicationId: string, secretId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApplicationSecret(applicationId, secretId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit a secret belonging to the application
         * @param {string} applicationId Application ID
         * @param {string} secretId Secret ID
         * @param {SecretEditRequest} secretEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editApplicationSecret(applicationId: string, secretId: string, secretEditRequest: SecretEditRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editApplicationSecret(applicationId, secretId, secretEditRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Secrets are like environment variables, but they are secured and can\'t be revealed.
         * @summary List application secrets
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplicationSecrets(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecretResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplicationSecrets(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApplicationSecretApi - factory interface
 * @export
 */
export const ApplicationSecretApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationSecretApiFp(configuration)
    return {
        /**
         * - Add a secret to the application. 
         * @summary Add a secret to the application
         * @param {string} applicationId Application ID
         * @param {SecretRequest} [secretRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationSecret(applicationId: string, secretRequest?: SecretRequest, options?: any): AxiosPromise<Secret> {
            return localVarFp.createApplicationSecret(applicationId, secretRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to add an alias at application level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at application level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - You can\'t create an alias on an alias 
         * @summary Create a secret alias at the application level
         * @param {string} applicationId Application ID
         * @param {string} secretId Secret ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationSecretAlias(applicationId: string, secretId: string, key?: Key, options?: any): AxiosPromise<Secret> {
            return localVarFp.createApplicationSecretAlias(applicationId, secretId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to override at application level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at application level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
         * @summary Create a secret override at the application level
         * @param {string} applicationId Application ID
         * @param {string} secretId Secret ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationSecretOverride(applicationId: string, secretId: string, value?: Value, options?: any): AxiosPromise<Secret> {
            return localVarFp.createApplicationSecretOverride(applicationId, secretId, value, options).then((request) => request(axios, basePath));
        },
        /**
         * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete a secret from an application
         * @param {string} applicationId Application ID
         * @param {string} secretId Secret ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationSecret(applicationId: string, secretId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteApplicationSecret(applicationId, secretId, options).then((request) => request(axios, basePath));
        },
        /**
         * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit a secret belonging to the application
         * @param {string} applicationId Application ID
         * @param {string} secretId Secret ID
         * @param {SecretEditRequest} secretEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editApplicationSecret(applicationId: string, secretId: string, secretEditRequest: SecretEditRequest, options?: any): AxiosPromise<Secret> {
            return localVarFp.editApplicationSecret(applicationId, secretId, secretEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Secrets are like environment variables, but they are secured and can\'t be revealed.
         * @summary List application secrets
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationSecrets(applicationId: string, options?: any): AxiosPromise<SecretResponseList> {
            return localVarFp.listApplicationSecrets(applicationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationSecretApi - object-oriented interface
 * @export
 * @class ApplicationSecretApi
 * @extends {BaseAPI}
 */
export class ApplicationSecretApi extends BaseAPI {
    /**
     * - Add a secret to the application. 
     * @summary Add a secret to the application
     * @param {string} applicationId Application ID
     * @param {SecretRequest} [secretRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationSecretApi
     */
    public createApplicationSecret(applicationId: string, secretRequest?: SecretRequest, options?: AxiosRequestConfig) {
        return ApplicationSecretApiFp(this.configuration).createApplicationSecret(applicationId, secretRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to add an alias at application level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at application level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - You can\'t create an alias on an alias 
     * @summary Create a secret alias at the application level
     * @param {string} applicationId Application ID
     * @param {string} secretId Secret ID
     * @param {Key} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationSecretApi
     */
    public createApplicationSecretAlias(applicationId: string, secretId: string, key?: Key, options?: AxiosRequestConfig) {
        return ApplicationSecretApiFp(this.configuration).createApplicationSecretAlias(applicationId, secretId, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to override at application level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at application level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
     * @summary Create a secret override at the application level
     * @param {string} applicationId Application ID
     * @param {string} secretId Secret ID
     * @param {Value} [value] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationSecretApi
     */
    public createApplicationSecretOverride(applicationId: string, secretId: string, value?: Value, options?: AxiosRequestConfig) {
        return ApplicationSecretApiFp(this.configuration).createApplicationSecretOverride(applicationId, secretId, value, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well 
     * @summary Delete a secret from an application
     * @param {string} applicationId Application ID
     * @param {string} secretId Secret ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationSecretApi
     */
    public deleteApplicationSecret(applicationId: string, secretId: string, options?: AxiosRequestConfig) {
        return ApplicationSecretApiFp(this.configuration).deleteApplicationSecret(applicationId, secretId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
     * @summary Edit a secret belonging to the application
     * @param {string} applicationId Application ID
     * @param {string} secretId Secret ID
     * @param {SecretEditRequest} secretEditRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationSecretApi
     */
    public editApplicationSecret(applicationId: string, secretId: string, secretEditRequest: SecretEditRequest, options?: AxiosRequestConfig) {
        return ApplicationSecretApiFp(this.configuration).editApplicationSecret(applicationId, secretId, secretEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Secrets are like environment variables, but they are secured and can\'t be revealed.
     * @summary List application secrets
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationSecretApi
     */
    public listApplicationSecrets(applicationId: string, options?: AxiosRequestConfig) {
        return ApplicationSecretApiFp(this.configuration).listApplicationSecrets(applicationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ApplicationsApi - axios parameter creator
 * @export
 */
export const ApplicationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This will create a new application with the same configuration on the targeted environment Id.
         * @summary Clone application
         * @param {string} applicationId Application ID
         * @param {CloneServiceRequest} [cloneServiceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneApplication: async (applicationId: string, cloneServiceRequest?: CloneServiceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('cloneApplication', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/clone`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloneServiceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an application
         * @param {string} environmentId Environment ID
         * @param {ApplicationRequest} [applicationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplication: async (environmentId: string, applicationRequest?: ApplicationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('createApplication', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/application`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(applicationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Default values for each setting are available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/advanced-settings/)
         * @summary List default application advanced settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultApplicationAdvancedSettings: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/defaultApplicationAdvancedSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of applications with only their id and status.
         * @summary List all environment applications statuses
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentApplicationStatus: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('getEnvironmentApplicationStatus', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/application/status`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns list of languages supported by Buildpacks.
         * @summary List supported languages
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentApplicationSupportedLanguages: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('getEnvironmentApplicationSupportedLanguages', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/application/supportedLanguage`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List applications
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplication: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('listApplication', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/application`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationsApi - functional programming interface
 * @export
 */
export const ApplicationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationsApiAxiosParamCreator(configuration)
    return {
        /**
         * This will create a new application with the same configuration on the targeted environment Id.
         * @summary Clone application
         * @param {string} applicationId Application ID
         * @param {CloneServiceRequest} [cloneServiceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloneApplication(applicationId: string, cloneServiceRequest?: CloneServiceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Application>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cloneApplication(applicationId, cloneServiceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create an application
         * @param {string} environmentId Environment ID
         * @param {ApplicationRequest} [applicationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplication(environmentId: string, applicationRequest?: ApplicationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Application>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplication(environmentId, applicationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Default values for each setting are available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/advanced-settings/)
         * @summary List default application advanced settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDefaultApplicationAdvancedSettings(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationAdvancedSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDefaultApplicationAdvancedSettings(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of applications with only their id and status.
         * @summary List all environment applications statuses
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironmentApplicationStatus(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReferenceObjectStatusResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironmentApplicationStatus(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns list of languages supported by Buildpacks.
         * @summary List supported languages
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironmentApplicationSupportedLanguages(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentApplicationsSupportedLanguageList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironmentApplicationSupportedLanguages(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List applications
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplication(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplication(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApplicationsApi - factory interface
 * @export
 */
export const ApplicationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationsApiFp(configuration)
    return {
        /**
         * This will create a new application with the same configuration on the targeted environment Id.
         * @summary Clone application
         * @param {string} applicationId Application ID
         * @param {CloneServiceRequest} [cloneServiceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneApplication(applicationId: string, cloneServiceRequest?: CloneServiceRequest, options?: any): AxiosPromise<Application> {
            return localVarFp.cloneApplication(applicationId, cloneServiceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create an application
         * @param {string} environmentId Environment ID
         * @param {ApplicationRequest} [applicationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplication(environmentId: string, applicationRequest?: ApplicationRequest, options?: any): AxiosPromise<Application> {
            return localVarFp.createApplication(environmentId, applicationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Default values for each setting are available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/advanced-settings/)
         * @summary List default application advanced settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultApplicationAdvancedSettings(options?: any): AxiosPromise<ApplicationAdvancedSettings> {
            return localVarFp.getDefaultApplicationAdvancedSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of applications with only their id and status.
         * @summary List all environment applications statuses
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentApplicationStatus(environmentId: string, options?: any): AxiosPromise<ReferenceObjectStatusResponseList> {
            return localVarFp.getEnvironmentApplicationStatus(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns list of languages supported by Buildpacks.
         * @summary List supported languages
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentApplicationSupportedLanguages(environmentId: string, options?: any): AxiosPromise<EnvironmentApplicationsSupportedLanguageList> {
            return localVarFp.getEnvironmentApplicationSupportedLanguages(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List applications
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplication(environmentId: string, options?: any): AxiosPromise<ApplicationResponseList> {
            return localVarFp.listApplication(environmentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationsApi - object-oriented interface
 * @export
 * @class ApplicationsApi
 * @extends {BaseAPI}
 */
export class ApplicationsApi extends BaseAPI {
    /**
     * This will create a new application with the same configuration on the targeted environment Id.
     * @summary Clone application
     * @param {string} applicationId Application ID
     * @param {CloneServiceRequest} [cloneServiceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public cloneApplication(applicationId: string, cloneServiceRequest?: CloneServiceRequest, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).cloneApplication(applicationId, cloneServiceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create an application
     * @param {string} environmentId Environment ID
     * @param {ApplicationRequest} [applicationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public createApplication(environmentId: string, applicationRequest?: ApplicationRequest, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).createApplication(environmentId, applicationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Default values for each setting are available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/advanced-settings/)
     * @summary List default application advanced settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public getDefaultApplicationAdvancedSettings(options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).getDefaultApplicationAdvancedSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of applications with only their id and status.
     * @summary List all environment applications statuses
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public getEnvironmentApplicationStatus(environmentId: string, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).getEnvironmentApplicationStatus(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns list of languages supported by Buildpacks.
     * @summary List supported languages
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public getEnvironmentApplicationSupportedLanguages(environmentId: string, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).getEnvironmentApplicationSupportedLanguages(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List applications
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public listApplication(environmentId: string, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).listApplication(environmentId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BackupsApi - axios parameter creator
 * @export
 */
export const BackupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a backup to the Database 
         * @param {string} databaseId Database ID
         * @param {BackupRequest} [backupRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addBackupDatabase: async (databaseId: string, backupRequest?: BackupRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('addBackupDatabase', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}/backup`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(backupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter
         * @summary List database  backups
         * @param {string} databaseId Database ID
         * @param {string} [startId] Starting point after which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseBackup: async (databaseId: string, startId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('listDatabaseBackup', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}/backup`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (startId !== undefined) {
                localVarQueryParameter['startId'] = startId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove database  backup
         * @param {string} databaseId Database ID
         * @param {string} backupId Database Backup ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDatabaseBackup: async (databaseId: string, backupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('removeDatabaseBackup', 'databaseId', databaseId)
            // verify required parameter 'backupId' is not null or undefined
            assertParamExists('removeDatabaseBackup', 'backupId', backupId)
            const localVarPath = `/database/{databaseId}/backup/{backupId}`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)))
                .replace(`{${"backupId"}}`, encodeURIComponent(String(backupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BackupsApi - functional programming interface
 * @export
 */
export const BackupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BackupsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a backup to the Database 
         * @param {string} databaseId Database ID
         * @param {BackupRequest} [backupRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addBackupDatabase(databaseId: string, backupRequest?: BackupRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Backup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addBackupDatabase(databaseId, backupRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter
         * @summary List database  backups
         * @param {string} databaseId Database ID
         * @param {string} [startId] Starting point after which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDatabaseBackup(databaseId: string, startId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BackupPaginatedResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDatabaseBackup(databaseId, startId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove database  backup
         * @param {string} databaseId Database ID
         * @param {string} backupId Database Backup ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeDatabaseBackup(databaseId: string, backupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeDatabaseBackup(databaseId, backupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BackupsApi - factory interface
 * @export
 */
export const BackupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BackupsApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a backup to the Database 
         * @param {string} databaseId Database ID
         * @param {BackupRequest} [backupRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addBackupDatabase(databaseId: string, backupRequest?: BackupRequest, options?: any): AxiosPromise<Backup> {
            return localVarFp.addBackupDatabase(databaseId, backupRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter
         * @summary List database  backups
         * @param {string} databaseId Database ID
         * @param {string} [startId] Starting point after which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseBackup(databaseId: string, startId?: string, options?: any): AxiosPromise<BackupPaginatedResponseList> {
            return localVarFp.listDatabaseBackup(databaseId, startId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove database  backup
         * @param {string} databaseId Database ID
         * @param {string} backupId Database Backup ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDatabaseBackup(databaseId: string, backupId: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeDatabaseBackup(databaseId, backupId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BackupsApi - object-oriented interface
 * @export
 * @class BackupsApi
 * @extends {BaseAPI}
 */
export class BackupsApi extends BaseAPI {
    /**
     * 
     * @summary Add a backup to the Database 
     * @param {string} databaseId Database ID
     * @param {BackupRequest} [backupRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackupsApi
     */
    public addBackupDatabase(databaseId: string, backupRequest?: BackupRequest, options?: AxiosRequestConfig) {
        return BackupsApiFp(this.configuration).addBackupDatabase(databaseId, backupRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter
     * @summary List database  backups
     * @param {string} databaseId Database ID
     * @param {string} [startId] Starting point after which to return results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackupsApi
     */
    public listDatabaseBackup(databaseId: string, startId?: string, options?: AxiosRequestConfig) {
        return BackupsApiFp(this.configuration).listDatabaseBackup(databaseId, startId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove database  backup
     * @param {string} databaseId Database ID
     * @param {string} backupId Database Backup ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackupsApi
     */
    public removeDatabaseBackup(databaseId: string, backupId: string, options?: AxiosRequestConfig) {
        return BackupsApiFp(this.configuration).removeDatabaseBackup(databaseId, backupId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BillingApi - axios parameter creator
 * @export
 */
export const BillingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add credit card
         * @param {string} organizationId Organization ID
         * @param {CreditCardRequest} [creditCardRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCreditCard: async (organizationId: string, creditCardRequest?: CreditCardRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('addCreditCard', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/creditCard`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(creditCardRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add credit code
         * @param {string} organizationId Organization ID
         * @param {OrganizationCreditCodeRequest} [organizationCreditCodeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCreditCode: async (organizationId: string, organizationCreditCodeRequest?: OrganizationCreditCodeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('addCreditCode', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/creditCode`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationCreditCodeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Change organization plan
         * @param {string} organizationId Organization ID
         * @param {OrganizationChangePlanRequest} [organizationChangePlanRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePlan: async (organizationId: string, organizationChangePlanRequest?: OrganizationChangePlanRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('changePlan', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/changePlan`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationChangePlanRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete credit card
         * @param {string} organizationId Organization ID
         * @param {string} creditCardId Credit Card ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCreditCard: async (organizationId: string, creditCardId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteCreditCard', 'organizationId', organizationId)
            // verify required parameter 'creditCardId' is not null or undefined
            assertParamExists('deleteCreditCard', 'creditCardId', creditCardId)
            const localVarPath = `/organization/{organizationId}/creditCard/{creditCardId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"creditCardId"}}`, encodeURIComponent(String(creditCardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit Organization Billing Info
         * @param {string} organizationId Organization ID
         * @param {BillingInfoRequest} [billingInfoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editOrganizationBillingInfo: async (organizationId: string, billingInfoRequest?: BillingInfoRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('editOrganizationBillingInfo', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/billingInfo`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(billingInfoRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generate organization billing usage report
         * @param {string} organizationId Organization ID
         * @param {OrganizationBillingUsageReportRequest} [organizationBillingUsageReportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateBillingUsageReport: async (organizationId: string, organizationBillingUsageReportRequest?: OrganizationBillingUsageReportRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('generateBillingUsageReport', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/billingUsageReport`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationBillingUsageReportRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get your cluster cost range. We are unable to give a precise cost of your infrastructure at the moment. But Qovery guarantees that the cost of your cluster will not exceed the max range. 
         * @summary Get cluster current cost
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterCurrentCost: async (organizationId: string, clusterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getClusterCurrentCost', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('getClusterCurrentCost', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}/currentCost`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns the external ID of the organization\'s billing account. 
         * @summary Get organization billing external ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationBillingExternalId: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationBillingExternalId', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/billingExternalId`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get organization billing info
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationBillingInfo: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationBillingInfo', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/billingInfo`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns a \"is_valid\" boolean field reflecting the billing status of the organization: - If true, the organization billing is valid - For Startup organization, it returns false if there is at least 1 invoice unpaid since 1 week - For Community organization, it returns false if there is no credit left 
         * @summary Get organization billing status
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationBillingStatus: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationBillingStatus', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/billingStatus`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get organization current cost
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationCurrentCost: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationCurrentCost', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/currentCost`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get organization invoice
         * @param {string} organizationId Organization ID
         * @param {string} invoiceId Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationInvoice: async (organizationId: string, invoiceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationInvoice', 'organizationId', organizationId)
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('getOrganizationInvoice', 'invoiceId', invoiceId)
            const localVarPath = `/organization/{organizationId}/invoice/{invoiceId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This will return URL of the invoice PDF
         * @summary Get invoice link
         * @param {string} organizationId Organization ID
         * @param {string} invoiceId Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationInvoicePDF: async (organizationId: string, invoiceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationInvoicePDF', 'organizationId', organizationId)
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('getOrganizationInvoicePDF', 'invoiceId', invoiceId)
            const localVarPath = `/organization/{organizationId}/invoice/{invoiceId}/download`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List organization credit cards
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationCreditCards: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listOrganizationCreditCards', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/creditCard`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List organization invoices
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationInvoice: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listOrganizationInvoice', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/invoice`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download all invoices
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationDownloadAllInvoices: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('organizationDownloadAllInvoices', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/downloadInvoices`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BillingApi - functional programming interface
 * @export
 */
export const BillingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BillingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add credit card
         * @param {string} organizationId Organization ID
         * @param {CreditCardRequest} [creditCardRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addCreditCard(organizationId: string, creditCardRequest?: CreditCardRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditCard>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addCreditCard(organizationId, creditCardRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add credit code
         * @param {string} organizationId Organization ID
         * @param {OrganizationCreditCodeRequest} [organizationCreditCodeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addCreditCode(organizationId: string, organizationCreditCodeRequest?: OrganizationCreditCodeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addCreditCode(organizationId, organizationCreditCodeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Change organization plan
         * @param {string} organizationId Organization ID
         * @param {OrganizationChangePlanRequest} [organizationChangePlanRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changePlan(organizationId: string, organizationChangePlanRequest?: OrganizationChangePlanRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changePlan(organizationId, organizationChangePlanRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete credit card
         * @param {string} organizationId Organization ID
         * @param {string} creditCardId Credit Card ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCreditCard(organizationId: string, creditCardId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCreditCard(organizationId, creditCardId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit Organization Billing Info
         * @param {string} organizationId Organization ID
         * @param {BillingInfoRequest} [billingInfoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editOrganizationBillingInfo(organizationId: string, billingInfoRequest?: BillingInfoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BillingInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editOrganizationBillingInfo(organizationId, billingInfoRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Generate organization billing usage report
         * @param {string} organizationId Organization ID
         * @param {OrganizationBillingUsageReportRequest} [organizationBillingUsageReportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateBillingUsageReport(organizationId: string, organizationBillingUsageReportRequest?: OrganizationBillingUsageReportRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationBillingUsageReportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateBillingUsageReport(organizationId, organizationBillingUsageReportRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get your cluster cost range. We are unable to give a precise cost of your infrastructure at the moment. But Qovery guarantees that the cost of your cluster will not exceed the max range. 
         * @summary Get cluster current cost
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClusterCurrentCost(organizationId: string, clusterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CostRange>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClusterCurrentCost(organizationId, clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns the external ID of the organization\'s billing account. 
         * @summary Get organization billing external ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationBillingExternalId(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BillingExternalId>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationBillingExternalId(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get organization billing info
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationBillingInfo(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BillingInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationBillingInfo(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns a \"is_valid\" boolean field reflecting the billing status of the organization: - If true, the organization billing is valid - For Startup organization, it returns false if there is at least 1 invoice unpaid since 1 week - For Community organization, it returns false if there is no credit left 
         * @summary Get organization billing status
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationBillingStatus(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BillingStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationBillingStatus(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get organization current cost
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationCurrentCost(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationCurrentCost>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationCurrentCost(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get organization invoice
         * @param {string} organizationId Organization ID
         * @param {string} invoiceId Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationInvoice(organizationId: string, invoiceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invoice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationInvoice(organizationId, invoiceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This will return URL of the invoice PDF
         * @summary Get invoice link
         * @param {string} organizationId Organization ID
         * @param {string} invoiceId Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationInvoicePDF(organizationId: string, invoiceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Link>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationInvoicePDF(organizationId, invoiceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List organization credit cards
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizationCreditCards(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditCardResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationCreditCards(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List organization invoices
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizationInvoice(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationInvoice(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Download all invoices
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationDownloadAllInvoices(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationDownloadAllInvoices(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BillingApi - factory interface
 * @export
 */
export const BillingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BillingApiFp(configuration)
    return {
        /**
         * 
         * @summary Add credit card
         * @param {string} organizationId Organization ID
         * @param {CreditCardRequest} [creditCardRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCreditCard(organizationId: string, creditCardRequest?: CreditCardRequest, options?: any): AxiosPromise<CreditCard> {
            return localVarFp.addCreditCard(organizationId, creditCardRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add credit code
         * @param {string} organizationId Organization ID
         * @param {OrganizationCreditCodeRequest} [organizationCreditCodeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCreditCode(organizationId: string, organizationCreditCodeRequest?: OrganizationCreditCodeRequest, options?: any): AxiosPromise<void> {
            return localVarFp.addCreditCode(organizationId, organizationCreditCodeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Change organization plan
         * @param {string} organizationId Organization ID
         * @param {OrganizationChangePlanRequest} [organizationChangePlanRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePlan(organizationId: string, organizationChangePlanRequest?: OrganizationChangePlanRequest, options?: any): AxiosPromise<Organization> {
            return localVarFp.changePlan(organizationId, organizationChangePlanRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete credit card
         * @param {string} organizationId Organization ID
         * @param {string} creditCardId Credit Card ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCreditCard(organizationId: string, creditCardId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCreditCard(organizationId, creditCardId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit Organization Billing Info
         * @param {string} organizationId Organization ID
         * @param {BillingInfoRequest} [billingInfoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editOrganizationBillingInfo(organizationId: string, billingInfoRequest?: BillingInfoRequest, options?: any): AxiosPromise<BillingInfo> {
            return localVarFp.editOrganizationBillingInfo(organizationId, billingInfoRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Generate organization billing usage report
         * @param {string} organizationId Organization ID
         * @param {OrganizationBillingUsageReportRequest} [organizationBillingUsageReportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateBillingUsageReport(organizationId: string, organizationBillingUsageReportRequest?: OrganizationBillingUsageReportRequest, options?: any): AxiosPromise<OrganizationBillingUsageReportResponse> {
            return localVarFp.generateBillingUsageReport(organizationId, organizationBillingUsageReportRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get your cluster cost range. We are unable to give a precise cost of your infrastructure at the moment. But Qovery guarantees that the cost of your cluster will not exceed the max range. 
         * @summary Get cluster current cost
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterCurrentCost(organizationId: string, clusterId: string, options?: any): AxiosPromise<CostRange> {
            return localVarFp.getClusterCurrentCost(organizationId, clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns the external ID of the organization\'s billing account. 
         * @summary Get organization billing external ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationBillingExternalId(organizationId: string, options?: any): AxiosPromise<BillingExternalId> {
            return localVarFp.getOrganizationBillingExternalId(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get organization billing info
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationBillingInfo(organizationId: string, options?: any): AxiosPromise<BillingInfo> {
            return localVarFp.getOrganizationBillingInfo(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a \"is_valid\" boolean field reflecting the billing status of the organization: - If true, the organization billing is valid - For Startup organization, it returns false if there is at least 1 invoice unpaid since 1 week - For Community organization, it returns false if there is no credit left 
         * @summary Get organization billing status
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationBillingStatus(organizationId: string, options?: any): AxiosPromise<BillingStatus> {
            return localVarFp.getOrganizationBillingStatus(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get organization current cost
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationCurrentCost(organizationId: string, options?: any): AxiosPromise<OrganizationCurrentCost> {
            return localVarFp.getOrganizationCurrentCost(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get organization invoice
         * @param {string} organizationId Organization ID
         * @param {string} invoiceId Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationInvoice(organizationId: string, invoiceId: string, options?: any): AxiosPromise<Invoice> {
            return localVarFp.getOrganizationInvoice(organizationId, invoiceId, options).then((request) => request(axios, basePath));
        },
        /**
         * This will return URL of the invoice PDF
         * @summary Get invoice link
         * @param {string} organizationId Organization ID
         * @param {string} invoiceId Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationInvoicePDF(organizationId: string, invoiceId: string, options?: any): AxiosPromise<Link> {
            return localVarFp.getOrganizationInvoicePDF(organizationId, invoiceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List organization credit cards
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationCreditCards(organizationId: string, options?: any): AxiosPromise<CreditCardResponseList> {
            return localVarFp.listOrganizationCreditCards(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List organization invoices
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationInvoice(organizationId: string, options?: any): AxiosPromise<InvoiceResponseList> {
            return localVarFp.listOrganizationInvoice(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download all invoices
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationDownloadAllInvoices(organizationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.organizationDownloadAllInvoices(organizationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BillingApi - object-oriented interface
 * @export
 * @class BillingApi
 * @extends {BaseAPI}
 */
export class BillingApi extends BaseAPI {
    /**
     * 
     * @summary Add credit card
     * @param {string} organizationId Organization ID
     * @param {CreditCardRequest} [creditCardRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public addCreditCard(organizationId: string, creditCardRequest?: CreditCardRequest, options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).addCreditCard(organizationId, creditCardRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add credit code
     * @param {string} organizationId Organization ID
     * @param {OrganizationCreditCodeRequest} [organizationCreditCodeRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public addCreditCode(organizationId: string, organizationCreditCodeRequest?: OrganizationCreditCodeRequest, options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).addCreditCode(organizationId, organizationCreditCodeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Change organization plan
     * @param {string} organizationId Organization ID
     * @param {OrganizationChangePlanRequest} [organizationChangePlanRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public changePlan(organizationId: string, organizationChangePlanRequest?: OrganizationChangePlanRequest, options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).changePlan(organizationId, organizationChangePlanRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete credit card
     * @param {string} organizationId Organization ID
     * @param {string} creditCardId Credit Card ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public deleteCreditCard(organizationId: string, creditCardId: string, options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).deleteCreditCard(organizationId, creditCardId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit Organization Billing Info
     * @param {string} organizationId Organization ID
     * @param {BillingInfoRequest} [billingInfoRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public editOrganizationBillingInfo(organizationId: string, billingInfoRequest?: BillingInfoRequest, options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).editOrganizationBillingInfo(organizationId, billingInfoRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Generate organization billing usage report
     * @param {string} organizationId Organization ID
     * @param {OrganizationBillingUsageReportRequest} [organizationBillingUsageReportRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public generateBillingUsageReport(organizationId: string, organizationBillingUsageReportRequest?: OrganizationBillingUsageReportRequest, options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).generateBillingUsageReport(organizationId, organizationBillingUsageReportRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get your cluster cost range. We are unable to give a precise cost of your infrastructure at the moment. But Qovery guarantees that the cost of your cluster will not exceed the max range. 
     * @summary Get cluster current cost
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getClusterCurrentCost(organizationId: string, clusterId: string, options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).getClusterCurrentCost(organizationId, clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns the external ID of the organization\'s billing account. 
     * @summary Get organization billing external ID
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getOrganizationBillingExternalId(organizationId: string, options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).getOrganizationBillingExternalId(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get organization billing info
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getOrganizationBillingInfo(organizationId: string, options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).getOrganizationBillingInfo(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns a \"is_valid\" boolean field reflecting the billing status of the organization: - If true, the organization billing is valid - For Startup organization, it returns false if there is at least 1 invoice unpaid since 1 week - For Community organization, it returns false if there is no credit left 
     * @summary Get organization billing status
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getOrganizationBillingStatus(organizationId: string, options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).getOrganizationBillingStatus(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get organization current cost
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getOrganizationCurrentCost(organizationId: string, options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).getOrganizationCurrentCost(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get organization invoice
     * @param {string} organizationId Organization ID
     * @param {string} invoiceId Invoice ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getOrganizationInvoice(organizationId: string, invoiceId: string, options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).getOrganizationInvoice(organizationId, invoiceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will return URL of the invoice PDF
     * @summary Get invoice link
     * @param {string} organizationId Organization ID
     * @param {string} invoiceId Invoice ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getOrganizationInvoicePDF(organizationId: string, invoiceId: string, options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).getOrganizationInvoicePDF(organizationId, invoiceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List organization credit cards
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public listOrganizationCreditCards(organizationId: string, options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).listOrganizationCreditCards(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List organization invoices
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public listOrganizationInvoice(organizationId: string, options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).listOrganizationInvoice(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download all invoices
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public organizationDownloadAllInvoices(organizationId: string, options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).organizationDownloadAllInvoices(organizationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CloudProviderApi - axios parameter creator
 * @export
 */
export const CloudProviderApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List AWS EKS available instance types
         * @param {string} region region name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAWSEKSInstanceType: async (region: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'region' is not null or undefined
            assertParamExists('listAWSEKSInstanceType', 'region', region)
            const localVarPath = `/aws/eks/instanceType/{region}`
                .replace(`{${"region"}}`, encodeURIComponent(String(region)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List AWS EC2 available instance types
         * @param {string} region region name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAWSEc2InstanceType: async (region: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'region' is not null or undefined
            assertParamExists('listAWSEc2InstanceType', 'region', region)
            const localVarPath = `/aws/ec2/instanceType/{region}`
                .replace(`{${"region"}}`, encodeURIComponent(String(region)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List AWS features available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAWSFeatures: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/aws/clusterFeature`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List AWS available instance types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAWSInstanceType: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/aws/instanceType`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List AWS available managed database instance types
         * @param {string} region region name
         * @param {string} databaseType Database type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAWSManagedDatabaseInstanceType: async (region: string, databaseType: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'region' is not null or undefined
            assertParamExists('listAWSManagedDatabaseInstanceType', 'region', region)
            // verify required parameter 'databaseType' is not null or undefined
            assertParamExists('listAWSManagedDatabaseInstanceType', 'databaseType', databaseType)
            const localVarPath = `/aws/managedDatabase/instanceType/{region}/{databaseType}`
                .replace(`{${"region"}}`, encodeURIComponent(String(region)))
                .replace(`{${"databaseType"}}`, encodeURIComponent(String(databaseType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List AWS available managed database types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAWSManagedDatabaseType: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/aws/managedDatabase/type`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List AWS regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAWSRegions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/aws/region`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Cloud providers available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCloudProvider: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cloudProvider`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List GCP features available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGcpFeatures: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/gcp/clusterFeature`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List GCP GKE available instance types
         * @param {string} region region name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGcpGkeInstanceType: async (region: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'region' is not null or undefined
            assertParamExists('listGcpGkeInstanceType', 'region', region)
            const localVarPath = `/gcp/instanceType/{region}`
                .replace(`{${"region"}}`, encodeURIComponent(String(region)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List GCP regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGcpRegions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/gcp/region`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Scaleway available managed database instance types
         * @param {string} databaseType Database type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSCWManagedDatabaseInstanceType: async (databaseType: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseType' is not null or undefined
            assertParamExists('listSCWManagedDatabaseInstanceType', 'databaseType', databaseType)
            const localVarPath = `/scaleway/managedDatabase/instanceType/{zone}/{databaseType}`
                .replace(`{${"databaseType"}}`, encodeURIComponent(String(databaseType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Scaleway available managed database types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSCWManagedDatabaseType: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/scaleway/managedDatabase/type`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Scaleway features available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScalewayFeatures: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/scaleway/clusterFeature`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Scaleway available instance types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScalewayInstanceType: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/scaleway/instanceType`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Scaleway Kapsule available instance types
         * @param {string} zone zone name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScalewayKapsuleInstanceType: async (zone: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zone' is not null or undefined
            assertParamExists('listScalewayKapsuleInstanceType', 'zone', zone)
            const localVarPath = `/scaleway/instanceType/{zone}`
                .replace(`{${"zone"}}`, encodeURIComponent(String(zone)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Scaleway regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScalewayRegions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/scaleway/region`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CloudProviderApi - functional programming interface
 * @export
 */
export const CloudProviderApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CloudProviderApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List AWS EKS available instance types
         * @param {string} region region name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAWSEKSInstanceType(region: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterInstanceTypeResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAWSEKSInstanceType(region, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List AWS EC2 available instance types
         * @param {string} region region name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAWSEc2InstanceType(region: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterInstanceTypeResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAWSEc2InstanceType(region, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List AWS features available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAWSFeatures(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterFeatureResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAWSFeatures(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List AWS available instance types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAWSInstanceType(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterInstanceTypeResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAWSInstanceType(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List AWS available managed database instance types
         * @param {string} region region name
         * @param {string} databaseType Database type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAWSManagedDatabaseInstanceType(region: string, databaseType: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManagedDatabaseInstanceTypeResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAWSManagedDatabaseInstanceType(region, databaseType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List AWS available managed database types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAWSManagedDatabaseType(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManagedDatabaseTypeResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAWSManagedDatabaseType(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List AWS regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAWSRegions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterRegionResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAWSRegions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Cloud providers available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCloudProvider(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudProviderResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCloudProvider(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List GCP features available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGcpFeatures(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterFeatureResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGcpFeatures(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List GCP GKE available instance types
         * @param {string} region region name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGcpGkeInstanceType(region: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterInstanceTypeResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGcpGkeInstanceType(region, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List GCP regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGcpRegions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterRegionResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGcpRegions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Scaleway available managed database instance types
         * @param {string} databaseType Database type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSCWManagedDatabaseInstanceType(databaseType: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManagedDatabaseInstanceTypeResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSCWManagedDatabaseInstanceType(databaseType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Scaleway available managed database types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSCWManagedDatabaseType(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManagedDatabaseTypeResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSCWManagedDatabaseType(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Scaleway features available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listScalewayFeatures(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterFeatureResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listScalewayFeatures(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Scaleway available instance types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listScalewayInstanceType(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterInstanceTypeResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listScalewayInstanceType(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Scaleway Kapsule available instance types
         * @param {string} zone zone name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listScalewayKapsuleInstanceType(zone: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterInstanceTypeResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listScalewayKapsuleInstanceType(zone, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Scaleway regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listScalewayRegions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterRegionResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listScalewayRegions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CloudProviderApi - factory interface
 * @export
 */
export const CloudProviderApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CloudProviderApiFp(configuration)
    return {
        /**
         * 
         * @summary List AWS EKS available instance types
         * @param {string} region region name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAWSEKSInstanceType(region: string, options?: any): AxiosPromise<ClusterInstanceTypeResponseList> {
            return localVarFp.listAWSEKSInstanceType(region, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List AWS EC2 available instance types
         * @param {string} region region name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAWSEc2InstanceType(region: string, options?: any): AxiosPromise<ClusterInstanceTypeResponseList> {
            return localVarFp.listAWSEc2InstanceType(region, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List AWS features available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAWSFeatures(options?: any): AxiosPromise<ClusterFeatureResponseList> {
            return localVarFp.listAWSFeatures(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List AWS available instance types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAWSInstanceType(options?: any): AxiosPromise<ClusterInstanceTypeResponseList> {
            return localVarFp.listAWSInstanceType(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List AWS available managed database instance types
         * @param {string} region region name
         * @param {string} databaseType Database type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAWSManagedDatabaseInstanceType(region: string, databaseType: string, options?: any): AxiosPromise<ManagedDatabaseInstanceTypeResponseList> {
            return localVarFp.listAWSManagedDatabaseInstanceType(region, databaseType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List AWS available managed database types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAWSManagedDatabaseType(options?: any): AxiosPromise<ManagedDatabaseTypeResponseList> {
            return localVarFp.listAWSManagedDatabaseType(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List AWS regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAWSRegions(options?: any): AxiosPromise<ClusterRegionResponseList> {
            return localVarFp.listAWSRegions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Cloud providers available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCloudProvider(options?: any): AxiosPromise<CloudProviderResponseList> {
            return localVarFp.listCloudProvider(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List GCP features available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGcpFeatures(options?: any): AxiosPromise<ClusterFeatureResponseList> {
            return localVarFp.listGcpFeatures(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List GCP GKE available instance types
         * @param {string} region region name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGcpGkeInstanceType(region: string, options?: any): AxiosPromise<ClusterInstanceTypeResponseList> {
            return localVarFp.listGcpGkeInstanceType(region, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List GCP regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGcpRegions(options?: any): AxiosPromise<ClusterRegionResponseList> {
            return localVarFp.listGcpRegions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Scaleway available managed database instance types
         * @param {string} databaseType Database type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSCWManagedDatabaseInstanceType(databaseType: string, options?: any): AxiosPromise<ManagedDatabaseInstanceTypeResponseList> {
            return localVarFp.listSCWManagedDatabaseInstanceType(databaseType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Scaleway available managed database types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSCWManagedDatabaseType(options?: any): AxiosPromise<ManagedDatabaseTypeResponseList> {
            return localVarFp.listSCWManagedDatabaseType(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Scaleway features available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScalewayFeatures(options?: any): AxiosPromise<ClusterFeatureResponseList> {
            return localVarFp.listScalewayFeatures(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Scaleway available instance types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScalewayInstanceType(options?: any): AxiosPromise<ClusterInstanceTypeResponseList> {
            return localVarFp.listScalewayInstanceType(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Scaleway Kapsule available instance types
         * @param {string} zone zone name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScalewayKapsuleInstanceType(zone: string, options?: any): AxiosPromise<ClusterInstanceTypeResponseList> {
            return localVarFp.listScalewayKapsuleInstanceType(zone, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Scaleway regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScalewayRegions(options?: any): AxiosPromise<ClusterRegionResponseList> {
            return localVarFp.listScalewayRegions(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CloudProviderApi - object-oriented interface
 * @export
 * @class CloudProviderApi
 * @extends {BaseAPI}
 */
export class CloudProviderApi extends BaseAPI {
    /**
     * 
     * @summary List AWS EKS available instance types
     * @param {string} region region name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listAWSEKSInstanceType(region: string, options?: AxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listAWSEKSInstanceType(region, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List AWS EC2 available instance types
     * @param {string} region region name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listAWSEc2InstanceType(region: string, options?: AxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listAWSEc2InstanceType(region, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List AWS features available
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listAWSFeatures(options?: AxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listAWSFeatures(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List AWS available instance types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listAWSInstanceType(options?: AxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listAWSInstanceType(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List AWS available managed database instance types
     * @param {string} region region name
     * @param {string} databaseType Database type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listAWSManagedDatabaseInstanceType(region: string, databaseType: string, options?: AxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listAWSManagedDatabaseInstanceType(region, databaseType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List AWS available managed database types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listAWSManagedDatabaseType(options?: AxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listAWSManagedDatabaseType(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List AWS regions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listAWSRegions(options?: AxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listAWSRegions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Cloud providers available
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listCloudProvider(options?: AxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listCloudProvider(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List GCP features available
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listGcpFeatures(options?: AxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listGcpFeatures(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List GCP GKE available instance types
     * @param {string} region region name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listGcpGkeInstanceType(region: string, options?: AxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listGcpGkeInstanceType(region, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List GCP regions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listGcpRegions(options?: AxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listGcpRegions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Scaleway available managed database instance types
     * @param {string} databaseType Database type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listSCWManagedDatabaseInstanceType(databaseType: string, options?: AxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listSCWManagedDatabaseInstanceType(databaseType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Scaleway available managed database types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listSCWManagedDatabaseType(options?: AxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listSCWManagedDatabaseType(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Scaleway features available
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listScalewayFeatures(options?: AxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listScalewayFeatures(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Scaleway available instance types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listScalewayInstanceType(options?: AxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listScalewayInstanceType(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Scaleway Kapsule available instance types
     * @param {string} zone zone name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listScalewayKapsuleInstanceType(zone: string, options?: AxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listScalewayKapsuleInstanceType(zone, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Scaleway regions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listScalewayRegions(options?: AxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listScalewayRegions(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CloudProviderCredentialsApi - axios parameter creator
 * @export
 */
export const CloudProviderCredentialsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create AWS credentials set
         * @param {string} organizationId Organization ID
         * @param {AwsCredentialsRequest} [awsCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAWSCredentials: async (organizationId: string, awsCredentialsRequest?: AwsCredentialsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createAWSCredentials', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/aws/credentials`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(awsCredentialsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create GCP credentials set
         * @param {string} organizationId Organization ID
         * @param {GcpCredentialsRequest} [gcpCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGcpCredentials: async (organizationId: string, gcpCredentialsRequest?: GcpCredentialsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createGcpCredentials', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/gcp/credentials`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gcpCredentialsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create OnPremise credentials set
         * @param {string} organizationId Organization ID
         * @param {OnPremiseCredentialsRequest} [onPremiseCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOnPremiseCredentials: async (organizationId: string, onPremiseCredentialsRequest?: OnPremiseCredentialsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createOnPremiseCredentials', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/onPremise/credentials`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(onPremiseCredentialsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Scaleway credentials set
         * @param {string} organizationId Organization ID
         * @param {ScalewayCredentialsRequest} [scalewayCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScalewayCredentials: async (organizationId: string, scalewayCredentialsRequest?: ScalewayCredentialsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createScalewayCredentials', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/scaleway/credentials`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scalewayCredentialsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a set of AWS credentials
         * @param {string} credentialsId Credentials ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAWSCredentials: async (credentialsId: string, organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'credentialsId' is not null or undefined
            assertParamExists('deleteAWSCredentials', 'credentialsId', credentialsId)
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteAWSCredentials', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/aws/credentials/{credentialsId}`
                .replace(`{${"credentialsId"}}`, encodeURIComponent(String(credentialsId)))
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a set of GCP credentials
         * @param {string} credentialsId Credentials ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGcpCredentials: async (credentialsId: string, organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'credentialsId' is not null or undefined
            assertParamExists('deleteGcpCredentials', 'credentialsId', credentialsId)
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteGcpCredentials', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/gcp/credentials/{credentialsId}`
                .replace(`{${"credentialsId"}}`, encodeURIComponent(String(credentialsId)))
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a set of OnPremise credentials
         * @param {string} credentialsId Credentials ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOnPremiseCredentials: async (credentialsId: string, organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'credentialsId' is not null or undefined
            assertParamExists('deleteOnPremiseCredentials', 'credentialsId', credentialsId)
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteOnPremiseCredentials', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/onPremise/credentials/{credentialsId}`
                .replace(`{${"credentialsId"}}`, encodeURIComponent(String(credentialsId)))
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a set of Scaleway credentials
         * @param {string} credentialsId Credentials ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScalewayCredentials: async (credentialsId: string, organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'credentialsId' is not null or undefined
            assertParamExists('deleteScalewayCredentials', 'credentialsId', credentialsId)
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteScalewayCredentials', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/scaleway/credentials/{credentialsId}`
                .replace(`{${"credentialsId"}}`, encodeURIComponent(String(credentialsId)))
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a set of AWS credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {AwsCredentialsRequest} [awsCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editAWSCredentials: async (organizationId: string, credentialsId: string, awsCredentialsRequest?: AwsCredentialsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('editAWSCredentials', 'organizationId', organizationId)
            // verify required parameter 'credentialsId' is not null or undefined
            assertParamExists('editAWSCredentials', 'credentialsId', credentialsId)
            const localVarPath = `/organization/{organizationId}/aws/credentials/{credentialsId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"credentialsId"}}`, encodeURIComponent(String(credentialsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(awsCredentialsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a set of GCP credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {GcpCredentialsRequest} [gcpCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editGcpCredentials: async (organizationId: string, credentialsId: string, gcpCredentialsRequest?: GcpCredentialsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('editGcpCredentials', 'organizationId', organizationId)
            // verify required parameter 'credentialsId' is not null or undefined
            assertParamExists('editGcpCredentials', 'credentialsId', credentialsId)
            const localVarPath = `/organization/{organizationId}/gcp/credentials/{credentialsId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"credentialsId"}}`, encodeURIComponent(String(credentialsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gcpCredentialsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a set of OnPremise credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {OnPremiseCredentialsRequest} [onPremiseCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editOnPremiseCredentials: async (organizationId: string, credentialsId: string, onPremiseCredentialsRequest?: OnPremiseCredentialsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('editOnPremiseCredentials', 'organizationId', organizationId)
            // verify required parameter 'credentialsId' is not null or undefined
            assertParamExists('editOnPremiseCredentials', 'credentialsId', credentialsId)
            const localVarPath = `/organization/{organizationId}/onPremise/credentials/{credentialsId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"credentialsId"}}`, encodeURIComponent(String(credentialsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(onPremiseCredentialsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a set of Scaleway credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {ScalewayCredentialsRequest} [scalewayCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editScalewayCredentials: async (organizationId: string, credentialsId: string, scalewayCredentialsRequest?: ScalewayCredentialsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('editScalewayCredentials', 'organizationId', organizationId)
            // verify required parameter 'credentialsId' is not null or undefined
            assertParamExists('editScalewayCredentials', 'credentialsId', credentialsId)
            const localVarPath = `/organization/{organizationId}/scaleway/credentials/{credentialsId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"credentialsId"}}`, encodeURIComponent(String(credentialsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scalewayCredentialsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a set of AWS credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAWSCredentials: async (organizationId: string, credentialsId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getAWSCredentials', 'organizationId', organizationId)
            // verify required parameter 'credentialsId' is not null or undefined
            assertParamExists('getAWSCredentials', 'credentialsId', credentialsId)
            const localVarPath = `/organization/{organizationId}/aws/credentials/{credentialsId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"credentialsId"}}`, encodeURIComponent(String(credentialsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a set of GCP credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGcpCredentials: async (organizationId: string, credentialsId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getGcpCredentials', 'organizationId', organizationId)
            // verify required parameter 'credentialsId' is not null or undefined
            assertParamExists('getGcpCredentials', 'credentialsId', credentialsId)
            const localVarPath = `/organization/{organizationId}/gcp/credentials/{credentialsId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"credentialsId"}}`, encodeURIComponent(String(credentialsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a set of OnPremise credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOnPremiseCredentials: async (organizationId: string, credentialsId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOnPremiseCredentials', 'organizationId', organizationId)
            // verify required parameter 'credentialsId' is not null or undefined
            assertParamExists('getOnPremiseCredentials', 'credentialsId', credentialsId)
            const localVarPath = `/organization/{organizationId}/onPremise/credentials/{credentialsId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"credentialsId"}}`, encodeURIComponent(String(credentialsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a set of Scaleway credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScalewayCredentials: async (organizationId: string, credentialsId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getScalewayCredentials', 'organizationId', organizationId)
            // verify required parameter 'credentialsId' is not null or undefined
            assertParamExists('getScalewayCredentials', 'credentialsId', credentialsId)
            const localVarPath = `/organization/{organizationId}/scaleway/credentials/{credentialsId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"credentialsId"}}`, encodeURIComponent(String(credentialsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List AWS credentials
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAWSCredentials: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listAWSCredentials', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/aws/credentials`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List GCP credentials
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGcpCredentials: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listGcpCredentials', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/gcp/credentials`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List OnPremise credentials
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOnPremiseCredentials: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listOnPremiseCredentials', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/onPremise/credentials`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Scaleway credentials
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScalewayCredentials: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listScalewayCredentials', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/scaleway/credentials`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CloudProviderCredentialsApi - functional programming interface
 * @export
 */
export const CloudProviderCredentialsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CloudProviderCredentialsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create AWS credentials set
         * @param {string} organizationId Organization ID
         * @param {AwsCredentialsRequest} [awsCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAWSCredentials(organizationId: string, awsCredentialsRequest?: AwsCredentialsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentials>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAWSCredentials(organizationId, awsCredentialsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create GCP credentials set
         * @param {string} organizationId Organization ID
         * @param {GcpCredentialsRequest} [gcpCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGcpCredentials(organizationId: string, gcpCredentialsRequest?: GcpCredentialsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentials>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGcpCredentials(organizationId, gcpCredentialsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create OnPremise credentials set
         * @param {string} organizationId Organization ID
         * @param {OnPremiseCredentialsRequest} [onPremiseCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOnPremiseCredentials(organizationId: string, onPremiseCredentialsRequest?: OnPremiseCredentialsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentials>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOnPremiseCredentials(organizationId, onPremiseCredentialsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create Scaleway credentials set
         * @param {string} organizationId Organization ID
         * @param {ScalewayCredentialsRequest} [scalewayCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createScalewayCredentials(organizationId: string, scalewayCredentialsRequest?: ScalewayCredentialsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentials>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createScalewayCredentials(organizationId, scalewayCredentialsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a set of AWS credentials
         * @param {string} credentialsId Credentials ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAWSCredentials(credentialsId: string, organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAWSCredentials(credentialsId, organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a set of GCP credentials
         * @param {string} credentialsId Credentials ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGcpCredentials(credentialsId: string, organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGcpCredentials(credentialsId, organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a set of OnPremise credentials
         * @param {string} credentialsId Credentials ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOnPremiseCredentials(credentialsId: string, organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOnPremiseCredentials(credentialsId, organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a set of Scaleway credentials
         * @param {string} credentialsId Credentials ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteScalewayCredentials(credentialsId: string, organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteScalewayCredentials(credentialsId, organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit a set of AWS credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {AwsCredentialsRequest} [awsCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editAWSCredentials(organizationId: string, credentialsId: string, awsCredentialsRequest?: AwsCredentialsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentials>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editAWSCredentials(organizationId, credentialsId, awsCredentialsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit a set of GCP credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {GcpCredentialsRequest} [gcpCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editGcpCredentials(organizationId: string, credentialsId: string, gcpCredentialsRequest?: GcpCredentialsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentials>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editGcpCredentials(organizationId, credentialsId, gcpCredentialsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit a set of OnPremise credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {OnPremiseCredentialsRequest} [onPremiseCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editOnPremiseCredentials(organizationId: string, credentialsId: string, onPremiseCredentialsRequest?: OnPremiseCredentialsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentials>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editOnPremiseCredentials(organizationId, credentialsId, onPremiseCredentialsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit a set of Scaleway credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {ScalewayCredentialsRequest} [scalewayCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editScalewayCredentials(organizationId: string, credentialsId: string, scalewayCredentialsRequest?: ScalewayCredentialsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentials>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editScalewayCredentials(organizationId, credentialsId, scalewayCredentialsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a set of AWS credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAWSCredentials(organizationId: string, credentialsId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentials>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAWSCredentials(organizationId, credentialsId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a set of GCP credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGcpCredentials(organizationId: string, credentialsId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentials>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGcpCredentials(organizationId, credentialsId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a set of OnPremise credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOnPremiseCredentials(organizationId: string, credentialsId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentials>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOnPremiseCredentials(organizationId, credentialsId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a set of Scaleway credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScalewayCredentials(organizationId: string, credentialsId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentials>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScalewayCredentials(organizationId, credentialsId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List AWS credentials
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAWSCredentials(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentialsResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAWSCredentials(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List GCP credentials
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGcpCredentials(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentialsResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGcpCredentials(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List OnPremise credentials
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOnPremiseCredentials(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentialsResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOnPremiseCredentials(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Scaleway credentials
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listScalewayCredentials(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentialsResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listScalewayCredentials(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CloudProviderCredentialsApi - factory interface
 * @export
 */
export const CloudProviderCredentialsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CloudProviderCredentialsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create AWS credentials set
         * @param {string} organizationId Organization ID
         * @param {AwsCredentialsRequest} [awsCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAWSCredentials(organizationId: string, awsCredentialsRequest?: AwsCredentialsRequest, options?: any): AxiosPromise<ClusterCredentials> {
            return localVarFp.createAWSCredentials(organizationId, awsCredentialsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create GCP credentials set
         * @param {string} organizationId Organization ID
         * @param {GcpCredentialsRequest} [gcpCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGcpCredentials(organizationId: string, gcpCredentialsRequest?: GcpCredentialsRequest, options?: any): AxiosPromise<ClusterCredentials> {
            return localVarFp.createGcpCredentials(organizationId, gcpCredentialsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create OnPremise credentials set
         * @param {string} organizationId Organization ID
         * @param {OnPremiseCredentialsRequest} [onPremiseCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOnPremiseCredentials(organizationId: string, onPremiseCredentialsRequest?: OnPremiseCredentialsRequest, options?: any): AxiosPromise<ClusterCredentials> {
            return localVarFp.createOnPremiseCredentials(organizationId, onPremiseCredentialsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Scaleway credentials set
         * @param {string} organizationId Organization ID
         * @param {ScalewayCredentialsRequest} [scalewayCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScalewayCredentials(organizationId: string, scalewayCredentialsRequest?: ScalewayCredentialsRequest, options?: any): AxiosPromise<ClusterCredentials> {
            return localVarFp.createScalewayCredentials(organizationId, scalewayCredentialsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a set of AWS credentials
         * @param {string} credentialsId Credentials ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAWSCredentials(credentialsId: string, organizationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAWSCredentials(credentialsId, organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a set of GCP credentials
         * @param {string} credentialsId Credentials ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGcpCredentials(credentialsId: string, organizationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteGcpCredentials(credentialsId, organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a set of OnPremise credentials
         * @param {string} credentialsId Credentials ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOnPremiseCredentials(credentialsId: string, organizationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteOnPremiseCredentials(credentialsId, organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a set of Scaleway credentials
         * @param {string} credentialsId Credentials ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScalewayCredentials(credentialsId: string, organizationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteScalewayCredentials(credentialsId, organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a set of AWS credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {AwsCredentialsRequest} [awsCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editAWSCredentials(organizationId: string, credentialsId: string, awsCredentialsRequest?: AwsCredentialsRequest, options?: any): AxiosPromise<ClusterCredentials> {
            return localVarFp.editAWSCredentials(organizationId, credentialsId, awsCredentialsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a set of GCP credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {GcpCredentialsRequest} [gcpCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editGcpCredentials(organizationId: string, credentialsId: string, gcpCredentialsRequest?: GcpCredentialsRequest, options?: any): AxiosPromise<ClusterCredentials> {
            return localVarFp.editGcpCredentials(organizationId, credentialsId, gcpCredentialsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a set of OnPremise credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {OnPremiseCredentialsRequest} [onPremiseCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editOnPremiseCredentials(organizationId: string, credentialsId: string, onPremiseCredentialsRequest?: OnPremiseCredentialsRequest, options?: any): AxiosPromise<ClusterCredentials> {
            return localVarFp.editOnPremiseCredentials(organizationId, credentialsId, onPremiseCredentialsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a set of Scaleway credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {ScalewayCredentialsRequest} [scalewayCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editScalewayCredentials(organizationId: string, credentialsId: string, scalewayCredentialsRequest?: ScalewayCredentialsRequest, options?: any): AxiosPromise<ClusterCredentials> {
            return localVarFp.editScalewayCredentials(organizationId, credentialsId, scalewayCredentialsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a set of AWS credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAWSCredentials(organizationId: string, credentialsId: string, options?: any): AxiosPromise<ClusterCredentials> {
            return localVarFp.getAWSCredentials(organizationId, credentialsId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a set of GCP credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGcpCredentials(organizationId: string, credentialsId: string, options?: any): AxiosPromise<ClusterCredentials> {
            return localVarFp.getGcpCredentials(organizationId, credentialsId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a set of OnPremise credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOnPremiseCredentials(organizationId: string, credentialsId: string, options?: any): AxiosPromise<ClusterCredentials> {
            return localVarFp.getOnPremiseCredentials(organizationId, credentialsId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a set of Scaleway credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScalewayCredentials(organizationId: string, credentialsId: string, options?: any): AxiosPromise<ClusterCredentials> {
            return localVarFp.getScalewayCredentials(organizationId, credentialsId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List AWS credentials
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAWSCredentials(organizationId: string, options?: any): AxiosPromise<ClusterCredentialsResponseList> {
            return localVarFp.listAWSCredentials(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List GCP credentials
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGcpCredentials(organizationId: string, options?: any): AxiosPromise<ClusterCredentialsResponseList> {
            return localVarFp.listGcpCredentials(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List OnPremise credentials
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOnPremiseCredentials(organizationId: string, options?: any): AxiosPromise<ClusterCredentialsResponseList> {
            return localVarFp.listOnPremiseCredentials(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Scaleway credentials
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScalewayCredentials(organizationId: string, options?: any): AxiosPromise<ClusterCredentialsResponseList> {
            return localVarFp.listScalewayCredentials(organizationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CloudProviderCredentialsApi - object-oriented interface
 * @export
 * @class CloudProviderCredentialsApi
 * @extends {BaseAPI}
 */
export class CloudProviderCredentialsApi extends BaseAPI {
    /**
     * 
     * @summary Create AWS credentials set
     * @param {string} organizationId Organization ID
     * @param {AwsCredentialsRequest} [awsCredentialsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public createAWSCredentials(organizationId: string, awsCredentialsRequest?: AwsCredentialsRequest, options?: AxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).createAWSCredentials(organizationId, awsCredentialsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create GCP credentials set
     * @param {string} organizationId Organization ID
     * @param {GcpCredentialsRequest} [gcpCredentialsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public createGcpCredentials(organizationId: string, gcpCredentialsRequest?: GcpCredentialsRequest, options?: AxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).createGcpCredentials(organizationId, gcpCredentialsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create OnPremise credentials set
     * @param {string} organizationId Organization ID
     * @param {OnPremiseCredentialsRequest} [onPremiseCredentialsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public createOnPremiseCredentials(organizationId: string, onPremiseCredentialsRequest?: OnPremiseCredentialsRequest, options?: AxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).createOnPremiseCredentials(organizationId, onPremiseCredentialsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Scaleway credentials set
     * @param {string} organizationId Organization ID
     * @param {ScalewayCredentialsRequest} [scalewayCredentialsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public createScalewayCredentials(organizationId: string, scalewayCredentialsRequest?: ScalewayCredentialsRequest, options?: AxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).createScalewayCredentials(organizationId, scalewayCredentialsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a set of AWS credentials
     * @param {string} credentialsId Credentials ID
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public deleteAWSCredentials(credentialsId: string, organizationId: string, options?: AxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).deleteAWSCredentials(credentialsId, organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a set of GCP credentials
     * @param {string} credentialsId Credentials ID
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public deleteGcpCredentials(credentialsId: string, organizationId: string, options?: AxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).deleteGcpCredentials(credentialsId, organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a set of OnPremise credentials
     * @param {string} credentialsId Credentials ID
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public deleteOnPremiseCredentials(credentialsId: string, organizationId: string, options?: AxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).deleteOnPremiseCredentials(credentialsId, organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a set of Scaleway credentials
     * @param {string} credentialsId Credentials ID
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public deleteScalewayCredentials(credentialsId: string, organizationId: string, options?: AxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).deleteScalewayCredentials(credentialsId, organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a set of AWS credentials
     * @param {string} organizationId Organization ID
     * @param {string} credentialsId Credentials ID
     * @param {AwsCredentialsRequest} [awsCredentialsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public editAWSCredentials(organizationId: string, credentialsId: string, awsCredentialsRequest?: AwsCredentialsRequest, options?: AxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).editAWSCredentials(organizationId, credentialsId, awsCredentialsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a set of GCP credentials
     * @param {string} organizationId Organization ID
     * @param {string} credentialsId Credentials ID
     * @param {GcpCredentialsRequest} [gcpCredentialsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public editGcpCredentials(organizationId: string, credentialsId: string, gcpCredentialsRequest?: GcpCredentialsRequest, options?: AxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).editGcpCredentials(organizationId, credentialsId, gcpCredentialsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a set of OnPremise credentials
     * @param {string} organizationId Organization ID
     * @param {string} credentialsId Credentials ID
     * @param {OnPremiseCredentialsRequest} [onPremiseCredentialsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public editOnPremiseCredentials(organizationId: string, credentialsId: string, onPremiseCredentialsRequest?: OnPremiseCredentialsRequest, options?: AxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).editOnPremiseCredentials(organizationId, credentialsId, onPremiseCredentialsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a set of Scaleway credentials
     * @param {string} organizationId Organization ID
     * @param {string} credentialsId Credentials ID
     * @param {ScalewayCredentialsRequest} [scalewayCredentialsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public editScalewayCredentials(organizationId: string, credentialsId: string, scalewayCredentialsRequest?: ScalewayCredentialsRequest, options?: AxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).editScalewayCredentials(organizationId, credentialsId, scalewayCredentialsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a set of AWS credentials
     * @param {string} organizationId Organization ID
     * @param {string} credentialsId Credentials ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public getAWSCredentials(organizationId: string, credentialsId: string, options?: AxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).getAWSCredentials(organizationId, credentialsId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a set of GCP credentials
     * @param {string} organizationId Organization ID
     * @param {string} credentialsId Credentials ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public getGcpCredentials(organizationId: string, credentialsId: string, options?: AxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).getGcpCredentials(organizationId, credentialsId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a set of OnPremise credentials
     * @param {string} organizationId Organization ID
     * @param {string} credentialsId Credentials ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public getOnPremiseCredentials(organizationId: string, credentialsId: string, options?: AxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).getOnPremiseCredentials(organizationId, credentialsId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a set of Scaleway credentials
     * @param {string} organizationId Organization ID
     * @param {string} credentialsId Credentials ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public getScalewayCredentials(organizationId: string, credentialsId: string, options?: AxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).getScalewayCredentials(organizationId, credentialsId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List AWS credentials
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public listAWSCredentials(organizationId: string, options?: AxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).listAWSCredentials(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List GCP credentials
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public listGcpCredentials(organizationId: string, options?: AxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).listGcpCredentials(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List OnPremise credentials
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public listOnPremiseCredentials(organizationId: string, options?: AxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).listOnPremiseCredentials(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Scaleway credentials
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public listScalewayCredentials(organizationId: string, options?: AxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).listScalewayCredentials(organizationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ClustersApi - axios parameter creator
 * @export
 */
export const ClustersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a cluster
         * @param {string} organizationId Organization ID
         * @param {ClusterRequest} [clusterRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCluster: async (organizationId: string, clusterRequest?: ClusterRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createCluster', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/cluster`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clusterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a cluster
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {ClusterDeleteMode} [deleteMode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCluster: async (organizationId: string, clusterId: string, deleteMode?: ClusterDeleteMode, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteCluster', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('deleteCluster', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (deleteMode !== undefined) {
                localVarQueryParameter['deleteMode'] = deleteMode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * allows to deploy a cluster
         * @summary Deploy a cluster
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployCluster: async (organizationId: string, clusterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deployCluster', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('deployCluster', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}/deploy`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a cluster
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {ClusterRequest} [clusterRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editCluster: async (organizationId: string, clusterId: string, clusterRequest?: ClusterRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('editCluster', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('editCluster', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clusterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit advanced settings by returning table of advanced settings.
         * @summary Edit advanced settings
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {ClusterAdvancedSettings} [clusterAdvancedSettings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editClusterAdvancedSettings: async (organizationId: string, clusterId: string, clusterAdvancedSettings?: ClusterAdvancedSettings, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('editClusterAdvancedSettings', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('editClusterAdvancedSettings', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}/advancedSettings`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clusterAdvancedSettings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit cluster kubeconfig
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editClusterKubeconfig: async (organizationId: string, clusterId: string, body?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('editClusterKubeconfig', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('editClusterKubeconfig', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}/kubeconfig`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/x-yaml';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit routing table by returning updated table.
         * @summary Edit routing table
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {ClusterRoutingTableRequest} [clusterRoutingTableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editRoutingTable: async (organizationId: string, clusterId: string, clusterRoutingTableRequest?: ClusterRoutingTableRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('editRoutingTable', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('editRoutingTable', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}/routingTable`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clusterRoutingTableRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the list and values of the advanced settings of the cluster. Default values for each setting are available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/cluster-advanced-settings/) 
         * @summary Get advanced settings
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterAdvancedSettings: async (organizationId: string, clusterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getClusterAdvancedSettings', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('getClusterAdvancedSettings', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}/advancedSettings`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get cluster kubeconfig
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterKubeconfig: async (organizationId: string, clusterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getClusterKubeconfig', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('getClusterKubeconfig', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}/kubeconfig`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Know if a cluster is ready to be deployed or not
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterReadinessStatus: async (organizationId: string, clusterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getClusterReadinessStatus', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('getClusterReadinessStatus', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}/isReady`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get cluster status
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterStatus: async (organizationId: string, clusterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getClusterStatus', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('getClusterStatus', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}/status`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Default values for each setting are available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/cluster-advanced-settings/)
         * @summary List default cluster advanced settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultClusterAdvancedSettings: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/defaultClusterAdvancedSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get cluster helm values for self managed installation
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstallationHelmValues: async (organizationId: string, clusterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getInstallationHelmValues', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('getInstallationHelmValues', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}/installationHelmValues`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get cluster cloud provider info and credentials
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationCloudProviderInfo: async (organizationId: string, clusterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationCloudProviderInfo', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('getOrganizationCloudProviderInfo', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}/cloudProviderInfo`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of clusters with only their id and status.
         * @summary List all clusters statuses
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationClusterStatus: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationClusterStatus', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/cluster/status`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve network routing table where each line corresponds to a route between a destination and a target.
         * @summary Get routing table
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutingTable: async (organizationId: string, clusterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getRoutingTable', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('getRoutingTable', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}/routingTable`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List Cluster Logs
         * @summary List Cluster Logs
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listClusterLogs: async (organizationId: string, clusterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listClusterLogs', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('listClusterLogs', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}/logs`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List organization clusters
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationCluster: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listOrganizationCluster', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/cluster`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Specify cluster cloud provider info and credentials
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {ClusterCloudProviderInfoRequest} [clusterCloudProviderInfoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifyClusterCloudProviderInfo: async (organizationId: string, clusterId: string, clusterCloudProviderInfoRequest?: ClusterCloudProviderInfoRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('specifyClusterCloudProviderInfo', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('specifyClusterCloudProviderInfo', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}/cloudProviderInfo`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clusterCloudProviderInfoRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cluster stop has been requester.
         * @summary Stop cluster
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopCluster: async (organizationId: string, clusterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('stopCluster', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('stopCluster', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}/stop`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClustersApi - functional programming interface
 * @export
 */
export const ClustersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClustersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a cluster
         * @param {string} organizationId Organization ID
         * @param {ClusterRequest} [clusterRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCluster(organizationId: string, clusterRequest?: ClusterRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cluster>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCluster(organizationId, clusterRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a cluster
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {ClusterDeleteMode} [deleteMode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCluster(organizationId: string, clusterId: string, deleteMode?: ClusterDeleteMode, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCluster(organizationId, clusterId, deleteMode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * allows to deploy a cluster
         * @summary Deploy a cluster
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployCluster(organizationId: string, clusterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployCluster(organizationId, clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit a cluster
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {ClusterRequest} [clusterRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editCluster(organizationId: string, clusterId: string, clusterRequest?: ClusterRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cluster>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editCluster(organizationId, clusterId, clusterRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Edit advanced settings by returning table of advanced settings.
         * @summary Edit advanced settings
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {ClusterAdvancedSettings} [clusterAdvancedSettings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editClusterAdvancedSettings(organizationId: string, clusterId: string, clusterAdvancedSettings?: ClusterAdvancedSettings, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterAdvancedSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editClusterAdvancedSettings(organizationId, clusterId, clusterAdvancedSettings, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit cluster kubeconfig
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editClusterKubeconfig(organizationId: string, clusterId: string, body?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editClusterKubeconfig(organizationId, clusterId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Edit routing table by returning updated table.
         * @summary Edit routing table
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {ClusterRoutingTableRequest} [clusterRoutingTableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editRoutingTable(organizationId: string, clusterId: string, clusterRoutingTableRequest?: ClusterRoutingTableRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterRoutingTable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editRoutingTable(organizationId, clusterId, clusterRoutingTableRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the list and values of the advanced settings of the cluster. Default values for each setting are available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/cluster-advanced-settings/) 
         * @summary Get advanced settings
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClusterAdvancedSettings(organizationId: string, clusterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterAdvancedSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClusterAdvancedSettings(organizationId, clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get cluster kubeconfig
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClusterKubeconfig(organizationId: string, clusterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClusterKubeconfig(organizationId, clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Know if a cluster is ready to be deployed or not
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClusterReadinessStatus(organizationId: string, clusterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterReadinessStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClusterReadinessStatus(organizationId, clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get cluster status
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClusterStatus(organizationId: string, clusterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterStatusGet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClusterStatus(organizationId, clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Default values for each setting are available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/cluster-advanced-settings/)
         * @summary List default cluster advanced settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDefaultClusterAdvancedSettings(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterAdvancedSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDefaultClusterAdvancedSettings(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get cluster helm values for self managed installation
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInstallationHelmValues(organizationId: string, clusterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInstallationHelmValues(organizationId, clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get cluster cloud provider info and credentials
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationCloudProviderInfo(organizationId: string, clusterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCloudProviderInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationCloudProviderInfo(organizationId, clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of clusters with only their id and status.
         * @summary List all clusters statuses
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationClusterStatus(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterStatusResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationClusterStatus(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve network routing table where each line corresponds to a route between a destination and a target.
         * @summary Get routing table
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoutingTable(organizationId: string, clusterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterRoutingTable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoutingTable(organizationId, clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List Cluster Logs
         * @summary List Cluster Logs
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listClusterLogs(organizationId: string, clusterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterLogsResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listClusterLogs(organizationId, clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List organization clusters
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizationCluster(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationCluster(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Specify cluster cloud provider info and credentials
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {ClusterCloudProviderInfoRequest} [clusterCloudProviderInfoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async specifyClusterCloudProviderInfo(organizationId: string, clusterId: string, clusterCloudProviderInfoRequest?: ClusterCloudProviderInfoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCloudProviderInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.specifyClusterCloudProviderInfo(organizationId, clusterId, clusterCloudProviderInfoRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Cluster stop has been requester.
         * @summary Stop cluster
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopCluster(organizationId: string, clusterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopCluster(organizationId, clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ClustersApi - factory interface
 * @export
 */
export const ClustersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClustersApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a cluster
         * @param {string} organizationId Organization ID
         * @param {ClusterRequest} [clusterRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCluster(organizationId: string, clusterRequest?: ClusterRequest, options?: any): AxiosPromise<Cluster> {
            return localVarFp.createCluster(organizationId, clusterRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a cluster
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {ClusterDeleteMode} [deleteMode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCluster(organizationId: string, clusterId: string, deleteMode?: ClusterDeleteMode, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCluster(organizationId, clusterId, deleteMode, options).then((request) => request(axios, basePath));
        },
        /**
         * allows to deploy a cluster
         * @summary Deploy a cluster
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployCluster(organizationId: string, clusterId: string, options?: any): AxiosPromise<ClusterStatus> {
            return localVarFp.deployCluster(organizationId, clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a cluster
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {ClusterRequest} [clusterRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editCluster(organizationId: string, clusterId: string, clusterRequest?: ClusterRequest, options?: any): AxiosPromise<Cluster> {
            return localVarFp.editCluster(organizationId, clusterId, clusterRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit advanced settings by returning table of advanced settings.
         * @summary Edit advanced settings
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {ClusterAdvancedSettings} [clusterAdvancedSettings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editClusterAdvancedSettings(organizationId: string, clusterId: string, clusterAdvancedSettings?: ClusterAdvancedSettings, options?: any): AxiosPromise<ClusterAdvancedSettings> {
            return localVarFp.editClusterAdvancedSettings(organizationId, clusterId, clusterAdvancedSettings, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit cluster kubeconfig
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editClusterKubeconfig(organizationId: string, clusterId: string, body?: string, options?: any): AxiosPromise<void> {
            return localVarFp.editClusterKubeconfig(organizationId, clusterId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit routing table by returning updated table.
         * @summary Edit routing table
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {ClusterRoutingTableRequest} [clusterRoutingTableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editRoutingTable(organizationId: string, clusterId: string, clusterRoutingTableRequest?: ClusterRoutingTableRequest, options?: any): AxiosPromise<ClusterRoutingTable> {
            return localVarFp.editRoutingTable(organizationId, clusterId, clusterRoutingTableRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the list and values of the advanced settings of the cluster. Default values for each setting are available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/cluster-advanced-settings/) 
         * @summary Get advanced settings
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterAdvancedSettings(organizationId: string, clusterId: string, options?: any): AxiosPromise<ClusterAdvancedSettings> {
            return localVarFp.getClusterAdvancedSettings(organizationId, clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get cluster kubeconfig
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterKubeconfig(organizationId: string, clusterId: string, options?: any): AxiosPromise<string> {
            return localVarFp.getClusterKubeconfig(organizationId, clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Know if a cluster is ready to be deployed or not
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterReadinessStatus(organizationId: string, clusterId: string, options?: any): AxiosPromise<ClusterReadinessStatus> {
            return localVarFp.getClusterReadinessStatus(organizationId, clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get cluster status
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterStatus(organizationId: string, clusterId: string, options?: any): AxiosPromise<ClusterStatusGet> {
            return localVarFp.getClusterStatus(organizationId, clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Default values for each setting are available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/cluster-advanced-settings/)
         * @summary List default cluster advanced settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultClusterAdvancedSettings(options?: any): AxiosPromise<ClusterAdvancedSettings> {
            return localVarFp.getDefaultClusterAdvancedSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get cluster helm values for self managed installation
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstallationHelmValues(organizationId: string, clusterId: string, options?: any): AxiosPromise<string> {
            return localVarFp.getInstallationHelmValues(organizationId, clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get cluster cloud provider info and credentials
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationCloudProviderInfo(organizationId: string, clusterId: string, options?: any): AxiosPromise<ClusterCloudProviderInfo> {
            return localVarFp.getOrganizationCloudProviderInfo(organizationId, clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of clusters with only their id and status.
         * @summary List all clusters statuses
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationClusterStatus(organizationId: string, options?: any): AxiosPromise<ClusterStatusResponseList> {
            return localVarFp.getOrganizationClusterStatus(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve network routing table where each line corresponds to a route between a destination and a target.
         * @summary Get routing table
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutingTable(organizationId: string, clusterId: string, options?: any): AxiosPromise<ClusterRoutingTable> {
            return localVarFp.getRoutingTable(organizationId, clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * List Cluster Logs
         * @summary List Cluster Logs
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listClusterLogs(organizationId: string, clusterId: string, options?: any): AxiosPromise<ClusterLogsResponseList> {
            return localVarFp.listClusterLogs(organizationId, clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List organization clusters
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationCluster(organizationId: string, options?: any): AxiosPromise<ClusterResponseList> {
            return localVarFp.listOrganizationCluster(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Specify cluster cloud provider info and credentials
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {ClusterCloudProviderInfoRequest} [clusterCloudProviderInfoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifyClusterCloudProviderInfo(organizationId: string, clusterId: string, clusterCloudProviderInfoRequest?: ClusterCloudProviderInfoRequest, options?: any): AxiosPromise<ClusterCloudProviderInfo> {
            return localVarFp.specifyClusterCloudProviderInfo(organizationId, clusterId, clusterCloudProviderInfoRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Cluster stop has been requester.
         * @summary Stop cluster
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopCluster(organizationId: string, clusterId: string, options?: any): AxiosPromise<ClusterStatus> {
            return localVarFp.stopCluster(organizationId, clusterId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClustersApi - object-oriented interface
 * @export
 * @class ClustersApi
 * @extends {BaseAPI}
 */
export class ClustersApi extends BaseAPI {
    /**
     * 
     * @summary Create a cluster
     * @param {string} organizationId Organization ID
     * @param {ClusterRequest} [clusterRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public createCluster(organizationId: string, clusterRequest?: ClusterRequest, options?: AxiosRequestConfig) {
        return ClustersApiFp(this.configuration).createCluster(organizationId, clusterRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a cluster
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {ClusterDeleteMode} [deleteMode] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public deleteCluster(organizationId: string, clusterId: string, deleteMode?: ClusterDeleteMode, options?: AxiosRequestConfig) {
        return ClustersApiFp(this.configuration).deleteCluster(organizationId, clusterId, deleteMode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * allows to deploy a cluster
     * @summary Deploy a cluster
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public deployCluster(organizationId: string, clusterId: string, options?: AxiosRequestConfig) {
        return ClustersApiFp(this.configuration).deployCluster(organizationId, clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a cluster
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {ClusterRequest} [clusterRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public editCluster(organizationId: string, clusterId: string, clusterRequest?: ClusterRequest, options?: AxiosRequestConfig) {
        return ClustersApiFp(this.configuration).editCluster(organizationId, clusterId, clusterRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit advanced settings by returning table of advanced settings.
     * @summary Edit advanced settings
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {ClusterAdvancedSettings} [clusterAdvancedSettings] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public editClusterAdvancedSettings(organizationId: string, clusterId: string, clusterAdvancedSettings?: ClusterAdvancedSettings, options?: AxiosRequestConfig) {
        return ClustersApiFp(this.configuration).editClusterAdvancedSettings(organizationId, clusterId, clusterAdvancedSettings, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit cluster kubeconfig
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {string} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public editClusterKubeconfig(organizationId: string, clusterId: string, body?: string, options?: AxiosRequestConfig) {
        return ClustersApiFp(this.configuration).editClusterKubeconfig(organizationId, clusterId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit routing table by returning updated table.
     * @summary Edit routing table
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {ClusterRoutingTableRequest} [clusterRoutingTableRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public editRoutingTable(organizationId: string, clusterId: string, clusterRoutingTableRequest?: ClusterRoutingTableRequest, options?: AxiosRequestConfig) {
        return ClustersApiFp(this.configuration).editRoutingTable(organizationId, clusterId, clusterRoutingTableRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the list and values of the advanced settings of the cluster. Default values for each setting are available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/cluster-advanced-settings/) 
     * @summary Get advanced settings
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public getClusterAdvancedSettings(organizationId: string, clusterId: string, options?: AxiosRequestConfig) {
        return ClustersApiFp(this.configuration).getClusterAdvancedSettings(organizationId, clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get cluster kubeconfig
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public getClusterKubeconfig(organizationId: string, clusterId: string, options?: AxiosRequestConfig) {
        return ClustersApiFp(this.configuration).getClusterKubeconfig(organizationId, clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Know if a cluster is ready to be deployed or not
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public getClusterReadinessStatus(organizationId: string, clusterId: string, options?: AxiosRequestConfig) {
        return ClustersApiFp(this.configuration).getClusterReadinessStatus(organizationId, clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get cluster status
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public getClusterStatus(organizationId: string, clusterId: string, options?: AxiosRequestConfig) {
        return ClustersApiFp(this.configuration).getClusterStatus(organizationId, clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Default values for each setting are available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/cluster-advanced-settings/)
     * @summary List default cluster advanced settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public getDefaultClusterAdvancedSettings(options?: AxiosRequestConfig) {
        return ClustersApiFp(this.configuration).getDefaultClusterAdvancedSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get cluster helm values for self managed installation
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public getInstallationHelmValues(organizationId: string, clusterId: string, options?: AxiosRequestConfig) {
        return ClustersApiFp(this.configuration).getInstallationHelmValues(organizationId, clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get cluster cloud provider info and credentials
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public getOrganizationCloudProviderInfo(organizationId: string, clusterId: string, options?: AxiosRequestConfig) {
        return ClustersApiFp(this.configuration).getOrganizationCloudProviderInfo(organizationId, clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of clusters with only their id and status.
     * @summary List all clusters statuses
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public getOrganizationClusterStatus(organizationId: string, options?: AxiosRequestConfig) {
        return ClustersApiFp(this.configuration).getOrganizationClusterStatus(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve network routing table where each line corresponds to a route between a destination and a target.
     * @summary Get routing table
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public getRoutingTable(organizationId: string, clusterId: string, options?: AxiosRequestConfig) {
        return ClustersApiFp(this.configuration).getRoutingTable(organizationId, clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List Cluster Logs
     * @summary List Cluster Logs
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public listClusterLogs(organizationId: string, clusterId: string, options?: AxiosRequestConfig) {
        return ClustersApiFp(this.configuration).listClusterLogs(organizationId, clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List organization clusters
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public listOrganizationCluster(organizationId: string, options?: AxiosRequestConfig) {
        return ClustersApiFp(this.configuration).listOrganizationCluster(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Specify cluster cloud provider info and credentials
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {ClusterCloudProviderInfoRequest} [clusterCloudProviderInfoRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public specifyClusterCloudProviderInfo(organizationId: string, clusterId: string, clusterCloudProviderInfoRequest?: ClusterCloudProviderInfoRequest, options?: AxiosRequestConfig) {
        return ClustersApiFp(this.configuration).specifyClusterCloudProviderInfo(organizationId, clusterId, clusterCloudProviderInfoRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cluster stop has been requester.
     * @summary Stop cluster
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public stopCluster(organizationId: string, clusterId: string, options?: AxiosRequestConfig) {
        return ClustersApiFp(this.configuration).stopCluster(organizationId, clusterId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContainerActionsApi - axios parameter creator
 * @export
 */
export const ContainerActionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * You must provide a git commit id
         * @summary Deploy container
         * @param {string} containerId Container ID
         * @param {ContainerDeployRequest} [containerDeployRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployContainer: async (containerId: string, containerDeployRequest?: ContainerDeployRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('deployContainer', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/deploy`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(containerDeployRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reboot container
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rebootContainer: async (containerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('rebootContainer', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/restart-service`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Redeploy container
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeployContainer: async (containerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('redeployContainer', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/redeploy`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop container
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopContainer: async (containerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('stopContainer', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/stop`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContainerActionsApi - functional programming interface
 * @export
 */
export const ContainerActionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContainerActionsApiAxiosParamCreator(configuration)
    return {
        /**
         * You must provide a git commit id
         * @summary Deploy container
         * @param {string} containerId Container ID
         * @param {ContainerDeployRequest} [containerDeployRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployContainer(containerId: string, containerDeployRequest?: ContainerDeployRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployContainer(containerId, containerDeployRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Reboot container
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rebootContainer(containerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rebootContainer(containerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Redeploy container
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async redeployContainer(containerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.redeployContainer(containerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Stop container
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopContainer(containerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopContainer(containerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContainerActionsApi - factory interface
 * @export
 */
export const ContainerActionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContainerActionsApiFp(configuration)
    return {
        /**
         * You must provide a git commit id
         * @summary Deploy container
         * @param {string} containerId Container ID
         * @param {ContainerDeployRequest} [containerDeployRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployContainer(containerId: string, containerDeployRequest?: ContainerDeployRequest, options?: any): AxiosPromise<Status> {
            return localVarFp.deployContainer(containerId, containerDeployRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reboot container
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rebootContainer(containerId: string, options?: any): AxiosPromise<Status> {
            return localVarFp.rebootContainer(containerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Redeploy container
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeployContainer(containerId: string, options?: any): AxiosPromise<Status> {
            return localVarFp.redeployContainer(containerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Stop container
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopContainer(containerId: string, options?: any): AxiosPromise<Status> {
            return localVarFp.stopContainer(containerId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContainerActionsApi - object-oriented interface
 * @export
 * @class ContainerActionsApi
 * @extends {BaseAPI}
 */
export class ContainerActionsApi extends BaseAPI {
    /**
     * You must provide a git commit id
     * @summary Deploy container
     * @param {string} containerId Container ID
     * @param {ContainerDeployRequest} [containerDeployRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerActionsApi
     */
    public deployContainer(containerId: string, containerDeployRequest?: ContainerDeployRequest, options?: AxiosRequestConfig) {
        return ContainerActionsApiFp(this.configuration).deployContainer(containerId, containerDeployRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reboot container
     * @param {string} containerId Container ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerActionsApi
     */
    public rebootContainer(containerId: string, options?: AxiosRequestConfig) {
        return ContainerActionsApiFp(this.configuration).rebootContainer(containerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Redeploy container
     * @param {string} containerId Container ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerActionsApi
     */
    public redeployContainer(containerId: string, options?: AxiosRequestConfig) {
        return ContainerActionsApiFp(this.configuration).redeployContainer(containerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Stop container
     * @param {string} containerId Container ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerActionsApi
     */
    public stopContainer(containerId: string, options?: AxiosRequestConfig) {
        return ContainerActionsApiFp(this.configuration).stopContainer(containerId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContainerConfigurationApi - axios parameter creator
 * @export
 */
export const ContainerConfigurationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Edit advanced settings by returning table of advanced settings.
         * @summary Edit advanced settings
         * @param {string} containerId Container ID
         * @param {ContainerAdvancedSettings} [containerAdvancedSettings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editContainerAdvancedSettings: async (containerId: string, containerAdvancedSettings?: ContainerAdvancedSettings, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('editContainerAdvancedSettings', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/advancedSettings`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(containerAdvancedSettings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit the Network settings of the container.
         * @summary Edit Container Network
         * @param {string} containerId Container ID
         * @param {ContainerNetworkRequest} [containerNetworkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editContainerNetwork: async (containerId: string, containerNetworkRequest?: ContainerNetworkRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('editContainerNetwork', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/network`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(containerNetworkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list and values of the advanced settings of the container. Default values for each setting are available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/advanced-settings/) 
         * @summary Get advanced settings
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainerAdvancedSettings: async (containerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('getContainerAdvancedSettings', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/advancedSettings`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get status of the container network settings.
         * @summary Get Container Network information
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainerNetwork: async (containerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('getContainerNetwork', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/network`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContainerConfigurationApi - functional programming interface
 * @export
 */
export const ContainerConfigurationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContainerConfigurationApiAxiosParamCreator(configuration)
    return {
        /**
         * Edit advanced settings by returning table of advanced settings.
         * @summary Edit advanced settings
         * @param {string} containerId Container ID
         * @param {ContainerAdvancedSettings} [containerAdvancedSettings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editContainerAdvancedSettings(containerId: string, containerAdvancedSettings?: ContainerAdvancedSettings, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerAdvancedSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editContainerAdvancedSettings(containerId, containerAdvancedSettings, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Edit the Network settings of the container.
         * @summary Edit Container Network
         * @param {string} containerId Container ID
         * @param {ContainerNetworkRequest} [containerNetworkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editContainerNetwork(containerId: string, containerNetworkRequest?: ContainerNetworkRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerNetwork>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editContainerNetwork(containerId, containerNetworkRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get list and values of the advanced settings of the container. Default values for each setting are available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/advanced-settings/) 
         * @summary Get advanced settings
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContainerAdvancedSettings(containerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerAdvancedSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContainerAdvancedSettings(containerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get status of the container network settings.
         * @summary Get Container Network information
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContainerNetwork(containerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerNetwork>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContainerNetwork(containerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContainerConfigurationApi - factory interface
 * @export
 */
export const ContainerConfigurationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContainerConfigurationApiFp(configuration)
    return {
        /**
         * Edit advanced settings by returning table of advanced settings.
         * @summary Edit advanced settings
         * @param {string} containerId Container ID
         * @param {ContainerAdvancedSettings} [containerAdvancedSettings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editContainerAdvancedSettings(containerId: string, containerAdvancedSettings?: ContainerAdvancedSettings, options?: any): AxiosPromise<ContainerAdvancedSettings> {
            return localVarFp.editContainerAdvancedSettings(containerId, containerAdvancedSettings, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit the Network settings of the container.
         * @summary Edit Container Network
         * @param {string} containerId Container ID
         * @param {ContainerNetworkRequest} [containerNetworkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editContainerNetwork(containerId: string, containerNetworkRequest?: ContainerNetworkRequest, options?: any): AxiosPromise<ContainerNetwork> {
            return localVarFp.editContainerNetwork(containerId, containerNetworkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get list and values of the advanced settings of the container. Default values for each setting are available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/advanced-settings/) 
         * @summary Get advanced settings
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainerAdvancedSettings(containerId: string, options?: any): AxiosPromise<ContainerAdvancedSettings> {
            return localVarFp.getContainerAdvancedSettings(containerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get status of the container network settings.
         * @summary Get Container Network information
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainerNetwork(containerId: string, options?: any): AxiosPromise<ContainerNetwork> {
            return localVarFp.getContainerNetwork(containerId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContainerConfigurationApi - object-oriented interface
 * @export
 * @class ContainerConfigurationApi
 * @extends {BaseAPI}
 */
export class ContainerConfigurationApi extends BaseAPI {
    /**
     * Edit advanced settings by returning table of advanced settings.
     * @summary Edit advanced settings
     * @param {string} containerId Container ID
     * @param {ContainerAdvancedSettings} [containerAdvancedSettings] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerConfigurationApi
     */
    public editContainerAdvancedSettings(containerId: string, containerAdvancedSettings?: ContainerAdvancedSettings, options?: AxiosRequestConfig) {
        return ContainerConfigurationApiFp(this.configuration).editContainerAdvancedSettings(containerId, containerAdvancedSettings, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit the Network settings of the container.
     * @summary Edit Container Network
     * @param {string} containerId Container ID
     * @param {ContainerNetworkRequest} [containerNetworkRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerConfigurationApi
     */
    public editContainerNetwork(containerId: string, containerNetworkRequest?: ContainerNetworkRequest, options?: AxiosRequestConfig) {
        return ContainerConfigurationApiFp(this.configuration).editContainerNetwork(containerId, containerNetworkRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list and values of the advanced settings of the container. Default values for each setting are available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/advanced-settings/) 
     * @summary Get advanced settings
     * @param {string} containerId Container ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerConfigurationApi
     */
    public getContainerAdvancedSettings(containerId: string, options?: AxiosRequestConfig) {
        return ContainerConfigurationApiFp(this.configuration).getContainerAdvancedSettings(containerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get status of the container network settings.
     * @summary Get Container Network information
     * @param {string} containerId Container ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerConfigurationApi
     */
    public getContainerNetwork(containerId: string, options?: AxiosRequestConfig) {
        return ContainerConfigurationApiFp(this.configuration).getContainerNetwork(containerId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContainerCustomDomainApi - axios parameter creator
 * @export
 */
export const ContainerCustomDomainApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a custom domain to this container in order not to use qovery autogenerated domain
         * @summary Add custom domain to the container.
         * @param {string} containerId Container ID
         * @param {CustomDomainRequest} [customDomainRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainerCustomDomain: async (containerId: string, customDomainRequest?: CustomDomainRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('createContainerCustomDomain', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/customDomain`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customDomainRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To delete an CustomDomain you must have the project user permission
         * @summary Delete a Custom Domain
         * @param {string} containerId Container ID
         * @param {string} customDomainId Custom Domain ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContainerCustomDomain: async (containerId: string, customDomainId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('deleteContainerCustomDomain', 'containerId', containerId)
            // verify required parameter 'customDomainId' is not null or undefined
            assertParamExists('deleteContainerCustomDomain', 'customDomainId', customDomainId)
            const localVarPath = `/container/{containerId}/customDomain/{customDomainId}`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"customDomainId"}}`, encodeURIComponent(String(customDomainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To edit a Custom Domain  you must have the project user permission
         * @summary Edit a Custom Domain
         * @param {string} containerId Container ID
         * @param {string} customDomainId Custom Domain ID
         * @param {CustomDomainRequest} [customDomainRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editContainerCustomDomain: async (containerId: string, customDomainId: string, customDomainRequest?: CustomDomainRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('editContainerCustomDomain', 'containerId', containerId)
            // verify required parameter 'customDomainId' is not null or undefined
            assertParamExists('editContainerCustomDomain', 'customDomainId', customDomainId)
            const localVarPath = `/container/{containerId}/customDomain/{customDomainId}`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"customDomainId"}}`, encodeURIComponent(String(customDomainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customDomainRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Custom Domain status
         * @param {string} containerId Container ID
         * @param {string} customDomainId Custom Domain ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainerCustomDomainStatus: async (containerId: string, customDomainId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('getContainerCustomDomainStatus', 'containerId', containerId)
            // verify required parameter 'customDomainId' is not null or undefined
            assertParamExists('getContainerCustomDomainStatus', 'customDomainId', customDomainId)
            const localVarPath = `/container/{containerId}/customDomain/{customDomainId}/status`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"customDomainId"}}`, encodeURIComponent(String(customDomainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List container custom domains
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerCustomDomain: async (containerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('listContainerCustomDomain', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/customDomain`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContainerCustomDomainApi - functional programming interface
 * @export
 */
export const ContainerCustomDomainApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContainerCustomDomainApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a custom domain to this container in order not to use qovery autogenerated domain
         * @summary Add custom domain to the container.
         * @param {string} containerId Container ID
         * @param {CustomDomainRequest} [customDomainRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContainerCustomDomain(containerId: string, customDomainRequest?: CustomDomainRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomDomain>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContainerCustomDomain(containerId, customDomainRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * To delete an CustomDomain you must have the project user permission
         * @summary Delete a Custom Domain
         * @param {string} containerId Container ID
         * @param {string} customDomainId Custom Domain ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteContainerCustomDomain(containerId: string, customDomainId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteContainerCustomDomain(containerId, customDomainId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * To edit a Custom Domain  you must have the project user permission
         * @summary Edit a Custom Domain
         * @param {string} containerId Container ID
         * @param {string} customDomainId Custom Domain ID
         * @param {CustomDomainRequest} [customDomainRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editContainerCustomDomain(containerId: string, customDomainId: string, customDomainRequest?: CustomDomainRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomDomain>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editContainerCustomDomain(containerId, customDomainId, customDomainRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Custom Domain status
         * @param {string} containerId Container ID
         * @param {string} customDomainId Custom Domain ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContainerCustomDomainStatus(containerId: string, customDomainId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomDomain>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContainerCustomDomainStatus(containerId, customDomainId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List container custom domains
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContainerCustomDomain(containerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomDomainResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listContainerCustomDomain(containerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContainerCustomDomainApi - factory interface
 * @export
 */
export const ContainerCustomDomainApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContainerCustomDomainApiFp(configuration)
    return {
        /**
         * Add a custom domain to this container in order not to use qovery autogenerated domain
         * @summary Add custom domain to the container.
         * @param {string} containerId Container ID
         * @param {CustomDomainRequest} [customDomainRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainerCustomDomain(containerId: string, customDomainRequest?: CustomDomainRequest, options?: any): AxiosPromise<CustomDomain> {
            return localVarFp.createContainerCustomDomain(containerId, customDomainRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * To delete an CustomDomain you must have the project user permission
         * @summary Delete a Custom Domain
         * @param {string} containerId Container ID
         * @param {string} customDomainId Custom Domain ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContainerCustomDomain(containerId: string, customDomainId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteContainerCustomDomain(containerId, customDomainId, options).then((request) => request(axios, basePath));
        },
        /**
         * To edit a Custom Domain  you must have the project user permission
         * @summary Edit a Custom Domain
         * @param {string} containerId Container ID
         * @param {string} customDomainId Custom Domain ID
         * @param {CustomDomainRequest} [customDomainRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editContainerCustomDomain(containerId: string, customDomainId: string, customDomainRequest?: CustomDomainRequest, options?: any): AxiosPromise<CustomDomain> {
            return localVarFp.editContainerCustomDomain(containerId, customDomainId, customDomainRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Custom Domain status
         * @param {string} containerId Container ID
         * @param {string} customDomainId Custom Domain ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainerCustomDomainStatus(containerId: string, customDomainId: string, options?: any): AxiosPromise<CustomDomain> {
            return localVarFp.getContainerCustomDomainStatus(containerId, customDomainId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List container custom domains
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerCustomDomain(containerId: string, options?: any): AxiosPromise<CustomDomainResponseList> {
            return localVarFp.listContainerCustomDomain(containerId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContainerCustomDomainApi - object-oriented interface
 * @export
 * @class ContainerCustomDomainApi
 * @extends {BaseAPI}
 */
export class ContainerCustomDomainApi extends BaseAPI {
    /**
     * Add a custom domain to this container in order not to use qovery autogenerated domain
     * @summary Add custom domain to the container.
     * @param {string} containerId Container ID
     * @param {CustomDomainRequest} [customDomainRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerCustomDomainApi
     */
    public createContainerCustomDomain(containerId: string, customDomainRequest?: CustomDomainRequest, options?: AxiosRequestConfig) {
        return ContainerCustomDomainApiFp(this.configuration).createContainerCustomDomain(containerId, customDomainRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To delete an CustomDomain you must have the project user permission
     * @summary Delete a Custom Domain
     * @param {string} containerId Container ID
     * @param {string} customDomainId Custom Domain ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerCustomDomainApi
     */
    public deleteContainerCustomDomain(containerId: string, customDomainId: string, options?: AxiosRequestConfig) {
        return ContainerCustomDomainApiFp(this.configuration).deleteContainerCustomDomain(containerId, customDomainId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To edit a Custom Domain  you must have the project user permission
     * @summary Edit a Custom Domain
     * @param {string} containerId Container ID
     * @param {string} customDomainId Custom Domain ID
     * @param {CustomDomainRequest} [customDomainRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerCustomDomainApi
     */
    public editContainerCustomDomain(containerId: string, customDomainId: string, customDomainRequest?: CustomDomainRequest, options?: AxiosRequestConfig) {
        return ContainerCustomDomainApiFp(this.configuration).editContainerCustomDomain(containerId, customDomainId, customDomainRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Custom Domain status
     * @param {string} containerId Container ID
     * @param {string} customDomainId Custom Domain ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerCustomDomainApi
     */
    public getContainerCustomDomainStatus(containerId: string, customDomainId: string, options?: AxiosRequestConfig) {
        return ContainerCustomDomainApiFp(this.configuration).getContainerCustomDomainStatus(containerId, customDomainId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List container custom domains
     * @param {string} containerId Container ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerCustomDomainApi
     */
    public listContainerCustomDomain(containerId: string, options?: AxiosRequestConfig) {
        return ContainerCustomDomainApiFp(this.configuration).listContainerCustomDomain(containerId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContainerDeploymentHistoryApi - axios parameter creator
 * @export
 */
export const ContainerDeploymentHistoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the 20 last container deployments
         * @summary List container deployments
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerDeploymentHistory: async (containerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('listContainerDeploymentHistory', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/deploymentHistory`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContainerDeploymentHistoryApi - functional programming interface
 * @export
 */
export const ContainerDeploymentHistoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContainerDeploymentHistoryApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the 20 last container deployments
         * @summary List container deployments
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContainerDeploymentHistory(containerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListContainerDeploymentHistory200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listContainerDeploymentHistory(containerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContainerDeploymentHistoryApi - factory interface
 * @export
 */
export const ContainerDeploymentHistoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContainerDeploymentHistoryApiFp(configuration)
    return {
        /**
         * Returns the 20 last container deployments
         * @summary List container deployments
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerDeploymentHistory(containerId: string, options?: any): AxiosPromise<ListContainerDeploymentHistory200Response> {
            return localVarFp.listContainerDeploymentHistory(containerId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContainerDeploymentHistoryApi - object-oriented interface
 * @export
 * @class ContainerDeploymentHistoryApi
 * @extends {BaseAPI}
 */
export class ContainerDeploymentHistoryApi extends BaseAPI {
    /**
     * Returns the 20 last container deployments
     * @summary List container deployments
     * @param {string} containerId Container ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerDeploymentHistoryApi
     */
    public listContainerDeploymentHistory(containerId: string, options?: AxiosRequestConfig) {
        return ContainerDeploymentHistoryApiFp(this.configuration).listContainerDeploymentHistory(containerId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContainerEnvironmentVariableApi - axios parameter creator
 * @export
 */
export const ContainerEnvironmentVariableApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * - Add an environment variable to the container. 
         * @summary Add an environment variable to the container
         * @param {string} containerId Container ID
         * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainerEnvironmentVariable: async (containerId: string, environmentVariableRequest?: EnvironmentVariableRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('createContainerEnvironmentVariable', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/environmentVariable`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentVariableRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to add an alias at container level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at container level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - You can\'t create an alias on an alias 
         * @summary Create an environment variable alias at the container level
         * @param {string} containerId Container ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainerEnvironmentVariableAlias: async (containerId: string, environmentVariableId: string, key?: Key, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('createContainerEnvironmentVariableAlias', 'containerId', containerId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('createContainerEnvironmentVariableAlias', 'environmentVariableId', environmentVariableId)
            const localVarPath = `/container/{containerId}/environmentVariable/{environmentVariableId}/alias`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(key, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to override at container level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at container level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
         * @summary Create an environment variable override at the container level
         * @param {string} containerId Container ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainerEnvironmentVariableOverride: async (containerId: string, environmentVariableId: string, value?: Value, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('createContainerEnvironmentVariableOverride', 'containerId', containerId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('createContainerEnvironmentVariableOverride', 'environmentVariableId', environmentVariableId)
            const localVarPath = `/container/{containerId}/environmentVariable/{environmentVariableId}/override`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(value, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - To delete an environment variable from an container you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete an environment variable from a container
         * @param {string} containerId Container ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContainerEnvironmentVariable: async (containerId: string, environmentVariableId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('deleteContainerEnvironmentVariable', 'containerId', containerId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('deleteContainerEnvironmentVariable', 'environmentVariableId', environmentVariableId)
            const localVarPath = `/container/{containerId}/environmentVariable/{environmentVariableId}`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > CONTAINER) 
         * @summary Edit an environment variable belonging to the container
         * @param {string} containerId Container ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editContainerEnvironmentVariable: async (containerId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('editContainerEnvironmentVariable', 'containerId', containerId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('editContainerEnvironmentVariable', 'environmentVariableId', environmentVariableId)
            // verify required parameter 'environmentVariableEditRequest' is not null or undefined
            assertParamExists('editContainerEnvironmentVariable', 'environmentVariableEditRequest', environmentVariableEditRequest)
            const localVarPath = `/container/{containerId}/environmentVariable/{environmentVariableId}`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentVariableEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Import environment variables in a defined scope, with a defined visibility.
         * @summary Import variables
         * @param {string} containerId Container ID
         * @param {VariableImportRequest} [variableImportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importContainerEnvironmentVariable: async (containerId: string, variableImportRequest?: VariableImportRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('importContainerEnvironmentVariable', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/environmentVariable/import`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(variableImportRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List environment variables
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerEnvironmentVariable: async (containerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('listContainerEnvironmentVariable', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/environmentVariable`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContainerEnvironmentVariableApi - functional programming interface
 * @export
 */
export const ContainerEnvironmentVariableApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContainerEnvironmentVariableApiAxiosParamCreator(configuration)
    return {
        /**
         * - Add an environment variable to the container. 
         * @summary Add an environment variable to the container
         * @param {string} containerId Container ID
         * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContainerEnvironmentVariable(containerId: string, environmentVariableRequest?: EnvironmentVariableRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContainerEnvironmentVariable(containerId, environmentVariableRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - Allows you to add an alias at container level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at container level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - You can\'t create an alias on an alias 
         * @summary Create an environment variable alias at the container level
         * @param {string} containerId Container ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContainerEnvironmentVariableAlias(containerId: string, environmentVariableId: string, key?: Key, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContainerEnvironmentVariableAlias(containerId, environmentVariableId, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - Allows you to override at container level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at container level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
         * @summary Create an environment variable override at the container level
         * @param {string} containerId Container ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContainerEnvironmentVariableOverride(containerId: string, environmentVariableId: string, value?: Value, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContainerEnvironmentVariableOverride(containerId, environmentVariableId, value, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - To delete an environment variable from an container you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete an environment variable from a container
         * @param {string} containerId Container ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteContainerEnvironmentVariable(containerId: string, environmentVariableId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteContainerEnvironmentVariable(containerId, environmentVariableId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > CONTAINER) 
         * @summary Edit an environment variable belonging to the container
         * @param {string} containerId Container ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editContainerEnvironmentVariable(containerId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editContainerEnvironmentVariable(containerId, environmentVariableId, environmentVariableEditRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Import environment variables in a defined scope, with a defined visibility.
         * @summary Import variables
         * @param {string} containerId Container ID
         * @param {VariableImportRequest} [variableImportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importContainerEnvironmentVariable(containerId: string, variableImportRequest?: VariableImportRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariableImport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importContainerEnvironmentVariable(containerId, variableImportRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List environment variables
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContainerEnvironmentVariable(containerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariableResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listContainerEnvironmentVariable(containerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContainerEnvironmentVariableApi - factory interface
 * @export
 */
export const ContainerEnvironmentVariableApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContainerEnvironmentVariableApiFp(configuration)
    return {
        /**
         * - Add an environment variable to the container. 
         * @summary Add an environment variable to the container
         * @param {string} containerId Container ID
         * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainerEnvironmentVariable(containerId: string, environmentVariableRequest?: EnvironmentVariableRequest, options?: any): AxiosPromise<EnvironmentVariable> {
            return localVarFp.createContainerEnvironmentVariable(containerId, environmentVariableRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to add an alias at container level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at container level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - You can\'t create an alias on an alias 
         * @summary Create an environment variable alias at the container level
         * @param {string} containerId Container ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainerEnvironmentVariableAlias(containerId: string, environmentVariableId: string, key?: Key, options?: any): AxiosPromise<EnvironmentVariable> {
            return localVarFp.createContainerEnvironmentVariableAlias(containerId, environmentVariableId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to override at container level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at container level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
         * @summary Create an environment variable override at the container level
         * @param {string} containerId Container ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainerEnvironmentVariableOverride(containerId: string, environmentVariableId: string, value?: Value, options?: any): AxiosPromise<EnvironmentVariable> {
            return localVarFp.createContainerEnvironmentVariableOverride(containerId, environmentVariableId, value, options).then((request) => request(axios, basePath));
        },
        /**
         * - To delete an environment variable from an container you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete an environment variable from a container
         * @param {string} containerId Container ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContainerEnvironmentVariable(containerId: string, environmentVariableId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteContainerEnvironmentVariable(containerId, environmentVariableId, options).then((request) => request(axios, basePath));
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > CONTAINER) 
         * @summary Edit an environment variable belonging to the container
         * @param {string} containerId Container ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editContainerEnvironmentVariable(containerId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options?: any): AxiosPromise<EnvironmentVariable> {
            return localVarFp.editContainerEnvironmentVariable(containerId, environmentVariableId, environmentVariableEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Import environment variables in a defined scope, with a defined visibility.
         * @summary Import variables
         * @param {string} containerId Container ID
         * @param {VariableImportRequest} [variableImportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importContainerEnvironmentVariable(containerId: string, variableImportRequest?: VariableImportRequest, options?: any): AxiosPromise<VariableImport> {
            return localVarFp.importContainerEnvironmentVariable(containerId, variableImportRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List environment variables
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerEnvironmentVariable(containerId: string, options?: any): AxiosPromise<EnvironmentVariableResponseList> {
            return localVarFp.listContainerEnvironmentVariable(containerId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContainerEnvironmentVariableApi - object-oriented interface
 * @export
 * @class ContainerEnvironmentVariableApi
 * @extends {BaseAPI}
 */
export class ContainerEnvironmentVariableApi extends BaseAPI {
    /**
     * - Add an environment variable to the container. 
     * @summary Add an environment variable to the container
     * @param {string} containerId Container ID
     * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerEnvironmentVariableApi
     */
    public createContainerEnvironmentVariable(containerId: string, environmentVariableRequest?: EnvironmentVariableRequest, options?: AxiosRequestConfig) {
        return ContainerEnvironmentVariableApiFp(this.configuration).createContainerEnvironmentVariable(containerId, environmentVariableRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to add an alias at container level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at container level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - You can\'t create an alias on an alias 
     * @summary Create an environment variable alias at the container level
     * @param {string} containerId Container ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {Key} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerEnvironmentVariableApi
     */
    public createContainerEnvironmentVariableAlias(containerId: string, environmentVariableId: string, key?: Key, options?: AxiosRequestConfig) {
        return ContainerEnvironmentVariableApiFp(this.configuration).createContainerEnvironmentVariableAlias(containerId, environmentVariableId, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to override at container level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at container level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
     * @summary Create an environment variable override at the container level
     * @param {string} containerId Container ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {Value} [value] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerEnvironmentVariableApi
     */
    public createContainerEnvironmentVariableOverride(containerId: string, environmentVariableId: string, value?: Value, options?: AxiosRequestConfig) {
        return ContainerEnvironmentVariableApiFp(this.configuration).createContainerEnvironmentVariableOverride(containerId, environmentVariableId, value, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - To delete an environment variable from an container you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
     * @summary Delete an environment variable from a container
     * @param {string} containerId Container ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerEnvironmentVariableApi
     */
    public deleteContainerEnvironmentVariable(containerId: string, environmentVariableId: string, options?: AxiosRequestConfig) {
        return ContainerEnvironmentVariableApiFp(this.configuration).deleteContainerEnvironmentVariable(containerId, environmentVariableId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > CONTAINER) 
     * @summary Edit an environment variable belonging to the container
     * @param {string} containerId Container ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerEnvironmentVariableApi
     */
    public editContainerEnvironmentVariable(containerId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options?: AxiosRequestConfig) {
        return ContainerEnvironmentVariableApiFp(this.configuration).editContainerEnvironmentVariable(containerId, environmentVariableId, environmentVariableEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Import environment variables in a defined scope, with a defined visibility.
     * @summary Import variables
     * @param {string} containerId Container ID
     * @param {VariableImportRequest} [variableImportRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerEnvironmentVariableApi
     */
    public importContainerEnvironmentVariable(containerId: string, variableImportRequest?: VariableImportRequest, options?: AxiosRequestConfig) {
        return ContainerEnvironmentVariableApiFp(this.configuration).importContainerEnvironmentVariable(containerId, variableImportRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List environment variables
     * @param {string} containerId Container ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerEnvironmentVariableApi
     */
    public listContainerEnvironmentVariable(containerId: string, options?: AxiosRequestConfig) {
        return ContainerEnvironmentVariableApiFp(this.configuration).listContainerEnvironmentVariable(containerId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContainerLogsApi - axios parameter creator
 * @export
 */
export const ContainerLogsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This will list the last 1000 logs of the container
         * @summary List logs
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerLog: async (containerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('listContainerLog', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/log`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContainerLogsApi - functional programming interface
 * @export
 */
export const ContainerLogsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContainerLogsApiAxiosParamCreator(configuration)
    return {
        /**
         * This will list the last 1000 logs of the container
         * @summary List logs
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContainerLog(containerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listContainerLog(containerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContainerLogsApi - factory interface
 * @export
 */
export const ContainerLogsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContainerLogsApiFp(configuration)
    return {
        /**
         * This will list the last 1000 logs of the container
         * @summary List logs
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerLog(containerId: string, options?: any): AxiosPromise<LogResponseList> {
            return localVarFp.listContainerLog(containerId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContainerLogsApi - object-oriented interface
 * @export
 * @class ContainerLogsApi
 * @extends {BaseAPI}
 */
export class ContainerLogsApi extends BaseAPI {
    /**
     * This will list the last 1000 logs of the container
     * @summary List logs
     * @param {string} containerId Container ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerLogsApi
     */
    public listContainerLog(containerId: string, options?: AxiosRequestConfig) {
        return ContainerLogsApiFp(this.configuration).listContainerLog(containerId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContainerMainCallsApi - axios parameter creator
 * @export
 */
export const ContainerMainCallsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * To delete the container you must have the admin permission
         * @summary Delete container
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContainer: async (containerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('deleteContainer', 'containerId', containerId)
            const localVarPath = `/container/{containerId}`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - To edit the container you must have the admin permission. - For port edition, if you provide a port id, we will update the corresponding port. If you don\'t we will create a new one. If you remove a port from the payload, we will delete it. - For storage edition, if you provide a storage id, we will update the corresponding storage. If you don\'t we will create a new one. If you remove a storage from the payload, we will delete it. 
         * @summary Edit container
         * @param {string} containerId Container ID
         * @param {ContainerRequest} [containerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editContainer: async (containerId: string, containerRequest?: ContainerRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('editContainer', 'containerId', containerId)
            const localVarPath = `/container/{containerId}`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(containerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get container by ID
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainer: async (containerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('getContainer', 'containerId', containerId)
            const localVarPath = `/container/{containerId}`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get container status
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainerStatus: async (containerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('getContainerStatus', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/status`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This will return all the custom domains and Qovery autogenerated domain for the given container
         * @summary List all URLs of the container
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerLinks: async (containerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('listContainerLinks', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/link`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContainerMainCallsApi - functional programming interface
 * @export
 */
export const ContainerMainCallsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContainerMainCallsApiAxiosParamCreator(configuration)
    return {
        /**
         * To delete the container you must have the admin permission
         * @summary Delete container
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteContainer(containerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteContainer(containerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - To edit the container you must have the admin permission. - For port edition, if you provide a port id, we will update the corresponding port. If you don\'t we will create a new one. If you remove a port from the payload, we will delete it. - For storage edition, if you provide a storage id, we will update the corresponding storage. If you don\'t we will create a new one. If you remove a storage from the payload, we will delete it. 
         * @summary Edit container
         * @param {string} containerId Container ID
         * @param {ContainerRequest} [containerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editContainer(containerId: string, containerRequest?: ContainerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editContainer(containerId, containerRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get container by ID
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContainer(containerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContainer(containerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get container status
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContainerStatus(containerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContainerStatus(containerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This will return all the custom domains and Qovery autogenerated domain for the given container
         * @summary List all URLs of the container
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContainerLinks(containerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listContainerLinks(containerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContainerMainCallsApi - factory interface
 * @export
 */
export const ContainerMainCallsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContainerMainCallsApiFp(configuration)
    return {
        /**
         * To delete the container you must have the admin permission
         * @summary Delete container
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContainer(containerId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteContainer(containerId, options).then((request) => request(axios, basePath));
        },
        /**
         * - To edit the container you must have the admin permission. - For port edition, if you provide a port id, we will update the corresponding port. If you don\'t we will create a new one. If you remove a port from the payload, we will delete it. - For storage edition, if you provide a storage id, we will update the corresponding storage. If you don\'t we will create a new one. If you remove a storage from the payload, we will delete it. 
         * @summary Edit container
         * @param {string} containerId Container ID
         * @param {ContainerRequest} [containerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editContainer(containerId: string, containerRequest?: ContainerRequest, options?: any): AxiosPromise<ContainerResponse> {
            return localVarFp.editContainer(containerId, containerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get container by ID
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainer(containerId: string, options?: any): AxiosPromise<ContainerResponse> {
            return localVarFp.getContainer(containerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get container status
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainerStatus(containerId: string, options?: any): AxiosPromise<Status> {
            return localVarFp.getContainerStatus(containerId, options).then((request) => request(axios, basePath));
        },
        /**
         * This will return all the custom domains and Qovery autogenerated domain for the given container
         * @summary List all URLs of the container
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerLinks(containerId: string, options?: any): AxiosPromise<LinkResponseList> {
            return localVarFp.listContainerLinks(containerId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContainerMainCallsApi - object-oriented interface
 * @export
 * @class ContainerMainCallsApi
 * @extends {BaseAPI}
 */
export class ContainerMainCallsApi extends BaseAPI {
    /**
     * To delete the container you must have the admin permission
     * @summary Delete container
     * @param {string} containerId Container ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerMainCallsApi
     */
    public deleteContainer(containerId: string, options?: AxiosRequestConfig) {
        return ContainerMainCallsApiFp(this.configuration).deleteContainer(containerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - To edit the container you must have the admin permission. - For port edition, if you provide a port id, we will update the corresponding port. If you don\'t we will create a new one. If you remove a port from the payload, we will delete it. - For storage edition, if you provide a storage id, we will update the corresponding storage. If you don\'t we will create a new one. If you remove a storage from the payload, we will delete it. 
     * @summary Edit container
     * @param {string} containerId Container ID
     * @param {ContainerRequest} [containerRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerMainCallsApi
     */
    public editContainer(containerId: string, containerRequest?: ContainerRequest, options?: AxiosRequestConfig) {
        return ContainerMainCallsApiFp(this.configuration).editContainer(containerId, containerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get container by ID
     * @param {string} containerId Container ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerMainCallsApi
     */
    public getContainer(containerId: string, options?: AxiosRequestConfig) {
        return ContainerMainCallsApiFp(this.configuration).getContainer(containerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get container status
     * @param {string} containerId Container ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerMainCallsApi
     */
    public getContainerStatus(containerId: string, options?: AxiosRequestConfig) {
        return ContainerMainCallsApiFp(this.configuration).getContainerStatus(containerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will return all the custom domains and Qovery autogenerated domain for the given container
     * @summary List all URLs of the container
     * @param {string} containerId Container ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerMainCallsApi
     */
    public listContainerLinks(containerId: string, options?: AxiosRequestConfig) {
        return ContainerMainCallsApiFp(this.configuration).listContainerLinks(containerId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContainerRegistriesApi - axios parameter creator
 * @export
 */
export const ContainerRegistriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a container registry
         * @param {string} organizationId Organization ID
         * @param {ContainerRegistryRequest} [containerRegistryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainerRegistry: async (organizationId: string, containerRegistryRequest?: ContainerRegistryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createContainerRegistry', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/containerRegistry`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(containerRegistryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a container registry
         * @param {string} organizationId Organization ID
         * @param {string} containerRegistryId Container Registry ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContainerRegistry: async (organizationId: string, containerRegistryId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteContainerRegistry', 'organizationId', organizationId)
            // verify required parameter 'containerRegistryId' is not null or undefined
            assertParamExists('deleteContainerRegistry', 'containerRegistryId', containerRegistryId)
            const localVarPath = `/organization/{organizationId}/containerRegistry/{containerRegistryId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"containerRegistryId"}}`, encodeURIComponent(String(containerRegistryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a container registry
         * @param {string} organizationId Organization ID
         * @param {string} containerRegistryId Container Registry ID
         * @param {ContainerRegistryRequest} [containerRegistryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editContainerRegistry: async (organizationId: string, containerRegistryId: string, containerRegistryRequest?: ContainerRegistryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('editContainerRegistry', 'organizationId', organizationId)
            // verify required parameter 'containerRegistryId' is not null or undefined
            assertParamExists('editContainerRegistry', 'containerRegistryId', containerRegistryId)
            const localVarPath = `/organization/{organizationId}/containerRegistry/{containerRegistryId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"containerRegistryId"}}`, encodeURIComponent(String(containerRegistryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(containerRegistryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a container registry
         * @param {string} organizationId Organization ID
         * @param {string} containerRegistryId Container Registry ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainerRegistry: async (organizationId: string, containerRegistryId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getContainerRegistry', 'organizationId', organizationId)
            // verify required parameter 'containerRegistryId' is not null or undefined
            assertParamExists('getContainerRegistry', 'containerRegistryId', containerRegistryId)
            const localVarPath = `/organization/{organizationId}/containerRegistry/{containerRegistryId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"containerRegistryId"}}`, encodeURIComponent(String(containerRegistryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List image version for a container registry
         * @param {string} organizationId Organization ID
         * @param {string} containerRegistryId Container Registry ID
         * @param {string} imageName container image name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainerVersions: async (organizationId: string, containerRegistryId: string, imageName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getContainerVersions', 'organizationId', organizationId)
            // verify required parameter 'containerRegistryId' is not null or undefined
            assertParamExists('getContainerVersions', 'containerRegistryId', containerRegistryId)
            // verify required parameter 'imageName' is not null or undefined
            assertParamExists('getContainerVersions', 'imageName', imageName)
            const localVarPath = `/organization/{organizationId}/containerRegistry/{containerRegistryId}/images`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"containerRegistryId"}}`, encodeURIComponent(String(containerRegistryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (imageName !== undefined) {
                localVarQueryParameter['imageName'] = imageName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List supported container registries by Qovery and get the mandatory authentification configuration.
         * @summary List supported container registries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAvailableContainerRegistry: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/availableContainerRegistry`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List organization container registries
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerRegistry: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listContainerRegistry', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/containerRegistry`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContainerRegistriesApi - functional programming interface
 * @export
 */
export const ContainerRegistriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContainerRegistriesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a container registry
         * @param {string} organizationId Organization ID
         * @param {ContainerRegistryRequest} [containerRegistryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContainerRegistry(organizationId: string, containerRegistryRequest?: ContainerRegistryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerRegistryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContainerRegistry(organizationId, containerRegistryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a container registry
         * @param {string} organizationId Organization ID
         * @param {string} containerRegistryId Container Registry ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteContainerRegistry(organizationId: string, containerRegistryId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteContainerRegistry(organizationId, containerRegistryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit a container registry
         * @param {string} organizationId Organization ID
         * @param {string} containerRegistryId Container Registry ID
         * @param {ContainerRegistryRequest} [containerRegistryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editContainerRegistry(organizationId: string, containerRegistryId: string, containerRegistryRequest?: ContainerRegistryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerRegistryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editContainerRegistry(organizationId, containerRegistryId, containerRegistryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a container registry
         * @param {string} organizationId Organization ID
         * @param {string} containerRegistryId Container Registry ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContainerRegistry(organizationId: string, containerRegistryId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerRegistryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContainerRegistry(organizationId, containerRegistryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List image version for a container registry
         * @param {string} organizationId Organization ID
         * @param {string} containerRegistryId Container Registry ID
         * @param {string} imageName container image name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContainerVersions(organizationId: string, containerRegistryId: string, imageName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerVersionResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContainerVersions(organizationId, containerRegistryId, imageName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List supported container registries by Qovery and get the mandatory authentification configuration.
         * @summary List supported container registries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAvailableContainerRegistry(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AvailableContainerRegistryResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAvailableContainerRegistry(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List organization container registries
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContainerRegistry(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerRegistryResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listContainerRegistry(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContainerRegistriesApi - factory interface
 * @export
 */
export const ContainerRegistriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContainerRegistriesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a container registry
         * @param {string} organizationId Organization ID
         * @param {ContainerRegistryRequest} [containerRegistryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainerRegistry(organizationId: string, containerRegistryRequest?: ContainerRegistryRequest, options?: any): AxiosPromise<ContainerRegistryResponse> {
            return localVarFp.createContainerRegistry(organizationId, containerRegistryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a container registry
         * @param {string} organizationId Organization ID
         * @param {string} containerRegistryId Container Registry ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContainerRegistry(organizationId: string, containerRegistryId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteContainerRegistry(organizationId, containerRegistryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a container registry
         * @param {string} organizationId Organization ID
         * @param {string} containerRegistryId Container Registry ID
         * @param {ContainerRegistryRequest} [containerRegistryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editContainerRegistry(organizationId: string, containerRegistryId: string, containerRegistryRequest?: ContainerRegistryRequest, options?: any): AxiosPromise<ContainerRegistryResponse> {
            return localVarFp.editContainerRegistry(organizationId, containerRegistryId, containerRegistryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a container registry
         * @param {string} organizationId Organization ID
         * @param {string} containerRegistryId Container Registry ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainerRegistry(organizationId: string, containerRegistryId: string, options?: any): AxiosPromise<ContainerRegistryResponse> {
            return localVarFp.getContainerRegistry(organizationId, containerRegistryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List image version for a container registry
         * @param {string} organizationId Organization ID
         * @param {string} containerRegistryId Container Registry ID
         * @param {string} imageName container image name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainerVersions(organizationId: string, containerRegistryId: string, imageName: string, options?: any): AxiosPromise<ContainerVersionResponseList> {
            return localVarFp.getContainerVersions(organizationId, containerRegistryId, imageName, options).then((request) => request(axios, basePath));
        },
        /**
         * List supported container registries by Qovery and get the mandatory authentification configuration.
         * @summary List supported container registries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAvailableContainerRegistry(options?: any): AxiosPromise<AvailableContainerRegistryResponseList> {
            return localVarFp.listAvailableContainerRegistry(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List organization container registries
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerRegistry(organizationId: string, options?: any): AxiosPromise<ContainerRegistryResponseList> {
            return localVarFp.listContainerRegistry(organizationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContainerRegistriesApi - object-oriented interface
 * @export
 * @class ContainerRegistriesApi
 * @extends {BaseAPI}
 */
export class ContainerRegistriesApi extends BaseAPI {
    /**
     * 
     * @summary Create a container registry
     * @param {string} organizationId Organization ID
     * @param {ContainerRegistryRequest} [containerRegistryRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerRegistriesApi
     */
    public createContainerRegistry(organizationId: string, containerRegistryRequest?: ContainerRegistryRequest, options?: AxiosRequestConfig) {
        return ContainerRegistriesApiFp(this.configuration).createContainerRegistry(organizationId, containerRegistryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a container registry
     * @param {string} organizationId Organization ID
     * @param {string} containerRegistryId Container Registry ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerRegistriesApi
     */
    public deleteContainerRegistry(organizationId: string, containerRegistryId: string, options?: AxiosRequestConfig) {
        return ContainerRegistriesApiFp(this.configuration).deleteContainerRegistry(organizationId, containerRegistryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a container registry
     * @param {string} organizationId Organization ID
     * @param {string} containerRegistryId Container Registry ID
     * @param {ContainerRegistryRequest} [containerRegistryRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerRegistriesApi
     */
    public editContainerRegistry(organizationId: string, containerRegistryId: string, containerRegistryRequest?: ContainerRegistryRequest, options?: AxiosRequestConfig) {
        return ContainerRegistriesApiFp(this.configuration).editContainerRegistry(organizationId, containerRegistryId, containerRegistryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a container registry
     * @param {string} organizationId Organization ID
     * @param {string} containerRegistryId Container Registry ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerRegistriesApi
     */
    public getContainerRegistry(organizationId: string, containerRegistryId: string, options?: AxiosRequestConfig) {
        return ContainerRegistriesApiFp(this.configuration).getContainerRegistry(organizationId, containerRegistryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List image version for a container registry
     * @param {string} organizationId Organization ID
     * @param {string} containerRegistryId Container Registry ID
     * @param {string} imageName container image name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerRegistriesApi
     */
    public getContainerVersions(organizationId: string, containerRegistryId: string, imageName: string, options?: AxiosRequestConfig) {
        return ContainerRegistriesApiFp(this.configuration).getContainerVersions(organizationId, containerRegistryId, imageName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List supported container registries by Qovery and get the mandatory authentification configuration.
     * @summary List supported container registries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerRegistriesApi
     */
    public listAvailableContainerRegistry(options?: AxiosRequestConfig) {
        return ContainerRegistriesApiFp(this.configuration).listAvailableContainerRegistry(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List organization container registries
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerRegistriesApi
     */
    public listContainerRegistry(organizationId: string, options?: AxiosRequestConfig) {
        return ContainerRegistriesApiFp(this.configuration).listContainerRegistry(organizationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContainerSecretApi - axios parameter creator
 * @export
 */
export const ContainerSecretApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * - Add a secret to the container. 
         * @summary Add a secret to the container
         * @param {string} containerId Container ID
         * @param {SecretRequest} [secretRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainerSecret: async (containerId: string, secretRequest?: SecretRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('createContainerSecret', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/secret`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(secretRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to add an alias at container level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at container level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - You can\'t create an alias on an alias 
         * @summary Create a secret alias at the container level
         * @param {string} containerId Container ID
         * @param {string} secretId Secret ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainerSecretAlias: async (containerId: string, secretId: string, key?: Key, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('createContainerSecretAlias', 'containerId', containerId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('createContainerSecretAlias', 'secretId', secretId)
            const localVarPath = `/container/{containerId}/secret/{secretId}/alias`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(key, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to override at container level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at container level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
         * @summary Create a secret override at the container level
         * @param {string} containerId Container ID
         * @param {string} secretId Secret ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainerSecretOverride: async (containerId: string, secretId: string, value?: Value, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('createContainerSecretOverride', 'containerId', containerId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('createContainerSecretOverride', 'secretId', secretId)
            const localVarPath = `/container/{containerId}/secret/{secretId}/override`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(value, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete a secret from an container
         * @param {string} containerId Container ID
         * @param {string} secretId Secret ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContainerSecret: async (containerId: string, secretId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('deleteContainerSecret', 'containerId', containerId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('deleteContainerSecret', 'secretId', secretId)
            const localVarPath = `/container/{containerId}/secret/{secretId}`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > CONTAINER) 
         * @summary Edit a secret belonging to the container
         * @param {string} containerId Container ID
         * @param {string} secretId Secret ID
         * @param {SecretEditRequest} secretEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editContainerSecret: async (containerId: string, secretId: string, secretEditRequest: SecretEditRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('editContainerSecret', 'containerId', containerId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('editContainerSecret', 'secretId', secretId)
            // verify required parameter 'secretEditRequest' is not null or undefined
            assertParamExists('editContainerSecret', 'secretEditRequest', secretEditRequest)
            const localVarPath = `/container/{containerId}/secret/{secretId}`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(secretEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Secrets are like environment variables, but they are secured and can\'t be revealed.
         * @summary List container secrets
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerSecrets: async (containerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('listContainerSecrets', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/secret`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContainerSecretApi - functional programming interface
 * @export
 */
export const ContainerSecretApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContainerSecretApiAxiosParamCreator(configuration)
    return {
        /**
         * - Add a secret to the container. 
         * @summary Add a secret to the container
         * @param {string} containerId Container ID
         * @param {SecretRequest} [secretRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContainerSecret(containerId: string, secretRequest?: SecretRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContainerSecret(containerId, secretRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - Allows you to add an alias at container level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at container level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - You can\'t create an alias on an alias 
         * @summary Create a secret alias at the container level
         * @param {string} containerId Container ID
         * @param {string} secretId Secret ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContainerSecretAlias(containerId: string, secretId: string, key?: Key, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContainerSecretAlias(containerId, secretId, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - Allows you to override at container level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at container level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
         * @summary Create a secret override at the container level
         * @param {string} containerId Container ID
         * @param {string} secretId Secret ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContainerSecretOverride(containerId: string, secretId: string, value?: Value, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContainerSecretOverride(containerId, secretId, value, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete a secret from an container
         * @param {string} containerId Container ID
         * @param {string} secretId Secret ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteContainerSecret(containerId: string, secretId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteContainerSecret(containerId, secretId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > CONTAINER) 
         * @summary Edit a secret belonging to the container
         * @param {string} containerId Container ID
         * @param {string} secretId Secret ID
         * @param {SecretEditRequest} secretEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editContainerSecret(containerId: string, secretId: string, secretEditRequest: SecretEditRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editContainerSecret(containerId, secretId, secretEditRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Secrets are like environment variables, but they are secured and can\'t be revealed.
         * @summary List container secrets
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContainerSecrets(containerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecretResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listContainerSecrets(containerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContainerSecretApi - factory interface
 * @export
 */
export const ContainerSecretApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContainerSecretApiFp(configuration)
    return {
        /**
         * - Add a secret to the container. 
         * @summary Add a secret to the container
         * @param {string} containerId Container ID
         * @param {SecretRequest} [secretRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainerSecret(containerId: string, secretRequest?: SecretRequest, options?: any): AxiosPromise<Secret> {
            return localVarFp.createContainerSecret(containerId, secretRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to add an alias at container level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at container level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - You can\'t create an alias on an alias 
         * @summary Create a secret alias at the container level
         * @param {string} containerId Container ID
         * @param {string} secretId Secret ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainerSecretAlias(containerId: string, secretId: string, key?: Key, options?: any): AxiosPromise<Secret> {
            return localVarFp.createContainerSecretAlias(containerId, secretId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to override at container level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at container level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
         * @summary Create a secret override at the container level
         * @param {string} containerId Container ID
         * @param {string} secretId Secret ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainerSecretOverride(containerId: string, secretId: string, value?: Value, options?: any): AxiosPromise<Secret> {
            return localVarFp.createContainerSecretOverride(containerId, secretId, value, options).then((request) => request(axios, basePath));
        },
        /**
         * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete a secret from an container
         * @param {string} containerId Container ID
         * @param {string} secretId Secret ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContainerSecret(containerId: string, secretId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteContainerSecret(containerId, secretId, options).then((request) => request(axios, basePath));
        },
        /**
         * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > CONTAINER) 
         * @summary Edit a secret belonging to the container
         * @param {string} containerId Container ID
         * @param {string} secretId Secret ID
         * @param {SecretEditRequest} secretEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editContainerSecret(containerId: string, secretId: string, secretEditRequest: SecretEditRequest, options?: any): AxiosPromise<Secret> {
            return localVarFp.editContainerSecret(containerId, secretId, secretEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Secrets are like environment variables, but they are secured and can\'t be revealed.
         * @summary List container secrets
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerSecrets(containerId: string, options?: any): AxiosPromise<SecretResponseList> {
            return localVarFp.listContainerSecrets(containerId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContainerSecretApi - object-oriented interface
 * @export
 * @class ContainerSecretApi
 * @extends {BaseAPI}
 */
export class ContainerSecretApi extends BaseAPI {
    /**
     * - Add a secret to the container. 
     * @summary Add a secret to the container
     * @param {string} containerId Container ID
     * @param {SecretRequest} [secretRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerSecretApi
     */
    public createContainerSecret(containerId: string, secretRequest?: SecretRequest, options?: AxiosRequestConfig) {
        return ContainerSecretApiFp(this.configuration).createContainerSecret(containerId, secretRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to add an alias at container level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at container level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - You can\'t create an alias on an alias 
     * @summary Create a secret alias at the container level
     * @param {string} containerId Container ID
     * @param {string} secretId Secret ID
     * @param {Key} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerSecretApi
     */
    public createContainerSecretAlias(containerId: string, secretId: string, key?: Key, options?: AxiosRequestConfig) {
        return ContainerSecretApiFp(this.configuration).createContainerSecretAlias(containerId, secretId, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to override at container level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at container level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
     * @summary Create a secret override at the container level
     * @param {string} containerId Container ID
     * @param {string} secretId Secret ID
     * @param {Value} [value] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerSecretApi
     */
    public createContainerSecretOverride(containerId: string, secretId: string, value?: Value, options?: AxiosRequestConfig) {
        return ContainerSecretApiFp(this.configuration).createContainerSecretOverride(containerId, secretId, value, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well 
     * @summary Delete a secret from an container
     * @param {string} containerId Container ID
     * @param {string} secretId Secret ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerSecretApi
     */
    public deleteContainerSecret(containerId: string, secretId: string, options?: AxiosRequestConfig) {
        return ContainerSecretApiFp(this.configuration).deleteContainerSecret(containerId, secretId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > CONTAINER) 
     * @summary Edit a secret belonging to the container
     * @param {string} containerId Container ID
     * @param {string} secretId Secret ID
     * @param {SecretEditRequest} secretEditRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerSecretApi
     */
    public editContainerSecret(containerId: string, secretId: string, secretEditRequest: SecretEditRequest, options?: AxiosRequestConfig) {
        return ContainerSecretApiFp(this.configuration).editContainerSecret(containerId, secretId, secretEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Secrets are like environment variables, but they are secured and can\'t be revealed.
     * @summary List container secrets
     * @param {string} containerId Container ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerSecretApi
     */
    public listContainerSecrets(containerId: string, options?: AxiosRequestConfig) {
        return ContainerSecretApiFp(this.configuration).listContainerSecrets(containerId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContainersApi - axios parameter creator
 * @export
 */
export const ContainersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Triggers a new container deploy in each environment matching the following conditions - environment should have the auto-deploy enabled - the container should have the same image name and a different tag 
         * @summary Auto deploy containers
         * @param {string} organizationId Organization ID
         * @param {OrganizationContainerAutoDeployRequest} [organizationContainerAutoDeployRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoDeployContainerEnvironments: async (organizationId: string, organizationContainerAutoDeployRequest?: OrganizationContainerAutoDeployRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('autoDeployContainerEnvironments', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/container/deploy`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationContainerAutoDeployRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This will create a new container with the same configuration on the targeted environment Id.
         * @summary Clone container
         * @param {string} containerId Container ID
         * @param {CloneServiceRequest} [cloneServiceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneContainer: async (containerId: string, cloneServiceRequest?: CloneServiceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('cloneContainer', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/clone`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloneServiceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a container
         * @param {string} environmentId Environment ID
         * @param {ContainerRequest} [containerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainer: async (environmentId: string, containerRequest?: ContainerRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('createContainer', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/container`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(containerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of containers with only their id and status.
         * @summary List all container registry container statuses
         * @param {string} organizationId Organization ID
         * @param {string} containerRegistryId Container Registry ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainerRegistryContainerStatus: async (organizationId: string, containerRegistryId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getContainerRegistryContainerStatus', 'organizationId', organizationId)
            // verify required parameter 'containerRegistryId' is not null or undefined
            assertParamExists('getContainerRegistryContainerStatus', 'containerRegistryId', containerRegistryId)
            const localVarPath = `/organization/{organizationId}/containerRegistry/{containerRegistryId}/container/status`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"containerRegistryId"}}`, encodeURIComponent(String(containerRegistryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Default values for each setting are available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/advanced-settings/)
         * @summary List default container advanced settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultContainerAdvancedSettings: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/defaultContainerAdvancedSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of containers with only their id and status.
         * @summary List all environment container statuses
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentContainerStatus: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('getEnvironmentContainerStatus', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/container/status`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List containers
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainer: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('listContainer', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/container`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Triggers a new container preview for each environment matching the following conditions - preview environment feature should be enabled for the container - the container should have the same image name and a different tag 
         * @summary Preview container environments
         * @param {string} organizationId Organization ID
         * @param {OrganizationContainerPreviewRequest} [organizationContainerPreviewRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewContainerEnvironments: async (organizationId: string, organizationContainerPreviewRequest?: OrganizationContainerPreviewRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('previewContainerEnvironments', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/container/preview`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationContainerPreviewRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContainersApi - functional programming interface
 * @export
 */
export const ContainersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContainersApiAxiosParamCreator(configuration)
    return {
        /**
         * Triggers a new container deploy in each environment matching the following conditions - environment should have the auto-deploy enabled - the container should have the same image name and a different tag 
         * @summary Auto deploy containers
         * @param {string} organizationId Organization ID
         * @param {OrganizationContainerAutoDeployRequest} [organizationContainerAutoDeployRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autoDeployContainerEnvironments(organizationId: string, organizationContainerAutoDeployRequest?: OrganizationContainerAutoDeployRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autoDeployContainerEnvironments(organizationId, organizationContainerAutoDeployRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This will create a new container with the same configuration on the targeted environment Id.
         * @summary Clone container
         * @param {string} containerId Container ID
         * @param {CloneServiceRequest} [cloneServiceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloneContainer(containerId: string, cloneServiceRequest?: CloneServiceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cloneContainer(containerId, cloneServiceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a container
         * @param {string} environmentId Environment ID
         * @param {ContainerRequest} [containerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContainer(environmentId: string, containerRequest?: ContainerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContainer(environmentId, containerRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of containers with only their id and status.
         * @summary List all container registry container statuses
         * @param {string} organizationId Organization ID
         * @param {string} containerRegistryId Container Registry ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContainerRegistryContainerStatus(organizationId: string, containerRegistryId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReferenceObjectStatusResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContainerRegistryContainerStatus(organizationId, containerRegistryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Default values for each setting are available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/advanced-settings/)
         * @summary List default container advanced settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDefaultContainerAdvancedSettings(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerAdvancedSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDefaultContainerAdvancedSettings(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of containers with only their id and status.
         * @summary List all environment container statuses
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironmentContainerStatus(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReferenceObjectStatusResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironmentContainerStatus(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List containers
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContainer(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listContainer(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Triggers a new container preview for each environment matching the following conditions - preview environment feature should be enabled for the container - the container should have the same image name and a different tag 
         * @summary Preview container environments
         * @param {string} organizationId Organization ID
         * @param {OrganizationContainerPreviewRequest} [organizationContainerPreviewRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async previewContainerEnvironments(organizationId: string, organizationContainerPreviewRequest?: OrganizationContainerPreviewRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.previewContainerEnvironments(organizationId, organizationContainerPreviewRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContainersApi - factory interface
 * @export
 */
export const ContainersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContainersApiFp(configuration)
    return {
        /**
         * Triggers a new container deploy in each environment matching the following conditions - environment should have the auto-deploy enabled - the container should have the same image name and a different tag 
         * @summary Auto deploy containers
         * @param {string} organizationId Organization ID
         * @param {OrganizationContainerAutoDeployRequest} [organizationContainerAutoDeployRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoDeployContainerEnvironments(organizationId: string, organizationContainerAutoDeployRequest?: OrganizationContainerAutoDeployRequest, options?: any): AxiosPromise<Status> {
            return localVarFp.autoDeployContainerEnvironments(organizationId, organizationContainerAutoDeployRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This will create a new container with the same configuration on the targeted environment Id.
         * @summary Clone container
         * @param {string} containerId Container ID
         * @param {CloneServiceRequest} [cloneServiceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneContainer(containerId: string, cloneServiceRequest?: CloneServiceRequest, options?: any): AxiosPromise<ContainerResponse> {
            return localVarFp.cloneContainer(containerId, cloneServiceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a container
         * @param {string} environmentId Environment ID
         * @param {ContainerRequest} [containerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainer(environmentId: string, containerRequest?: ContainerRequest, options?: any): AxiosPromise<ContainerResponse> {
            return localVarFp.createContainer(environmentId, containerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of containers with only their id and status.
         * @summary List all container registry container statuses
         * @param {string} organizationId Organization ID
         * @param {string} containerRegistryId Container Registry ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainerRegistryContainerStatus(organizationId: string, containerRegistryId: string, options?: any): AxiosPromise<ReferenceObjectStatusResponseList> {
            return localVarFp.getContainerRegistryContainerStatus(organizationId, containerRegistryId, options).then((request) => request(axios, basePath));
        },
        /**
         * Default values for each setting are available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/advanced-settings/)
         * @summary List default container advanced settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultContainerAdvancedSettings(options?: any): AxiosPromise<ContainerAdvancedSettings> {
            return localVarFp.getDefaultContainerAdvancedSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of containers with only their id and status.
         * @summary List all environment container statuses
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentContainerStatus(environmentId: string, options?: any): AxiosPromise<ReferenceObjectStatusResponseList> {
            return localVarFp.getEnvironmentContainerStatus(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List containers
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainer(environmentId: string, options?: any): AxiosPromise<ContainerResponseList> {
            return localVarFp.listContainer(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Triggers a new container preview for each environment matching the following conditions - preview environment feature should be enabled for the container - the container should have the same image name and a different tag 
         * @summary Preview container environments
         * @param {string} organizationId Organization ID
         * @param {OrganizationContainerPreviewRequest} [organizationContainerPreviewRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewContainerEnvironments(organizationId: string, organizationContainerPreviewRequest?: OrganizationContainerPreviewRequest, options?: any): AxiosPromise<Status> {
            return localVarFp.previewContainerEnvironments(organizationId, organizationContainerPreviewRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContainersApi - object-oriented interface
 * @export
 * @class ContainersApi
 * @extends {BaseAPI}
 */
export class ContainersApi extends BaseAPI {
    /**
     * Triggers a new container deploy in each environment matching the following conditions - environment should have the auto-deploy enabled - the container should have the same image name and a different tag 
     * @summary Auto deploy containers
     * @param {string} organizationId Organization ID
     * @param {OrganizationContainerAutoDeployRequest} [organizationContainerAutoDeployRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public autoDeployContainerEnvironments(organizationId: string, organizationContainerAutoDeployRequest?: OrganizationContainerAutoDeployRequest, options?: AxiosRequestConfig) {
        return ContainersApiFp(this.configuration).autoDeployContainerEnvironments(organizationId, organizationContainerAutoDeployRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will create a new container with the same configuration on the targeted environment Id.
     * @summary Clone container
     * @param {string} containerId Container ID
     * @param {CloneServiceRequest} [cloneServiceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public cloneContainer(containerId: string, cloneServiceRequest?: CloneServiceRequest, options?: AxiosRequestConfig) {
        return ContainersApiFp(this.configuration).cloneContainer(containerId, cloneServiceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a container
     * @param {string} environmentId Environment ID
     * @param {ContainerRequest} [containerRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public createContainer(environmentId: string, containerRequest?: ContainerRequest, options?: AxiosRequestConfig) {
        return ContainersApiFp(this.configuration).createContainer(environmentId, containerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of containers with only their id and status.
     * @summary List all container registry container statuses
     * @param {string} organizationId Organization ID
     * @param {string} containerRegistryId Container Registry ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public getContainerRegistryContainerStatus(organizationId: string, containerRegistryId: string, options?: AxiosRequestConfig) {
        return ContainersApiFp(this.configuration).getContainerRegistryContainerStatus(organizationId, containerRegistryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Default values for each setting are available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/advanced-settings/)
     * @summary List default container advanced settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public getDefaultContainerAdvancedSettings(options?: AxiosRequestConfig) {
        return ContainersApiFp(this.configuration).getDefaultContainerAdvancedSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of containers with only their id and status.
     * @summary List all environment container statuses
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public getEnvironmentContainerStatus(environmentId: string, options?: AxiosRequestConfig) {
        return ContainersApiFp(this.configuration).getEnvironmentContainerStatus(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List containers
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public listContainer(environmentId: string, options?: AxiosRequestConfig) {
        return ContainersApiFp(this.configuration).listContainer(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Triggers a new container preview for each environment matching the following conditions - preview environment feature should be enabled for the container - the container should have the same image name and a different tag 
     * @summary Preview container environments
     * @param {string} organizationId Organization ID
     * @param {OrganizationContainerPreviewRequest} [organizationContainerPreviewRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public previewContainerEnvironments(organizationId: string, organizationContainerPreviewRequest?: OrganizationContainerPreviewRequest, options?: AxiosRequestConfig) {
        return ContainersApiFp(this.configuration).previewContainerEnvironments(organizationId, organizationContainerPreviewRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CustomDomainApi - axios parameter creator
 * @export
 */
export const CustomDomainApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a custom domain to this application in order not to use qovery autogenerated domain
         * @summary Add custom domain to the application.
         * @param {string} applicationId Application ID
         * @param {CustomDomainRequest} [customDomainRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationCustomDomain: async (applicationId: string, customDomainRequest?: CustomDomainRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('createApplicationCustomDomain', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/customDomain`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customDomainRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To delete an CustomDomain you must have the project user permission
         * @summary Delete a Custom Domain
         * @param {string} applicationId Application ID
         * @param {string} customDomainId Custom Domain ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomDomain: async (applicationId: string, customDomainId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('deleteCustomDomain', 'applicationId', applicationId)
            // verify required parameter 'customDomainId' is not null or undefined
            assertParamExists('deleteCustomDomain', 'customDomainId', customDomainId)
            const localVarPath = `/application/{applicationId}/customDomain/{customDomainId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"customDomainId"}}`, encodeURIComponent(String(customDomainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To edit a Custom Domain you must have the project user permission
         * @summary Edit a Custom Domain
         * @param {string} applicationId Application ID
         * @param {string} customDomainId Custom Domain ID
         * @param {CustomDomainRequest} [customDomainRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editCustomDomain: async (applicationId: string, customDomainId: string, customDomainRequest?: CustomDomainRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('editCustomDomain', 'applicationId', applicationId)
            // verify required parameter 'customDomainId' is not null or undefined
            assertParamExists('editCustomDomain', 'customDomainId', customDomainId)
            const localVarPath = `/application/{applicationId}/customDomain/{customDomainId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"customDomainId"}}`, encodeURIComponent(String(customDomainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customDomainRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Custom Domain status
         * @param {string} applicationId Application ID
         * @param {string} customDomainId Custom Domain ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomDomainStatus: async (applicationId: string, customDomainId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getCustomDomainStatus', 'applicationId', applicationId)
            // verify required parameter 'customDomainId' is not null or undefined
            assertParamExists('getCustomDomainStatus', 'customDomainId', customDomainId)
            const localVarPath = `/application/{applicationId}/customDomain/{customDomainId}/status`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"customDomainId"}}`, encodeURIComponent(String(customDomainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List application custom domains
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationCustomDomain: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('listApplicationCustomDomain', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/customDomain`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomDomainApi - functional programming interface
 * @export
 */
export const CustomDomainApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomDomainApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a custom domain to this application in order not to use qovery autogenerated domain
         * @summary Add custom domain to the application.
         * @param {string} applicationId Application ID
         * @param {CustomDomainRequest} [customDomainRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplicationCustomDomain(applicationId: string, customDomainRequest?: CustomDomainRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomDomain>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplicationCustomDomain(applicationId, customDomainRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * To delete an CustomDomain you must have the project user permission
         * @summary Delete a Custom Domain
         * @param {string} applicationId Application ID
         * @param {string} customDomainId Custom Domain ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCustomDomain(applicationId: string, customDomainId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCustomDomain(applicationId, customDomainId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * To edit a Custom Domain you must have the project user permission
         * @summary Edit a Custom Domain
         * @param {string} applicationId Application ID
         * @param {string} customDomainId Custom Domain ID
         * @param {CustomDomainRequest} [customDomainRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editCustomDomain(applicationId: string, customDomainId: string, customDomainRequest?: CustomDomainRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomDomain>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editCustomDomain(applicationId, customDomainId, customDomainRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Custom Domain status
         * @param {string} applicationId Application ID
         * @param {string} customDomainId Custom Domain ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomDomainStatus(applicationId: string, customDomainId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomDomain>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomDomainStatus(applicationId, customDomainId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List application custom domains
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplicationCustomDomain(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomDomainResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplicationCustomDomain(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CustomDomainApi - factory interface
 * @export
 */
export const CustomDomainApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomDomainApiFp(configuration)
    return {
        /**
         * Add a custom domain to this application in order not to use qovery autogenerated domain
         * @summary Add custom domain to the application.
         * @param {string} applicationId Application ID
         * @param {CustomDomainRequest} [customDomainRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationCustomDomain(applicationId: string, customDomainRequest?: CustomDomainRequest, options?: any): AxiosPromise<CustomDomain> {
            return localVarFp.createApplicationCustomDomain(applicationId, customDomainRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * To delete an CustomDomain you must have the project user permission
         * @summary Delete a Custom Domain
         * @param {string} applicationId Application ID
         * @param {string} customDomainId Custom Domain ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomDomain(applicationId: string, customDomainId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCustomDomain(applicationId, customDomainId, options).then((request) => request(axios, basePath));
        },
        /**
         * To edit a Custom Domain you must have the project user permission
         * @summary Edit a Custom Domain
         * @param {string} applicationId Application ID
         * @param {string} customDomainId Custom Domain ID
         * @param {CustomDomainRequest} [customDomainRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editCustomDomain(applicationId: string, customDomainId: string, customDomainRequest?: CustomDomainRequest, options?: any): AxiosPromise<CustomDomain> {
            return localVarFp.editCustomDomain(applicationId, customDomainId, customDomainRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Custom Domain status
         * @param {string} applicationId Application ID
         * @param {string} customDomainId Custom Domain ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomDomainStatus(applicationId: string, customDomainId: string, options?: any): AxiosPromise<CustomDomain> {
            return localVarFp.getCustomDomainStatus(applicationId, customDomainId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List application custom domains
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationCustomDomain(applicationId: string, options?: any): AxiosPromise<CustomDomainResponseList> {
            return localVarFp.listApplicationCustomDomain(applicationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CustomDomainApi - object-oriented interface
 * @export
 * @class CustomDomainApi
 * @extends {BaseAPI}
 */
export class CustomDomainApi extends BaseAPI {
    /**
     * Add a custom domain to this application in order not to use qovery autogenerated domain
     * @summary Add custom domain to the application.
     * @param {string} applicationId Application ID
     * @param {CustomDomainRequest} [customDomainRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomDomainApi
     */
    public createApplicationCustomDomain(applicationId: string, customDomainRequest?: CustomDomainRequest, options?: AxiosRequestConfig) {
        return CustomDomainApiFp(this.configuration).createApplicationCustomDomain(applicationId, customDomainRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To delete an CustomDomain you must have the project user permission
     * @summary Delete a Custom Domain
     * @param {string} applicationId Application ID
     * @param {string} customDomainId Custom Domain ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomDomainApi
     */
    public deleteCustomDomain(applicationId: string, customDomainId: string, options?: AxiosRequestConfig) {
        return CustomDomainApiFp(this.configuration).deleteCustomDomain(applicationId, customDomainId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To edit a Custom Domain you must have the project user permission
     * @summary Edit a Custom Domain
     * @param {string} applicationId Application ID
     * @param {string} customDomainId Custom Domain ID
     * @param {CustomDomainRequest} [customDomainRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomDomainApi
     */
    public editCustomDomain(applicationId: string, customDomainId: string, customDomainRequest?: CustomDomainRequest, options?: AxiosRequestConfig) {
        return CustomDomainApiFp(this.configuration).editCustomDomain(applicationId, customDomainId, customDomainRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Custom Domain status
     * @param {string} applicationId Application ID
     * @param {string} customDomainId Custom Domain ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomDomainApi
     */
    public getCustomDomainStatus(applicationId: string, customDomainId: string, options?: AxiosRequestConfig) {
        return CustomDomainApiFp(this.configuration).getCustomDomainStatus(applicationId, customDomainId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List application custom domains
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomDomainApi
     */
    public listApplicationCustomDomain(applicationId: string, options?: AxiosRequestConfig) {
        return CustomDomainApiFp(this.configuration).listApplicationCustomDomain(applicationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DatabaseActionsApi - axios parameter creator
 * @export
 */
export const DatabaseActionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deploy database 
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployDatabase: async (databaseId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('deployDatabase', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}/deploy`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retart database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rebootDatabase: async (databaseId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('rebootDatabase', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}/restart-service`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Redeploy database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeployDatabase: async (databaseId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('redeployDatabase', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}/redeploy`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopDatabase: async (databaseId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('stopDatabase', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}/stop`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatabaseActionsApi - functional programming interface
 * @export
 */
export const DatabaseActionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DatabaseActionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Deploy database 
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployDatabase(databaseId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployDatabase(databaseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retart database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rebootDatabase(databaseId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rebootDatabase(databaseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Redeploy database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async redeployDatabase(databaseId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.redeployDatabase(databaseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Stop database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopDatabase(databaseId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopDatabase(databaseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DatabaseActionsApi - factory interface
 * @export
 */
export const DatabaseActionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DatabaseActionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Deploy database 
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployDatabase(databaseId: string, options?: any): AxiosPromise<Status> {
            return localVarFp.deployDatabase(databaseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retart database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rebootDatabase(databaseId: string, options?: any): AxiosPromise<Status> {
            return localVarFp.rebootDatabase(databaseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Redeploy database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeployDatabase(databaseId: string, options?: any): AxiosPromise<Status> {
            return localVarFp.redeployDatabase(databaseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Stop database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopDatabase(databaseId: string, options?: any): AxiosPromise<Status> {
            return localVarFp.stopDatabase(databaseId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DatabaseActionsApi - object-oriented interface
 * @export
 * @class DatabaseActionsApi
 * @extends {BaseAPI}
 */
export class DatabaseActionsApi extends BaseAPI {
    /**
     * 
     * @summary Deploy database 
     * @param {string} databaseId Database ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseActionsApi
     */
    public deployDatabase(databaseId: string, options?: AxiosRequestConfig) {
        return DatabaseActionsApiFp(this.configuration).deployDatabase(databaseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retart database
     * @param {string} databaseId Database ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseActionsApi
     */
    public rebootDatabase(databaseId: string, options?: AxiosRequestConfig) {
        return DatabaseActionsApiFp(this.configuration).rebootDatabase(databaseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Redeploy database
     * @param {string} databaseId Database ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseActionsApi
     */
    public redeployDatabase(databaseId: string, options?: AxiosRequestConfig) {
        return DatabaseActionsApiFp(this.configuration).redeployDatabase(databaseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Stop database
     * @param {string} databaseId Database ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseActionsApi
     */
    public stopDatabase(databaseId: string, options?: AxiosRequestConfig) {
        return DatabaseActionsApiFp(this.configuration).stopDatabase(databaseId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DatabaseApplicationApi - axios parameter creator
 * @export
 */
export const DatabaseApplicationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List applications using the database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseApplication: async (databaseId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('listDatabaseApplication', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}/application`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove an application from this database 
         * @param {string} databaseId Database ID
         * @param {string} targetApplicationId Target application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeApplicationFromDatabase: async (databaseId: string, targetApplicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('removeApplicationFromDatabase', 'databaseId', databaseId)
            // verify required parameter 'targetApplicationId' is not null or undefined
            assertParamExists('removeApplicationFromDatabase', 'targetApplicationId', targetApplicationId)
            const localVarPath = `/database/{databaseId}/application/{targetApplicationId}`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)))
                .replace(`{${"targetApplicationId"}}`, encodeURIComponent(String(targetApplicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatabaseApplicationApi - functional programming interface
 * @export
 */
export const DatabaseApplicationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DatabaseApplicationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List applications using the database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDatabaseApplication(databaseId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDatabaseApplication(databaseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove an application from this database 
         * @param {string} databaseId Database ID
         * @param {string} targetApplicationId Target application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeApplicationFromDatabase(databaseId: string, targetApplicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeApplicationFromDatabase(databaseId, targetApplicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DatabaseApplicationApi - factory interface
 * @export
 */
export const DatabaseApplicationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DatabaseApplicationApiFp(configuration)
    return {
        /**
         * 
         * @summary List applications using the database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseApplication(databaseId: string, options?: any): AxiosPromise<ApplicationResponseList> {
            return localVarFp.listDatabaseApplication(databaseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove an application from this database 
         * @param {string} databaseId Database ID
         * @param {string} targetApplicationId Target application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeApplicationFromDatabase(databaseId: string, targetApplicationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeApplicationFromDatabase(databaseId, targetApplicationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DatabaseApplicationApi - object-oriented interface
 * @export
 * @class DatabaseApplicationApi
 * @extends {BaseAPI}
 */
export class DatabaseApplicationApi extends BaseAPI {
    /**
     * 
     * @summary List applications using the database
     * @param {string} databaseId Database ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseApplicationApi
     */
    public listDatabaseApplication(databaseId: string, options?: AxiosRequestConfig) {
        return DatabaseApplicationApiFp(this.configuration).listDatabaseApplication(databaseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove an application from this database 
     * @param {string} databaseId Database ID
     * @param {string} targetApplicationId Target application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseApplicationApi
     */
    public removeApplicationFromDatabase(databaseId: string, targetApplicationId: string, options?: AxiosRequestConfig) {
        return DatabaseApplicationApiFp(this.configuration).removeApplicationFromDatabase(databaseId, targetApplicationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DatabaseDeploymentHistoryApi - axios parameter creator
 * @export
 */
export const DatabaseDeploymentHistoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * By default it returns the 20 last results. The response is paginated.
         * @summary List database deploys
         * @param {string} databaseId Database ID
         * @param {string} [startId] Starting point after which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseDeploymentHistory: async (databaseId: string, startId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('listDatabaseDeploymentHistory', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}/deploymentHistory`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (startId !== undefined) {
                localVarQueryParameter['startId'] = startId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatabaseDeploymentHistoryApi - functional programming interface
 * @export
 */
export const DatabaseDeploymentHistoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DatabaseDeploymentHistoryApiAxiosParamCreator(configuration)
    return {
        /**
         * By default it returns the 20 last results. The response is paginated.
         * @summary List database deploys
         * @param {string} databaseId Database ID
         * @param {string} [startId] Starting point after which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDatabaseDeploymentHistory(databaseId: string, startId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListDatabaseDeploymentHistory200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDatabaseDeploymentHistory(databaseId, startId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DatabaseDeploymentHistoryApi - factory interface
 * @export
 */
export const DatabaseDeploymentHistoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DatabaseDeploymentHistoryApiFp(configuration)
    return {
        /**
         * By default it returns the 20 last results. The response is paginated.
         * @summary List database deploys
         * @param {string} databaseId Database ID
         * @param {string} [startId] Starting point after which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseDeploymentHistory(databaseId: string, startId?: string, options?: any): AxiosPromise<ListDatabaseDeploymentHistory200Response> {
            return localVarFp.listDatabaseDeploymentHistory(databaseId, startId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DatabaseDeploymentHistoryApi - object-oriented interface
 * @export
 * @class DatabaseDeploymentHistoryApi
 * @extends {BaseAPI}
 */
export class DatabaseDeploymentHistoryApi extends BaseAPI {
    /**
     * By default it returns the 20 last results. The response is paginated.
     * @summary List database deploys
     * @param {string} databaseId Database ID
     * @param {string} [startId] Starting point after which to return results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseDeploymentHistoryApi
     */
    public listDatabaseDeploymentHistory(databaseId: string, startId?: string, options?: AxiosRequestConfig) {
        return DatabaseDeploymentHistoryApiFp(this.configuration).listDatabaseDeploymentHistory(databaseId, startId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DatabaseMainCallsApi - axios parameter creator
 * @export
 */
export const DatabaseMainCallsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * To delete a database you must have the admin permission
         * @summary Delete a database 
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDatabase: async (databaseId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('deleteDatabase', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To edit a database  you must have the admin permission
         * @summary Edit a database 
         * @param {string} databaseId Database ID
         * @param {DatabaseEditRequest} [databaseEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editDatabase: async (databaseId: string, databaseEditRequest?: DatabaseEditRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('editDatabase', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(databaseEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit database  master credentials
         * @param {string} databaseId Database ID
         * @param {CredentialsRequest} [credentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editDatabaseCredentials: async (databaseId: string, credentialsRequest?: CredentialsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('editDatabaseCredentials', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}/masterCredentials`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(credentialsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get database by ID
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabase: async (databaseId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('getDatabase', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get master credentials of the database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseMasterCredentials: async (databaseId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('getDatabaseMasterCredentials', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}/masterCredentials`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get database status
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseStatus: async (databaseId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('getDatabaseStatus', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}/status`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List eligible versions for the database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseVersion: async (databaseId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('listDatabaseVersion', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}/version`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatabaseMainCallsApi - functional programming interface
 * @export
 */
export const DatabaseMainCallsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DatabaseMainCallsApiAxiosParamCreator(configuration)
    return {
        /**
         * To delete a database you must have the admin permission
         * @summary Delete a database 
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDatabase(databaseId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDatabase(databaseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * To edit a database  you must have the admin permission
         * @summary Edit a database 
         * @param {string} databaseId Database ID
         * @param {DatabaseEditRequest} [databaseEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editDatabase(databaseId: string, databaseEditRequest?: DatabaseEditRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Database>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editDatabase(databaseId, databaseEditRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit database  master credentials
         * @param {string} databaseId Database ID
         * @param {CredentialsRequest} [credentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editDatabaseCredentials(databaseId: string, credentialsRequest?: CredentialsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Credentials>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editDatabaseCredentials(databaseId, credentialsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get database by ID
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDatabase(databaseId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Database>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDatabase(databaseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get master credentials of the database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDatabaseMasterCredentials(databaseId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Credentials>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDatabaseMasterCredentials(databaseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get database status
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDatabaseStatus(databaseId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDatabaseStatus(databaseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List eligible versions for the database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDatabaseVersion(databaseId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VersionResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDatabaseVersion(databaseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DatabaseMainCallsApi - factory interface
 * @export
 */
export const DatabaseMainCallsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DatabaseMainCallsApiFp(configuration)
    return {
        /**
         * To delete a database you must have the admin permission
         * @summary Delete a database 
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDatabase(databaseId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDatabase(databaseId, options).then((request) => request(axios, basePath));
        },
        /**
         * To edit a database  you must have the admin permission
         * @summary Edit a database 
         * @param {string} databaseId Database ID
         * @param {DatabaseEditRequest} [databaseEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editDatabase(databaseId: string, databaseEditRequest?: DatabaseEditRequest, options?: any): AxiosPromise<Database> {
            return localVarFp.editDatabase(databaseId, databaseEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit database  master credentials
         * @param {string} databaseId Database ID
         * @param {CredentialsRequest} [credentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editDatabaseCredentials(databaseId: string, credentialsRequest?: CredentialsRequest, options?: any): AxiosPromise<Credentials> {
            return localVarFp.editDatabaseCredentials(databaseId, credentialsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get database by ID
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabase(databaseId: string, options?: any): AxiosPromise<Database> {
            return localVarFp.getDatabase(databaseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get master credentials of the database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseMasterCredentials(databaseId: string, options?: any): AxiosPromise<Credentials> {
            return localVarFp.getDatabaseMasterCredentials(databaseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get database status
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseStatus(databaseId: string, options?: any): AxiosPromise<Status> {
            return localVarFp.getDatabaseStatus(databaseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List eligible versions for the database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseVersion(databaseId: string, options?: any): AxiosPromise<VersionResponseList> {
            return localVarFp.listDatabaseVersion(databaseId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DatabaseMainCallsApi - object-oriented interface
 * @export
 * @class DatabaseMainCallsApi
 * @extends {BaseAPI}
 */
export class DatabaseMainCallsApi extends BaseAPI {
    /**
     * To delete a database you must have the admin permission
     * @summary Delete a database 
     * @param {string} databaseId Database ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseMainCallsApi
     */
    public deleteDatabase(databaseId: string, options?: AxiosRequestConfig) {
        return DatabaseMainCallsApiFp(this.configuration).deleteDatabase(databaseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To edit a database  you must have the admin permission
     * @summary Edit a database 
     * @param {string} databaseId Database ID
     * @param {DatabaseEditRequest} [databaseEditRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseMainCallsApi
     */
    public editDatabase(databaseId: string, databaseEditRequest?: DatabaseEditRequest, options?: AxiosRequestConfig) {
        return DatabaseMainCallsApiFp(this.configuration).editDatabase(databaseId, databaseEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit database  master credentials
     * @param {string} databaseId Database ID
     * @param {CredentialsRequest} [credentialsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseMainCallsApi
     */
    public editDatabaseCredentials(databaseId: string, credentialsRequest?: CredentialsRequest, options?: AxiosRequestConfig) {
        return DatabaseMainCallsApiFp(this.configuration).editDatabaseCredentials(databaseId, credentialsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get database by ID
     * @param {string} databaseId Database ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseMainCallsApi
     */
    public getDatabase(databaseId: string, options?: AxiosRequestConfig) {
        return DatabaseMainCallsApiFp(this.configuration).getDatabase(databaseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get master credentials of the database
     * @param {string} databaseId Database ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseMainCallsApi
     */
    public getDatabaseMasterCredentials(databaseId: string, options?: AxiosRequestConfig) {
        return DatabaseMainCallsApiFp(this.configuration).getDatabaseMasterCredentials(databaseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get database status
     * @param {string} databaseId Database ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseMainCallsApi
     */
    public getDatabaseStatus(databaseId: string, options?: AxiosRequestConfig) {
        return DatabaseMainCallsApiFp(this.configuration).getDatabaseStatus(databaseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List eligible versions for the database
     * @param {string} databaseId Database ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseMainCallsApi
     */
    public listDatabaseVersion(databaseId: string, options?: AxiosRequestConfig) {
        return DatabaseMainCallsApiFp(this.configuration).listDatabaseVersion(databaseId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DatabasesApi - axios parameter creator
 * @export
 */
export const DatabasesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This will create a new database with the same configuration on the targeted environment Id.
         * @summary Clone database
         * @param {string} databaseId Database ID
         * @param {CloneServiceRequest} [cloneServiceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneDatabase: async (databaseId: string, cloneServiceRequest?: CloneServiceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('cloneDatabase', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}/clone`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloneServiceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a database
         * @param {string} environmentId Environment ID
         * @param {DatabaseRequest} [databaseRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatabase: async (environmentId: string, databaseRequest?: DatabaseRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('createDatabase', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/database`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(databaseRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of databases with only their id and status.
         * @summary List all environment databases statuses
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentDatabaseStatus: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('getEnvironmentDatabaseStatus', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/database/status`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List environment databases
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabase: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('listDatabase', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/database`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List eligible database types, versions and modes for the environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentDatabaseConfig: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('listEnvironmentDatabaseConfig', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/databaseConfiguration`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatabasesApi - functional programming interface
 * @export
 */
export const DatabasesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DatabasesApiAxiosParamCreator(configuration)
    return {
        /**
         * This will create a new database with the same configuration on the targeted environment Id.
         * @summary Clone database
         * @param {string} databaseId Database ID
         * @param {CloneServiceRequest} [cloneServiceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloneDatabase(databaseId: string, cloneServiceRequest?: CloneServiceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Database>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cloneDatabase(databaseId, cloneServiceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a database
         * @param {string} environmentId Environment ID
         * @param {DatabaseRequest} [databaseRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDatabase(environmentId: string, databaseRequest?: DatabaseRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Database>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDatabase(environmentId, databaseRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of databases with only their id and status.
         * @summary List all environment databases statuses
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironmentDatabaseStatus(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReferenceObjectStatusResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironmentDatabaseStatus(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List environment databases
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDatabase(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatabaseResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDatabase(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List eligible database types, versions and modes for the environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEnvironmentDatabaseConfig(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatabaseConfigurationResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEnvironmentDatabaseConfig(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DatabasesApi - factory interface
 * @export
 */
export const DatabasesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DatabasesApiFp(configuration)
    return {
        /**
         * This will create a new database with the same configuration on the targeted environment Id.
         * @summary Clone database
         * @param {string} databaseId Database ID
         * @param {CloneServiceRequest} [cloneServiceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneDatabase(databaseId: string, cloneServiceRequest?: CloneServiceRequest, options?: any): AxiosPromise<Database> {
            return localVarFp.cloneDatabase(databaseId, cloneServiceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a database
         * @param {string} environmentId Environment ID
         * @param {DatabaseRequest} [databaseRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatabase(environmentId: string, databaseRequest?: DatabaseRequest, options?: any): AxiosPromise<Database> {
            return localVarFp.createDatabase(environmentId, databaseRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of databases with only their id and status.
         * @summary List all environment databases statuses
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentDatabaseStatus(environmentId: string, options?: any): AxiosPromise<ReferenceObjectStatusResponseList> {
            return localVarFp.getEnvironmentDatabaseStatus(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List environment databases
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabase(environmentId: string, options?: any): AxiosPromise<DatabaseResponseList> {
            return localVarFp.listDatabase(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List eligible database types, versions and modes for the environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentDatabaseConfig(environmentId: string, options?: any): AxiosPromise<DatabaseConfigurationResponseList> {
            return localVarFp.listEnvironmentDatabaseConfig(environmentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DatabasesApi - object-oriented interface
 * @export
 * @class DatabasesApi
 * @extends {BaseAPI}
 */
export class DatabasesApi extends BaseAPI {
    /**
     * This will create a new database with the same configuration on the targeted environment Id.
     * @summary Clone database
     * @param {string} databaseId Database ID
     * @param {CloneServiceRequest} [cloneServiceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabasesApi
     */
    public cloneDatabase(databaseId: string, cloneServiceRequest?: CloneServiceRequest, options?: AxiosRequestConfig) {
        return DatabasesApiFp(this.configuration).cloneDatabase(databaseId, cloneServiceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a database
     * @param {string} environmentId Environment ID
     * @param {DatabaseRequest} [databaseRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabasesApi
     */
    public createDatabase(environmentId: string, databaseRequest?: DatabaseRequest, options?: AxiosRequestConfig) {
        return DatabasesApiFp(this.configuration).createDatabase(environmentId, databaseRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of databases with only their id and status.
     * @summary List all environment databases statuses
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabasesApi
     */
    public getEnvironmentDatabaseStatus(environmentId: string, options?: AxiosRequestConfig) {
        return DatabasesApiFp(this.configuration).getEnvironmentDatabaseStatus(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List environment databases
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabasesApi
     */
    public listDatabase(environmentId: string, options?: AxiosRequestConfig) {
        return DatabasesApiFp(this.configuration).listDatabase(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List eligible database types, versions and modes for the environment
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabasesApi
     */
    public listEnvironmentDatabaseConfig(environmentId: string, options?: AxiosRequestConfig) {
        return DatabasesApiFp(this.configuration).listEnvironmentDatabaseConfig(environmentId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DeploymentStageMainCallsApi - axios parameter creator
 * @export
 */
export const DeploymentStageMainCallsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Attach service to deployment stage
         * @param {string} deploymentStageId Deployment Stage ID
         * @param {string} serviceId Service ID of an application/job/container/database
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachServiceToDeploymentStage: async (deploymentStageId: string, serviceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deploymentStageId' is not null or undefined
            assertParamExists('attachServiceToDeploymentStage', 'deploymentStageId', deploymentStageId)
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('attachServiceToDeploymentStage', 'serviceId', serviceId)
            const localVarPath = `/deploymentStage/{deploymentStageId}/service/{serviceId}`
                .replace(`{${"deploymentStageId"}}`, encodeURIComponent(String(deploymentStageId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create environment deployment stage
         * @param {string} environmentId Environment ID
         * @param {DeploymentStageRequest} [deploymentStageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironmentDeploymentStage: async (environmentId: string, deploymentStageRequest?: DeploymentStageRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('createEnvironmentDeploymentStage', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/deploymentStage`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deploymentStageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete deployment stage
         * @param {string} deploymentStageId Deployment Stage ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeploymentStage: async (deploymentStageId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deploymentStageId' is not null or undefined
            assertParamExists('deleteDeploymentStage', 'deploymentStageId', deploymentStageId)
            const localVarPath = `/deploymentStage/{deploymentStageId}`
                .replace(`{${"deploymentStageId"}}`, encodeURIComponent(String(deploymentStageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit deployment stage
         * @param {string} deploymentStageId Deployment Stage ID
         * @param {DeploymentStageRequest} [deploymentStageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editDeploymentStage: async (deploymentStageId: string, deploymentStageRequest?: DeploymentStageRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deploymentStageId' is not null or undefined
            assertParamExists('editDeploymentStage', 'deploymentStageId', deploymentStageId)
            const localVarPath = `/deploymentStage/{deploymentStageId}`
                .replace(`{${"deploymentStageId"}}`, encodeURIComponent(String(deploymentStageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deploymentStageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Deployment Stage
         * @param {string} deploymentStageId Deployment Stage ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeploymentStage: async (deploymentStageId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deploymentStageId' is not null or undefined
            assertParamExists('getDeploymentStage', 'deploymentStageId', deploymentStageId)
            const localVarPath = `/deploymentStage/{deploymentStageId}`
                .replace(`{${"deploymentStageId"}}`, encodeURIComponent(String(deploymentStageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Service Deployment Stage
         * @param {string} serviceId Service ID of an application/job/container/database
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeploymentStage: async (serviceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('getServiceDeploymentStage', 'serviceId', serviceId)
            const localVarPath = `/service/{serviceId}/deploymentStage`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List environment deployment stage
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentDeploymentStage: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('listEnvironmentDeploymentStage', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/deploymentStage`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Move deployment stage after requested stage
         * @param {string} deploymentStageId Deployment Stage ID
         * @param {string} stageId Deployment Stage ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveAfterDeploymentStage: async (deploymentStageId: string, stageId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deploymentStageId' is not null or undefined
            assertParamExists('moveAfterDeploymentStage', 'deploymentStageId', deploymentStageId)
            // verify required parameter 'stageId' is not null or undefined
            assertParamExists('moveAfterDeploymentStage', 'stageId', stageId)
            const localVarPath = `/deploymentStage/{deploymentStageId}/moveAfter/{stageId}`
                .replace(`{${"deploymentStageId"}}`, encodeURIComponent(String(deploymentStageId)))
                .replace(`{${"stageId"}}`, encodeURIComponent(String(stageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Move deployment stage before requested stage
         * @param {string} deploymentStageId Deployment Stage ID
         * @param {string} stageId Deployment Stage ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveBeforeDeploymentStage: async (deploymentStageId: string, stageId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deploymentStageId' is not null or undefined
            assertParamExists('moveBeforeDeploymentStage', 'deploymentStageId', deploymentStageId)
            // verify required parameter 'stageId' is not null or undefined
            assertParamExists('moveBeforeDeploymentStage', 'stageId', stageId)
            const localVarPath = `/deploymentStage/{deploymentStageId}/moveBefore/{stageId}`
                .replace(`{${"deploymentStageId"}}`, encodeURIComponent(String(deploymentStageId)))
                .replace(`{${"stageId"}}`, encodeURIComponent(String(stageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeploymentStageMainCallsApi - functional programming interface
 * @export
 */
export const DeploymentStageMainCallsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeploymentStageMainCallsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Attach service to deployment stage
         * @param {string} deploymentStageId Deployment Stage ID
         * @param {string} serviceId Service ID of an application/job/container/database
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async attachServiceToDeploymentStage(deploymentStageId: string, serviceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentStageResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.attachServiceToDeploymentStage(deploymentStageId, serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create environment deployment stage
         * @param {string} environmentId Environment ID
         * @param {DeploymentStageRequest} [deploymentStageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEnvironmentDeploymentStage(environmentId: string, deploymentStageRequest?: DeploymentStageRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentStageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEnvironmentDeploymentStage(environmentId, deploymentStageRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete deployment stage
         * @param {string} deploymentStageId Deployment Stage ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDeploymentStage(deploymentStageId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDeploymentStage(deploymentStageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit deployment stage
         * @param {string} deploymentStageId Deployment Stage ID
         * @param {DeploymentStageRequest} [deploymentStageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editDeploymentStage(deploymentStageId: string, deploymentStageRequest?: DeploymentStageRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentStageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editDeploymentStage(deploymentStageId, deploymentStageRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Deployment Stage
         * @param {string} deploymentStageId Deployment Stage ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeploymentStage(deploymentStageId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentStageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeploymentStage(deploymentStageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Service Deployment Stage
         * @param {string} serviceId Service ID of an application/job/container/database
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceDeploymentStage(serviceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentStageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceDeploymentStage(serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List environment deployment stage
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEnvironmentDeploymentStage(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentStageResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEnvironmentDeploymentStage(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Move deployment stage after requested stage
         * @param {string} deploymentStageId Deployment Stage ID
         * @param {string} stageId Deployment Stage ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moveAfterDeploymentStage(deploymentStageId: string, stageId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentStageResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moveAfterDeploymentStage(deploymentStageId, stageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Move deployment stage before requested stage
         * @param {string} deploymentStageId Deployment Stage ID
         * @param {string} stageId Deployment Stage ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moveBeforeDeploymentStage(deploymentStageId: string, stageId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentStageResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moveBeforeDeploymentStage(deploymentStageId, stageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DeploymentStageMainCallsApi - factory interface
 * @export
 */
export const DeploymentStageMainCallsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeploymentStageMainCallsApiFp(configuration)
    return {
        /**
         * 
         * @summary Attach service to deployment stage
         * @param {string} deploymentStageId Deployment Stage ID
         * @param {string} serviceId Service ID of an application/job/container/database
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachServiceToDeploymentStage(deploymentStageId: string, serviceId: string, options?: any): AxiosPromise<DeploymentStageResponseList> {
            return localVarFp.attachServiceToDeploymentStage(deploymentStageId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create environment deployment stage
         * @param {string} environmentId Environment ID
         * @param {DeploymentStageRequest} [deploymentStageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironmentDeploymentStage(environmentId: string, deploymentStageRequest?: DeploymentStageRequest, options?: any): AxiosPromise<DeploymentStageResponse> {
            return localVarFp.createEnvironmentDeploymentStage(environmentId, deploymentStageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete deployment stage
         * @param {string} deploymentStageId Deployment Stage ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeploymentStage(deploymentStageId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDeploymentStage(deploymentStageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit deployment stage
         * @param {string} deploymentStageId Deployment Stage ID
         * @param {DeploymentStageRequest} [deploymentStageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editDeploymentStage(deploymentStageId: string, deploymentStageRequest?: DeploymentStageRequest, options?: any): AxiosPromise<DeploymentStageResponse> {
            return localVarFp.editDeploymentStage(deploymentStageId, deploymentStageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Deployment Stage
         * @param {string} deploymentStageId Deployment Stage ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeploymentStage(deploymentStageId: string, options?: any): AxiosPromise<DeploymentStageResponse> {
            return localVarFp.getDeploymentStage(deploymentStageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Service Deployment Stage
         * @param {string} serviceId Service ID of an application/job/container/database
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeploymentStage(serviceId: string, options?: any): AxiosPromise<DeploymentStageResponse> {
            return localVarFp.getServiceDeploymentStage(serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List environment deployment stage
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentDeploymentStage(environmentId: string, options?: any): AxiosPromise<DeploymentStageResponseList> {
            return localVarFp.listEnvironmentDeploymentStage(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Move deployment stage after requested stage
         * @param {string} deploymentStageId Deployment Stage ID
         * @param {string} stageId Deployment Stage ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveAfterDeploymentStage(deploymentStageId: string, stageId: string, options?: any): AxiosPromise<DeploymentStageResponseList> {
            return localVarFp.moveAfterDeploymentStage(deploymentStageId, stageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Move deployment stage before requested stage
         * @param {string} deploymentStageId Deployment Stage ID
         * @param {string} stageId Deployment Stage ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveBeforeDeploymentStage(deploymentStageId: string, stageId: string, options?: any): AxiosPromise<DeploymentStageResponseList> {
            return localVarFp.moveBeforeDeploymentStage(deploymentStageId, stageId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeploymentStageMainCallsApi - object-oriented interface
 * @export
 * @class DeploymentStageMainCallsApi
 * @extends {BaseAPI}
 */
export class DeploymentStageMainCallsApi extends BaseAPI {
    /**
     * 
     * @summary Attach service to deployment stage
     * @param {string} deploymentStageId Deployment Stage ID
     * @param {string} serviceId Service ID of an application/job/container/database
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentStageMainCallsApi
     */
    public attachServiceToDeploymentStage(deploymentStageId: string, serviceId: string, options?: AxiosRequestConfig) {
        return DeploymentStageMainCallsApiFp(this.configuration).attachServiceToDeploymentStage(deploymentStageId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create environment deployment stage
     * @param {string} environmentId Environment ID
     * @param {DeploymentStageRequest} [deploymentStageRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentStageMainCallsApi
     */
    public createEnvironmentDeploymentStage(environmentId: string, deploymentStageRequest?: DeploymentStageRequest, options?: AxiosRequestConfig) {
        return DeploymentStageMainCallsApiFp(this.configuration).createEnvironmentDeploymentStage(environmentId, deploymentStageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete deployment stage
     * @param {string} deploymentStageId Deployment Stage ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentStageMainCallsApi
     */
    public deleteDeploymentStage(deploymentStageId: string, options?: AxiosRequestConfig) {
        return DeploymentStageMainCallsApiFp(this.configuration).deleteDeploymentStage(deploymentStageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit deployment stage
     * @param {string} deploymentStageId Deployment Stage ID
     * @param {DeploymentStageRequest} [deploymentStageRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentStageMainCallsApi
     */
    public editDeploymentStage(deploymentStageId: string, deploymentStageRequest?: DeploymentStageRequest, options?: AxiosRequestConfig) {
        return DeploymentStageMainCallsApiFp(this.configuration).editDeploymentStage(deploymentStageId, deploymentStageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Deployment Stage
     * @param {string} deploymentStageId Deployment Stage ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentStageMainCallsApi
     */
    public getDeploymentStage(deploymentStageId: string, options?: AxiosRequestConfig) {
        return DeploymentStageMainCallsApiFp(this.configuration).getDeploymentStage(deploymentStageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Service Deployment Stage
     * @param {string} serviceId Service ID of an application/job/container/database
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentStageMainCallsApi
     */
    public getServiceDeploymentStage(serviceId: string, options?: AxiosRequestConfig) {
        return DeploymentStageMainCallsApiFp(this.configuration).getServiceDeploymentStage(serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List environment deployment stage
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentStageMainCallsApi
     */
    public listEnvironmentDeploymentStage(environmentId: string, options?: AxiosRequestConfig) {
        return DeploymentStageMainCallsApiFp(this.configuration).listEnvironmentDeploymentStage(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Move deployment stage after requested stage
     * @param {string} deploymentStageId Deployment Stage ID
     * @param {string} stageId Deployment Stage ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentStageMainCallsApi
     */
    public moveAfterDeploymentStage(deploymentStageId: string, stageId: string, options?: AxiosRequestConfig) {
        return DeploymentStageMainCallsApiFp(this.configuration).moveAfterDeploymentStage(deploymentStageId, stageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Move deployment stage before requested stage
     * @param {string} deploymentStageId Deployment Stage ID
     * @param {string} stageId Deployment Stage ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentStageMainCallsApi
     */
    public moveBeforeDeploymentStage(deploymentStageId: string, stageId: string, options?: AxiosRequestConfig) {
        return DeploymentStageMainCallsApiFp(this.configuration).moveBeforeDeploymentStage(deploymentStageId, stageId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EnvironmentApi - axios parameter creator
 * @export
 */
export const EnvironmentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Check container image configuration is correct
         * @param {string} environmentId Environment ID
         * @param {ContainerImageCheckRequest} [containerImageCheckRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkContainerImage: async (environmentId: string, containerImageCheckRequest?: ContainerImageCheckRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('checkContainerImage', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/checkContainerImage`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(containerImageCheckRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check dockerfile configuration is correct
         * @param {string} environmentId Environment ID
         * @param {DockerfileCheckRequest} [dockerfileCheckRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkDockerfile: async (environmentId: string, dockerfileCheckRequest?: DockerfileCheckRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('checkDockerfile', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/checkDockerfile`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dockerfileCheckRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check git file configuration is correct
         * @param {string} environmentId Environment ID
         * @param {GitFileCheckRequest} [gitFileCheckRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkGitFile: async (environmentId: string, gitFileCheckRequest?: GitFileCheckRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('checkGitFile', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/checkGitFile`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gitFileCheckRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check helm repository configuration is correct
         * @param {string} environmentId Environment ID
         * @param {HelmCheckRequest} [helmCheckRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkHelmRepository: async (environmentId: string, helmCheckRequest?: HelmCheckRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('checkHelmRepository', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/checkHelmRepository`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(helmCheckRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start a deployment of the environment. Any of the services within the chosen environment based on the following rule: a service is deployed only if a new version is specified in the payload for that application/container or if there was a change in its configuration that needs to be applied (vCPU,RAM etc..)
         * @summary Deploy applications
         * @param {string} environmentId Environment ID
         * @param {DeployAllRequest} [deployAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployAllApplications: async (environmentId: string, deployAllRequest?: DeployAllRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('deployAllApplications', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/application/deploy`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deployAllRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentApi - functional programming interface
 * @export
 */
export const EnvironmentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnvironmentApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Check container image configuration is correct
         * @param {string} environmentId Environment ID
         * @param {ContainerImageCheckRequest} [containerImageCheckRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkContainerImage(environmentId: string, containerImageCheckRequest?: ContainerImageCheckRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkContainerImage(environmentId, containerImageCheckRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Check dockerfile configuration is correct
         * @param {string} environmentId Environment ID
         * @param {DockerfileCheckRequest} [dockerfileCheckRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkDockerfile(environmentId: string, dockerfileCheckRequest?: DockerfileCheckRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DockerfileCheckResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkDockerfile(environmentId, dockerfileCheckRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Check git file configuration is correct
         * @param {string} environmentId Environment ID
         * @param {GitFileCheckRequest} [gitFileCheckRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkGitFile(environmentId: string, gitFileCheckRequest?: GitFileCheckRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkGitFile(environmentId, gitFileCheckRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Check helm repository configuration is correct
         * @param {string} environmentId Environment ID
         * @param {HelmCheckRequest} [helmCheckRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkHelmRepository(environmentId: string, helmCheckRequest?: HelmCheckRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkHelmRepository(environmentId, helmCheckRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Start a deployment of the environment. Any of the services within the chosen environment based on the following rule: a service is deployed only if a new version is specified in the payload for that application/container or if there was a change in its configuration that needs to be applied (vCPU,RAM etc..)
         * @summary Deploy applications
         * @param {string} environmentId Environment ID
         * @param {DeployAllRequest} [deployAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployAllApplications(environmentId: string, deployAllRequest?: DeployAllRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployAllApplications(environmentId, deployAllRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EnvironmentApi - factory interface
 * @export
 */
export const EnvironmentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnvironmentApiFp(configuration)
    return {
        /**
         * 
         * @summary Check container image configuration is correct
         * @param {string} environmentId Environment ID
         * @param {ContainerImageCheckRequest} [containerImageCheckRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkContainerImage(environmentId: string, containerImageCheckRequest?: ContainerImageCheckRequest, options?: any): AxiosPromise<object> {
            return localVarFp.checkContainerImage(environmentId, containerImageCheckRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check dockerfile configuration is correct
         * @param {string} environmentId Environment ID
         * @param {DockerfileCheckRequest} [dockerfileCheckRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkDockerfile(environmentId: string, dockerfileCheckRequest?: DockerfileCheckRequest, options?: any): AxiosPromise<DockerfileCheckResponse> {
            return localVarFp.checkDockerfile(environmentId, dockerfileCheckRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check git file configuration is correct
         * @param {string} environmentId Environment ID
         * @param {GitFileCheckRequest} [gitFileCheckRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkGitFile(environmentId: string, gitFileCheckRequest?: GitFileCheckRequest, options?: any): AxiosPromise<object> {
            return localVarFp.checkGitFile(environmentId, gitFileCheckRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check helm repository configuration is correct
         * @param {string} environmentId Environment ID
         * @param {HelmCheckRequest} [helmCheckRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkHelmRepository(environmentId: string, helmCheckRequest?: HelmCheckRequest, options?: any): AxiosPromise<object> {
            return localVarFp.checkHelmRepository(environmentId, helmCheckRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Start a deployment of the environment. Any of the services within the chosen environment based on the following rule: a service is deployed only if a new version is specified in the payload for that application/container or if there was a change in its configuration that needs to be applied (vCPU,RAM etc..)
         * @summary Deploy applications
         * @param {string} environmentId Environment ID
         * @param {DeployAllRequest} [deployAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployAllApplications(environmentId: string, deployAllRequest?: DeployAllRequest, options?: any): AxiosPromise<Status> {
            return localVarFp.deployAllApplications(environmentId, deployAllRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnvironmentApi - object-oriented interface
 * @export
 * @class EnvironmentApi
 * @extends {BaseAPI}
 */
export class EnvironmentApi extends BaseAPI {
    /**
     * 
     * @summary Check container image configuration is correct
     * @param {string} environmentId Environment ID
     * @param {ContainerImageCheckRequest} [containerImageCheckRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public checkContainerImage(environmentId: string, containerImageCheckRequest?: ContainerImageCheckRequest, options?: AxiosRequestConfig) {
        return EnvironmentApiFp(this.configuration).checkContainerImage(environmentId, containerImageCheckRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check dockerfile configuration is correct
     * @param {string} environmentId Environment ID
     * @param {DockerfileCheckRequest} [dockerfileCheckRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public checkDockerfile(environmentId: string, dockerfileCheckRequest?: DockerfileCheckRequest, options?: AxiosRequestConfig) {
        return EnvironmentApiFp(this.configuration).checkDockerfile(environmentId, dockerfileCheckRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check git file configuration is correct
     * @param {string} environmentId Environment ID
     * @param {GitFileCheckRequest} [gitFileCheckRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public checkGitFile(environmentId: string, gitFileCheckRequest?: GitFileCheckRequest, options?: AxiosRequestConfig) {
        return EnvironmentApiFp(this.configuration).checkGitFile(environmentId, gitFileCheckRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check helm repository configuration is correct
     * @param {string} environmentId Environment ID
     * @param {HelmCheckRequest} [helmCheckRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public checkHelmRepository(environmentId: string, helmCheckRequest?: HelmCheckRequest, options?: AxiosRequestConfig) {
        return EnvironmentApiFp(this.configuration).checkHelmRepository(environmentId, helmCheckRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start a deployment of the environment. Any of the services within the chosen environment based on the following rule: a service is deployed only if a new version is specified in the payload for that application/container or if there was a change in its configuration that needs to be applied (vCPU,RAM etc..)
     * @summary Deploy applications
     * @param {string} environmentId Environment ID
     * @param {DeployAllRequest} [deployAllRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public deployAllApplications(environmentId: string, deployAllRequest?: DeployAllRequest, options?: AxiosRequestConfig) {
        return EnvironmentApiFp(this.configuration).deployAllApplications(environmentId, deployAllRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EnvironmentActionsApi - axios parameter creator
 * @export
 */
export const EnvironmentActionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancel the current deployment of your environment.
         * @summary Cancel environment deployment
         * @param {string} environmentId Environment ID
         * @param {CancelEnvironmentDeploymentRequest} [cancelEnvironmentDeploymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelEnvironmentDeployment: async (environmentId: string, cancelEnvironmentDeploymentRequest?: CancelEnvironmentDeploymentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('cancelEnvironmentDeployment', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/cancelDeployment`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cancelEnvironmentDeploymentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Clean failed jobs within an environment
         * @param {string} environmentId 
         * @param {CleanFailedJobsRequest} [cleanFailedJobsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cleanFailedJobs: async (environmentId: string, cleanFailedJobsRequest?: CleanFailedJobsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('cleanFailedJobs', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/cleanFailedJobs`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cleanFailedJobsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You must provide a name. This will create a new environment, with the same configuration, and same applications and databases. Database data is not cloned.
         * @summary Clone environment
         * @param {string} environmentId Environment ID
         * @param {CloneEnvironmentRequest} [cloneEnvironmentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneEnvironment: async (environmentId: string, cloneEnvironmentRequest?: CloneEnvironmentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('cloneEnvironment', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/clone`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloneEnvironmentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete selected services
         * @summary Delete services
         * @param {string} environmentId Environment ID
         * @param {EnvironmentServiceIdsAllRequest} [environmentServiceIdsAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSelectedServices: async (environmentId: string, environmentServiceIdsAllRequest?: EnvironmentServiceIdsAllRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('deleteSelectedServices', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/service/delete`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentServiceIdsAllRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update and deploy the selected services
         * @summary Deploy services
         * @param {string} environmentId Environment ID
         * @param {DeployAllRequest} [deployAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployAllServices: async (environmentId: string, deployAllRequest?: DeployAllRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('deployAllServices', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/service/deploy`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deployAllRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This will deploy all the services of this environment to their latest version.
         * @summary Deploy environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployEnvironment: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('deployEnvironment', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/deploy`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update and reboot the selected services
         * @summary Reboot services
         * @param {string} environmentId Environment ID
         * @param {RebootServicesRequest} [rebootServicesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rebootServices: async (environmentId: string, rebootServicesRequest?: RebootServicesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('rebootServices', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/service/restart-service`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rebootServicesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Redeploy environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeployEnvironment: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('redeployEnvironment', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/redeploy`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopEnvironment: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('stopEnvironment', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/stop`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stop selected services
         * @summary Stop services
         * @param {string} environmentId Environment ID
         * @param {EnvironmentServiceIdsAllRequest} [environmentServiceIdsAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopSelectedServices: async (environmentId: string, environmentServiceIdsAllRequest?: EnvironmentServiceIdsAllRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('stopSelectedServices', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/service/stop`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentServiceIdsAllRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentActionsApi - functional programming interface
 * @export
 */
export const EnvironmentActionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnvironmentActionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Cancel the current deployment of your environment.
         * @summary Cancel environment deployment
         * @param {string} environmentId Environment ID
         * @param {CancelEnvironmentDeploymentRequest} [cancelEnvironmentDeploymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelEnvironmentDeployment(environmentId: string, cancelEnvironmentDeploymentRequest?: CancelEnvironmentDeploymentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelEnvironmentDeployment(environmentId, cancelEnvironmentDeploymentRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Clean failed jobs within an environment
         * @param {string} environmentId 
         * @param {CleanFailedJobsRequest} [cleanFailedJobsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cleanFailedJobs(environmentId: string, cleanFailedJobsRequest?: CleanFailedJobsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CleanFailedJobs200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cleanFailedJobs(environmentId, cleanFailedJobsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * You must provide a name. This will create a new environment, with the same configuration, and same applications and databases. Database data is not cloned.
         * @summary Clone environment
         * @param {string} environmentId Environment ID
         * @param {CloneEnvironmentRequest} [cloneEnvironmentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloneEnvironment(environmentId: string, cloneEnvironmentRequest?: CloneEnvironmentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Environment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cloneEnvironment(environmentId, cloneEnvironmentRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete selected services
         * @summary Delete services
         * @param {string} environmentId Environment ID
         * @param {EnvironmentServiceIdsAllRequest} [environmentServiceIdsAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSelectedServices(environmentId: string, environmentServiceIdsAllRequest?: EnvironmentServiceIdsAllRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSelectedServices(environmentId, environmentServiceIdsAllRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update and deploy the selected services
         * @summary Deploy services
         * @param {string} environmentId Environment ID
         * @param {DeployAllRequest} [deployAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployAllServices(environmentId: string, deployAllRequest?: DeployAllRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployAllServices(environmentId, deployAllRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This will deploy all the services of this environment to their latest version.
         * @summary Deploy environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployEnvironment(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployEnvironment(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update and reboot the selected services
         * @summary Reboot services
         * @param {string} environmentId Environment ID
         * @param {RebootServicesRequest} [rebootServicesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rebootServices(environmentId: string, rebootServicesRequest?: RebootServicesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rebootServices(environmentId, rebootServicesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Redeploy environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async redeployEnvironment(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.redeployEnvironment(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Stop environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopEnvironment(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopEnvironment(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Stop selected services
         * @summary Stop services
         * @param {string} environmentId Environment ID
         * @param {EnvironmentServiceIdsAllRequest} [environmentServiceIdsAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopSelectedServices(environmentId: string, environmentServiceIdsAllRequest?: EnvironmentServiceIdsAllRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopSelectedServices(environmentId, environmentServiceIdsAllRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EnvironmentActionsApi - factory interface
 * @export
 */
export const EnvironmentActionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnvironmentActionsApiFp(configuration)
    return {
        /**
         * Cancel the current deployment of your environment.
         * @summary Cancel environment deployment
         * @param {string} environmentId Environment ID
         * @param {CancelEnvironmentDeploymentRequest} [cancelEnvironmentDeploymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelEnvironmentDeployment(environmentId: string, cancelEnvironmentDeploymentRequest?: CancelEnvironmentDeploymentRequest, options?: any): AxiosPromise<EnvironmentStatus> {
            return localVarFp.cancelEnvironmentDeployment(environmentId, cancelEnvironmentDeploymentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Clean failed jobs within an environment
         * @param {string} environmentId 
         * @param {CleanFailedJobsRequest} [cleanFailedJobsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cleanFailedJobs(environmentId: string, cleanFailedJobsRequest?: CleanFailedJobsRequest, options?: any): AxiosPromise<CleanFailedJobs200Response> {
            return localVarFp.cleanFailedJobs(environmentId, cleanFailedJobsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * You must provide a name. This will create a new environment, with the same configuration, and same applications and databases. Database data is not cloned.
         * @summary Clone environment
         * @param {string} environmentId Environment ID
         * @param {CloneEnvironmentRequest} [cloneEnvironmentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneEnvironment(environmentId: string, cloneEnvironmentRequest?: CloneEnvironmentRequest, options?: any): AxiosPromise<Environment> {
            return localVarFp.cloneEnvironment(environmentId, cloneEnvironmentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete selected services
         * @summary Delete services
         * @param {string} environmentId Environment ID
         * @param {EnvironmentServiceIdsAllRequest} [environmentServiceIdsAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSelectedServices(environmentId: string, environmentServiceIdsAllRequest?: EnvironmentServiceIdsAllRequest, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSelectedServices(environmentId, environmentServiceIdsAllRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update and deploy the selected services
         * @summary Deploy services
         * @param {string} environmentId Environment ID
         * @param {DeployAllRequest} [deployAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployAllServices(environmentId: string, deployAllRequest?: DeployAllRequest, options?: any): AxiosPromise<EnvironmentStatus> {
            return localVarFp.deployAllServices(environmentId, deployAllRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This will deploy all the services of this environment to their latest version.
         * @summary Deploy environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployEnvironment(environmentId: string, options?: any): AxiosPromise<Status> {
            return localVarFp.deployEnvironment(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update and reboot the selected services
         * @summary Reboot services
         * @param {string} environmentId Environment ID
         * @param {RebootServicesRequest} [rebootServicesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rebootServices(environmentId: string, rebootServicesRequest?: RebootServicesRequest, options?: any): AxiosPromise<Status> {
            return localVarFp.rebootServices(environmentId, rebootServicesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Redeploy environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeployEnvironment(environmentId: string, options?: any): AxiosPromise<EnvironmentStatus> {
            return localVarFp.redeployEnvironment(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Stop environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopEnvironment(environmentId: string, options?: any): AxiosPromise<EnvironmentStatus> {
            return localVarFp.stopEnvironment(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Stop selected services
         * @summary Stop services
         * @param {string} environmentId Environment ID
         * @param {EnvironmentServiceIdsAllRequest} [environmentServiceIdsAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopSelectedServices(environmentId: string, environmentServiceIdsAllRequest?: EnvironmentServiceIdsAllRequest, options?: any): AxiosPromise<void> {
            return localVarFp.stopSelectedServices(environmentId, environmentServiceIdsAllRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnvironmentActionsApi - object-oriented interface
 * @export
 * @class EnvironmentActionsApi
 * @extends {BaseAPI}
 */
export class EnvironmentActionsApi extends BaseAPI {
    /**
     * Cancel the current deployment of your environment.
     * @summary Cancel environment deployment
     * @param {string} environmentId Environment ID
     * @param {CancelEnvironmentDeploymentRequest} [cancelEnvironmentDeploymentRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentActionsApi
     */
    public cancelEnvironmentDeployment(environmentId: string, cancelEnvironmentDeploymentRequest?: CancelEnvironmentDeploymentRequest, options?: AxiosRequestConfig) {
        return EnvironmentActionsApiFp(this.configuration).cancelEnvironmentDeployment(environmentId, cancelEnvironmentDeploymentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Clean failed jobs within an environment
     * @param {string} environmentId 
     * @param {CleanFailedJobsRequest} [cleanFailedJobsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentActionsApi
     */
    public cleanFailedJobs(environmentId: string, cleanFailedJobsRequest?: CleanFailedJobsRequest, options?: AxiosRequestConfig) {
        return EnvironmentActionsApiFp(this.configuration).cleanFailedJobs(environmentId, cleanFailedJobsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You must provide a name. This will create a new environment, with the same configuration, and same applications and databases. Database data is not cloned.
     * @summary Clone environment
     * @param {string} environmentId Environment ID
     * @param {CloneEnvironmentRequest} [cloneEnvironmentRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentActionsApi
     */
    public cloneEnvironment(environmentId: string, cloneEnvironmentRequest?: CloneEnvironmentRequest, options?: AxiosRequestConfig) {
        return EnvironmentActionsApiFp(this.configuration).cloneEnvironment(environmentId, cloneEnvironmentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete selected services
     * @summary Delete services
     * @param {string} environmentId Environment ID
     * @param {EnvironmentServiceIdsAllRequest} [environmentServiceIdsAllRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentActionsApi
     */
    public deleteSelectedServices(environmentId: string, environmentServiceIdsAllRequest?: EnvironmentServiceIdsAllRequest, options?: AxiosRequestConfig) {
        return EnvironmentActionsApiFp(this.configuration).deleteSelectedServices(environmentId, environmentServiceIdsAllRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update and deploy the selected services
     * @summary Deploy services
     * @param {string} environmentId Environment ID
     * @param {DeployAllRequest} [deployAllRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentActionsApi
     */
    public deployAllServices(environmentId: string, deployAllRequest?: DeployAllRequest, options?: AxiosRequestConfig) {
        return EnvironmentActionsApiFp(this.configuration).deployAllServices(environmentId, deployAllRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will deploy all the services of this environment to their latest version.
     * @summary Deploy environment
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentActionsApi
     */
    public deployEnvironment(environmentId: string, options?: AxiosRequestConfig) {
        return EnvironmentActionsApiFp(this.configuration).deployEnvironment(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update and reboot the selected services
     * @summary Reboot services
     * @param {string} environmentId Environment ID
     * @param {RebootServicesRequest} [rebootServicesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentActionsApi
     */
    public rebootServices(environmentId: string, rebootServicesRequest?: RebootServicesRequest, options?: AxiosRequestConfig) {
        return EnvironmentActionsApiFp(this.configuration).rebootServices(environmentId, rebootServicesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Redeploy environment
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentActionsApi
     */
    public redeployEnvironment(environmentId: string, options?: AxiosRequestConfig) {
        return EnvironmentActionsApiFp(this.configuration).redeployEnvironment(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Stop environment
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentActionsApi
     */
    public stopEnvironment(environmentId: string, options?: AxiosRequestConfig) {
        return EnvironmentActionsApiFp(this.configuration).stopEnvironment(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Stop selected services
     * @summary Stop services
     * @param {string} environmentId Environment ID
     * @param {EnvironmentServiceIdsAllRequest} [environmentServiceIdsAllRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentActionsApi
     */
    public stopSelectedServices(environmentId: string, environmentServiceIdsAllRequest?: EnvironmentServiceIdsAllRequest, options?: AxiosRequestConfig) {
        return EnvironmentActionsApiFp(this.configuration).stopSelectedServices(environmentId, environmentServiceIdsAllRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EnvironmentDeploymentHistoryApi - axios parameter creator
 * @export
 */
export const EnvironmentDeploymentHistoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List previous and current environment deployments with the status deployment and the related services. By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter
         * @summary List environment deployments
         * @param {string} environmentId Environment ID
         * @param {string} [startId] Starting point after which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentDeploymentHistory: async (environmentId: string, startId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('listEnvironmentDeploymentHistory', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/deploymentHistory`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (startId !== undefined) {
                localVarQueryParameter['startId'] = startId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentDeploymentHistoryApi - functional programming interface
 * @export
 */
export const EnvironmentDeploymentHistoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnvironmentDeploymentHistoryApiAxiosParamCreator(configuration)
    return {
        /**
         * List previous and current environment deployments with the status deployment and the related services. By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter
         * @summary List environment deployments
         * @param {string} environmentId Environment ID
         * @param {string} [startId] Starting point after which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEnvironmentDeploymentHistory(environmentId: string, startId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentHistoryEnvironmentPaginatedResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEnvironmentDeploymentHistory(environmentId, startId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EnvironmentDeploymentHistoryApi - factory interface
 * @export
 */
export const EnvironmentDeploymentHistoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnvironmentDeploymentHistoryApiFp(configuration)
    return {
        /**
         * List previous and current environment deployments with the status deployment and the related services. By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter
         * @summary List environment deployments
         * @param {string} environmentId Environment ID
         * @param {string} [startId] Starting point after which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentDeploymentHistory(environmentId: string, startId?: string, options?: any): AxiosPromise<DeploymentHistoryEnvironmentPaginatedResponseList> {
            return localVarFp.listEnvironmentDeploymentHistory(environmentId, startId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnvironmentDeploymentHistoryApi - object-oriented interface
 * @export
 * @class EnvironmentDeploymentHistoryApi
 * @extends {BaseAPI}
 */
export class EnvironmentDeploymentHistoryApi extends BaseAPI {
    /**
     * List previous and current environment deployments with the status deployment and the related services. By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter
     * @summary List environment deployments
     * @param {string} environmentId Environment ID
     * @param {string} [startId] Starting point after which to return results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentDeploymentHistoryApi
     */
    public listEnvironmentDeploymentHistory(environmentId: string, startId?: string, options?: AxiosRequestConfig) {
        return EnvironmentDeploymentHistoryApiFp(this.configuration).listEnvironmentDeploymentHistory(environmentId, startId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EnvironmentDeploymentRuleApi - axios parameter creator
 * @export
 */
export const EnvironmentDeploymentRuleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Edit an environment deployment rule
         * @param {string} environmentId Environment ID
         * @param {string} deploymentRuleId Deployment Rule ID
         * @param {EnvironmentDeploymentRuleEditRequest} [environmentDeploymentRuleEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editEnvironmentDeploymentRule: async (environmentId: string, deploymentRuleId: string, environmentDeploymentRuleEditRequest?: EnvironmentDeploymentRuleEditRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('editEnvironmentDeploymentRule', 'environmentId', environmentId)
            // verify required parameter 'deploymentRuleId' is not null or undefined
            assertParamExists('editEnvironmentDeploymentRule', 'deploymentRuleId', deploymentRuleId)
            const localVarPath = `/environment/{environmentId}/deploymentRule/{deploymentRuleId}`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)))
                .replace(`{${"deploymentRuleId"}}`, encodeURIComponent(String(deploymentRuleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentDeploymentRuleEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get environment deployment rule
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentDeploymentRule: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('getEnvironmentDeploymentRule', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/deploymentRule`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentDeploymentRuleApi - functional programming interface
 * @export
 */
export const EnvironmentDeploymentRuleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnvironmentDeploymentRuleApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Edit an environment deployment rule
         * @param {string} environmentId Environment ID
         * @param {string} deploymentRuleId Deployment Rule ID
         * @param {EnvironmentDeploymentRuleEditRequest} [environmentDeploymentRuleEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editEnvironmentDeploymentRule(environmentId: string, deploymentRuleId: string, environmentDeploymentRuleEditRequest?: EnvironmentDeploymentRuleEditRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentDeploymentRule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editEnvironmentDeploymentRule(environmentId, deploymentRuleId, environmentDeploymentRuleEditRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get environment deployment rule
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironmentDeploymentRule(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentDeploymentRule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironmentDeploymentRule(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EnvironmentDeploymentRuleApi - factory interface
 * @export
 */
export const EnvironmentDeploymentRuleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnvironmentDeploymentRuleApiFp(configuration)
    return {
        /**
         * 
         * @summary Edit an environment deployment rule
         * @param {string} environmentId Environment ID
         * @param {string} deploymentRuleId Deployment Rule ID
         * @param {EnvironmentDeploymentRuleEditRequest} [environmentDeploymentRuleEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editEnvironmentDeploymentRule(environmentId: string, deploymentRuleId: string, environmentDeploymentRuleEditRequest?: EnvironmentDeploymentRuleEditRequest, options?: any): AxiosPromise<EnvironmentDeploymentRule> {
            return localVarFp.editEnvironmentDeploymentRule(environmentId, deploymentRuleId, environmentDeploymentRuleEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get environment deployment rule
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentDeploymentRule(environmentId: string, options?: any): AxiosPromise<EnvironmentDeploymentRule> {
            return localVarFp.getEnvironmentDeploymentRule(environmentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnvironmentDeploymentRuleApi - object-oriented interface
 * @export
 * @class EnvironmentDeploymentRuleApi
 * @extends {BaseAPI}
 */
export class EnvironmentDeploymentRuleApi extends BaseAPI {
    /**
     * 
     * @summary Edit an environment deployment rule
     * @param {string} environmentId Environment ID
     * @param {string} deploymentRuleId Deployment Rule ID
     * @param {EnvironmentDeploymentRuleEditRequest} [environmentDeploymentRuleEditRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentDeploymentRuleApi
     */
    public editEnvironmentDeploymentRule(environmentId: string, deploymentRuleId: string, environmentDeploymentRuleEditRequest?: EnvironmentDeploymentRuleEditRequest, options?: AxiosRequestConfig) {
        return EnvironmentDeploymentRuleApiFp(this.configuration).editEnvironmentDeploymentRule(environmentId, deploymentRuleId, environmentDeploymentRuleEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get environment deployment rule
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentDeploymentRuleApi
     */
    public getEnvironmentDeploymentRule(environmentId: string, options?: AxiosRequestConfig) {
        return EnvironmentDeploymentRuleApiFp(this.configuration).getEnvironmentDeploymentRule(environmentId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EnvironmentExportApi - axios parameter creator
 * @export
 */
export const EnvironmentExportApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Export full environment and its resources into Terraform manifests
         * @param {string} environmentId Environment ID
         * @param {boolean} [exportSecrets] export Secrets from configuration and include them into Terraform export
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportEnvironmentConfigurationIntoTerraform: async (environmentId: string, exportSecrets?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('exportEnvironmentConfigurationIntoTerraform', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/terraformExport`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (exportSecrets !== undefined) {
                localVarQueryParameter['exportSecrets'] = exportSecrets;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentExportApi - functional programming interface
 * @export
 */
export const EnvironmentExportApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnvironmentExportApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Export full environment and its resources into Terraform manifests
         * @param {string} environmentId Environment ID
         * @param {boolean} [exportSecrets] export Secrets from configuration and include them into Terraform export
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportEnvironmentConfigurationIntoTerraform(environmentId: string, exportSecrets?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportEnvironmentConfigurationIntoTerraform(environmentId, exportSecrets, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EnvironmentExportApi - factory interface
 * @export
 */
export const EnvironmentExportApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnvironmentExportApiFp(configuration)
    return {
        /**
         * 
         * @summary Export full environment and its resources into Terraform manifests
         * @param {string} environmentId Environment ID
         * @param {boolean} [exportSecrets] export Secrets from configuration and include them into Terraform export
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportEnvironmentConfigurationIntoTerraform(environmentId: string, exportSecrets?: boolean, options?: any): AxiosPromise<File> {
            return localVarFp.exportEnvironmentConfigurationIntoTerraform(environmentId, exportSecrets, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnvironmentExportApi - object-oriented interface
 * @export
 * @class EnvironmentExportApi
 * @extends {BaseAPI}
 */
export class EnvironmentExportApi extends BaseAPI {
    /**
     * 
     * @summary Export full environment and its resources into Terraform manifests
     * @param {string} environmentId Environment ID
     * @param {boolean} [exportSecrets] export Secrets from configuration and include them into Terraform export
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentExportApi
     */
    public exportEnvironmentConfigurationIntoTerraform(environmentId: string, exportSecrets?: boolean, options?: AxiosRequestConfig) {
        return EnvironmentExportApiFp(this.configuration).exportEnvironmentConfigurationIntoTerraform(environmentId, exportSecrets, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EnvironmentLogsApi - axios parameter creator
 * @export
 */
export const EnvironmentLogsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This returns the last 1000 environment deployment logs.
         * @summary List environment deployment logs
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentLog: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('listEnvironmentLog', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/log`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This returns the last 1000 environment deployment logs v2
         * @summary List environment deployment logs v2
         * @param {string} environmentId Environment ID
         * @param {string} [version] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentLogs: async (environmentId: string, version?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('listEnvironmentLogs', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/logs`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentLogsApi - functional programming interface
 * @export
 */
export const EnvironmentLogsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnvironmentLogsApiAxiosParamCreator(configuration)
    return {
        /**
         * This returns the last 1000 environment deployment logs.
         * @summary List environment deployment logs
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEnvironmentLog(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentLogResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEnvironmentLog(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This returns the last 1000 environment deployment logs v2
         * @summary List environment deployment logs v2
         * @param {string} environmentId Environment ID
         * @param {string} [version] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEnvironmentLogs(environmentId: string, version?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EnvironmentLogs>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEnvironmentLogs(environmentId, version, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EnvironmentLogsApi - factory interface
 * @export
 */
export const EnvironmentLogsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnvironmentLogsApiFp(configuration)
    return {
        /**
         * This returns the last 1000 environment deployment logs.
         * @summary List environment deployment logs
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentLog(environmentId: string, options?: any): AxiosPromise<EnvironmentLogResponseList> {
            return localVarFp.listEnvironmentLog(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * This returns the last 1000 environment deployment logs v2
         * @summary List environment deployment logs v2
         * @param {string} environmentId Environment ID
         * @param {string} [version] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentLogs(environmentId: string, version?: string, options?: any): AxiosPromise<Array<EnvironmentLogs>> {
            return localVarFp.listEnvironmentLogs(environmentId, version, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnvironmentLogsApi - object-oriented interface
 * @export
 * @class EnvironmentLogsApi
 * @extends {BaseAPI}
 */
export class EnvironmentLogsApi extends BaseAPI {
    /**
     * This returns the last 1000 environment deployment logs.
     * @summary List environment deployment logs
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentLogsApi
     */
    public listEnvironmentLog(environmentId: string, options?: AxiosRequestConfig) {
        return EnvironmentLogsApiFp(this.configuration).listEnvironmentLog(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This returns the last 1000 environment deployment logs v2
     * @summary List environment deployment logs v2
     * @param {string} environmentId Environment ID
     * @param {string} [version] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentLogsApi
     */
    public listEnvironmentLogs(environmentId: string, version?: string, options?: AxiosRequestConfig) {
        return EnvironmentLogsApiFp(this.configuration).listEnvironmentLogs(environmentId, version, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EnvironmentMainCallsApi - axios parameter creator
 * @export
 */
export const EnvironmentMainCallsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * To delete an environment you must have the admin permission
         * @summary Delete an environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEnvironment: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('deleteEnvironment', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To edit an environment you must have the admin permission
         * @summary Edit an environment
         * @param {string} environmentId Environment ID
         * @param {EnvironmentEditRequest} [environmentEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editEnvironment: async (environmentId: string, environmentEditRequest?: EnvironmentEditRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('editEnvironment', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get environment by ID
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironment: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('getEnvironment', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get environment status
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentStatus: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('getEnvironmentStatus', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/status`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get environment statuses with services status
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentStatuses: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('getEnvironmentStatuses', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/statuses`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get environment statuses with stages
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentStatusesWithStages: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('getEnvironmentStatusesWithStages', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/statusesWithStages`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentMainCallsApi - functional programming interface
 * @export
 */
export const EnvironmentMainCallsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnvironmentMainCallsApiAxiosParamCreator(configuration)
    return {
        /**
         * To delete an environment you must have the admin permission
         * @summary Delete an environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEnvironment(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEnvironment(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * To edit an environment you must have the admin permission
         * @summary Edit an environment
         * @param {string} environmentId Environment ID
         * @param {EnvironmentEditRequest} [environmentEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editEnvironment(environmentId: string, environmentEditRequest?: EnvironmentEditRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Environment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editEnvironment(environmentId, environmentEditRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get environment by ID
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironment(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Environment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironment(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get environment status
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironmentStatus(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironmentStatus(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get environment statuses with services status
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironmentStatuses(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentStatuses>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironmentStatuses(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get environment statuses with stages
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironmentStatusesWithStages(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentStatusesWithStages>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironmentStatusesWithStages(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EnvironmentMainCallsApi - factory interface
 * @export
 */
export const EnvironmentMainCallsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnvironmentMainCallsApiFp(configuration)
    return {
        /**
         * To delete an environment you must have the admin permission
         * @summary Delete an environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEnvironment(environmentId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteEnvironment(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * To edit an environment you must have the admin permission
         * @summary Edit an environment
         * @param {string} environmentId Environment ID
         * @param {EnvironmentEditRequest} [environmentEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editEnvironment(environmentId: string, environmentEditRequest?: EnvironmentEditRequest, options?: any): AxiosPromise<Environment> {
            return localVarFp.editEnvironment(environmentId, environmentEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get environment by ID
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironment(environmentId: string, options?: any): AxiosPromise<Environment> {
            return localVarFp.getEnvironment(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get environment status
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentStatus(environmentId: string, options?: any): AxiosPromise<EnvironmentStatus> {
            return localVarFp.getEnvironmentStatus(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get environment statuses with services status
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentStatuses(environmentId: string, options?: any): AxiosPromise<EnvironmentStatuses> {
            return localVarFp.getEnvironmentStatuses(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get environment statuses with stages
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentStatusesWithStages(environmentId: string, options?: any): AxiosPromise<EnvironmentStatusesWithStages> {
            return localVarFp.getEnvironmentStatusesWithStages(environmentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnvironmentMainCallsApi - object-oriented interface
 * @export
 * @class EnvironmentMainCallsApi
 * @extends {BaseAPI}
 */
export class EnvironmentMainCallsApi extends BaseAPI {
    /**
     * To delete an environment you must have the admin permission
     * @summary Delete an environment
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentMainCallsApi
     */
    public deleteEnvironment(environmentId: string, options?: AxiosRequestConfig) {
        return EnvironmentMainCallsApiFp(this.configuration).deleteEnvironment(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To edit an environment you must have the admin permission
     * @summary Edit an environment
     * @param {string} environmentId Environment ID
     * @param {EnvironmentEditRequest} [environmentEditRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentMainCallsApi
     */
    public editEnvironment(environmentId: string, environmentEditRequest?: EnvironmentEditRequest, options?: AxiosRequestConfig) {
        return EnvironmentMainCallsApiFp(this.configuration).editEnvironment(environmentId, environmentEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get environment by ID
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentMainCallsApi
     */
    public getEnvironment(environmentId: string, options?: AxiosRequestConfig) {
        return EnvironmentMainCallsApiFp(this.configuration).getEnvironment(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get environment status
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentMainCallsApi
     */
    public getEnvironmentStatus(environmentId: string, options?: AxiosRequestConfig) {
        return EnvironmentMainCallsApiFp(this.configuration).getEnvironmentStatus(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get environment statuses with services status
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentMainCallsApi
     */
    public getEnvironmentStatuses(environmentId: string, options?: AxiosRequestConfig) {
        return EnvironmentMainCallsApiFp(this.configuration).getEnvironmentStatuses(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get environment statuses with stages
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentMainCallsApi
     */
    public getEnvironmentStatusesWithStages(environmentId: string, options?: AxiosRequestConfig) {
        return EnvironmentMainCallsApiFp(this.configuration).getEnvironmentStatusesWithStages(environmentId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EnvironmentSecretApi - axios parameter creator
 * @export
 */
export const EnvironmentSecretApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * - Add a secret to the environment.   - If the secret key already exists, then it will be replaced by the new one.   - If the secret value points toward an existing secret key, it will be considered as an alias. 
         * @summary Add a secret to the environment
         * @param {string} environmentId Environment ID
         * @param {SecretRequest} [secretRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironmentSecret: async (environmentId: string, secretRequest?: SecretRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('createEnvironmentSecret', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/secret`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(secretRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to add an alias at environment level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at environment level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - You can\'t create an alias on an alias 
         * @summary Create a secret alias at the environment level
         * @param {string} environmentId Environment ID
         * @param {string} secretId Secret ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironmentSecretAlias: async (environmentId: string, secretId: string, key?: Key, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('createEnvironmentSecretAlias', 'environmentId', environmentId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('createEnvironmentSecretAlias', 'secretId', secretId)
            const localVarPath = `/environment/{environmentId}/secret/{secretId}/alias`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(key, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to override at environment level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at environment level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
         * @summary Create a secret override at the environment level
         * @param {string} environmentId Environment ID
         * @param {string} secretId Secret ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironmentSecretOverride: async (environmentId: string, secretId: string, value?: Value, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('createEnvironmentSecretOverride', 'environmentId', environmentId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('createEnvironmentSecretOverride', 'secretId', secretId)
            const localVarPath = `/environment/{environmentId}/secret/{secretId}/override`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(value, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well  operationId: deleteEnvironmentSecret 
         * @summary Delete a secret from the environment
         * @param {string} environmentId Environment ID
         * @param {string} secretId Secret ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEnvironmentSecret: async (environmentId: string, secretId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('deleteEnvironmentSecret', 'environmentId', environmentId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('deleteEnvironmentSecret', 'secretId', secretId)
            const localVarPath = `/environment/{environmentId}/secret/{secretId}`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit a secret belonging to the environment
         * @param {string} environmentId Environment ID
         * @param {string} secretId Secret ID
         * @param {SecretEditRequest} secretEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editEnvironmentSecret: async (environmentId: string, secretId: string, secretEditRequest: SecretEditRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('editEnvironmentSecret', 'environmentId', environmentId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('editEnvironmentSecret', 'secretId', secretId)
            // verify required parameter 'secretEditRequest' is not null or undefined
            assertParamExists('editEnvironmentSecret', 'secretEditRequest', secretEditRequest)
            const localVarPath = `/environment/{environmentId}/secret/{secretId}`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(secretEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List environment secrets
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentSecrets: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('listEnvironmentSecrets', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/secret`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentSecretApi - functional programming interface
 * @export
 */
export const EnvironmentSecretApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnvironmentSecretApiAxiosParamCreator(configuration)
    return {
        /**
         * - Add a secret to the environment.   - If the secret key already exists, then it will be replaced by the new one.   - If the secret value points toward an existing secret key, it will be considered as an alias. 
         * @summary Add a secret to the environment
         * @param {string} environmentId Environment ID
         * @param {SecretRequest} [secretRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEnvironmentSecret(environmentId: string, secretRequest?: SecretRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEnvironmentSecret(environmentId, secretRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - Allows you to add an alias at environment level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at environment level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - You can\'t create an alias on an alias 
         * @summary Create a secret alias at the environment level
         * @param {string} environmentId Environment ID
         * @param {string} secretId Secret ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEnvironmentSecretAlias(environmentId: string, secretId: string, key?: Key, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEnvironmentSecretAlias(environmentId, secretId, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - Allows you to override at environment level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at environment level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
         * @summary Create a secret override at the environment level
         * @param {string} environmentId Environment ID
         * @param {string} secretId Secret ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEnvironmentSecretOverride(environmentId: string, secretId: string, value?: Value, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEnvironmentSecretOverride(environmentId, secretId, value, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well  operationId: deleteEnvironmentSecret 
         * @summary Delete a secret from the environment
         * @param {string} environmentId Environment ID
         * @param {string} secretId Secret ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEnvironmentSecret(environmentId: string, secretId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEnvironmentSecret(environmentId, secretId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit a secret belonging to the environment
         * @param {string} environmentId Environment ID
         * @param {string} secretId Secret ID
         * @param {SecretEditRequest} secretEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editEnvironmentSecret(environmentId: string, secretId: string, secretEditRequest: SecretEditRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editEnvironmentSecret(environmentId, secretId, secretEditRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List environment secrets
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEnvironmentSecrets(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecretResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEnvironmentSecrets(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EnvironmentSecretApi - factory interface
 * @export
 */
export const EnvironmentSecretApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnvironmentSecretApiFp(configuration)
    return {
        /**
         * - Add a secret to the environment.   - If the secret key already exists, then it will be replaced by the new one.   - If the secret value points toward an existing secret key, it will be considered as an alias. 
         * @summary Add a secret to the environment
         * @param {string} environmentId Environment ID
         * @param {SecretRequest} [secretRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironmentSecret(environmentId: string, secretRequest?: SecretRequest, options?: any): AxiosPromise<Secret> {
            return localVarFp.createEnvironmentSecret(environmentId, secretRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to add an alias at environment level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at environment level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - You can\'t create an alias on an alias 
         * @summary Create a secret alias at the environment level
         * @param {string} environmentId Environment ID
         * @param {string} secretId Secret ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironmentSecretAlias(environmentId: string, secretId: string, key?: Key, options?: any): AxiosPromise<Secret> {
            return localVarFp.createEnvironmentSecretAlias(environmentId, secretId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to override at environment level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at environment level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
         * @summary Create a secret override at the environment level
         * @param {string} environmentId Environment ID
         * @param {string} secretId Secret ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironmentSecretOverride(environmentId: string, secretId: string, value?: Value, options?: any): AxiosPromise<Secret> {
            return localVarFp.createEnvironmentSecretOverride(environmentId, secretId, value, options).then((request) => request(axios, basePath));
        },
        /**
         * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well  operationId: deleteEnvironmentSecret 
         * @summary Delete a secret from the environment
         * @param {string} environmentId Environment ID
         * @param {string} secretId Secret ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEnvironmentSecret(environmentId: string, secretId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteEnvironmentSecret(environmentId, secretId, options).then((request) => request(axios, basePath));
        },
        /**
         * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit a secret belonging to the environment
         * @param {string} environmentId Environment ID
         * @param {string} secretId Secret ID
         * @param {SecretEditRequest} secretEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editEnvironmentSecret(environmentId: string, secretId: string, secretEditRequest: SecretEditRequest, options?: any): AxiosPromise<Secret> {
            return localVarFp.editEnvironmentSecret(environmentId, secretId, secretEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List environment secrets
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentSecrets(environmentId: string, options?: any): AxiosPromise<SecretResponseList> {
            return localVarFp.listEnvironmentSecrets(environmentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnvironmentSecretApi - object-oriented interface
 * @export
 * @class EnvironmentSecretApi
 * @extends {BaseAPI}
 */
export class EnvironmentSecretApi extends BaseAPI {
    /**
     * - Add a secret to the environment.   - If the secret key already exists, then it will be replaced by the new one.   - If the secret value points toward an existing secret key, it will be considered as an alias. 
     * @summary Add a secret to the environment
     * @param {string} environmentId Environment ID
     * @param {SecretRequest} [secretRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentSecretApi
     */
    public createEnvironmentSecret(environmentId: string, secretRequest?: SecretRequest, options?: AxiosRequestConfig) {
        return EnvironmentSecretApiFp(this.configuration).createEnvironmentSecret(environmentId, secretRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to add an alias at environment level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at environment level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - You can\'t create an alias on an alias 
     * @summary Create a secret alias at the environment level
     * @param {string} environmentId Environment ID
     * @param {string} secretId Secret ID
     * @param {Key} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentSecretApi
     */
    public createEnvironmentSecretAlias(environmentId: string, secretId: string, key?: Key, options?: AxiosRequestConfig) {
        return EnvironmentSecretApiFp(this.configuration).createEnvironmentSecretAlias(environmentId, secretId, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to override at environment level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at environment level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
     * @summary Create a secret override at the environment level
     * @param {string} environmentId Environment ID
     * @param {string} secretId Secret ID
     * @param {Value} [value] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentSecretApi
     */
    public createEnvironmentSecretOverride(environmentId: string, secretId: string, value?: Value, options?: AxiosRequestConfig) {
        return EnvironmentSecretApiFp(this.configuration).createEnvironmentSecretOverride(environmentId, secretId, value, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well  operationId: deleteEnvironmentSecret 
     * @summary Delete a secret from the environment
     * @param {string} environmentId Environment ID
     * @param {string} secretId Secret ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentSecretApi
     */
    public deleteEnvironmentSecret(environmentId: string, secretId: string, options?: AxiosRequestConfig) {
        return EnvironmentSecretApiFp(this.configuration).deleteEnvironmentSecret(environmentId, secretId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
     * @summary Edit a secret belonging to the environment
     * @param {string} environmentId Environment ID
     * @param {string} secretId Secret ID
     * @param {SecretEditRequest} secretEditRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentSecretApi
     */
    public editEnvironmentSecret(environmentId: string, secretId: string, secretEditRequest: SecretEditRequest, options?: AxiosRequestConfig) {
        return EnvironmentSecretApiFp(this.configuration).editEnvironmentSecret(environmentId, secretId, secretEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List environment secrets
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentSecretApi
     */
    public listEnvironmentSecrets(environmentId: string, options?: AxiosRequestConfig) {
        return EnvironmentSecretApiFp(this.configuration).listEnvironmentSecrets(environmentId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EnvironmentVariableApi - axios parameter creator
 * @export
 */
export const EnvironmentVariableApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * - Add an environment variable to the environment.   - If the environment variable key already exists, then it will be replaced by the new one.   - If the environment variable value points toward an existing environment variable key, it will be considered as an alias. 
         * @summary Add an environment variable to the environment
         * @param {string} environmentId Environment ID
         * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironmentEnvironmentVariable: async (environmentId: string, environmentVariableRequest?: EnvironmentVariableRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('createEnvironmentEnvironmentVariable', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/environmentVariable`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentVariableRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to add an alias at environment level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at environment level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - You can\'t create an alias on an alias 
         * @summary Create an environment variable alias at the environment level
         * @param {string} environmentId Environment ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironmentEnvironmentVariableAlias: async (environmentId: string, environmentVariableId: string, key?: Key, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('createEnvironmentEnvironmentVariableAlias', 'environmentId', environmentId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('createEnvironmentEnvironmentVariableAlias', 'environmentVariableId', environmentVariableId)
            const localVarPath = `/environment/{environmentId}/environmentVariable/{environmentVariableId}/alias`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(key, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to override at environment level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at environment level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
         * @summary Create an environment variable override at the environment level
         * @param {string} environmentId Environment ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironmentEnvironmentVariableOverride: async (environmentId: string, environmentVariableId: string, value?: Value, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('createEnvironmentEnvironmentVariableOverride', 'environmentId', environmentId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('createEnvironmentEnvironmentVariableOverride', 'environmentVariableId', environmentVariableId)
            const localVarPath = `/environment/{environmentId}/environmentVariable/{environmentVariableId}/override`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(value, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - To delete an environment variable you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete an environment variable from an environment
         * @param {string} environmentId Environment ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEnvironmentEnvironmentVariable: async (environmentId: string, environmentVariableId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('deleteEnvironmentEnvironmentVariable', 'environmentId', environmentId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('deleteEnvironmentEnvironmentVariable', 'environmentVariableId', environmentVariableId)
            const localVarPath = `/environment/{environmentId}/environmentVariable/{environmentVariableId}`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit an environment variable belonging to the environment
         * @param {string} environmentId Environment ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editEnvironmentEnvironmentVariable: async (environmentId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('editEnvironmentEnvironmentVariable', 'environmentId', environmentId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('editEnvironmentEnvironmentVariable', 'environmentVariableId', environmentVariableId)
            // verify required parameter 'environmentVariableEditRequest' is not null or undefined
            assertParamExists('editEnvironmentEnvironmentVariable', 'environmentVariableEditRequest', environmentVariableEditRequest)
            const localVarPath = `/environment/{environmentId}/environmentVariable/{environmentVariableId}`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentVariableEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List environment variables
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentEnvironmentVariable: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('listEnvironmentEnvironmentVariable', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/environmentVariable`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentVariableApi - functional programming interface
 * @export
 */
export const EnvironmentVariableApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnvironmentVariableApiAxiosParamCreator(configuration)
    return {
        /**
         * - Add an environment variable to the environment.   - If the environment variable key already exists, then it will be replaced by the new one.   - If the environment variable value points toward an existing environment variable key, it will be considered as an alias. 
         * @summary Add an environment variable to the environment
         * @param {string} environmentId Environment ID
         * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEnvironmentEnvironmentVariable(environmentId: string, environmentVariableRequest?: EnvironmentVariableRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEnvironmentEnvironmentVariable(environmentId, environmentVariableRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - Allows you to add an alias at environment level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at environment level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - You can\'t create an alias on an alias 
         * @summary Create an environment variable alias at the environment level
         * @param {string} environmentId Environment ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEnvironmentEnvironmentVariableAlias(environmentId: string, environmentVariableId: string, key?: Key, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEnvironmentEnvironmentVariableAlias(environmentId, environmentVariableId, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - Allows you to override at environment level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at environment level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
         * @summary Create an environment variable override at the environment level
         * @param {string} environmentId Environment ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEnvironmentEnvironmentVariableOverride(environmentId: string, environmentVariableId: string, value?: Value, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEnvironmentEnvironmentVariableOverride(environmentId, environmentVariableId, value, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - To delete an environment variable you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete an environment variable from an environment
         * @param {string} environmentId Environment ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEnvironmentEnvironmentVariable(environmentId: string, environmentVariableId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEnvironmentEnvironmentVariable(environmentId, environmentVariableId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit an environment variable belonging to the environment
         * @param {string} environmentId Environment ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editEnvironmentEnvironmentVariable(environmentId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editEnvironmentEnvironmentVariable(environmentId, environmentVariableId, environmentVariableEditRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List environment variables
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEnvironmentEnvironmentVariable(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariableResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEnvironmentEnvironmentVariable(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EnvironmentVariableApi - factory interface
 * @export
 */
export const EnvironmentVariableApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnvironmentVariableApiFp(configuration)
    return {
        /**
         * - Add an environment variable to the environment.   - If the environment variable key already exists, then it will be replaced by the new one.   - If the environment variable value points toward an existing environment variable key, it will be considered as an alias. 
         * @summary Add an environment variable to the environment
         * @param {string} environmentId Environment ID
         * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironmentEnvironmentVariable(environmentId: string, environmentVariableRequest?: EnvironmentVariableRequest, options?: any): AxiosPromise<EnvironmentVariable> {
            return localVarFp.createEnvironmentEnvironmentVariable(environmentId, environmentVariableRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to add an alias at environment level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at environment level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - You can\'t create an alias on an alias 
         * @summary Create an environment variable alias at the environment level
         * @param {string} environmentId Environment ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironmentEnvironmentVariableAlias(environmentId: string, environmentVariableId: string, key?: Key, options?: any): AxiosPromise<EnvironmentVariable> {
            return localVarFp.createEnvironmentEnvironmentVariableAlias(environmentId, environmentVariableId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to override at environment level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at environment level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
         * @summary Create an environment variable override at the environment level
         * @param {string} environmentId Environment ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironmentEnvironmentVariableOverride(environmentId: string, environmentVariableId: string, value?: Value, options?: any): AxiosPromise<EnvironmentVariable> {
            return localVarFp.createEnvironmentEnvironmentVariableOverride(environmentId, environmentVariableId, value, options).then((request) => request(axios, basePath));
        },
        /**
         * - To delete an environment variable you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete an environment variable from an environment
         * @param {string} environmentId Environment ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEnvironmentEnvironmentVariable(environmentId: string, environmentVariableId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteEnvironmentEnvironmentVariable(environmentId, environmentVariableId, options).then((request) => request(axios, basePath));
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit an environment variable belonging to the environment
         * @param {string} environmentId Environment ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editEnvironmentEnvironmentVariable(environmentId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options?: any): AxiosPromise<EnvironmentVariable> {
            return localVarFp.editEnvironmentEnvironmentVariable(environmentId, environmentVariableId, environmentVariableEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List environment variables
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentEnvironmentVariable(environmentId: string, options?: any): AxiosPromise<EnvironmentVariableResponseList> {
            return localVarFp.listEnvironmentEnvironmentVariable(environmentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnvironmentVariableApi - object-oriented interface
 * @export
 * @class EnvironmentVariableApi
 * @extends {BaseAPI}
 */
export class EnvironmentVariableApi extends BaseAPI {
    /**
     * - Add an environment variable to the environment.   - If the environment variable key already exists, then it will be replaced by the new one.   - If the environment variable value points toward an existing environment variable key, it will be considered as an alias. 
     * @summary Add an environment variable to the environment
     * @param {string} environmentId Environment ID
     * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentVariableApi
     */
    public createEnvironmentEnvironmentVariable(environmentId: string, environmentVariableRequest?: EnvironmentVariableRequest, options?: AxiosRequestConfig) {
        return EnvironmentVariableApiFp(this.configuration).createEnvironmentEnvironmentVariable(environmentId, environmentVariableRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to add an alias at environment level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at environment level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - You can\'t create an alias on an alias 
     * @summary Create an environment variable alias at the environment level
     * @param {string} environmentId Environment ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {Key} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentVariableApi
     */
    public createEnvironmentEnvironmentVariableAlias(environmentId: string, environmentVariableId: string, key?: Key, options?: AxiosRequestConfig) {
        return EnvironmentVariableApiFp(this.configuration).createEnvironmentEnvironmentVariableAlias(environmentId, environmentVariableId, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to override at environment level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at environment level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
     * @summary Create an environment variable override at the environment level
     * @param {string} environmentId Environment ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {Value} [value] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentVariableApi
     */
    public createEnvironmentEnvironmentVariableOverride(environmentId: string, environmentVariableId: string, value?: Value, options?: AxiosRequestConfig) {
        return EnvironmentVariableApiFp(this.configuration).createEnvironmentEnvironmentVariableOverride(environmentId, environmentVariableId, value, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - To delete an environment variable you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
     * @summary Delete an environment variable from an environment
     * @param {string} environmentId Environment ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentVariableApi
     */
    public deleteEnvironmentEnvironmentVariable(environmentId: string, environmentVariableId: string, options?: AxiosRequestConfig) {
        return EnvironmentVariableApiFp(this.configuration).deleteEnvironmentEnvironmentVariable(environmentId, environmentVariableId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
     * @summary Edit an environment variable belonging to the environment
     * @param {string} environmentId Environment ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentVariableApi
     */
    public editEnvironmentEnvironmentVariable(environmentId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options?: AxiosRequestConfig) {
        return EnvironmentVariableApiFp(this.configuration).editEnvironmentEnvironmentVariable(environmentId, environmentVariableId, environmentVariableEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List environment variables
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentVariableApi
     */
    public listEnvironmentEnvironmentVariable(environmentId: string, options?: AxiosRequestConfig) {
        return EnvironmentVariableApiFp(this.configuration).listEnvironmentEnvironmentVariable(environmentId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EnvironmentsApi - axios parameter creator
 * @export
 */
export const EnvironmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create an environment
         * @param {string} projectId Project ID
         * @param {CreateEnvironmentRequest} [createEnvironmentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironment: async (projectId: string, createEnvironmentRequest?: CreateEnvironmentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createEnvironment', 'projectId', projectId)
            const localVarPath = `/project/{projectId}/environment`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createEnvironmentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of environment ids, and for each its total numberof services
         * @summary List total number of services for each environment of the project
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectEnvironmentServiceNumber: async (projectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getProjectEnvironmentServiceNumber', 'projectId', projectId)
            const localVarPath = `/project/{projectId}/environment/stats`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of environments with only their id and status.
         * @summary List environments statuses
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectEnvironmentsStatus: async (projectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getProjectEnvironmentsStatus', 'projectId', projectId)
            const localVarPath = `/project/{projectId}/environment/status`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List environments
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironment: async (projectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('listEnvironment', 'projectId', projectId)
            const localVarPath = `/project/{projectId}/environment`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentsApi - functional programming interface
 * @export
 */
export const EnvironmentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnvironmentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create an environment
         * @param {string} projectId Project ID
         * @param {CreateEnvironmentRequest} [createEnvironmentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEnvironment(projectId: string, createEnvironmentRequest?: CreateEnvironmentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Environment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEnvironment(projectId, createEnvironmentRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of environment ids, and for each its total numberof services
         * @summary List total number of services for each environment of the project
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjectEnvironmentServiceNumber(projectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentStatsResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectEnvironmentServiceNumber(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of environments with only their id and status.
         * @summary List environments statuses
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjectEnvironmentsStatus(projectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentStatusList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectEnvironmentsStatus(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List environments
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEnvironment(projectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEnvironment(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EnvironmentsApi - factory interface
 * @export
 */
export const EnvironmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnvironmentsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create an environment
         * @param {string} projectId Project ID
         * @param {CreateEnvironmentRequest} [createEnvironmentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironment(projectId: string, createEnvironmentRequest?: CreateEnvironmentRequest, options?: any): AxiosPromise<Environment> {
            return localVarFp.createEnvironment(projectId, createEnvironmentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of environment ids, and for each its total numberof services
         * @summary List total number of services for each environment of the project
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectEnvironmentServiceNumber(projectId: string, options?: any): AxiosPromise<EnvironmentStatsResponseList> {
            return localVarFp.getProjectEnvironmentServiceNumber(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of environments with only their id and status.
         * @summary List environments statuses
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectEnvironmentsStatus(projectId: string, options?: any): AxiosPromise<EnvironmentStatusList> {
            return localVarFp.getProjectEnvironmentsStatus(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List environments
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironment(projectId: string, options?: any): AxiosPromise<EnvironmentResponseList> {
            return localVarFp.listEnvironment(projectId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnvironmentsApi - object-oriented interface
 * @export
 * @class EnvironmentsApi
 * @extends {BaseAPI}
 */
export class EnvironmentsApi extends BaseAPI {
    /**
     * 
     * @summary Create an environment
     * @param {string} projectId Project ID
     * @param {CreateEnvironmentRequest} [createEnvironmentRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public createEnvironment(projectId: string, createEnvironmentRequest?: CreateEnvironmentRequest, options?: AxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).createEnvironment(projectId, createEnvironmentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of environment ids, and for each its total numberof services
     * @summary List total number of services for each environment of the project
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public getProjectEnvironmentServiceNumber(projectId: string, options?: AxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).getProjectEnvironmentServiceNumber(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of environments with only their id and status.
     * @summary List environments statuses
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public getProjectEnvironmentsStatus(projectId: string, options?: AxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).getProjectEnvironmentsStatus(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List environments
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public listEnvironment(projectId: string, options?: AxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).listEnvironment(projectId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GitRepositoriesApi - axios parameter creator
 * @export
 */
export const GitRepositoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get bitbucket repositories of the connected user
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getBitbucketRepositories: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/bitbucket/repository`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get bitbucket branches of the specified repository
         * @param {string} [name] The name of the repository where to retrieve the branches
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getBitbucketRepositoryBranches: async (name?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/bitbucket/repository/branch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get git provider accounts
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getGitProviderAccount: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/gitAuthProvider`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get github repositories of the connected user
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getGithubRepositories: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/github/repository`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get github branches of the specified repository
         * @param {string} [name] The name of the repository where to retrieve the branches
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getGithubRepositoryBranches: async (name?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/github/repository/branch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get gitlab repositories of the connected user
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getGitlabRepositories: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/gitlab/repository`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get gitlab branches of the specified repository
         * @param {string} [name] The name of the repository to retrieve the branches
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getGitlabRepositoryBranches: async (name?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/gitlab/repository/branch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GitRepositoriesApi - functional programming interface
 * @export
 */
export const GitRepositoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GitRepositoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get bitbucket repositories of the connected user
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getBitbucketRepositories(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitRepositoryResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBitbucketRepositories(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get bitbucket branches of the specified repository
         * @param {string} [name] The name of the repository where to retrieve the branches
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getBitbucketRepositoryBranches(name?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitRepositoryBranchResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBitbucketRepositoryBranches(name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get git provider accounts
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getGitProviderAccount(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitAuthProviderResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGitProviderAccount(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get github repositories of the connected user
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getGithubRepositories(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitRepositoryResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGithubRepositories(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get github branches of the specified repository
         * @param {string} [name] The name of the repository where to retrieve the branches
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getGithubRepositoryBranches(name?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitRepositoryBranchResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGithubRepositoryBranches(name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get gitlab repositories of the connected user
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getGitlabRepositories(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitRepositoryResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGitlabRepositories(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get gitlab branches of the specified repository
         * @param {string} [name] The name of the repository to retrieve the branches
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getGitlabRepositoryBranches(name?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitRepositoryBranchResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGitlabRepositoryBranches(name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GitRepositoriesApi - factory interface
 * @export
 */
export const GitRepositoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GitRepositoriesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get bitbucket repositories of the connected user
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getBitbucketRepositories(options?: any): AxiosPromise<GitRepositoryResponseList> {
            return localVarFp.getBitbucketRepositories(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get bitbucket branches of the specified repository
         * @param {string} [name] The name of the repository where to retrieve the branches
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getBitbucketRepositoryBranches(name?: string, options?: any): AxiosPromise<GitRepositoryBranchResponseList> {
            return localVarFp.getBitbucketRepositoryBranches(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get git provider accounts
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getGitProviderAccount(options?: any): AxiosPromise<GitAuthProviderResponseList> {
            return localVarFp.getGitProviderAccount(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get github repositories of the connected user
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getGithubRepositories(options?: any): AxiosPromise<GitRepositoryResponseList> {
            return localVarFp.getGithubRepositories(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get github branches of the specified repository
         * @param {string} [name] The name of the repository where to retrieve the branches
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getGithubRepositoryBranches(name?: string, options?: any): AxiosPromise<GitRepositoryBranchResponseList> {
            return localVarFp.getGithubRepositoryBranches(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get gitlab repositories of the connected user
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getGitlabRepositories(options?: any): AxiosPromise<GitRepositoryResponseList> {
            return localVarFp.getGitlabRepositories(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get gitlab branches of the specified repository
         * @param {string} [name] The name of the repository to retrieve the branches
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getGitlabRepositoryBranches(name?: string, options?: any): AxiosPromise<GitRepositoryBranchResponseList> {
            return localVarFp.getGitlabRepositoryBranches(name, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GitRepositoriesApi - object-oriented interface
 * @export
 * @class GitRepositoriesApi
 * @extends {BaseAPI}
 */
export class GitRepositoriesApi extends BaseAPI {
    /**
     * 
     * @summary Get bitbucket repositories of the connected user
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof GitRepositoriesApi
     */
    public getBitbucketRepositories(options?: AxiosRequestConfig) {
        return GitRepositoriesApiFp(this.configuration).getBitbucketRepositories(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get bitbucket branches of the specified repository
     * @param {string} [name] The name of the repository where to retrieve the branches
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof GitRepositoriesApi
     */
    public getBitbucketRepositoryBranches(name?: string, options?: AxiosRequestConfig) {
        return GitRepositoriesApiFp(this.configuration).getBitbucketRepositoryBranches(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get git provider accounts
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof GitRepositoriesApi
     */
    public getGitProviderAccount(options?: AxiosRequestConfig) {
        return GitRepositoriesApiFp(this.configuration).getGitProviderAccount(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get github repositories of the connected user
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof GitRepositoriesApi
     */
    public getGithubRepositories(options?: AxiosRequestConfig) {
        return GitRepositoriesApiFp(this.configuration).getGithubRepositories(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get github branches of the specified repository
     * @param {string} [name] The name of the repository where to retrieve the branches
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof GitRepositoriesApi
     */
    public getGithubRepositoryBranches(name?: string, options?: AxiosRequestConfig) {
        return GitRepositoriesApiFp(this.configuration).getGithubRepositoryBranches(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get gitlab repositories of the connected user
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof GitRepositoriesApi
     */
    public getGitlabRepositories(options?: AxiosRequestConfig) {
        return GitRepositoriesApiFp(this.configuration).getGitlabRepositories(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get gitlab branches of the specified repository
     * @param {string} [name] The name of the repository to retrieve the branches
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof GitRepositoriesApi
     */
    public getGitlabRepositoryBranches(name?: string, options?: AxiosRequestConfig) {
        return GitRepositoriesApiFp(this.configuration).getGitlabRepositoryBranches(name, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GithubAppApi - axios parameter creator
 * @export
 */
export const GithubAppApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Connect a github account to an organization
         * @param {string} organizationId Organization ID
         * @param {OrganizationGithubAppConnectRequest} [organizationGithubAppConnectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationGithubAppConnect: async (organizationId: string, organizationGithubAppConnectRequest?: OrganizationGithubAppConnectRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('organizationGithubAppConnect', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/github/connect`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationGithubAppConnectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Disconnect a github account from an organization
         * @param {string} organizationId Organization ID
         * @param {boolean} [force] Indicates if the github app should be disconnected despite github applications linked to organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationGithubAppDisconnect: async (organizationId: string, force?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('organizationGithubAppDisconnect', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/github/disconnect`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GithubAppApi - functional programming interface
 * @export
 */
export const GithubAppApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GithubAppApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Connect a github account to an organization
         * @param {string} organizationId Organization ID
         * @param {OrganizationGithubAppConnectRequest} [organizationGithubAppConnectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationGithubAppConnect(organizationId: string, organizationGithubAppConnectRequest?: OrganizationGithubAppConnectRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationGithubAppConnect(organizationId, organizationGithubAppConnectRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Disconnect a github account from an organization
         * @param {string} organizationId Organization ID
         * @param {boolean} [force] Indicates if the github app should be disconnected despite github applications linked to organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationGithubAppDisconnect(organizationId: string, force?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationGithubAppDisconnect(organizationId, force, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GithubAppApi - factory interface
 * @export
 */
export const GithubAppApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GithubAppApiFp(configuration)
    return {
        /**
         * 
         * @summary Connect a github account to an organization
         * @param {string} organizationId Organization ID
         * @param {OrganizationGithubAppConnectRequest} [organizationGithubAppConnectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationGithubAppConnect(organizationId: string, organizationGithubAppConnectRequest?: OrganizationGithubAppConnectRequest, options?: any): AxiosPromise<void> {
            return localVarFp.organizationGithubAppConnect(organizationId, organizationGithubAppConnectRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Disconnect a github account from an organization
         * @param {string} organizationId Organization ID
         * @param {boolean} [force] Indicates if the github app should be disconnected despite github applications linked to organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationGithubAppDisconnect(organizationId: string, force?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.organizationGithubAppDisconnect(organizationId, force, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GithubAppApi - object-oriented interface
 * @export
 * @class GithubAppApi
 * @extends {BaseAPI}
 */
export class GithubAppApi extends BaseAPI {
    /**
     * 
     * @summary Connect a github account to an organization
     * @param {string} organizationId Organization ID
     * @param {OrganizationGithubAppConnectRequest} [organizationGithubAppConnectRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GithubAppApi
     */
    public organizationGithubAppConnect(organizationId: string, organizationGithubAppConnectRequest?: OrganizationGithubAppConnectRequest, options?: AxiosRequestConfig) {
        return GithubAppApiFp(this.configuration).organizationGithubAppConnect(organizationId, organizationGithubAppConnectRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Disconnect a github account from an organization
     * @param {string} organizationId Organization ID
     * @param {boolean} [force] Indicates if the github app should be disconnected despite github applications linked to organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GithubAppApi
     */
    public organizationGithubAppDisconnect(organizationId: string, force?: boolean, options?: AxiosRequestConfig) {
        return GithubAppApiFp(this.configuration).organizationGithubAppDisconnect(organizationId, force, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HelmActionsApi - axios parameter creator
 * @export
 */
export const HelmActionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * You must provide a git commit id or an image tag depending on the source location of your code (git vs image repository).
         * @summary Deploy helm
         * @param {string} helmId Helm ID
         * @param {HelmForceEvent} [forceEvent] When filled, it indicates the target event to be deployed.   If the concerned helm hasn\&#39;t the target event provided, the helm won\&#39;t be deployed. 
         * @param {HelmDeployRequest} [helmDeployRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployHelm: async (helmId: string, forceEvent?: HelmForceEvent, helmDeployRequest?: HelmDeployRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'helmId' is not null or undefined
            assertParamExists('deployHelm', 'helmId', helmId)
            const localVarPath = `/helm/{helmId}/deploy`
                .replace(`{${"helmId"}}`, encodeURIComponent(String(helmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (forceEvent !== undefined) {
                localVarQueryParameter['forceEvent'] = forceEvent;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(helmDeployRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Redeploy helm
         * @param {string} helmId Helm ID
         * @param {HelmForceEvent} [forceEvent] When filled, it indicates the target event to be deployed.   If the concerned helm hasn\&#39;t the target event provided, the helm won\&#39;t be deployed. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeployHelm: async (helmId: string, forceEvent?: HelmForceEvent, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'helmId' is not null or undefined
            assertParamExists('redeployHelm', 'helmId', helmId)
            const localVarPath = `/helm/{helmId}/redeploy`
                .replace(`{${"helmId"}}`, encodeURIComponent(String(helmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (forceEvent !== undefined) {
                localVarQueryParameter['forceEvent'] = forceEvent;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop helm
         * @param {string} helmId Helm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopHelm: async (helmId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'helmId' is not null or undefined
            assertParamExists('stopHelm', 'helmId', helmId)
            const localVarPath = `/helm/{helmId}/stop`
                .replace(`{${"helmId"}}`, encodeURIComponent(String(helmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HelmActionsApi - functional programming interface
 * @export
 */
export const HelmActionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HelmActionsApiAxiosParamCreator(configuration)
    return {
        /**
         * You must provide a git commit id or an image tag depending on the source location of your code (git vs image repository).
         * @summary Deploy helm
         * @param {string} helmId Helm ID
         * @param {HelmForceEvent} [forceEvent] When filled, it indicates the target event to be deployed.   If the concerned helm hasn\&#39;t the target event provided, the helm won\&#39;t be deployed. 
         * @param {HelmDeployRequest} [helmDeployRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployHelm(helmId: string, forceEvent?: HelmForceEvent, helmDeployRequest?: HelmDeployRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployHelm(helmId, forceEvent, helmDeployRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Redeploy helm
         * @param {string} helmId Helm ID
         * @param {HelmForceEvent} [forceEvent] When filled, it indicates the target event to be deployed.   If the concerned helm hasn\&#39;t the target event provided, the helm won\&#39;t be deployed. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async redeployHelm(helmId: string, forceEvent?: HelmForceEvent, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.redeployHelm(helmId, forceEvent, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Stop helm
         * @param {string} helmId Helm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopHelm(helmId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopHelm(helmId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HelmActionsApi - factory interface
 * @export
 */
export const HelmActionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HelmActionsApiFp(configuration)
    return {
        /**
         * You must provide a git commit id or an image tag depending on the source location of your code (git vs image repository).
         * @summary Deploy helm
         * @param {string} helmId Helm ID
         * @param {HelmForceEvent} [forceEvent] When filled, it indicates the target event to be deployed.   If the concerned helm hasn\&#39;t the target event provided, the helm won\&#39;t be deployed. 
         * @param {HelmDeployRequest} [helmDeployRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployHelm(helmId: string, forceEvent?: HelmForceEvent, helmDeployRequest?: HelmDeployRequest, options?: any): AxiosPromise<Status> {
            return localVarFp.deployHelm(helmId, forceEvent, helmDeployRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Redeploy helm
         * @param {string} helmId Helm ID
         * @param {HelmForceEvent} [forceEvent] When filled, it indicates the target event to be deployed.   If the concerned helm hasn\&#39;t the target event provided, the helm won\&#39;t be deployed. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeployHelm(helmId: string, forceEvent?: HelmForceEvent, options?: any): AxiosPromise<Status> {
            return localVarFp.redeployHelm(helmId, forceEvent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Stop helm
         * @param {string} helmId Helm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopHelm(helmId: string, options?: any): AxiosPromise<Status> {
            return localVarFp.stopHelm(helmId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HelmActionsApi - object-oriented interface
 * @export
 * @class HelmActionsApi
 * @extends {BaseAPI}
 */
export class HelmActionsApi extends BaseAPI {
    /**
     * You must provide a git commit id or an image tag depending on the source location of your code (git vs image repository).
     * @summary Deploy helm
     * @param {string} helmId Helm ID
     * @param {HelmForceEvent} [forceEvent] When filled, it indicates the target event to be deployed.   If the concerned helm hasn\&#39;t the target event provided, the helm won\&#39;t be deployed. 
     * @param {HelmDeployRequest} [helmDeployRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmActionsApi
     */
    public deployHelm(helmId: string, forceEvent?: HelmForceEvent, helmDeployRequest?: HelmDeployRequest, options?: AxiosRequestConfig) {
        return HelmActionsApiFp(this.configuration).deployHelm(helmId, forceEvent, helmDeployRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Redeploy helm
     * @param {string} helmId Helm ID
     * @param {HelmForceEvent} [forceEvent] When filled, it indicates the target event to be deployed.   If the concerned helm hasn\&#39;t the target event provided, the helm won\&#39;t be deployed. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmActionsApi
     */
    public redeployHelm(helmId: string, forceEvent?: HelmForceEvent, options?: AxiosRequestConfig) {
        return HelmActionsApiFp(this.configuration).redeployHelm(helmId, forceEvent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Stop helm
     * @param {string} helmId Helm ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmActionsApi
     */
    public stopHelm(helmId: string, options?: AxiosRequestConfig) {
        return HelmActionsApiFp(this.configuration).stopHelm(helmId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HelmConfigurationApi - axios parameter creator
 * @export
 */
export const HelmConfigurationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Edit advanced settings by returning table of advanced settings.
         * @summary Edit advanced settings
         * @param {string} helmId Helm ID
         * @param {HelmAdvancedSettings} [helmAdvancedSettings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editHelmAdvancedSettings: async (helmId: string, helmAdvancedSettings?: HelmAdvancedSettings, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'helmId' is not null or undefined
            assertParamExists('editHelmAdvancedSettings', 'helmId', helmId)
            const localVarPath = `/helm/{helmId}/advancedSettings`
                .replace(`{${"helmId"}}`, encodeURIComponent(String(helmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(helmAdvancedSettings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list and values of the advanced settings of the helm.
         * @summary Get advanced settings
         * @param {string} helmId Helm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHelmAdvancedSettings: async (helmId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'helmId' is not null or undefined
            assertParamExists('getHelmAdvancedSettings', 'helmId', helmId)
            const localVarPath = `/helm/{helmId}/advancedSettings`
                .replace(`{${"helmId"}}`, encodeURIComponent(String(helmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HelmConfigurationApi - functional programming interface
 * @export
 */
export const HelmConfigurationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HelmConfigurationApiAxiosParamCreator(configuration)
    return {
        /**
         * Edit advanced settings by returning table of advanced settings.
         * @summary Edit advanced settings
         * @param {string} helmId Helm ID
         * @param {HelmAdvancedSettings} [helmAdvancedSettings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editHelmAdvancedSettings(helmId: string, helmAdvancedSettings?: HelmAdvancedSettings, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HelmAdvancedSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editHelmAdvancedSettings(helmId, helmAdvancedSettings, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get list and values of the advanced settings of the helm.
         * @summary Get advanced settings
         * @param {string} helmId Helm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHelmAdvancedSettings(helmId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HelmAdvancedSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHelmAdvancedSettings(helmId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HelmConfigurationApi - factory interface
 * @export
 */
export const HelmConfigurationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HelmConfigurationApiFp(configuration)
    return {
        /**
         * Edit advanced settings by returning table of advanced settings.
         * @summary Edit advanced settings
         * @param {string} helmId Helm ID
         * @param {HelmAdvancedSettings} [helmAdvancedSettings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editHelmAdvancedSettings(helmId: string, helmAdvancedSettings?: HelmAdvancedSettings, options?: any): AxiosPromise<HelmAdvancedSettings> {
            return localVarFp.editHelmAdvancedSettings(helmId, helmAdvancedSettings, options).then((request) => request(axios, basePath));
        },
        /**
         * Get list and values of the advanced settings of the helm.
         * @summary Get advanced settings
         * @param {string} helmId Helm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHelmAdvancedSettings(helmId: string, options?: any): AxiosPromise<HelmAdvancedSettings> {
            return localVarFp.getHelmAdvancedSettings(helmId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HelmConfigurationApi - object-oriented interface
 * @export
 * @class HelmConfigurationApi
 * @extends {BaseAPI}
 */
export class HelmConfigurationApi extends BaseAPI {
    /**
     * Edit advanced settings by returning table of advanced settings.
     * @summary Edit advanced settings
     * @param {string} helmId Helm ID
     * @param {HelmAdvancedSettings} [helmAdvancedSettings] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmConfigurationApi
     */
    public editHelmAdvancedSettings(helmId: string, helmAdvancedSettings?: HelmAdvancedSettings, options?: AxiosRequestConfig) {
        return HelmConfigurationApiFp(this.configuration).editHelmAdvancedSettings(helmId, helmAdvancedSettings, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list and values of the advanced settings of the helm.
     * @summary Get advanced settings
     * @param {string} helmId Helm ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmConfigurationApi
     */
    public getHelmAdvancedSettings(helmId: string, options?: AxiosRequestConfig) {
        return HelmConfigurationApiFp(this.configuration).getHelmAdvancedSettings(helmId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HelmCustomDomainApi - axios parameter creator
 * @export
 */
export const HelmCustomDomainApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a custom domain to this helm in order not to use qovery autogenerated domain
         * @summary Add custom domain to the helm.
         * @param {string} helmId Helm ID
         * @param {CustomDomainRequest} [customDomainRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHelmCustomDomain: async (helmId: string, customDomainRequest?: CustomDomainRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'helmId' is not null or undefined
            assertParamExists('createHelmCustomDomain', 'helmId', helmId)
            const localVarPath = `/helm/{helmId}/customDomain`
                .replace(`{${"helmId"}}`, encodeURIComponent(String(helmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customDomainRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To delete an CustomDomain you must have the project user permission
         * @summary Delete a Custom Domain
         * @param {string} helmId Helm ID
         * @param {string} customDomainId Custom Domain ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHelmCustomDomain: async (helmId: string, customDomainId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'helmId' is not null or undefined
            assertParamExists('deleteHelmCustomDomain', 'helmId', helmId)
            // verify required parameter 'customDomainId' is not null or undefined
            assertParamExists('deleteHelmCustomDomain', 'customDomainId', customDomainId)
            const localVarPath = `/helm/{helmId}/customDomain/{customDomainId}`
                .replace(`{${"helmId"}}`, encodeURIComponent(String(helmId)))
                .replace(`{${"customDomainId"}}`, encodeURIComponent(String(customDomainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To edit a Custom Domain you must have the project user permission
         * @summary Edit a Custom Domain
         * @param {string} helmId Helm ID
         * @param {string} customDomainId Custom Domain ID
         * @param {CustomDomainRequest} [customDomainRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editHelmCustomDomain: async (helmId: string, customDomainId: string, customDomainRequest?: CustomDomainRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'helmId' is not null or undefined
            assertParamExists('editHelmCustomDomain', 'helmId', helmId)
            // verify required parameter 'customDomainId' is not null or undefined
            assertParamExists('editHelmCustomDomain', 'customDomainId', customDomainId)
            const localVarPath = `/helm/{helmId}/customDomain/{customDomainId}`
                .replace(`{${"helmId"}}`, encodeURIComponent(String(helmId)))
                .replace(`{${"customDomainId"}}`, encodeURIComponent(String(customDomainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customDomainRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a custom domain
         * @summary Get a Custom Domain
         * @param {string} helmId Helm ID
         * @param {string} customDomainId Custom Domain ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHelmCustomDomain: async (helmId: string, customDomainId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'helmId' is not null or undefined
            assertParamExists('getHelmCustomDomain', 'helmId', helmId)
            // verify required parameter 'customDomainId' is not null or undefined
            assertParamExists('getHelmCustomDomain', 'customDomainId', customDomainId)
            const localVarPath = `/helm/{helmId}/customDomain/{customDomainId}`
                .replace(`{${"helmId"}}`, encodeURIComponent(String(helmId)))
                .replace(`{${"customDomainId"}}`, encodeURIComponent(String(customDomainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the custom domains of this helm
         * @summary List helm custom domains
         * @param {string} helmId Helm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHelmCustomDomain: async (helmId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'helmId' is not null or undefined
            assertParamExists('listHelmCustomDomain', 'helmId', helmId)
            const localVarPath = `/helm/{helmId}/customDomain`
                .replace(`{${"helmId"}}`, encodeURIComponent(String(helmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HelmCustomDomainApi - functional programming interface
 * @export
 */
export const HelmCustomDomainApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HelmCustomDomainApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a custom domain to this helm in order not to use qovery autogenerated domain
         * @summary Add custom domain to the helm.
         * @param {string} helmId Helm ID
         * @param {CustomDomainRequest} [customDomainRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createHelmCustomDomain(helmId: string, customDomainRequest?: CustomDomainRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomDomain>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createHelmCustomDomain(helmId, customDomainRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * To delete an CustomDomain you must have the project user permission
         * @summary Delete a Custom Domain
         * @param {string} helmId Helm ID
         * @param {string} customDomainId Custom Domain ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteHelmCustomDomain(helmId: string, customDomainId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteHelmCustomDomain(helmId, customDomainId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * To edit a Custom Domain you must have the project user permission
         * @summary Edit a Custom Domain
         * @param {string} helmId Helm ID
         * @param {string} customDomainId Custom Domain ID
         * @param {CustomDomainRequest} [customDomainRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editHelmCustomDomain(helmId: string, customDomainId: string, customDomainRequest?: CustomDomainRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomDomain>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editHelmCustomDomain(helmId, customDomainId, customDomainRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a custom domain
         * @summary Get a Custom Domain
         * @param {string} helmId Helm ID
         * @param {string} customDomainId Custom Domain ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHelmCustomDomain(helmId: string, customDomainId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomDomain>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHelmCustomDomain(helmId, customDomainId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the custom domains of this helm
         * @summary List helm custom domains
         * @param {string} helmId Helm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listHelmCustomDomain(helmId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomDomainResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listHelmCustomDomain(helmId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HelmCustomDomainApi - factory interface
 * @export
 */
export const HelmCustomDomainApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HelmCustomDomainApiFp(configuration)
    return {
        /**
         * Add a custom domain to this helm in order not to use qovery autogenerated domain
         * @summary Add custom domain to the helm.
         * @param {string} helmId Helm ID
         * @param {CustomDomainRequest} [customDomainRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHelmCustomDomain(helmId: string, customDomainRequest?: CustomDomainRequest, options?: any): AxiosPromise<CustomDomain> {
            return localVarFp.createHelmCustomDomain(helmId, customDomainRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * To delete an CustomDomain you must have the project user permission
         * @summary Delete a Custom Domain
         * @param {string} helmId Helm ID
         * @param {string} customDomainId Custom Domain ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHelmCustomDomain(helmId: string, customDomainId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteHelmCustomDomain(helmId, customDomainId, options).then((request) => request(axios, basePath));
        },
        /**
         * To edit a Custom Domain you must have the project user permission
         * @summary Edit a Custom Domain
         * @param {string} helmId Helm ID
         * @param {string} customDomainId Custom Domain ID
         * @param {CustomDomainRequest} [customDomainRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editHelmCustomDomain(helmId: string, customDomainId: string, customDomainRequest?: CustomDomainRequest, options?: any): AxiosPromise<CustomDomain> {
            return localVarFp.editHelmCustomDomain(helmId, customDomainId, customDomainRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a custom domain
         * @summary Get a Custom Domain
         * @param {string} helmId Helm ID
         * @param {string} customDomainId Custom Domain ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHelmCustomDomain(helmId: string, customDomainId: string, options?: any): AxiosPromise<CustomDomain> {
            return localVarFp.getHelmCustomDomain(helmId, customDomainId, options).then((request) => request(axios, basePath));
        },
        /**
         * List the custom domains of this helm
         * @summary List helm custom domains
         * @param {string} helmId Helm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHelmCustomDomain(helmId: string, options?: any): AxiosPromise<CustomDomainResponseList> {
            return localVarFp.listHelmCustomDomain(helmId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HelmCustomDomainApi - object-oriented interface
 * @export
 * @class HelmCustomDomainApi
 * @extends {BaseAPI}
 */
export class HelmCustomDomainApi extends BaseAPI {
    /**
     * Add a custom domain to this helm in order not to use qovery autogenerated domain
     * @summary Add custom domain to the helm.
     * @param {string} helmId Helm ID
     * @param {CustomDomainRequest} [customDomainRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmCustomDomainApi
     */
    public createHelmCustomDomain(helmId: string, customDomainRequest?: CustomDomainRequest, options?: AxiosRequestConfig) {
        return HelmCustomDomainApiFp(this.configuration).createHelmCustomDomain(helmId, customDomainRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To delete an CustomDomain you must have the project user permission
     * @summary Delete a Custom Domain
     * @param {string} helmId Helm ID
     * @param {string} customDomainId Custom Domain ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmCustomDomainApi
     */
    public deleteHelmCustomDomain(helmId: string, customDomainId: string, options?: AxiosRequestConfig) {
        return HelmCustomDomainApiFp(this.configuration).deleteHelmCustomDomain(helmId, customDomainId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To edit a Custom Domain you must have the project user permission
     * @summary Edit a Custom Domain
     * @param {string} helmId Helm ID
     * @param {string} customDomainId Custom Domain ID
     * @param {CustomDomainRequest} [customDomainRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmCustomDomainApi
     */
    public editHelmCustomDomain(helmId: string, customDomainId: string, customDomainRequest?: CustomDomainRequest, options?: AxiosRequestConfig) {
        return HelmCustomDomainApiFp(this.configuration).editHelmCustomDomain(helmId, customDomainId, customDomainRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a custom domain
     * @summary Get a Custom Domain
     * @param {string} helmId Helm ID
     * @param {string} customDomainId Custom Domain ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmCustomDomainApi
     */
    public getHelmCustomDomain(helmId: string, customDomainId: string, options?: AxiosRequestConfig) {
        return HelmCustomDomainApiFp(this.configuration).getHelmCustomDomain(helmId, customDomainId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the custom domains of this helm
     * @summary List helm custom domains
     * @param {string} helmId Helm ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmCustomDomainApi
     */
    public listHelmCustomDomain(helmId: string, options?: AxiosRequestConfig) {
        return HelmCustomDomainApiFp(this.configuration).listHelmCustomDomain(helmId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HelmDeploymentHistoryApi - axios parameter creator
 * @export
 */
export const HelmDeploymentHistoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the 20 last helm deployments
         * @summary List helm deployments
         * @param {string} helmId Helm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHelmDeploymentHistory: async (helmId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'helmId' is not null or undefined
            assertParamExists('listHelmDeploymentHistory', 'helmId', helmId)
            const localVarPath = `/helm/{helmId}/deploymentHistory`
                .replace(`{${"helmId"}}`, encodeURIComponent(String(helmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HelmDeploymentHistoryApi - functional programming interface
 * @export
 */
export const HelmDeploymentHistoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HelmDeploymentHistoryApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the 20 last helm deployments
         * @summary List helm deployments
         * @param {string} helmId Helm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listHelmDeploymentHistory(helmId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListHelmDeploymentHistory200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listHelmDeploymentHistory(helmId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HelmDeploymentHistoryApi - factory interface
 * @export
 */
export const HelmDeploymentHistoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HelmDeploymentHistoryApiFp(configuration)
    return {
        /**
         * Returns the 20 last helm deployments
         * @summary List helm deployments
         * @param {string} helmId Helm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHelmDeploymentHistory(helmId: string, options?: any): AxiosPromise<ListHelmDeploymentHistory200Response> {
            return localVarFp.listHelmDeploymentHistory(helmId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HelmDeploymentHistoryApi - object-oriented interface
 * @export
 * @class HelmDeploymentHistoryApi
 * @extends {BaseAPI}
 */
export class HelmDeploymentHistoryApi extends BaseAPI {
    /**
     * Returns the 20 last helm deployments
     * @summary List helm deployments
     * @param {string} helmId Helm ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmDeploymentHistoryApi
     */
    public listHelmDeploymentHistory(helmId: string, options?: AxiosRequestConfig) {
        return HelmDeploymentHistoryApiFp(this.configuration).listHelmDeploymentHistory(helmId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HelmDeploymentRestrictionApi - axios parameter creator
 * @export
 */
export const HelmDeploymentRestrictionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a helm deployment restriction
         * @summary Create a helm deployment restriction
         * @param {string} helmId Helm ID
         * @param {HelmDeploymentRestrictionRequest} [helmDeploymentRestrictionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHelmDeploymentRestriction: async (helmId: string, helmDeploymentRestrictionRequest?: HelmDeploymentRestrictionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'helmId' is not null or undefined
            assertParamExists('createHelmDeploymentRestriction', 'helmId', helmId)
            const localVarPath = `/helm/{helmId}/deploymentRestriction`
                .replace(`{${"helmId"}}`, encodeURIComponent(String(helmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(helmDeploymentRestrictionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a helm deployment restriction
         * @summary Delete a helm deployment restriction
         * @param {string} helmId Helm ID
         * @param {string} deploymentRestrictionId Deployment Restriction ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHelmDeploymentRestriction: async (helmId: string, deploymentRestrictionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'helmId' is not null or undefined
            assertParamExists('deleteHelmDeploymentRestriction', 'helmId', helmId)
            // verify required parameter 'deploymentRestrictionId' is not null or undefined
            assertParamExists('deleteHelmDeploymentRestriction', 'deploymentRestrictionId', deploymentRestrictionId)
            const localVarPath = `/helm/{helmId}/deploymentRestriction/{deploymentRestrictionId}`
                .replace(`{${"helmId"}}`, encodeURIComponent(String(helmId)))
                .replace(`{${"deploymentRestrictionId"}}`, encodeURIComponent(String(deploymentRestrictionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit a helm deployment restriction
         * @summary Edit a helm deployment restriction
         * @param {string} helmId Helm ID
         * @param {string} deploymentRestrictionId Deployment Restriction ID
         * @param {HelmDeploymentRestrictionRequest} [helmDeploymentRestrictionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editHelmDeploymentRestriction: async (helmId: string, deploymentRestrictionId: string, helmDeploymentRestrictionRequest?: HelmDeploymentRestrictionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'helmId' is not null or undefined
            assertParamExists('editHelmDeploymentRestriction', 'helmId', helmId)
            // verify required parameter 'deploymentRestrictionId' is not null or undefined
            assertParamExists('editHelmDeploymentRestriction', 'deploymentRestrictionId', deploymentRestrictionId)
            const localVarPath = `/helm/{helmId}/deploymentRestriction/{deploymentRestrictionId}`
                .replace(`{${"helmId"}}`, encodeURIComponent(String(helmId)))
                .replace(`{${"deploymentRestrictionId"}}`, encodeURIComponent(String(deploymentRestrictionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(helmDeploymentRestrictionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get helm deployment restrictions
         * @summary Get helm deployment restrictions
         * @param {string} helmId Helm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHelmDeploymentRestrictions: async (helmId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'helmId' is not null or undefined
            assertParamExists('getHelmDeploymentRestrictions', 'helmId', helmId)
            const localVarPath = `/helm/{helmId}/deploymentRestriction`
                .replace(`{${"helmId"}}`, encodeURIComponent(String(helmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HelmDeploymentRestrictionApi - functional programming interface
 * @export
 */
export const HelmDeploymentRestrictionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HelmDeploymentRestrictionApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a helm deployment restriction
         * @summary Create a helm deployment restriction
         * @param {string} helmId Helm ID
         * @param {HelmDeploymentRestrictionRequest} [helmDeploymentRestrictionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createHelmDeploymentRestriction(helmId: string, helmDeploymentRestrictionRequest?: HelmDeploymentRestrictionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HelmDeploymentRestrictionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createHelmDeploymentRestriction(helmId, helmDeploymentRestrictionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a helm deployment restriction
         * @summary Delete a helm deployment restriction
         * @param {string} helmId Helm ID
         * @param {string} deploymentRestrictionId Deployment Restriction ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteHelmDeploymentRestriction(helmId: string, deploymentRestrictionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteHelmDeploymentRestriction(helmId, deploymentRestrictionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Edit a helm deployment restriction
         * @summary Edit a helm deployment restriction
         * @param {string} helmId Helm ID
         * @param {string} deploymentRestrictionId Deployment Restriction ID
         * @param {HelmDeploymentRestrictionRequest} [helmDeploymentRestrictionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editHelmDeploymentRestriction(helmId: string, deploymentRestrictionId: string, helmDeploymentRestrictionRequest?: HelmDeploymentRestrictionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HelmDeploymentRestrictionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editHelmDeploymentRestriction(helmId, deploymentRestrictionId, helmDeploymentRestrictionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get helm deployment restrictions
         * @summary Get helm deployment restrictions
         * @param {string} helmId Helm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHelmDeploymentRestrictions(helmId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HelmDeploymentRestrictionResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHelmDeploymentRestrictions(helmId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HelmDeploymentRestrictionApi - factory interface
 * @export
 */
export const HelmDeploymentRestrictionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HelmDeploymentRestrictionApiFp(configuration)
    return {
        /**
         * Create a helm deployment restriction
         * @summary Create a helm deployment restriction
         * @param {string} helmId Helm ID
         * @param {HelmDeploymentRestrictionRequest} [helmDeploymentRestrictionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHelmDeploymentRestriction(helmId: string, helmDeploymentRestrictionRequest?: HelmDeploymentRestrictionRequest, options?: any): AxiosPromise<HelmDeploymentRestrictionResponse> {
            return localVarFp.createHelmDeploymentRestriction(helmId, helmDeploymentRestrictionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a helm deployment restriction
         * @summary Delete a helm deployment restriction
         * @param {string} helmId Helm ID
         * @param {string} deploymentRestrictionId Deployment Restriction ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHelmDeploymentRestriction(helmId: string, deploymentRestrictionId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteHelmDeploymentRestriction(helmId, deploymentRestrictionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit a helm deployment restriction
         * @summary Edit a helm deployment restriction
         * @param {string} helmId Helm ID
         * @param {string} deploymentRestrictionId Deployment Restriction ID
         * @param {HelmDeploymentRestrictionRequest} [helmDeploymentRestrictionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editHelmDeploymentRestriction(helmId: string, deploymentRestrictionId: string, helmDeploymentRestrictionRequest?: HelmDeploymentRestrictionRequest, options?: any): AxiosPromise<HelmDeploymentRestrictionResponse> {
            return localVarFp.editHelmDeploymentRestriction(helmId, deploymentRestrictionId, helmDeploymentRestrictionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get helm deployment restrictions
         * @summary Get helm deployment restrictions
         * @param {string} helmId Helm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHelmDeploymentRestrictions(helmId: string, options?: any): AxiosPromise<HelmDeploymentRestrictionResponseList> {
            return localVarFp.getHelmDeploymentRestrictions(helmId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HelmDeploymentRestrictionApi - object-oriented interface
 * @export
 * @class HelmDeploymentRestrictionApi
 * @extends {BaseAPI}
 */
export class HelmDeploymentRestrictionApi extends BaseAPI {
    /**
     * Create a helm deployment restriction
     * @summary Create a helm deployment restriction
     * @param {string} helmId Helm ID
     * @param {HelmDeploymentRestrictionRequest} [helmDeploymentRestrictionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmDeploymentRestrictionApi
     */
    public createHelmDeploymentRestriction(helmId: string, helmDeploymentRestrictionRequest?: HelmDeploymentRestrictionRequest, options?: AxiosRequestConfig) {
        return HelmDeploymentRestrictionApiFp(this.configuration).createHelmDeploymentRestriction(helmId, helmDeploymentRestrictionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a helm deployment restriction
     * @summary Delete a helm deployment restriction
     * @param {string} helmId Helm ID
     * @param {string} deploymentRestrictionId Deployment Restriction ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmDeploymentRestrictionApi
     */
    public deleteHelmDeploymentRestriction(helmId: string, deploymentRestrictionId: string, options?: AxiosRequestConfig) {
        return HelmDeploymentRestrictionApiFp(this.configuration).deleteHelmDeploymentRestriction(helmId, deploymentRestrictionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit a helm deployment restriction
     * @summary Edit a helm deployment restriction
     * @param {string} helmId Helm ID
     * @param {string} deploymentRestrictionId Deployment Restriction ID
     * @param {HelmDeploymentRestrictionRequest} [helmDeploymentRestrictionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmDeploymentRestrictionApi
     */
    public editHelmDeploymentRestriction(helmId: string, deploymentRestrictionId: string, helmDeploymentRestrictionRequest?: HelmDeploymentRestrictionRequest, options?: AxiosRequestConfig) {
        return HelmDeploymentRestrictionApiFp(this.configuration).editHelmDeploymentRestriction(helmId, deploymentRestrictionId, helmDeploymentRestrictionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get helm deployment restrictions
     * @summary Get helm deployment restrictions
     * @param {string} helmId Helm ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmDeploymentRestrictionApi
     */
    public getHelmDeploymentRestrictions(helmId: string, options?: AxiosRequestConfig) {
        return HelmDeploymentRestrictionApiFp(this.configuration).getHelmDeploymentRestrictions(helmId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HelmMainCallsApi - axios parameter creator
 * @export
 */
export const HelmMainCallsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * To delete the helm you must have the admin permission
         * @summary Delete helm
         * @param {string} helmId Helm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHelm: async (helmId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'helmId' is not null or undefined
            assertParamExists('deleteHelm', 'helmId', helmId)
            const localVarPath = `/helm/{helmId}`
                .replace(`{${"helmId"}}`, encodeURIComponent(String(helmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - To edit the helm you must have the admin permission. 
         * @summary Edit helm
         * @param {string} helmId Helm ID
         * @param {HelmRequest} [helmRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editHelm: async (helmId: string, helmRequest?: HelmRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'helmId' is not null or undefined
            assertParamExists('editHelm', 'helmId', helmId)
            const localVarPath = `/helm/{helmId}`
                .replace(`{${"helmId"}}`, encodeURIComponent(String(helmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(helmRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get helm by ID
         * @param {string} helmId Helm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHelm: async (helmId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'helmId' is not null or undefined
            assertParamExists('getHelm', 'helmId', helmId)
            const localVarPath = `/helm/{helmId}`
                .replace(`{${"helmId"}}`, encodeURIComponent(String(helmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get helm status
         * @param {string} helmId Helm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHelmStatus: async (helmId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'helmId' is not null or undefined
            assertParamExists('getHelmStatus', 'helmId', helmId)
            const localVarPath = `/helm/{helmId}/status`
                .replace(`{${"helmId"}}`, encodeURIComponent(String(helmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns list of the last 100 commits made on the repository linked to helm
         * @summary List last helm commits
         * @param {string} helmId Helm ID
         * @param {string} [of] Source of git commit. Can be \&#39;chart\&#39; or \&#39;values\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHelmCommit: async (helmId: string, of?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'helmId' is not null or undefined
            assertParamExists('listHelmCommit', 'helmId', helmId)
            const localVarPath = `/helm/{helmId}/commit`
                .replace(`{${"helmId"}}`, encodeURIComponent(String(helmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (of !== undefined) {
                localVarQueryParameter['of'] = of;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This will return all the custom domains and Qovery autogenerated domain for the given helm
         * @summary List all URLs of the helm
         * @param {string} helmId Helm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHelmLinks: async (helmId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'helmId' is not null or undefined
            assertParamExists('listHelmLinks', 'helmId', helmId)
            const localVarPath = `/helm/{helmId}/link`
                .replace(`{${"helmId"}}`, encodeURIComponent(String(helmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HelmMainCallsApi - functional programming interface
 * @export
 */
export const HelmMainCallsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HelmMainCallsApiAxiosParamCreator(configuration)
    return {
        /**
         * To delete the helm you must have the admin permission
         * @summary Delete helm
         * @param {string} helmId Helm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteHelm(helmId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteHelm(helmId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - To edit the helm you must have the admin permission. 
         * @summary Edit helm
         * @param {string} helmId Helm ID
         * @param {HelmRequest} [helmRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editHelm(helmId: string, helmRequest?: HelmRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HelmResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editHelm(helmId, helmRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get helm by ID
         * @param {string} helmId Helm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHelm(helmId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HelmResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHelm(helmId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get helm status
         * @param {string} helmId Helm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHelmStatus(helmId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHelmStatus(helmId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns list of the last 100 commits made on the repository linked to helm
         * @summary List last helm commits
         * @param {string} helmId Helm ID
         * @param {string} [of] Source of git commit. Can be \&#39;chart\&#39; or \&#39;values\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listHelmCommit(helmId: string, of?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommitResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listHelmCommit(helmId, of, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This will return all the custom domains and Qovery autogenerated domain for the given helm
         * @summary List all URLs of the helm
         * @param {string} helmId Helm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listHelmLinks(helmId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listHelmLinks(helmId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HelmMainCallsApi - factory interface
 * @export
 */
export const HelmMainCallsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HelmMainCallsApiFp(configuration)
    return {
        /**
         * To delete the helm you must have the admin permission
         * @summary Delete helm
         * @param {string} helmId Helm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHelm(helmId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteHelm(helmId, options).then((request) => request(axios, basePath));
        },
        /**
         * - To edit the helm you must have the admin permission. 
         * @summary Edit helm
         * @param {string} helmId Helm ID
         * @param {HelmRequest} [helmRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editHelm(helmId: string, helmRequest?: HelmRequest, options?: any): AxiosPromise<HelmResponse> {
            return localVarFp.editHelm(helmId, helmRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get helm by ID
         * @param {string} helmId Helm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHelm(helmId: string, options?: any): AxiosPromise<HelmResponse> {
            return localVarFp.getHelm(helmId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get helm status
         * @param {string} helmId Helm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHelmStatus(helmId: string, options?: any): AxiosPromise<Status> {
            return localVarFp.getHelmStatus(helmId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns list of the last 100 commits made on the repository linked to helm
         * @summary List last helm commits
         * @param {string} helmId Helm ID
         * @param {string} [of] Source of git commit. Can be \&#39;chart\&#39; or \&#39;values\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHelmCommit(helmId: string, of?: string, options?: any): AxiosPromise<CommitResponseList> {
            return localVarFp.listHelmCommit(helmId, of, options).then((request) => request(axios, basePath));
        },
        /**
         * This will return all the custom domains and Qovery autogenerated domain for the given helm
         * @summary List all URLs of the helm
         * @param {string} helmId Helm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHelmLinks(helmId: string, options?: any): AxiosPromise<LinkResponseList> {
            return localVarFp.listHelmLinks(helmId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HelmMainCallsApi - object-oriented interface
 * @export
 * @class HelmMainCallsApi
 * @extends {BaseAPI}
 */
export class HelmMainCallsApi extends BaseAPI {
    /**
     * To delete the helm you must have the admin permission
     * @summary Delete helm
     * @param {string} helmId Helm ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmMainCallsApi
     */
    public deleteHelm(helmId: string, options?: AxiosRequestConfig) {
        return HelmMainCallsApiFp(this.configuration).deleteHelm(helmId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - To edit the helm you must have the admin permission. 
     * @summary Edit helm
     * @param {string} helmId Helm ID
     * @param {HelmRequest} [helmRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmMainCallsApi
     */
    public editHelm(helmId: string, helmRequest?: HelmRequest, options?: AxiosRequestConfig) {
        return HelmMainCallsApiFp(this.configuration).editHelm(helmId, helmRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get helm by ID
     * @param {string} helmId Helm ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmMainCallsApi
     */
    public getHelm(helmId: string, options?: AxiosRequestConfig) {
        return HelmMainCallsApiFp(this.configuration).getHelm(helmId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get helm status
     * @param {string} helmId Helm ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmMainCallsApi
     */
    public getHelmStatus(helmId: string, options?: AxiosRequestConfig) {
        return HelmMainCallsApiFp(this.configuration).getHelmStatus(helmId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns list of the last 100 commits made on the repository linked to helm
     * @summary List last helm commits
     * @param {string} helmId Helm ID
     * @param {string} [of] Source of git commit. Can be \&#39;chart\&#39; or \&#39;values\&#39;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmMainCallsApi
     */
    public listHelmCommit(helmId: string, of?: string, options?: AxiosRequestConfig) {
        return HelmMainCallsApiFp(this.configuration).listHelmCommit(helmId, of, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will return all the custom domains and Qovery autogenerated domain for the given helm
     * @summary List all URLs of the helm
     * @param {string} helmId Helm ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmMainCallsApi
     */
    public listHelmLinks(helmId: string, options?: AxiosRequestConfig) {
        return HelmMainCallsApiFp(this.configuration).listHelmLinks(helmId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HelmRepositoriesApi - axios parameter creator
 * @export
 */
export const HelmRepositoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a helm repository
         * @param {string} organizationId Organization ID
         * @param {HelmRepositoryRequest} [helmRepositoryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHelmRepository: async (organizationId: string, helmRepositoryRequest?: HelmRepositoryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createHelmRepository', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/helmRepository`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(helmRepositoryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a helm repository
         * @param {string} organizationId Organization ID
         * @param {string} helmRepositoryId Helm chart repository ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHelmRepository: async (organizationId: string, helmRepositoryId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteHelmRepository', 'organizationId', organizationId)
            // verify required parameter 'helmRepositoryId' is not null or undefined
            assertParamExists('deleteHelmRepository', 'helmRepositoryId', helmRepositoryId)
            const localVarPath = `/organization/{organizationId}/helmRepository/{helmRepositoryId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"helmRepositoryId"}}`, encodeURIComponent(String(helmRepositoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a helm repository
         * @param {string} organizationId Organization ID
         * @param {string} helmRepositoryId Helm chart repository ID
         * @param {HelmRepositoryRequest} [helmRepositoryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editHelmRepository: async (organizationId: string, helmRepositoryId: string, helmRepositoryRequest?: HelmRepositoryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('editHelmRepository', 'organizationId', organizationId)
            // verify required parameter 'helmRepositoryId' is not null or undefined
            assertParamExists('editHelmRepository', 'helmRepositoryId', helmRepositoryId)
            const localVarPath = `/organization/{organizationId}/helmRepository/{helmRepositoryId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"helmRepositoryId"}}`, encodeURIComponent(String(helmRepositoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(helmRepositoryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List helm charts contained inside the repository
         * @param {string} organizationId Organization ID
         * @param {string} helmRepositoryId Helm chart repository ID
         * @param {string} [chartName] Helm chart name to filter the result on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHelmCharts: async (organizationId: string, helmRepositoryId: string, chartName?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getHelmCharts', 'organizationId', organizationId)
            // verify required parameter 'helmRepositoryId' is not null or undefined
            assertParamExists('getHelmCharts', 'helmRepositoryId', helmRepositoryId)
            const localVarPath = `/organization/{organizationId}/helmRepository/{helmRepositoryId}/charts`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"helmRepositoryId"}}`, encodeURIComponent(String(helmRepositoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (chartName !== undefined) {
                localVarQueryParameter['chartName'] = chartName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a helm repository
         * @param {string} organizationId Organization ID
         * @param {string} helmRepositoryId Helm chart repository ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHelmRepository: async (organizationId: string, helmRepositoryId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getHelmRepository', 'organizationId', organizationId)
            // verify required parameter 'helmRepositoryId' is not null or undefined
            assertParamExists('getHelmRepository', 'helmRepositoryId', helmRepositoryId)
            const localVarPath = `/organization/{organizationId}/helmRepository/{helmRepositoryId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"helmRepositoryId"}}`, encodeURIComponent(String(helmRepositoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List supported helm repository by Qovery and get the mandatory authentification configuration.
         * @summary List supported helm repository
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAvailableHelmRepository: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/availableHelmRepository`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List organization helm repositories
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHelmRepository: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listHelmRepository', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/helmRepository`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HelmRepositoriesApi - functional programming interface
 * @export
 */
export const HelmRepositoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HelmRepositoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a helm repository
         * @param {string} organizationId Organization ID
         * @param {HelmRepositoryRequest} [helmRepositoryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createHelmRepository(organizationId: string, helmRepositoryRequest?: HelmRepositoryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HelmRepositoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createHelmRepository(organizationId, helmRepositoryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a helm repository
         * @param {string} organizationId Organization ID
         * @param {string} helmRepositoryId Helm chart repository ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteHelmRepository(organizationId: string, helmRepositoryId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteHelmRepository(organizationId, helmRepositoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit a helm repository
         * @param {string} organizationId Organization ID
         * @param {string} helmRepositoryId Helm chart repository ID
         * @param {HelmRepositoryRequest} [helmRepositoryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editHelmRepository(organizationId: string, helmRepositoryId: string, helmRepositoryRequest?: HelmRepositoryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HelmRepositoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editHelmRepository(organizationId, helmRepositoryId, helmRepositoryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List helm charts contained inside the repository
         * @param {string} organizationId Organization ID
         * @param {string} helmRepositoryId Helm chart repository ID
         * @param {string} [chartName] Helm chart name to filter the result on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHelmCharts(organizationId: string, helmRepositoryId: string, chartName?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HelmVersionResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHelmCharts(organizationId, helmRepositoryId, chartName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a helm repository
         * @param {string} organizationId Organization ID
         * @param {string} helmRepositoryId Helm chart repository ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHelmRepository(organizationId: string, helmRepositoryId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HelmRepositoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHelmRepository(organizationId, helmRepositoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List supported helm repository by Qovery and get the mandatory authentification configuration.
         * @summary List supported helm repository
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAvailableHelmRepository(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AvailableHelmRepositoryResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAvailableHelmRepository(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List organization helm repositories
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listHelmRepository(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HelmRepositoryResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listHelmRepository(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HelmRepositoriesApi - factory interface
 * @export
 */
export const HelmRepositoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HelmRepositoriesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a helm repository
         * @param {string} organizationId Organization ID
         * @param {HelmRepositoryRequest} [helmRepositoryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHelmRepository(organizationId: string, helmRepositoryRequest?: HelmRepositoryRequest, options?: any): AxiosPromise<HelmRepositoryResponse> {
            return localVarFp.createHelmRepository(organizationId, helmRepositoryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a helm repository
         * @param {string} organizationId Organization ID
         * @param {string} helmRepositoryId Helm chart repository ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHelmRepository(organizationId: string, helmRepositoryId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteHelmRepository(organizationId, helmRepositoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a helm repository
         * @param {string} organizationId Organization ID
         * @param {string} helmRepositoryId Helm chart repository ID
         * @param {HelmRepositoryRequest} [helmRepositoryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editHelmRepository(organizationId: string, helmRepositoryId: string, helmRepositoryRequest?: HelmRepositoryRequest, options?: any): AxiosPromise<HelmRepositoryResponse> {
            return localVarFp.editHelmRepository(organizationId, helmRepositoryId, helmRepositoryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List helm charts contained inside the repository
         * @param {string} organizationId Organization ID
         * @param {string} helmRepositoryId Helm chart repository ID
         * @param {string} [chartName] Helm chart name to filter the result on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHelmCharts(organizationId: string, helmRepositoryId: string, chartName?: string, options?: any): AxiosPromise<HelmVersionResponseList> {
            return localVarFp.getHelmCharts(organizationId, helmRepositoryId, chartName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a helm repository
         * @param {string} organizationId Organization ID
         * @param {string} helmRepositoryId Helm chart repository ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHelmRepository(organizationId: string, helmRepositoryId: string, options?: any): AxiosPromise<HelmRepositoryResponse> {
            return localVarFp.getHelmRepository(organizationId, helmRepositoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * List supported helm repository by Qovery and get the mandatory authentification configuration.
         * @summary List supported helm repository
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAvailableHelmRepository(options?: any): AxiosPromise<AvailableHelmRepositoryResponseList> {
            return localVarFp.listAvailableHelmRepository(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List organization helm repositories
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHelmRepository(organizationId: string, options?: any): AxiosPromise<HelmRepositoryResponseList> {
            return localVarFp.listHelmRepository(organizationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HelmRepositoriesApi - object-oriented interface
 * @export
 * @class HelmRepositoriesApi
 * @extends {BaseAPI}
 */
export class HelmRepositoriesApi extends BaseAPI {
    /**
     * 
     * @summary Create a helm repository
     * @param {string} organizationId Organization ID
     * @param {HelmRepositoryRequest} [helmRepositoryRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmRepositoriesApi
     */
    public createHelmRepository(organizationId: string, helmRepositoryRequest?: HelmRepositoryRequest, options?: AxiosRequestConfig) {
        return HelmRepositoriesApiFp(this.configuration).createHelmRepository(organizationId, helmRepositoryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a helm repository
     * @param {string} organizationId Organization ID
     * @param {string} helmRepositoryId Helm chart repository ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmRepositoriesApi
     */
    public deleteHelmRepository(organizationId: string, helmRepositoryId: string, options?: AxiosRequestConfig) {
        return HelmRepositoriesApiFp(this.configuration).deleteHelmRepository(organizationId, helmRepositoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a helm repository
     * @param {string} organizationId Organization ID
     * @param {string} helmRepositoryId Helm chart repository ID
     * @param {HelmRepositoryRequest} [helmRepositoryRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmRepositoriesApi
     */
    public editHelmRepository(organizationId: string, helmRepositoryId: string, helmRepositoryRequest?: HelmRepositoryRequest, options?: AxiosRequestConfig) {
        return HelmRepositoriesApiFp(this.configuration).editHelmRepository(organizationId, helmRepositoryId, helmRepositoryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List helm charts contained inside the repository
     * @param {string} organizationId Organization ID
     * @param {string} helmRepositoryId Helm chart repository ID
     * @param {string} [chartName] Helm chart name to filter the result on
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmRepositoriesApi
     */
    public getHelmCharts(organizationId: string, helmRepositoryId: string, chartName?: string, options?: AxiosRequestConfig) {
        return HelmRepositoriesApiFp(this.configuration).getHelmCharts(organizationId, helmRepositoryId, chartName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a helm repository
     * @param {string} organizationId Organization ID
     * @param {string} helmRepositoryId Helm chart repository ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmRepositoriesApi
     */
    public getHelmRepository(organizationId: string, helmRepositoryId: string, options?: AxiosRequestConfig) {
        return HelmRepositoriesApiFp(this.configuration).getHelmRepository(organizationId, helmRepositoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List supported helm repository by Qovery and get the mandatory authentification configuration.
     * @summary List supported helm repository
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmRepositoriesApi
     */
    public listAvailableHelmRepository(options?: AxiosRequestConfig) {
        return HelmRepositoriesApiFp(this.configuration).listAvailableHelmRepository(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List organization helm repositories
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmRepositoriesApi
     */
    public listHelmRepository(organizationId: string, options?: AxiosRequestConfig) {
        return HelmRepositoriesApiFp(this.configuration).listHelmRepository(organizationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HelmsApi - axios parameter creator
 * @export
 */
export const HelmsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This will create a new helm with the same configuration on the targeted environment Id.
         * @summary Clone helm
         * @param {string} helmId Helm ID
         * @param {CloneServiceRequest} [cloneServiceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneHelm: async (helmId: string, cloneServiceRequest?: CloneServiceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'helmId' is not null or undefined
            assertParamExists('cloneHelm', 'helmId', helmId)
            const localVarPath = `/helm/{helmId}/clone`
                .replace(`{${"helmId"}}`, encodeURIComponent(String(helmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloneServiceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a helm
         * @param {string} environmentId Environment ID
         * @param {HelmRequest} [helmRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHelm: async (environmentId: string, helmRequest?: HelmRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('createHelm', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/helm`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(helmRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get helm default values
         * @param {string} environmentId Environment ID
         * @param {HelmDefaultValuesRequest} [helmDefaultValuesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHelmDefaultValues: async (environmentId: string, helmDefaultValuesRequest?: HelmDefaultValuesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('createHelmDefaultValues', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/helmDefaultValues`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(helmDefaultValuesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List default helm advanced settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultHelmAdvancedSettings: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/defaultHelmAdvancedSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of helms with only their id and status.
         * @summary List all environment helm statuses
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentHelmStatus: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('getEnvironmentHelmStatus', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/helm/status`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List helms
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHelms: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('listHelms', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/helm`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HelmsApi - functional programming interface
 * @export
 */
export const HelmsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HelmsApiAxiosParamCreator(configuration)
    return {
        /**
         * This will create a new helm with the same configuration on the targeted environment Id.
         * @summary Clone helm
         * @param {string} helmId Helm ID
         * @param {CloneServiceRequest} [cloneServiceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloneHelm(helmId: string, cloneServiceRequest?: CloneServiceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HelmResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cloneHelm(helmId, cloneServiceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a helm
         * @param {string} environmentId Environment ID
         * @param {HelmRequest} [helmRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createHelm(environmentId: string, helmRequest?: HelmRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HelmResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createHelm(environmentId, helmRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get helm default values
         * @param {string} environmentId Environment ID
         * @param {HelmDefaultValuesRequest} [helmDefaultValuesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createHelmDefaultValues(environmentId: string, helmDefaultValuesRequest?: HelmDefaultValuesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createHelmDefaultValues(environmentId, helmDefaultValuesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List default helm advanced settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDefaultHelmAdvancedSettings(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HelmAdvancedSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDefaultHelmAdvancedSettings(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of helms with only their id and status.
         * @summary List all environment helm statuses
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironmentHelmStatus(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReferenceObjectStatusResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironmentHelmStatus(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List helms
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listHelms(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HelmResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listHelms(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HelmsApi - factory interface
 * @export
 */
export const HelmsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HelmsApiFp(configuration)
    return {
        /**
         * This will create a new helm with the same configuration on the targeted environment Id.
         * @summary Clone helm
         * @param {string} helmId Helm ID
         * @param {CloneServiceRequest} [cloneServiceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneHelm(helmId: string, cloneServiceRequest?: CloneServiceRequest, options?: any): AxiosPromise<HelmResponse> {
            return localVarFp.cloneHelm(helmId, cloneServiceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a helm
         * @param {string} environmentId Environment ID
         * @param {HelmRequest} [helmRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHelm(environmentId: string, helmRequest?: HelmRequest, options?: any): AxiosPromise<HelmResponse> {
            return localVarFp.createHelm(environmentId, helmRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get helm default values
         * @param {string} environmentId Environment ID
         * @param {HelmDefaultValuesRequest} [helmDefaultValuesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHelmDefaultValues(environmentId: string, helmDefaultValuesRequest?: HelmDefaultValuesRequest, options?: any): AxiosPromise<string> {
            return localVarFp.createHelmDefaultValues(environmentId, helmDefaultValuesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List default helm advanced settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultHelmAdvancedSettings(options?: any): AxiosPromise<HelmAdvancedSettings> {
            return localVarFp.getDefaultHelmAdvancedSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of helms with only their id and status.
         * @summary List all environment helm statuses
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentHelmStatus(environmentId: string, options?: any): AxiosPromise<ReferenceObjectStatusResponseList> {
            return localVarFp.getEnvironmentHelmStatus(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List helms
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHelms(environmentId: string, options?: any): AxiosPromise<HelmResponseList> {
            return localVarFp.listHelms(environmentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HelmsApi - object-oriented interface
 * @export
 * @class HelmsApi
 * @extends {BaseAPI}
 */
export class HelmsApi extends BaseAPI {
    /**
     * This will create a new helm with the same configuration on the targeted environment Id.
     * @summary Clone helm
     * @param {string} helmId Helm ID
     * @param {CloneServiceRequest} [cloneServiceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmsApi
     */
    public cloneHelm(helmId: string, cloneServiceRequest?: CloneServiceRequest, options?: AxiosRequestConfig) {
        return HelmsApiFp(this.configuration).cloneHelm(helmId, cloneServiceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a helm
     * @param {string} environmentId Environment ID
     * @param {HelmRequest} [helmRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmsApi
     */
    public createHelm(environmentId: string, helmRequest?: HelmRequest, options?: AxiosRequestConfig) {
        return HelmsApiFp(this.configuration).createHelm(environmentId, helmRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get helm default values
     * @param {string} environmentId Environment ID
     * @param {HelmDefaultValuesRequest} [helmDefaultValuesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmsApi
     */
    public createHelmDefaultValues(environmentId: string, helmDefaultValuesRequest?: HelmDefaultValuesRequest, options?: AxiosRequestConfig) {
        return HelmsApiFp(this.configuration).createHelmDefaultValues(environmentId, helmDefaultValuesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List default helm advanced settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmsApi
     */
    public getDefaultHelmAdvancedSettings(options?: AxiosRequestConfig) {
        return HelmsApiFp(this.configuration).getDefaultHelmAdvancedSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of helms with only their id and status.
     * @summary List all environment helm statuses
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmsApi
     */
    public getEnvironmentHelmStatus(environmentId: string, options?: AxiosRequestConfig) {
        return HelmsApiFp(this.configuration).getEnvironmentHelmStatus(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List helms
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmsApi
     */
    public listHelms(environmentId: string, options?: AxiosRequestConfig) {
        return HelmsApiFp(this.configuration).listHelms(environmentId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * JobActionsApi - axios parameter creator
 * @export
 */
export const JobActionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Clean a failed job
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cleanFailedJob: async (jobId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('cleanFailedJob', 'jobId', jobId)
            const localVarPath = `/job/{jobId}/cleanFailedJob`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You must provide a git commit id or an image tag depending on the source location of your code (git vs image repository).
         * @summary Deploy job
         * @param {string} jobId Job ID
         * @param {JobForceEvent} [forceEvent] When filled, it indicates the target event to be deployed.   If the concerned job hasn\&#39;t the target event provided, the job won\&#39;t be deployed. 
         * @param {JobDeployRequest} [jobDeployRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployJob: async (jobId: string, forceEvent?: JobForceEvent, jobDeployRequest?: JobDeployRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('deployJob', 'jobId', jobId)
            const localVarPath = `/job/{jobId}/deploy`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (forceEvent !== undefined) {
                localVarQueryParameter['forceEvent'] = forceEvent;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jobDeployRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Redeploy job
         * @param {string} jobId Job ID
         * @param {JobForceEvent} [forceEvent] When filled, it indicates the target event to be deployed.   If the concerned job hasn\&#39;t the target event provided, the job won\&#39;t be deployed. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeployJob: async (jobId: string, forceEvent?: JobForceEvent, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('redeployJob', 'jobId', jobId)
            const localVarPath = `/job/{jobId}/redeploy`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (forceEvent !== undefined) {
                localVarQueryParameter['forceEvent'] = forceEvent;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop job
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopJob: async (jobId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('stopJob', 'jobId', jobId)
            const localVarPath = `/job/{jobId}/stop`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobActionsApi - functional programming interface
 * @export
 */
export const JobActionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JobActionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Clean a failed job
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cleanFailedJob(jobId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CleanFailedJob200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cleanFailedJob(jobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * You must provide a git commit id or an image tag depending on the source location of your code (git vs image repository).
         * @summary Deploy job
         * @param {string} jobId Job ID
         * @param {JobForceEvent} [forceEvent] When filled, it indicates the target event to be deployed.   If the concerned job hasn\&#39;t the target event provided, the job won\&#39;t be deployed. 
         * @param {JobDeployRequest} [jobDeployRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployJob(jobId: string, forceEvent?: JobForceEvent, jobDeployRequest?: JobDeployRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployJob(jobId, forceEvent, jobDeployRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Redeploy job
         * @param {string} jobId Job ID
         * @param {JobForceEvent} [forceEvent] When filled, it indicates the target event to be deployed.   If the concerned job hasn\&#39;t the target event provided, the job won\&#39;t be deployed. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async redeployJob(jobId: string, forceEvent?: JobForceEvent, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.redeployJob(jobId, forceEvent, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Stop job
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopJob(jobId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopJob(jobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * JobActionsApi - factory interface
 * @export
 */
export const JobActionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JobActionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Clean a failed job
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cleanFailedJob(jobId: string, options?: any): AxiosPromise<CleanFailedJob200Response> {
            return localVarFp.cleanFailedJob(jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * You must provide a git commit id or an image tag depending on the source location of your code (git vs image repository).
         * @summary Deploy job
         * @param {string} jobId Job ID
         * @param {JobForceEvent} [forceEvent] When filled, it indicates the target event to be deployed.   If the concerned job hasn\&#39;t the target event provided, the job won\&#39;t be deployed. 
         * @param {JobDeployRequest} [jobDeployRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployJob(jobId: string, forceEvent?: JobForceEvent, jobDeployRequest?: JobDeployRequest, options?: any): AxiosPromise<Status> {
            return localVarFp.deployJob(jobId, forceEvent, jobDeployRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Redeploy job
         * @param {string} jobId Job ID
         * @param {JobForceEvent} [forceEvent] When filled, it indicates the target event to be deployed.   If the concerned job hasn\&#39;t the target event provided, the job won\&#39;t be deployed. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeployJob(jobId: string, forceEvent?: JobForceEvent, options?: any): AxiosPromise<Status> {
            return localVarFp.redeployJob(jobId, forceEvent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Stop job
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopJob(jobId: string, options?: any): AxiosPromise<Status> {
            return localVarFp.stopJob(jobId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JobActionsApi - object-oriented interface
 * @export
 * @class JobActionsApi
 * @extends {BaseAPI}
 */
export class JobActionsApi extends BaseAPI {
    /**
     * 
     * @summary Clean a failed job
     * @param {string} jobId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobActionsApi
     */
    public cleanFailedJob(jobId: string, options?: AxiosRequestConfig) {
        return JobActionsApiFp(this.configuration).cleanFailedJob(jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You must provide a git commit id or an image tag depending on the source location of your code (git vs image repository).
     * @summary Deploy job
     * @param {string} jobId Job ID
     * @param {JobForceEvent} [forceEvent] When filled, it indicates the target event to be deployed.   If the concerned job hasn\&#39;t the target event provided, the job won\&#39;t be deployed. 
     * @param {JobDeployRequest} [jobDeployRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobActionsApi
     */
    public deployJob(jobId: string, forceEvent?: JobForceEvent, jobDeployRequest?: JobDeployRequest, options?: AxiosRequestConfig) {
        return JobActionsApiFp(this.configuration).deployJob(jobId, forceEvent, jobDeployRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Redeploy job
     * @param {string} jobId Job ID
     * @param {JobForceEvent} [forceEvent] When filled, it indicates the target event to be deployed.   If the concerned job hasn\&#39;t the target event provided, the job won\&#39;t be deployed. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobActionsApi
     */
    public redeployJob(jobId: string, forceEvent?: JobForceEvent, options?: AxiosRequestConfig) {
        return JobActionsApiFp(this.configuration).redeployJob(jobId, forceEvent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Stop job
     * @param {string} jobId Job ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobActionsApi
     */
    public stopJob(jobId: string, options?: AxiosRequestConfig) {
        return JobActionsApiFp(this.configuration).stopJob(jobId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * JobConfigurationApi - axios parameter creator
 * @export
 */
export const JobConfigurationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Edit advanced settings by returning table of advanced settings.
         * @summary Edit advanced settings
         * @param {string} jobId Job ID
         * @param {JobAdvancedSettings} [jobAdvancedSettings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editJobAdvancedSettings: async (jobId: string, jobAdvancedSettings?: JobAdvancedSettings, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('editJobAdvancedSettings', 'jobId', jobId)
            const localVarPath = `/job/{jobId}/advancedSettings`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jobAdvancedSettings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list and values of the advanced settings of the job. Default values for each setting are available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/advanced-settings/) 
         * @summary Get advanced settings
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobAdvancedSettings: async (jobId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getJobAdvancedSettings', 'jobId', jobId)
            const localVarPath = `/job/{jobId}/advancedSettings`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobConfigurationApi - functional programming interface
 * @export
 */
export const JobConfigurationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JobConfigurationApiAxiosParamCreator(configuration)
    return {
        /**
         * Edit advanced settings by returning table of advanced settings.
         * @summary Edit advanced settings
         * @param {string} jobId Job ID
         * @param {JobAdvancedSettings} [jobAdvancedSettings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editJobAdvancedSettings(jobId: string, jobAdvancedSettings?: JobAdvancedSettings, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobAdvancedSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editJobAdvancedSettings(jobId, jobAdvancedSettings, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get list and values of the advanced settings of the job. Default values for each setting are available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/advanced-settings/) 
         * @summary Get advanced settings
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobAdvancedSettings(jobId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobAdvancedSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobAdvancedSettings(jobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * JobConfigurationApi - factory interface
 * @export
 */
export const JobConfigurationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JobConfigurationApiFp(configuration)
    return {
        /**
         * Edit advanced settings by returning table of advanced settings.
         * @summary Edit advanced settings
         * @param {string} jobId Job ID
         * @param {JobAdvancedSettings} [jobAdvancedSettings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editJobAdvancedSettings(jobId: string, jobAdvancedSettings?: JobAdvancedSettings, options?: any): AxiosPromise<JobAdvancedSettings> {
            return localVarFp.editJobAdvancedSettings(jobId, jobAdvancedSettings, options).then((request) => request(axios, basePath));
        },
        /**
         * Get list and values of the advanced settings of the job. Default values for each setting are available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/advanced-settings/) 
         * @summary Get advanced settings
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobAdvancedSettings(jobId: string, options?: any): AxiosPromise<JobAdvancedSettings> {
            return localVarFp.getJobAdvancedSettings(jobId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JobConfigurationApi - object-oriented interface
 * @export
 * @class JobConfigurationApi
 * @extends {BaseAPI}
 */
export class JobConfigurationApi extends BaseAPI {
    /**
     * Edit advanced settings by returning table of advanced settings.
     * @summary Edit advanced settings
     * @param {string} jobId Job ID
     * @param {JobAdvancedSettings} [jobAdvancedSettings] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobConfigurationApi
     */
    public editJobAdvancedSettings(jobId: string, jobAdvancedSettings?: JobAdvancedSettings, options?: AxiosRequestConfig) {
        return JobConfigurationApiFp(this.configuration).editJobAdvancedSettings(jobId, jobAdvancedSettings, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list and values of the advanced settings of the job. Default values for each setting are available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/advanced-settings/) 
     * @summary Get advanced settings
     * @param {string} jobId Job ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobConfigurationApi
     */
    public getJobAdvancedSettings(jobId: string, options?: AxiosRequestConfig) {
        return JobConfigurationApiFp(this.configuration).getJobAdvancedSettings(jobId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * JobDeploymentHistoryApi - axios parameter creator
 * @export
 */
export const JobDeploymentHistoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the 20 last job deployments
         * @summary List job deployments
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobDeploymentHistory: async (jobId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('listJobDeploymentHistory', 'jobId', jobId)
            const localVarPath = `/job/{jobId}/deploymentHistory`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobDeploymentHistoryApi - functional programming interface
 * @export
 */
export const JobDeploymentHistoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JobDeploymentHistoryApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the 20 last job deployments
         * @summary List job deployments
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listJobDeploymentHistory(jobId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListJobDeploymentHistory200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listJobDeploymentHistory(jobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * JobDeploymentHistoryApi - factory interface
 * @export
 */
export const JobDeploymentHistoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JobDeploymentHistoryApiFp(configuration)
    return {
        /**
         * Returns the 20 last job deployments
         * @summary List job deployments
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobDeploymentHistory(jobId: string, options?: any): AxiosPromise<ListJobDeploymentHistory200Response> {
            return localVarFp.listJobDeploymentHistory(jobId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JobDeploymentHistoryApi - object-oriented interface
 * @export
 * @class JobDeploymentHistoryApi
 * @extends {BaseAPI}
 */
export class JobDeploymentHistoryApi extends BaseAPI {
    /**
     * Returns the 20 last job deployments
     * @summary List job deployments
     * @param {string} jobId Job ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobDeploymentHistoryApi
     */
    public listJobDeploymentHistory(jobId: string, options?: AxiosRequestConfig) {
        return JobDeploymentHistoryApiFp(this.configuration).listJobDeploymentHistory(jobId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * JobDeploymentRestrictionApi - axios parameter creator
 * @export
 */
export const JobDeploymentRestrictionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a job deployment restriction
         * @summary Create a job deployment restriction
         * @param {string} jobId Job ID
         * @param {JobDeploymentRestrictionRequest} [jobDeploymentRestrictionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJobDeploymentRestriction: async (jobId: string, jobDeploymentRestrictionRequest?: JobDeploymentRestrictionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('createJobDeploymentRestriction', 'jobId', jobId)
            const localVarPath = `/job/{jobId}/deploymentRestriction`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jobDeploymentRestrictionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a job deployment restriction
         * @summary Delete a job deployment restriction
         * @param {string} jobId Job ID
         * @param {string} deploymentRestrictionId Deployment Restriction ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJobDeploymentRestriction: async (jobId: string, deploymentRestrictionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('deleteJobDeploymentRestriction', 'jobId', jobId)
            // verify required parameter 'deploymentRestrictionId' is not null or undefined
            assertParamExists('deleteJobDeploymentRestriction', 'deploymentRestrictionId', deploymentRestrictionId)
            const localVarPath = `/job/{jobId}/deploymentRestriction/{deploymentRestrictionId}`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)))
                .replace(`{${"deploymentRestrictionId"}}`, encodeURIComponent(String(deploymentRestrictionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit a job deployment restriction
         * @summary Edit a job deployment restriction
         * @param {string} jobId Job ID
         * @param {string} deploymentRestrictionId Deployment Restriction ID
         * @param {JobDeploymentRestrictionRequest} [jobDeploymentRestrictionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editJobDeploymentRestriction: async (jobId: string, deploymentRestrictionId: string, jobDeploymentRestrictionRequest?: JobDeploymentRestrictionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('editJobDeploymentRestriction', 'jobId', jobId)
            // verify required parameter 'deploymentRestrictionId' is not null or undefined
            assertParamExists('editJobDeploymentRestriction', 'deploymentRestrictionId', deploymentRestrictionId)
            const localVarPath = `/job/{jobId}/deploymentRestriction/{deploymentRestrictionId}`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)))
                .replace(`{${"deploymentRestrictionId"}}`, encodeURIComponent(String(deploymentRestrictionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jobDeploymentRestrictionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get job deployment restrictions
         * @summary Get job deployment restrictions
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobDeploymentRestrictions: async (jobId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getJobDeploymentRestrictions', 'jobId', jobId)
            const localVarPath = `/job/{jobId}/deploymentRestriction`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobDeploymentRestrictionApi - functional programming interface
 * @export
 */
export const JobDeploymentRestrictionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JobDeploymentRestrictionApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a job deployment restriction
         * @summary Create a job deployment restriction
         * @param {string} jobId Job ID
         * @param {JobDeploymentRestrictionRequest} [jobDeploymentRestrictionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createJobDeploymentRestriction(jobId: string, jobDeploymentRestrictionRequest?: JobDeploymentRestrictionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobDeploymentRestrictionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createJobDeploymentRestriction(jobId, jobDeploymentRestrictionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a job deployment restriction
         * @summary Delete a job deployment restriction
         * @param {string} jobId Job ID
         * @param {string} deploymentRestrictionId Deployment Restriction ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteJobDeploymentRestriction(jobId: string, deploymentRestrictionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteJobDeploymentRestriction(jobId, deploymentRestrictionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Edit a job deployment restriction
         * @summary Edit a job deployment restriction
         * @param {string} jobId Job ID
         * @param {string} deploymentRestrictionId Deployment Restriction ID
         * @param {JobDeploymentRestrictionRequest} [jobDeploymentRestrictionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editJobDeploymentRestriction(jobId: string, deploymentRestrictionId: string, jobDeploymentRestrictionRequest?: JobDeploymentRestrictionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobDeploymentRestrictionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editJobDeploymentRestriction(jobId, deploymentRestrictionId, jobDeploymentRestrictionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get job deployment restrictions
         * @summary Get job deployment restrictions
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobDeploymentRestrictions(jobId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobDeploymentRestrictionResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobDeploymentRestrictions(jobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * JobDeploymentRestrictionApi - factory interface
 * @export
 */
export const JobDeploymentRestrictionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JobDeploymentRestrictionApiFp(configuration)
    return {
        /**
         * Create a job deployment restriction
         * @summary Create a job deployment restriction
         * @param {string} jobId Job ID
         * @param {JobDeploymentRestrictionRequest} [jobDeploymentRestrictionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJobDeploymentRestriction(jobId: string, jobDeploymentRestrictionRequest?: JobDeploymentRestrictionRequest, options?: any): AxiosPromise<JobDeploymentRestrictionResponse> {
            return localVarFp.createJobDeploymentRestriction(jobId, jobDeploymentRestrictionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a job deployment restriction
         * @summary Delete a job deployment restriction
         * @param {string} jobId Job ID
         * @param {string} deploymentRestrictionId Deployment Restriction ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJobDeploymentRestriction(jobId: string, deploymentRestrictionId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteJobDeploymentRestriction(jobId, deploymentRestrictionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit a job deployment restriction
         * @summary Edit a job deployment restriction
         * @param {string} jobId Job ID
         * @param {string} deploymentRestrictionId Deployment Restriction ID
         * @param {JobDeploymentRestrictionRequest} [jobDeploymentRestrictionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editJobDeploymentRestriction(jobId: string, deploymentRestrictionId: string, jobDeploymentRestrictionRequest?: JobDeploymentRestrictionRequest, options?: any): AxiosPromise<JobDeploymentRestrictionResponse> {
            return localVarFp.editJobDeploymentRestriction(jobId, deploymentRestrictionId, jobDeploymentRestrictionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get job deployment restrictions
         * @summary Get job deployment restrictions
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobDeploymentRestrictions(jobId: string, options?: any): AxiosPromise<JobDeploymentRestrictionResponseList> {
            return localVarFp.getJobDeploymentRestrictions(jobId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JobDeploymentRestrictionApi - object-oriented interface
 * @export
 * @class JobDeploymentRestrictionApi
 * @extends {BaseAPI}
 */
export class JobDeploymentRestrictionApi extends BaseAPI {
    /**
     * Create a job deployment restriction
     * @summary Create a job deployment restriction
     * @param {string} jobId Job ID
     * @param {JobDeploymentRestrictionRequest} [jobDeploymentRestrictionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobDeploymentRestrictionApi
     */
    public createJobDeploymentRestriction(jobId: string, jobDeploymentRestrictionRequest?: JobDeploymentRestrictionRequest, options?: AxiosRequestConfig) {
        return JobDeploymentRestrictionApiFp(this.configuration).createJobDeploymentRestriction(jobId, jobDeploymentRestrictionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a job deployment restriction
     * @summary Delete a job deployment restriction
     * @param {string} jobId Job ID
     * @param {string} deploymentRestrictionId Deployment Restriction ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobDeploymentRestrictionApi
     */
    public deleteJobDeploymentRestriction(jobId: string, deploymentRestrictionId: string, options?: AxiosRequestConfig) {
        return JobDeploymentRestrictionApiFp(this.configuration).deleteJobDeploymentRestriction(jobId, deploymentRestrictionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit a job deployment restriction
     * @summary Edit a job deployment restriction
     * @param {string} jobId Job ID
     * @param {string} deploymentRestrictionId Deployment Restriction ID
     * @param {JobDeploymentRestrictionRequest} [jobDeploymentRestrictionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobDeploymentRestrictionApi
     */
    public editJobDeploymentRestriction(jobId: string, deploymentRestrictionId: string, jobDeploymentRestrictionRequest?: JobDeploymentRestrictionRequest, options?: AxiosRequestConfig) {
        return JobDeploymentRestrictionApiFp(this.configuration).editJobDeploymentRestriction(jobId, deploymentRestrictionId, jobDeploymentRestrictionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get job deployment restrictions
     * @summary Get job deployment restrictions
     * @param {string} jobId Job ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobDeploymentRestrictionApi
     */
    public getJobDeploymentRestrictions(jobId: string, options?: AxiosRequestConfig) {
        return JobDeploymentRestrictionApiFp(this.configuration).getJobDeploymentRestrictions(jobId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * JobEnvironmentVariableApi - axios parameter creator
 * @export
 */
export const JobEnvironmentVariableApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * - Add an environment variable to the job. 
         * @summary Add an environment variable to the job
         * @param {string} jobId Job ID
         * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJobEnvironmentVariable: async (jobId: string, environmentVariableRequest?: EnvironmentVariableRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('createJobEnvironmentVariable', 'jobId', jobId)
            const localVarPath = `/job/{jobId}/environmentVariable`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentVariableRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to add an alias at job level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at job level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - You can\'t create an alias on an alias 
         * @summary Create an environment variable alias at the job level
         * @param {string} jobId Job ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJobEnvironmentVariableAlias: async (jobId: string, environmentVariableId: string, key?: Key, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('createJobEnvironmentVariableAlias', 'jobId', jobId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('createJobEnvironmentVariableAlias', 'environmentVariableId', environmentVariableId)
            const localVarPath = `/job/{jobId}/environmentVariable/{environmentVariableId}/alias`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(key, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to override at job level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at job level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
         * @summary Create an environment variable override at the job level
         * @param {string} jobId Job ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJobEnvironmentVariableOverride: async (jobId: string, environmentVariableId: string, value?: Value, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('createJobEnvironmentVariableOverride', 'jobId', jobId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('createJobEnvironmentVariableOverride', 'environmentVariableId', environmentVariableId)
            const localVarPath = `/job/{jobId}/environmentVariable/{environmentVariableId}/override`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(value, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - To delete an environment variable from an job you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete an environment variable from a job
         * @param {string} jobId Job ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJobEnvironmentVariable: async (jobId: string, environmentVariableId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('deleteJobEnvironmentVariable', 'jobId', jobId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('deleteJobEnvironmentVariable', 'environmentVariableId', environmentVariableId)
            const localVarPath = `/job/{jobId}/environmentVariable/{environmentVariableId}`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > CONTAINER) 
         * @summary Edit an environment variable belonging to the job
         * @param {string} jobId Job ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editJobEnvironmentVariable: async (jobId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('editJobEnvironmentVariable', 'jobId', jobId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('editJobEnvironmentVariable', 'environmentVariableId', environmentVariableId)
            // verify required parameter 'environmentVariableEditRequest' is not null or undefined
            assertParamExists('editJobEnvironmentVariable', 'environmentVariableEditRequest', environmentVariableEditRequest)
            const localVarPath = `/job/{jobId}/environmentVariable/{environmentVariableId}`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentVariableEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Import environment variables in a defined scope, with a defined visibility.
         * @summary Import variables
         * @param {string} jobId Job ID
         * @param {VariableImportRequest} [variableImportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importJobEnvironmentVariable: async (jobId: string, variableImportRequest?: VariableImportRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('importJobEnvironmentVariable', 'jobId', jobId)
            const localVarPath = `/job/{jobId}/environmentVariable/import`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(variableImportRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List environment variables
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobEnvironmentVariable: async (jobId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('listJobEnvironmentVariable', 'jobId', jobId)
            const localVarPath = `/job/{jobId}/environmentVariable`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobEnvironmentVariableApi - functional programming interface
 * @export
 */
export const JobEnvironmentVariableApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JobEnvironmentVariableApiAxiosParamCreator(configuration)
    return {
        /**
         * - Add an environment variable to the job. 
         * @summary Add an environment variable to the job
         * @param {string} jobId Job ID
         * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createJobEnvironmentVariable(jobId: string, environmentVariableRequest?: EnvironmentVariableRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createJobEnvironmentVariable(jobId, environmentVariableRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - Allows you to add an alias at job level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at job level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - You can\'t create an alias on an alias 
         * @summary Create an environment variable alias at the job level
         * @param {string} jobId Job ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createJobEnvironmentVariableAlias(jobId: string, environmentVariableId: string, key?: Key, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createJobEnvironmentVariableAlias(jobId, environmentVariableId, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - Allows you to override at job level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at job level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
         * @summary Create an environment variable override at the job level
         * @param {string} jobId Job ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createJobEnvironmentVariableOverride(jobId: string, environmentVariableId: string, value?: Value, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createJobEnvironmentVariableOverride(jobId, environmentVariableId, value, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - To delete an environment variable from an job you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete an environment variable from a job
         * @param {string} jobId Job ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteJobEnvironmentVariable(jobId: string, environmentVariableId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteJobEnvironmentVariable(jobId, environmentVariableId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > CONTAINER) 
         * @summary Edit an environment variable belonging to the job
         * @param {string} jobId Job ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editJobEnvironmentVariable(jobId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editJobEnvironmentVariable(jobId, environmentVariableId, environmentVariableEditRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Import environment variables in a defined scope, with a defined visibility.
         * @summary Import variables
         * @param {string} jobId Job ID
         * @param {VariableImportRequest} [variableImportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importJobEnvironmentVariable(jobId: string, variableImportRequest?: VariableImportRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariableImport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importJobEnvironmentVariable(jobId, variableImportRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List environment variables
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listJobEnvironmentVariable(jobId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariableResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listJobEnvironmentVariable(jobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * JobEnvironmentVariableApi - factory interface
 * @export
 */
export const JobEnvironmentVariableApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JobEnvironmentVariableApiFp(configuration)
    return {
        /**
         * - Add an environment variable to the job. 
         * @summary Add an environment variable to the job
         * @param {string} jobId Job ID
         * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJobEnvironmentVariable(jobId: string, environmentVariableRequest?: EnvironmentVariableRequest, options?: any): AxiosPromise<EnvironmentVariable> {
            return localVarFp.createJobEnvironmentVariable(jobId, environmentVariableRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to add an alias at job level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at job level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - You can\'t create an alias on an alias 
         * @summary Create an environment variable alias at the job level
         * @param {string} jobId Job ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJobEnvironmentVariableAlias(jobId: string, environmentVariableId: string, key?: Key, options?: any): AxiosPromise<EnvironmentVariable> {
            return localVarFp.createJobEnvironmentVariableAlias(jobId, environmentVariableId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to override at job level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at job level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
         * @summary Create an environment variable override at the job level
         * @param {string} jobId Job ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJobEnvironmentVariableOverride(jobId: string, environmentVariableId: string, value?: Value, options?: any): AxiosPromise<EnvironmentVariable> {
            return localVarFp.createJobEnvironmentVariableOverride(jobId, environmentVariableId, value, options).then((request) => request(axios, basePath));
        },
        /**
         * - To delete an environment variable from an job you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete an environment variable from a job
         * @param {string} jobId Job ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJobEnvironmentVariable(jobId: string, environmentVariableId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteJobEnvironmentVariable(jobId, environmentVariableId, options).then((request) => request(axios, basePath));
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > CONTAINER) 
         * @summary Edit an environment variable belonging to the job
         * @param {string} jobId Job ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editJobEnvironmentVariable(jobId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options?: any): AxiosPromise<EnvironmentVariable> {
            return localVarFp.editJobEnvironmentVariable(jobId, environmentVariableId, environmentVariableEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Import environment variables in a defined scope, with a defined visibility.
         * @summary Import variables
         * @param {string} jobId Job ID
         * @param {VariableImportRequest} [variableImportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importJobEnvironmentVariable(jobId: string, variableImportRequest?: VariableImportRequest, options?: any): AxiosPromise<VariableImport> {
            return localVarFp.importJobEnvironmentVariable(jobId, variableImportRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List environment variables
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobEnvironmentVariable(jobId: string, options?: any): AxiosPromise<EnvironmentVariableResponseList> {
            return localVarFp.listJobEnvironmentVariable(jobId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JobEnvironmentVariableApi - object-oriented interface
 * @export
 * @class JobEnvironmentVariableApi
 * @extends {BaseAPI}
 */
export class JobEnvironmentVariableApi extends BaseAPI {
    /**
     * - Add an environment variable to the job. 
     * @summary Add an environment variable to the job
     * @param {string} jobId Job ID
     * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobEnvironmentVariableApi
     */
    public createJobEnvironmentVariable(jobId: string, environmentVariableRequest?: EnvironmentVariableRequest, options?: AxiosRequestConfig) {
        return JobEnvironmentVariableApiFp(this.configuration).createJobEnvironmentVariable(jobId, environmentVariableRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to add an alias at job level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at job level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - You can\'t create an alias on an alias 
     * @summary Create an environment variable alias at the job level
     * @param {string} jobId Job ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {Key} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobEnvironmentVariableApi
     */
    public createJobEnvironmentVariableAlias(jobId: string, environmentVariableId: string, key?: Key, options?: AxiosRequestConfig) {
        return JobEnvironmentVariableApiFp(this.configuration).createJobEnvironmentVariableAlias(jobId, environmentVariableId, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to override at job level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at job level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
     * @summary Create an environment variable override at the job level
     * @param {string} jobId Job ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {Value} [value] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobEnvironmentVariableApi
     */
    public createJobEnvironmentVariableOverride(jobId: string, environmentVariableId: string, value?: Value, options?: AxiosRequestConfig) {
        return JobEnvironmentVariableApiFp(this.configuration).createJobEnvironmentVariableOverride(jobId, environmentVariableId, value, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - To delete an environment variable from an job you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
     * @summary Delete an environment variable from a job
     * @param {string} jobId Job ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobEnvironmentVariableApi
     */
    public deleteJobEnvironmentVariable(jobId: string, environmentVariableId: string, options?: AxiosRequestConfig) {
        return JobEnvironmentVariableApiFp(this.configuration).deleteJobEnvironmentVariable(jobId, environmentVariableId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > CONTAINER) 
     * @summary Edit an environment variable belonging to the job
     * @param {string} jobId Job ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobEnvironmentVariableApi
     */
    public editJobEnvironmentVariable(jobId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options?: AxiosRequestConfig) {
        return JobEnvironmentVariableApiFp(this.configuration).editJobEnvironmentVariable(jobId, environmentVariableId, environmentVariableEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Import environment variables in a defined scope, with a defined visibility.
     * @summary Import variables
     * @param {string} jobId Job ID
     * @param {VariableImportRequest} [variableImportRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobEnvironmentVariableApi
     */
    public importJobEnvironmentVariable(jobId: string, variableImportRequest?: VariableImportRequest, options?: AxiosRequestConfig) {
        return JobEnvironmentVariableApiFp(this.configuration).importJobEnvironmentVariable(jobId, variableImportRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List environment variables
     * @param {string} jobId Job ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobEnvironmentVariableApi
     */
    public listJobEnvironmentVariable(jobId: string, options?: AxiosRequestConfig) {
        return JobEnvironmentVariableApiFp(this.configuration).listJobEnvironmentVariable(jobId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * JobMainCallsApi - axios parameter creator
 * @export
 */
export const JobMainCallsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * To delete the job you must have the admin permission
         * @summary Delete job
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJob: async (jobId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('deleteJob', 'jobId', jobId)
            const localVarPath = `/job/{jobId}`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - To edit the job you must have the admin permission. 
         * @summary Edit job
         * @param {string} jobId Job ID
         * @param {JobRequest} [jobRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editJob: async (jobId: string, jobRequest?: JobRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('editJob', 'jobId', jobId)
            const localVarPath = `/job/{jobId}`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jobRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get job by ID
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJob: async (jobId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getJob', 'jobId', jobId)
            const localVarPath = `/job/{jobId}`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get job status
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobStatus: async (jobId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getJobStatus', 'jobId', jobId)
            const localVarPath = `/job/{jobId}/status`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns list of the last 100 commits made on the repository linked to the job
         * @summary List last job commits
         * @param {string} jobId Job ID
         * @param {string} [startId] Starting point after which to return results
         * @param {string} [gitCommitId] Git Commit ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobCommit: async (jobId: string, startId?: string, gitCommitId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('listJobCommit', 'jobId', jobId)
            const localVarPath = `/job/{jobId}/commit`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (startId !== undefined) {
                localVarQueryParameter['startId'] = startId;
            }

            if (gitCommitId !== undefined) {
                localVarQueryParameter['gitCommitId'] = gitCommitId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobMainCallsApi - functional programming interface
 * @export
 */
export const JobMainCallsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JobMainCallsApiAxiosParamCreator(configuration)
    return {
        /**
         * To delete the job you must have the admin permission
         * @summary Delete job
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteJob(jobId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteJob(jobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - To edit the job you must have the admin permission. 
         * @summary Edit job
         * @param {string} jobId Job ID
         * @param {JobRequest} [jobRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editJob(jobId: string, jobRequest?: JobRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editJob(jobId, jobRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get job by ID
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJob(jobId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJob(jobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get job status
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobStatus(jobId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobStatus(jobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns list of the last 100 commits made on the repository linked to the job
         * @summary List last job commits
         * @param {string} jobId Job ID
         * @param {string} [startId] Starting point after which to return results
         * @param {string} [gitCommitId] Git Commit ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listJobCommit(jobId: string, startId?: string, gitCommitId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommitResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listJobCommit(jobId, startId, gitCommitId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * JobMainCallsApi - factory interface
 * @export
 */
export const JobMainCallsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JobMainCallsApiFp(configuration)
    return {
        /**
         * To delete the job you must have the admin permission
         * @summary Delete job
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJob(jobId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteJob(jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * - To edit the job you must have the admin permission. 
         * @summary Edit job
         * @param {string} jobId Job ID
         * @param {JobRequest} [jobRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editJob(jobId: string, jobRequest?: JobRequest, options?: any): AxiosPromise<JobResponse> {
            return localVarFp.editJob(jobId, jobRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get job by ID
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJob(jobId: string, options?: any): AxiosPromise<JobResponse> {
            return localVarFp.getJob(jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get job status
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobStatus(jobId: string, options?: any): AxiosPromise<Status> {
            return localVarFp.getJobStatus(jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns list of the last 100 commits made on the repository linked to the job
         * @summary List last job commits
         * @param {string} jobId Job ID
         * @param {string} [startId] Starting point after which to return results
         * @param {string} [gitCommitId] Git Commit ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobCommit(jobId: string, startId?: string, gitCommitId?: string, options?: any): AxiosPromise<CommitResponseList> {
            return localVarFp.listJobCommit(jobId, startId, gitCommitId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JobMainCallsApi - object-oriented interface
 * @export
 * @class JobMainCallsApi
 * @extends {BaseAPI}
 */
export class JobMainCallsApi extends BaseAPI {
    /**
     * To delete the job you must have the admin permission
     * @summary Delete job
     * @param {string} jobId Job ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobMainCallsApi
     */
    public deleteJob(jobId: string, options?: AxiosRequestConfig) {
        return JobMainCallsApiFp(this.configuration).deleteJob(jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - To edit the job you must have the admin permission. 
     * @summary Edit job
     * @param {string} jobId Job ID
     * @param {JobRequest} [jobRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobMainCallsApi
     */
    public editJob(jobId: string, jobRequest?: JobRequest, options?: AxiosRequestConfig) {
        return JobMainCallsApiFp(this.configuration).editJob(jobId, jobRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get job by ID
     * @param {string} jobId Job ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobMainCallsApi
     */
    public getJob(jobId: string, options?: AxiosRequestConfig) {
        return JobMainCallsApiFp(this.configuration).getJob(jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get job status
     * @param {string} jobId Job ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobMainCallsApi
     */
    public getJobStatus(jobId: string, options?: AxiosRequestConfig) {
        return JobMainCallsApiFp(this.configuration).getJobStatus(jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns list of the last 100 commits made on the repository linked to the job
     * @summary List last job commits
     * @param {string} jobId Job ID
     * @param {string} [startId] Starting point after which to return results
     * @param {string} [gitCommitId] Git Commit ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobMainCallsApi
     */
    public listJobCommit(jobId: string, startId?: string, gitCommitId?: string, options?: AxiosRequestConfig) {
        return JobMainCallsApiFp(this.configuration).listJobCommit(jobId, startId, gitCommitId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * JobSecretApi - axios parameter creator
 * @export
 */
export const JobSecretApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * - Add a secret to the job. 
         * @summary Add a secret to the job
         * @param {string} jobId Job ID
         * @param {SecretRequest} [secretRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJobSecret: async (jobId: string, secretRequest?: SecretRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('createJobSecret', 'jobId', jobId)
            const localVarPath = `/job/{jobId}/secret`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(secretRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to add an alias at job level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at job level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - You can\'t create an alias on an alias 
         * @summary Create a secret alias at the job level
         * @param {string} jobId Job ID
         * @param {string} secretId Secret ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJobSecretAlias: async (jobId: string, secretId: string, key?: Key, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('createJobSecretAlias', 'jobId', jobId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('createJobSecretAlias', 'secretId', secretId)
            const localVarPath = `/job/{jobId}/secret/{secretId}/alias`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(key, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to override at job level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at job level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
         * @summary Create a secret override at the job level
         * @param {string} jobId Job ID
         * @param {string} secretId Secret ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJobSecretOverride: async (jobId: string, secretId: string, value?: Value, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('createJobSecretOverride', 'jobId', jobId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('createJobSecretOverride', 'secretId', secretId)
            const localVarPath = `/job/{jobId}/secret/{secretId}/override`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(value, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete a secret from an job
         * @param {string} jobId Job ID
         * @param {string} secretId Secret ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJobSecret: async (jobId: string, secretId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('deleteJobSecret', 'jobId', jobId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('deleteJobSecret', 'secretId', secretId)
            const localVarPath = `/job/{jobId}/secret/{secretId}`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > CONTAINER) 
         * @summary Edit a secret belonging to the job
         * @param {string} jobId Job ID
         * @param {string} secretId Secret ID
         * @param {SecretEditRequest} secretEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editJobSecret: async (jobId: string, secretId: string, secretEditRequest: SecretEditRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('editJobSecret', 'jobId', jobId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('editJobSecret', 'secretId', secretId)
            // verify required parameter 'secretEditRequest' is not null or undefined
            assertParamExists('editJobSecret', 'secretEditRequest', secretEditRequest)
            const localVarPath = `/job/{jobId}/secret/{secretId}`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(secretEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Secrets are like environment variables, but they are secured and can\'t be revealed.
         * @summary List job secrets
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobSecrets: async (jobId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('listJobSecrets', 'jobId', jobId)
            const localVarPath = `/job/{jobId}/secret`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobSecretApi - functional programming interface
 * @export
 */
export const JobSecretApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JobSecretApiAxiosParamCreator(configuration)
    return {
        /**
         * - Add a secret to the job. 
         * @summary Add a secret to the job
         * @param {string} jobId Job ID
         * @param {SecretRequest} [secretRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createJobSecret(jobId: string, secretRequest?: SecretRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createJobSecret(jobId, secretRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - Allows you to add an alias at job level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at job level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - You can\'t create an alias on an alias 
         * @summary Create a secret alias at the job level
         * @param {string} jobId Job ID
         * @param {string} secretId Secret ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createJobSecretAlias(jobId: string, secretId: string, key?: Key, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createJobSecretAlias(jobId, secretId, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - Allows you to override at job level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at job level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
         * @summary Create a secret override at the job level
         * @param {string} jobId Job ID
         * @param {string} secretId Secret ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createJobSecretOverride(jobId: string, secretId: string, value?: Value, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createJobSecretOverride(jobId, secretId, value, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete a secret from an job
         * @param {string} jobId Job ID
         * @param {string} secretId Secret ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteJobSecret(jobId: string, secretId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteJobSecret(jobId, secretId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > CONTAINER) 
         * @summary Edit a secret belonging to the job
         * @param {string} jobId Job ID
         * @param {string} secretId Secret ID
         * @param {SecretEditRequest} secretEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editJobSecret(jobId: string, secretId: string, secretEditRequest: SecretEditRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editJobSecret(jobId, secretId, secretEditRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Secrets are like environment variables, but they are secured and can\'t be revealed.
         * @summary List job secrets
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listJobSecrets(jobId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecretResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listJobSecrets(jobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * JobSecretApi - factory interface
 * @export
 */
export const JobSecretApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JobSecretApiFp(configuration)
    return {
        /**
         * - Add a secret to the job. 
         * @summary Add a secret to the job
         * @param {string} jobId Job ID
         * @param {SecretRequest} [secretRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJobSecret(jobId: string, secretRequest?: SecretRequest, options?: any): AxiosPromise<Secret> {
            return localVarFp.createJobSecret(jobId, secretRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to add an alias at job level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at job level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - You can\'t create an alias on an alias 
         * @summary Create a secret alias at the job level
         * @param {string} jobId Job ID
         * @param {string} secretId Secret ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJobSecretAlias(jobId: string, secretId: string, key?: Key, options?: any): AxiosPromise<Secret> {
            return localVarFp.createJobSecretAlias(jobId, secretId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to override at job level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at job level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
         * @summary Create a secret override at the job level
         * @param {string} jobId Job ID
         * @param {string} secretId Secret ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJobSecretOverride(jobId: string, secretId: string, value?: Value, options?: any): AxiosPromise<Secret> {
            return localVarFp.createJobSecretOverride(jobId, secretId, value, options).then((request) => request(axios, basePath));
        },
        /**
         * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete a secret from an job
         * @param {string} jobId Job ID
         * @param {string} secretId Secret ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJobSecret(jobId: string, secretId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteJobSecret(jobId, secretId, options).then((request) => request(axios, basePath));
        },
        /**
         * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > CONTAINER) 
         * @summary Edit a secret belonging to the job
         * @param {string} jobId Job ID
         * @param {string} secretId Secret ID
         * @param {SecretEditRequest} secretEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editJobSecret(jobId: string, secretId: string, secretEditRequest: SecretEditRequest, options?: any): AxiosPromise<Secret> {
            return localVarFp.editJobSecret(jobId, secretId, secretEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Secrets are like environment variables, but they are secured and can\'t be revealed.
         * @summary List job secrets
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobSecrets(jobId: string, options?: any): AxiosPromise<SecretResponseList> {
            return localVarFp.listJobSecrets(jobId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JobSecretApi - object-oriented interface
 * @export
 * @class JobSecretApi
 * @extends {BaseAPI}
 */
export class JobSecretApi extends BaseAPI {
    /**
     * - Add a secret to the job. 
     * @summary Add a secret to the job
     * @param {string} jobId Job ID
     * @param {SecretRequest} [secretRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobSecretApi
     */
    public createJobSecret(jobId: string, secretRequest?: SecretRequest, options?: AxiosRequestConfig) {
        return JobSecretApiFp(this.configuration).createJobSecret(jobId, secretRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to add an alias at job level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at job level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - You can\'t create an alias on an alias 
     * @summary Create a secret alias at the job level
     * @param {string} jobId Job ID
     * @param {string} secretId Secret ID
     * @param {Key} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobSecretApi
     */
    public createJobSecretAlias(jobId: string, secretId: string, key?: Key, options?: AxiosRequestConfig) {
        return JobSecretApiFp(this.configuration).createJobSecretAlias(jobId, secretId, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to override at job level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at job level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
     * @summary Create a secret override at the job level
     * @param {string} jobId Job ID
     * @param {string} secretId Secret ID
     * @param {Value} [value] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobSecretApi
     */
    public createJobSecretOverride(jobId: string, secretId: string, value?: Value, options?: AxiosRequestConfig) {
        return JobSecretApiFp(this.configuration).createJobSecretOverride(jobId, secretId, value, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well 
     * @summary Delete a secret from an job
     * @param {string} jobId Job ID
     * @param {string} secretId Secret ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobSecretApi
     */
    public deleteJobSecret(jobId: string, secretId: string, options?: AxiosRequestConfig) {
        return JobSecretApiFp(this.configuration).deleteJobSecret(jobId, secretId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > CONTAINER) 
     * @summary Edit a secret belonging to the job
     * @param {string} jobId Job ID
     * @param {string} secretId Secret ID
     * @param {SecretEditRequest} secretEditRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobSecretApi
     */
    public editJobSecret(jobId: string, secretId: string, secretEditRequest: SecretEditRequest, options?: AxiosRequestConfig) {
        return JobSecretApiFp(this.configuration).editJobSecret(jobId, secretId, secretEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Secrets are like environment variables, but they are secured and can\'t be revealed.
     * @summary List job secrets
     * @param {string} jobId Job ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobSecretApi
     */
    public listJobSecrets(jobId: string, options?: AxiosRequestConfig) {
        return JobSecretApiFp(this.configuration).listJobSecrets(jobId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * JobsApi - axios parameter creator
 * @export
 */
export const JobsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Triggers a new job deploy in each environment matching the following conditions - environment should have the auto-deploy enabled - the job should have the same image name and a different tag 
         * @summary Auto deploy jobs
         * @param {string} organizationId Organization ID
         * @param {OrganizationJobAutoDeployRequest} [organizationJobAutoDeployRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoDeployJobEnvironments: async (organizationId: string, organizationJobAutoDeployRequest?: OrganizationJobAutoDeployRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('autoDeployJobEnvironments', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/job/deploy`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationJobAutoDeployRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This will create a new job with the same configuration on the targeted environment Id.
         * @summary Clone job
         * @param {string} jobId Job ID
         * @param {CloneServiceRequest} [cloneServiceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneJob: async (jobId: string, cloneServiceRequest?: CloneServiceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('cloneJob', 'jobId', jobId)
            const localVarPath = `/job/{jobId}/clone`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloneServiceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a job
         * @param {string} environmentId Environment ID
         * @param {JobRequest} [jobRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJob: async (environmentId: string, jobRequest?: JobRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('createJob', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/job`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jobRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Default values for each setting is available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/advanced-settings/)
         * @summary List default job advanced settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultJobAdvancedSettings: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/defaultJobAdvancedSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of jobs with only their id and status.
         * @summary List all environment job statuses
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentJobStatus: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('getEnvironmentJobStatus', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/job/status`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List jobs
         * @param {string} environmentId Environment ID
         * @param {boolean} [toUpdate] return (or not) results that must be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobs: async (environmentId: string, toUpdate?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('listJobs', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/job`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (toUpdate !== undefined) {
                localVarQueryParameter['toUpdate'] = toUpdate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobsApi - functional programming interface
 * @export
 */
export const JobsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JobsApiAxiosParamCreator(configuration)
    return {
        /**
         * Triggers a new job deploy in each environment matching the following conditions - environment should have the auto-deploy enabled - the job should have the same image name and a different tag 
         * @summary Auto deploy jobs
         * @param {string} organizationId Organization ID
         * @param {OrganizationJobAutoDeployRequest} [organizationJobAutoDeployRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autoDeployJobEnvironments(organizationId: string, organizationJobAutoDeployRequest?: OrganizationJobAutoDeployRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autoDeployJobEnvironments(organizationId, organizationJobAutoDeployRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This will create a new job with the same configuration on the targeted environment Id.
         * @summary Clone job
         * @param {string} jobId Job ID
         * @param {CloneServiceRequest} [cloneServiceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloneJob(jobId: string, cloneServiceRequest?: CloneServiceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cloneJob(jobId, cloneServiceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a job
         * @param {string} environmentId Environment ID
         * @param {JobRequest} [jobRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createJob(environmentId: string, jobRequest?: JobRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createJob(environmentId, jobRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Default values for each setting is available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/advanced-settings/)
         * @summary List default job advanced settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDefaultJobAdvancedSettings(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobAdvancedSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDefaultJobAdvancedSettings(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of jobs with only their id and status.
         * @summary List all environment job statuses
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironmentJobStatus(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReferenceObjectStatusResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironmentJobStatus(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List jobs
         * @param {string} environmentId Environment ID
         * @param {boolean} [toUpdate] return (or not) results that must be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listJobs(environmentId: string, toUpdate?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listJobs(environmentId, toUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * JobsApi - factory interface
 * @export
 */
export const JobsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JobsApiFp(configuration)
    return {
        /**
         * Triggers a new job deploy in each environment matching the following conditions - environment should have the auto-deploy enabled - the job should have the same image name and a different tag 
         * @summary Auto deploy jobs
         * @param {string} organizationId Organization ID
         * @param {OrganizationJobAutoDeployRequest} [organizationJobAutoDeployRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoDeployJobEnvironments(organizationId: string, organizationJobAutoDeployRequest?: OrganizationJobAutoDeployRequest, options?: any): AxiosPromise<Status> {
            return localVarFp.autoDeployJobEnvironments(organizationId, organizationJobAutoDeployRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This will create a new job with the same configuration on the targeted environment Id.
         * @summary Clone job
         * @param {string} jobId Job ID
         * @param {CloneServiceRequest} [cloneServiceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneJob(jobId: string, cloneServiceRequest?: CloneServiceRequest, options?: any): AxiosPromise<JobResponse> {
            return localVarFp.cloneJob(jobId, cloneServiceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a job
         * @param {string} environmentId Environment ID
         * @param {JobRequest} [jobRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJob(environmentId: string, jobRequest?: JobRequest, options?: any): AxiosPromise<JobResponse> {
            return localVarFp.createJob(environmentId, jobRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Default values for each setting is available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/advanced-settings/)
         * @summary List default job advanced settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultJobAdvancedSettings(options?: any): AxiosPromise<JobAdvancedSettings> {
            return localVarFp.getDefaultJobAdvancedSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of jobs with only their id and status.
         * @summary List all environment job statuses
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentJobStatus(environmentId: string, options?: any): AxiosPromise<ReferenceObjectStatusResponseList> {
            return localVarFp.getEnvironmentJobStatus(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List jobs
         * @param {string} environmentId Environment ID
         * @param {boolean} [toUpdate] return (or not) results that must be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobs(environmentId: string, toUpdate?: boolean, options?: any): AxiosPromise<JobResponseList> {
            return localVarFp.listJobs(environmentId, toUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JobsApi - object-oriented interface
 * @export
 * @class JobsApi
 * @extends {BaseAPI}
 */
export class JobsApi extends BaseAPI {
    /**
     * Triggers a new job deploy in each environment matching the following conditions - environment should have the auto-deploy enabled - the job should have the same image name and a different tag 
     * @summary Auto deploy jobs
     * @param {string} organizationId Organization ID
     * @param {OrganizationJobAutoDeployRequest} [organizationJobAutoDeployRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public autoDeployJobEnvironments(organizationId: string, organizationJobAutoDeployRequest?: OrganizationJobAutoDeployRequest, options?: AxiosRequestConfig) {
        return JobsApiFp(this.configuration).autoDeployJobEnvironments(organizationId, organizationJobAutoDeployRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will create a new job with the same configuration on the targeted environment Id.
     * @summary Clone job
     * @param {string} jobId Job ID
     * @param {CloneServiceRequest} [cloneServiceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public cloneJob(jobId: string, cloneServiceRequest?: CloneServiceRequest, options?: AxiosRequestConfig) {
        return JobsApiFp(this.configuration).cloneJob(jobId, cloneServiceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a job
     * @param {string} environmentId Environment ID
     * @param {JobRequest} [jobRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public createJob(environmentId: string, jobRequest?: JobRequest, options?: AxiosRequestConfig) {
        return JobsApiFp(this.configuration).createJob(environmentId, jobRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Default values for each setting is available in [our documentation](https://hub.qovery.com/docs/using-qovery/configuration/advanced-settings/)
     * @summary List default job advanced settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public getDefaultJobAdvancedSettings(options?: AxiosRequestConfig) {
        return JobsApiFp(this.configuration).getDefaultJobAdvancedSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of jobs with only their id and status.
     * @summary List all environment job statuses
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public getEnvironmentJobStatus(environmentId: string, options?: AxiosRequestConfig) {
        return JobsApiFp(this.configuration).getEnvironmentJobStatus(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List jobs
     * @param {string} environmentId Environment ID
     * @param {boolean} [toUpdate] return (or not) results that must be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public listJobs(environmentId: string, toUpdate?: boolean, options?: AxiosRequestConfig) {
        return JobsApiFp(this.configuration).listJobs(environmentId, toUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LifecycleTemplateMainCallsApi - axios parameter creator
 * @export
 */
export const LifecycleTemplateMainCallsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get specific lifecycle template
         * @param {string} environmentId 
         * @param {string} lifecycleTemplateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentLifecycleTemplate: async (environmentId: string, lifecycleTemplateId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('getEnvironmentLifecycleTemplate', 'environmentId', environmentId)
            // verify required parameter 'lifecycleTemplateId' is not null or undefined
            assertParamExists('getEnvironmentLifecycleTemplate', 'lifecycleTemplateId', lifecycleTemplateId)
            const localVarPath = `/environment/{environmentId}/lifecycleTemplate/{lifecycleTemplateId}`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)))
                .replace(`{${"lifecycleTemplateId"}}`, encodeURIComponent(String(lifecycleTemplateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List available lifecycle template for this environment
         * @param {string} environmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentLifecycleTemplates: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('listEnvironmentLifecycleTemplates', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/lifecycleTemplate`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LifecycleTemplateMainCallsApi - functional programming interface
 * @export
 */
export const LifecycleTemplateMainCallsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LifecycleTemplateMainCallsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get specific lifecycle template
         * @param {string} environmentId 
         * @param {string} lifecycleTemplateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironmentLifecycleTemplate(environmentId: string, lifecycleTemplateId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifecycleTemplateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironmentLifecycleTemplate(environmentId, lifecycleTemplateId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List available lifecycle template for this environment
         * @param {string} environmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEnvironmentLifecycleTemplates(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifecycleTemplateListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEnvironmentLifecycleTemplates(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LifecycleTemplateMainCallsApi - factory interface
 * @export
 */
export const LifecycleTemplateMainCallsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LifecycleTemplateMainCallsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get specific lifecycle template
         * @param {string} environmentId 
         * @param {string} lifecycleTemplateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentLifecycleTemplate(environmentId: string, lifecycleTemplateId: string, options?: any): AxiosPromise<LifecycleTemplateResponse> {
            return localVarFp.getEnvironmentLifecycleTemplate(environmentId, lifecycleTemplateId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List available lifecycle template for this environment
         * @param {string} environmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentLifecycleTemplates(environmentId: string, options?: any): AxiosPromise<LifecycleTemplateListResponse> {
            return localVarFp.listEnvironmentLifecycleTemplates(environmentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LifecycleTemplateMainCallsApi - object-oriented interface
 * @export
 * @class LifecycleTemplateMainCallsApi
 * @extends {BaseAPI}
 */
export class LifecycleTemplateMainCallsApi extends BaseAPI {
    /**
     * 
     * @summary Get specific lifecycle template
     * @param {string} environmentId 
     * @param {string} lifecycleTemplateId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LifecycleTemplateMainCallsApi
     */
    public getEnvironmentLifecycleTemplate(environmentId: string, lifecycleTemplateId: string, options?: AxiosRequestConfig) {
        return LifecycleTemplateMainCallsApiFp(this.configuration).getEnvironmentLifecycleTemplate(environmentId, lifecycleTemplateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List available lifecycle template for this environment
     * @param {string} environmentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LifecycleTemplateMainCallsApi
     */
    public listEnvironmentLifecycleTemplates(environmentId: string, options?: AxiosRequestConfig) {
        return LifecycleTemplateMainCallsApiFp(this.configuration).listEnvironmentLifecycleTemplates(environmentId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MembersApi - axios parameter creator
 * @export
 */
export const MembersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove an invited member
         * @param {string} organizationId Organization ID
         * @param {string} inviteId Invite ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInviteMember: async (organizationId: string, inviteId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteInviteMember', 'organizationId', organizationId)
            // verify required parameter 'inviteId' is not null or undefined
            assertParamExists('deleteInviteMember', 'inviteId', inviteId)
            const localVarPath = `/organization/{organizationId}/inviteMember/{inviteId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"inviteId"}}`, encodeURIComponent(String(inviteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a member
         * @param {string} organizationId Organization ID
         * @param {DeleteMemberRequest} [deleteMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMember: async (organizationId: string, deleteMemberRequest?: DeleteMemberRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteMember', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/member`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteMemberRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit an organization member role
         * @summary Edit an organization member role
         * @param {string} organizationId Organization ID
         * @param {MemberRoleUpdateRequest} [memberRoleUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editOrganizationMemberRole: async (organizationId: string, memberRoleUpdateRequest?: MemberRoleUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('editOrganizationMemberRole', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/member`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(memberRoleUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get member invitation
         * @param {string} organizationId Organization ID
         * @param {string} inviteId Invite ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMemberInvitation: async (organizationId: string, inviteId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getMemberInvitation', 'organizationId', organizationId)
            // verify required parameter 'inviteId' is not null or undefined
            assertParamExists('getMemberInvitation', 'inviteId', inviteId)
            const localVarPath = `/organization/{organizationId}/inviteMember/{inviteId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"inviteId"}}`, encodeURIComponent(String(inviteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get invited members
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationInvitedMembers: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationInvitedMembers', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/inviteMember`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get organization members
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationMembers: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationMembers', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/member`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Accept Invite in the organization
         * @param {string} organizationId Organization ID
         * @param {string} inviteId Invite ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAcceptInviteMember: async (organizationId: string, inviteId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('postAcceptInviteMember', 'organizationId', organizationId)
            // verify required parameter 'inviteId' is not null or undefined
            assertParamExists('postAcceptInviteMember', 'inviteId', inviteId)
            const localVarPath = `/organization/{organizationId}/inviteMember/{inviteId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"inviteId"}}`, encodeURIComponent(String(inviteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invite someone in the organization
         * @param {string} organizationId Organization ID
         * @param {InviteMemberRequest} [inviteMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postInviteMember: async (organizationId: string, inviteMemberRequest?: InviteMemberRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('postInviteMember', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/inviteMember`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inviteMemberRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Transfer organization ownership to another user
         * @param {string} organizationId Organization ID
         * @param {TransferOwnershipRequest} [transferOwnershipRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrganizationTransferOwnership: async (organizationId: string, transferOwnershipRequest?: TransferOwnershipRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('postOrganizationTransferOwnership', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/transferOwnership`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transferOwnershipRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MembersApi - functional programming interface
 * @export
 */
export const MembersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MembersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove an invited member
         * @param {string} organizationId Organization ID
         * @param {string} inviteId Invite ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteInviteMember(organizationId: string, inviteId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteInviteMember(organizationId, inviteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove a member
         * @param {string} organizationId Organization ID
         * @param {DeleteMemberRequest} [deleteMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMember(organizationId: string, deleteMemberRequest?: DeleteMemberRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMember(organizationId, deleteMemberRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Edit an organization member role
         * @summary Edit an organization member role
         * @param {string} organizationId Organization ID
         * @param {MemberRoleUpdateRequest} [memberRoleUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editOrganizationMemberRole(organizationId: string, memberRoleUpdateRequest?: MemberRoleUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editOrganizationMemberRole(organizationId, memberRoleUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get member invitation
         * @param {string} organizationId Organization ID
         * @param {string} inviteId Invite ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMemberInvitation(organizationId: string, inviteId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InviteMember>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMemberInvitation(organizationId, inviteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get invited members
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationInvitedMembers(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InviteMemberResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationInvitedMembers(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get organization members
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationMembers(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemberResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationMembers(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Accept Invite in the organization
         * @param {string} organizationId Organization ID
         * @param {string} inviteId Invite ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAcceptInviteMember(organizationId: string, inviteId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InviteMember>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postAcceptInviteMember(organizationId, inviteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Invite someone in the organization
         * @param {string} organizationId Organization ID
         * @param {InviteMemberRequest} [inviteMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postInviteMember(organizationId: string, inviteMemberRequest?: InviteMemberRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InviteMember>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postInviteMember(organizationId, inviteMemberRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Transfer organization ownership to another user
         * @param {string} organizationId Organization ID
         * @param {TransferOwnershipRequest} [transferOwnershipRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postOrganizationTransferOwnership(organizationId: string, transferOwnershipRequest?: TransferOwnershipRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postOrganizationTransferOwnership(organizationId, transferOwnershipRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MembersApi - factory interface
 * @export
 */
export const MembersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MembersApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove an invited member
         * @param {string} organizationId Organization ID
         * @param {string} inviteId Invite ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInviteMember(organizationId: string, inviteId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteInviteMember(organizationId, inviteId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a member
         * @param {string} organizationId Organization ID
         * @param {DeleteMemberRequest} [deleteMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMember(organizationId: string, deleteMemberRequest?: DeleteMemberRequest, options?: any): AxiosPromise<void> {
            return localVarFp.deleteMember(organizationId, deleteMemberRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit an organization member role
         * @summary Edit an organization member role
         * @param {string} organizationId Organization ID
         * @param {MemberRoleUpdateRequest} [memberRoleUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editOrganizationMemberRole(organizationId: string, memberRoleUpdateRequest?: MemberRoleUpdateRequest, options?: any): AxiosPromise<void> {
            return localVarFp.editOrganizationMemberRole(organizationId, memberRoleUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get member invitation
         * @param {string} organizationId Organization ID
         * @param {string} inviteId Invite ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMemberInvitation(organizationId: string, inviteId: string, options?: any): AxiosPromise<InviteMember> {
            return localVarFp.getMemberInvitation(organizationId, inviteId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get invited members
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationInvitedMembers(organizationId: string, options?: any): AxiosPromise<InviteMemberResponseList> {
            return localVarFp.getOrganizationInvitedMembers(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get organization members
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationMembers(organizationId: string, options?: any): AxiosPromise<MemberResponseList> {
            return localVarFp.getOrganizationMembers(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Accept Invite in the organization
         * @param {string} organizationId Organization ID
         * @param {string} inviteId Invite ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAcceptInviteMember(organizationId: string, inviteId: string, options?: any): AxiosPromise<InviteMember> {
            return localVarFp.postAcceptInviteMember(organizationId, inviteId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invite someone in the organization
         * @param {string} organizationId Organization ID
         * @param {InviteMemberRequest} [inviteMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postInviteMember(organizationId: string, inviteMemberRequest?: InviteMemberRequest, options?: any): AxiosPromise<InviteMember> {
            return localVarFp.postInviteMember(organizationId, inviteMemberRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Transfer organization ownership to another user
         * @param {string} organizationId Organization ID
         * @param {TransferOwnershipRequest} [transferOwnershipRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrganizationTransferOwnership(organizationId: string, transferOwnershipRequest?: TransferOwnershipRequest, options?: any): AxiosPromise<void> {
            return localVarFp.postOrganizationTransferOwnership(organizationId, transferOwnershipRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MembersApi - object-oriented interface
 * @export
 * @class MembersApi
 * @extends {BaseAPI}
 */
export class MembersApi extends BaseAPI {
    /**
     * 
     * @summary Remove an invited member
     * @param {string} organizationId Organization ID
     * @param {string} inviteId Invite ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public deleteInviteMember(organizationId: string, inviteId: string, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).deleteInviteMember(organizationId, inviteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a member
     * @param {string} organizationId Organization ID
     * @param {DeleteMemberRequest} [deleteMemberRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public deleteMember(organizationId: string, deleteMemberRequest?: DeleteMemberRequest, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).deleteMember(organizationId, deleteMemberRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit an organization member role
     * @summary Edit an organization member role
     * @param {string} organizationId Organization ID
     * @param {MemberRoleUpdateRequest} [memberRoleUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public editOrganizationMemberRole(organizationId: string, memberRoleUpdateRequest?: MemberRoleUpdateRequest, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).editOrganizationMemberRole(organizationId, memberRoleUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get member invitation
     * @param {string} organizationId Organization ID
     * @param {string} inviteId Invite ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public getMemberInvitation(organizationId: string, inviteId: string, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).getMemberInvitation(organizationId, inviteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get invited members
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public getOrganizationInvitedMembers(organizationId: string, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).getOrganizationInvitedMembers(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get organization members
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public getOrganizationMembers(organizationId: string, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).getOrganizationMembers(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Accept Invite in the organization
     * @param {string} organizationId Organization ID
     * @param {string} inviteId Invite ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public postAcceptInviteMember(organizationId: string, inviteId: string, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).postAcceptInviteMember(organizationId, inviteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invite someone in the organization
     * @param {string} organizationId Organization ID
     * @param {InviteMemberRequest} [inviteMemberRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public postInviteMember(organizationId: string, inviteMemberRequest?: InviteMemberRequest, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).postInviteMember(organizationId, inviteMemberRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Transfer organization ownership to another user
     * @param {string} organizationId Organization ID
     * @param {TransferOwnershipRequest} [transferOwnershipRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public postOrganizationTransferOwnership(organizationId: string, transferOwnershipRequest?: TransferOwnershipRequest, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).postOrganizationTransferOwnership(organizationId, transferOwnershipRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrganizationAccountGitRepositoriesApi - axios parameter creator
 * @export
 */
export const OrganizationAccountGitRepositoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get bitbucket repositories of the connected user
         * @param {string} organizationId Organization ID
         * @param {string} [gitTokenId] The git token id that must be used for the application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationBitbucketRepositories: async (organizationId: string, gitTokenId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationBitbucketRepositories', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/account/bitbucket/repository`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (gitTokenId !== undefined) {
                localVarQueryParameter['gitTokenId'] = gitTokenId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get bitbucket branches of the specified repository
         * @param {string} organizationId Organization ID
         * @param {string} [name] The name of the repository where to retrieve the branches
         * @param {string} [gitTokenId] The git token id that must be used for the application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationBitbucketRepositoryBranches: async (organizationId: string, name?: string, gitTokenId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationBitbucketRepositoryBranches', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/account/bitbucket/repository/branch`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (gitTokenId !== undefined) {
                localVarQueryParameter['gitTokenId'] = gitTokenId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get git provider accounts
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationGitProviderAccount: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationGitProviderAccount', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/account/gitAuthProvider`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get github repositories of the connected user
         * @param {string} organizationId Organization ID
         * @param {string} [gitTokenId] The git token id that must be used for the application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationGithubRepositories: async (organizationId: string, gitTokenId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationGithubRepositories', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/account/github/repository`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (gitTokenId !== undefined) {
                localVarQueryParameter['gitTokenId'] = gitTokenId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get github branches of the specified repository
         * @param {string} organizationId Organization ID
         * @param {string} [name] The name of the repository where to retrieve the branches
         * @param {string} [gitTokenId] The git token id that must be used for the application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationGithubRepositoryBranches: async (organizationId: string, name?: string, gitTokenId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationGithubRepositoryBranches', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/account/github/repository/branch`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (gitTokenId !== undefined) {
                localVarQueryParameter['gitTokenId'] = gitTokenId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get gitlab repositories of the connected user
         * @param {string} organizationId Organization ID
         * @param {string} [gitTokenId] The git token id that must be used for the application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationGitlabRepositories: async (organizationId: string, gitTokenId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationGitlabRepositories', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/account/gitlab/repository`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (gitTokenId !== undefined) {
                localVarQueryParameter['gitTokenId'] = gitTokenId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get gitlab branches of the specified repository
         * @param {string} organizationId Organization ID
         * @param {string} [name] The name of the repository to retrieve the branches
         * @param {string} [gitTokenId] The git token id that must be used for the application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationGitlabRepositoryBranches: async (organizationId: string, name?: string, gitTokenId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationGitlabRepositoryBranches', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/account/gitlab/repository/branch`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (gitTokenId !== undefined) {
                localVarQueryParameter['gitTokenId'] = gitTokenId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationAccountGitRepositoriesApi - functional programming interface
 * @export
 */
export const OrganizationAccountGitRepositoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationAccountGitRepositoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get bitbucket repositories of the connected user
         * @param {string} organizationId Organization ID
         * @param {string} [gitTokenId] The git token id that must be used for the application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationBitbucketRepositories(organizationId: string, gitTokenId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitRepositoryResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationBitbucketRepositories(organizationId, gitTokenId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get bitbucket branches of the specified repository
         * @param {string} organizationId Organization ID
         * @param {string} [name] The name of the repository where to retrieve the branches
         * @param {string} [gitTokenId] The git token id that must be used for the application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationBitbucketRepositoryBranches(organizationId: string, name?: string, gitTokenId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitRepositoryBranchResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationBitbucketRepositoryBranches(organizationId, name, gitTokenId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get git provider accounts
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationGitProviderAccount(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitAuthProviderResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationGitProviderAccount(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get github repositories of the connected user
         * @param {string} organizationId Organization ID
         * @param {string} [gitTokenId] The git token id that must be used for the application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationGithubRepositories(organizationId: string, gitTokenId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitRepositoryResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationGithubRepositories(organizationId, gitTokenId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get github branches of the specified repository
         * @param {string} organizationId Organization ID
         * @param {string} [name] The name of the repository where to retrieve the branches
         * @param {string} [gitTokenId] The git token id that must be used for the application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationGithubRepositoryBranches(organizationId: string, name?: string, gitTokenId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitRepositoryBranchResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationGithubRepositoryBranches(organizationId, name, gitTokenId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get gitlab repositories of the connected user
         * @param {string} organizationId Organization ID
         * @param {string} [gitTokenId] The git token id that must be used for the application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationGitlabRepositories(organizationId: string, gitTokenId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitRepositoryResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationGitlabRepositories(organizationId, gitTokenId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get gitlab branches of the specified repository
         * @param {string} organizationId Organization ID
         * @param {string} [name] The name of the repository to retrieve the branches
         * @param {string} [gitTokenId] The git token id that must be used for the application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationGitlabRepositoryBranches(organizationId: string, name?: string, gitTokenId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitRepositoryBranchResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationGitlabRepositoryBranches(organizationId, name, gitTokenId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrganizationAccountGitRepositoriesApi - factory interface
 * @export
 */
export const OrganizationAccountGitRepositoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationAccountGitRepositoriesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get bitbucket repositories of the connected user
         * @param {string} organizationId Organization ID
         * @param {string} [gitTokenId] The git token id that must be used for the application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationBitbucketRepositories(organizationId: string, gitTokenId?: string, options?: any): AxiosPromise<GitRepositoryResponseList> {
            return localVarFp.getOrganizationBitbucketRepositories(organizationId, gitTokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get bitbucket branches of the specified repository
         * @param {string} organizationId Organization ID
         * @param {string} [name] The name of the repository where to retrieve the branches
         * @param {string} [gitTokenId] The git token id that must be used for the application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationBitbucketRepositoryBranches(organizationId: string, name?: string, gitTokenId?: string, options?: any): AxiosPromise<GitRepositoryBranchResponseList> {
            return localVarFp.getOrganizationBitbucketRepositoryBranches(organizationId, name, gitTokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get git provider accounts
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationGitProviderAccount(organizationId: string, options?: any): AxiosPromise<GitAuthProviderResponseList> {
            return localVarFp.getOrganizationGitProviderAccount(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get github repositories of the connected user
         * @param {string} organizationId Organization ID
         * @param {string} [gitTokenId] The git token id that must be used for the application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationGithubRepositories(organizationId: string, gitTokenId?: string, options?: any): AxiosPromise<GitRepositoryResponseList> {
            return localVarFp.getOrganizationGithubRepositories(organizationId, gitTokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get github branches of the specified repository
         * @param {string} organizationId Organization ID
         * @param {string} [name] The name of the repository where to retrieve the branches
         * @param {string} [gitTokenId] The git token id that must be used for the application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationGithubRepositoryBranches(organizationId: string, name?: string, gitTokenId?: string, options?: any): AxiosPromise<GitRepositoryBranchResponseList> {
            return localVarFp.getOrganizationGithubRepositoryBranches(organizationId, name, gitTokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get gitlab repositories of the connected user
         * @param {string} organizationId Organization ID
         * @param {string} [gitTokenId] The git token id that must be used for the application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationGitlabRepositories(organizationId: string, gitTokenId?: string, options?: any): AxiosPromise<GitRepositoryResponseList> {
            return localVarFp.getOrganizationGitlabRepositories(organizationId, gitTokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get gitlab branches of the specified repository
         * @param {string} organizationId Organization ID
         * @param {string} [name] The name of the repository to retrieve the branches
         * @param {string} [gitTokenId] The git token id that must be used for the application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationGitlabRepositoryBranches(organizationId: string, name?: string, gitTokenId?: string, options?: any): AxiosPromise<GitRepositoryBranchResponseList> {
            return localVarFp.getOrganizationGitlabRepositoryBranches(organizationId, name, gitTokenId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationAccountGitRepositoriesApi - object-oriented interface
 * @export
 * @class OrganizationAccountGitRepositoriesApi
 * @extends {BaseAPI}
 */
export class OrganizationAccountGitRepositoriesApi extends BaseAPI {
    /**
     * 
     * @summary Get bitbucket repositories of the connected user
     * @param {string} organizationId Organization ID
     * @param {string} [gitTokenId] The git token id that must be used for the application
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationAccountGitRepositoriesApi
     */
    public getOrganizationBitbucketRepositories(organizationId: string, gitTokenId?: string, options?: AxiosRequestConfig) {
        return OrganizationAccountGitRepositoriesApiFp(this.configuration).getOrganizationBitbucketRepositories(organizationId, gitTokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get bitbucket branches of the specified repository
     * @param {string} organizationId Organization ID
     * @param {string} [name] The name of the repository where to retrieve the branches
     * @param {string} [gitTokenId] The git token id that must be used for the application
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationAccountGitRepositoriesApi
     */
    public getOrganizationBitbucketRepositoryBranches(organizationId: string, name?: string, gitTokenId?: string, options?: AxiosRequestConfig) {
        return OrganizationAccountGitRepositoriesApiFp(this.configuration).getOrganizationBitbucketRepositoryBranches(organizationId, name, gitTokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get git provider accounts
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationAccountGitRepositoriesApi
     */
    public getOrganizationGitProviderAccount(organizationId: string, options?: AxiosRequestConfig) {
        return OrganizationAccountGitRepositoriesApiFp(this.configuration).getOrganizationGitProviderAccount(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get github repositories of the connected user
     * @param {string} organizationId Organization ID
     * @param {string} [gitTokenId] The git token id that must be used for the application
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationAccountGitRepositoriesApi
     */
    public getOrganizationGithubRepositories(organizationId: string, gitTokenId?: string, options?: AxiosRequestConfig) {
        return OrganizationAccountGitRepositoriesApiFp(this.configuration).getOrganizationGithubRepositories(organizationId, gitTokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get github branches of the specified repository
     * @param {string} organizationId Organization ID
     * @param {string} [name] The name of the repository where to retrieve the branches
     * @param {string} [gitTokenId] The git token id that must be used for the application
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationAccountGitRepositoriesApi
     */
    public getOrganizationGithubRepositoryBranches(organizationId: string, name?: string, gitTokenId?: string, options?: AxiosRequestConfig) {
        return OrganizationAccountGitRepositoriesApiFp(this.configuration).getOrganizationGithubRepositoryBranches(organizationId, name, gitTokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get gitlab repositories of the connected user
     * @param {string} organizationId Organization ID
     * @param {string} [gitTokenId] The git token id that must be used for the application
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationAccountGitRepositoriesApi
     */
    public getOrganizationGitlabRepositories(organizationId: string, gitTokenId?: string, options?: AxiosRequestConfig) {
        return OrganizationAccountGitRepositoriesApiFp(this.configuration).getOrganizationGitlabRepositories(organizationId, gitTokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get gitlab branches of the specified repository
     * @param {string} organizationId Organization ID
     * @param {string} [name] The name of the repository to retrieve the branches
     * @param {string} [gitTokenId] The git token id that must be used for the application
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationAccountGitRepositoriesApi
     */
    public getOrganizationGitlabRepositoryBranches(organizationId: string, name?: string, gitTokenId?: string, options?: AxiosRequestConfig) {
        return OrganizationAccountGitRepositoriesApiFp(this.configuration).getOrganizationGitlabRepositoryBranches(organizationId, name, gitTokenId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrganizationAnnotationsGroupApi - axios parameter creator
 * @export
 */
export const OrganizationAnnotationsGroupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an organization annotations group
         * @summary Create an organization annotations group
         * @param {string} organizationId Organization ID
         * @param {OrganizationAnnotationsGroupCreateRequest} [organizationAnnotationsGroupCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationAnnotationsGroup: async (organizationId: string, organizationAnnotationsGroupCreateRequest?: OrganizationAnnotationsGroupCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createOrganizationAnnotationsGroup', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/annotationsGroups`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationAnnotationsGroupCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete organization annotations group
         * @summary Delete organization annotations group
         * @param {string} organizationId Organization ID
         * @param {string} annotationsGroupId Organization annotations group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationAnnotationsGroup: async (organizationId: string, annotationsGroupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteOrganizationAnnotationsGroup', 'organizationId', organizationId)
            // verify required parameter 'annotationsGroupId' is not null or undefined
            assertParamExists('deleteOrganizationAnnotationsGroup', 'annotationsGroupId', annotationsGroupId)
            const localVarPath = `/organization/{organizationId}/annotationsGroups/{annotationsGroupId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"annotationsGroupId"}}`, encodeURIComponent(String(annotationsGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit organization annotations group
         * @summary Edit organization annotations group
         * @param {string} organizationId Organization ID
         * @param {string} annotationsGroupId Organization annotations group ID
         * @param {OrganizationAnnotationsGroupCreateRequest} [organizationAnnotationsGroupCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editOrganizationAnnotationsGroup: async (organizationId: string, annotationsGroupId: string, organizationAnnotationsGroupCreateRequest?: OrganizationAnnotationsGroupCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('editOrganizationAnnotationsGroup', 'organizationId', organizationId)
            // verify required parameter 'annotationsGroupId' is not null or undefined
            assertParamExists('editOrganizationAnnotationsGroup', 'annotationsGroupId', annotationsGroupId)
            const localVarPath = `/organization/{organizationId}/annotationsGroups/{annotationsGroupId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"annotationsGroupId"}}`, encodeURIComponent(String(annotationsGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationAnnotationsGroupCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get organization annotations group
         * @summary Get organization annotations group
         * @param {string} organizationId Organization ID
         * @param {string} annotationsGroupId Organization annotations group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationAnnotationsGroup: async (organizationId: string, annotationsGroupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationAnnotationsGroup', 'organizationId', organizationId)
            // verify required parameter 'annotationsGroupId' is not null or undefined
            assertParamExists('getOrganizationAnnotationsGroup', 'annotationsGroupId', annotationsGroupId)
            const localVarPath = `/organization/{organizationId}/annotationsGroups/{annotationsGroupId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"annotationsGroupId"}}`, encodeURIComponent(String(annotationsGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get organization annotations group associated items
         * @summary Get organization annotations group associated items
         * @param {string} organizationId Organization ID
         * @param {string} annotationsGroupId Organization annotations group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationAnnotationsGroupAssociatedItems: async (organizationId: string, annotationsGroupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationAnnotationsGroupAssociatedItems', 'organizationId', organizationId)
            // verify required parameter 'annotationsGroupId' is not null or undefined
            assertParamExists('getOrganizationAnnotationsGroupAssociatedItems', 'annotationsGroupId', annotationsGroupId)
            const localVarPath = `/organization/{organizationId}/annotationsGroups/{annotationsGroupId}/associatedItems`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"annotationsGroupId"}}`, encodeURIComponent(String(annotationsGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List organization annotations group
         * @summary List organization annotations group
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationAnnotationsGroup: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listOrganizationAnnotationsGroup', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/annotationsGroups`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationAnnotationsGroupApi - functional programming interface
 * @export
 */
export const OrganizationAnnotationsGroupApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationAnnotationsGroupApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an organization annotations group
         * @summary Create an organization annotations group
         * @param {string} organizationId Organization ID
         * @param {OrganizationAnnotationsGroupCreateRequest} [organizationAnnotationsGroupCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrganizationAnnotationsGroup(organizationId: string, organizationAnnotationsGroupCreateRequest?: OrganizationAnnotationsGroupCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationAnnotationsGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrganizationAnnotationsGroup(organizationId, organizationAnnotationsGroupCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete organization annotations group
         * @summary Delete organization annotations group
         * @param {string} organizationId Organization ID
         * @param {string} annotationsGroupId Organization annotations group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrganizationAnnotationsGroup(organizationId: string, annotationsGroupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrganizationAnnotationsGroup(organizationId, annotationsGroupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Edit organization annotations group
         * @summary Edit organization annotations group
         * @param {string} organizationId Organization ID
         * @param {string} annotationsGroupId Organization annotations group ID
         * @param {OrganizationAnnotationsGroupCreateRequest} [organizationAnnotationsGroupCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editOrganizationAnnotationsGroup(organizationId: string, annotationsGroupId: string, organizationAnnotationsGroupCreateRequest?: OrganizationAnnotationsGroupCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationAnnotationsGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editOrganizationAnnotationsGroup(organizationId, annotationsGroupId, organizationAnnotationsGroupCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get organization annotations group
         * @summary Get organization annotations group
         * @param {string} organizationId Organization ID
         * @param {string} annotationsGroupId Organization annotations group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationAnnotationsGroup(organizationId: string, annotationsGroupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationAnnotationsGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationAnnotationsGroup(organizationId, annotationsGroupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get organization annotations group associated items
         * @summary Get organization annotations group associated items
         * @param {string} organizationId Organization ID
         * @param {string} annotationsGroupId Organization annotations group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationAnnotationsGroupAssociatedItems(organizationId: string, annotationsGroupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationAnnotationsGroupAssociatedItemsResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationAnnotationsGroupAssociatedItems(organizationId, annotationsGroupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List organization annotations group
         * @summary List organization annotations group
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizationAnnotationsGroup(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOrganizationAnnotationsGroup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationAnnotationsGroup(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrganizationAnnotationsGroupApi - factory interface
 * @export
 */
export const OrganizationAnnotationsGroupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationAnnotationsGroupApiFp(configuration)
    return {
        /**
         * Create an organization annotations group
         * @summary Create an organization annotations group
         * @param {string} organizationId Organization ID
         * @param {OrganizationAnnotationsGroupCreateRequest} [organizationAnnotationsGroupCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationAnnotationsGroup(organizationId: string, organizationAnnotationsGroupCreateRequest?: OrganizationAnnotationsGroupCreateRequest, options?: any): AxiosPromise<OrganizationAnnotationsGroupResponse> {
            return localVarFp.createOrganizationAnnotationsGroup(organizationId, organizationAnnotationsGroupCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete organization annotations group
         * @summary Delete organization annotations group
         * @param {string} organizationId Organization ID
         * @param {string} annotationsGroupId Organization annotations group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationAnnotationsGroup(organizationId: string, annotationsGroupId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteOrganizationAnnotationsGroup(organizationId, annotationsGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit organization annotations group
         * @summary Edit organization annotations group
         * @param {string} organizationId Organization ID
         * @param {string} annotationsGroupId Organization annotations group ID
         * @param {OrganizationAnnotationsGroupCreateRequest} [organizationAnnotationsGroupCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editOrganizationAnnotationsGroup(organizationId: string, annotationsGroupId: string, organizationAnnotationsGroupCreateRequest?: OrganizationAnnotationsGroupCreateRequest, options?: any): AxiosPromise<OrganizationAnnotationsGroupResponse> {
            return localVarFp.editOrganizationAnnotationsGroup(organizationId, annotationsGroupId, organizationAnnotationsGroupCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get organization annotations group
         * @summary Get organization annotations group
         * @param {string} organizationId Organization ID
         * @param {string} annotationsGroupId Organization annotations group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationAnnotationsGroup(organizationId: string, annotationsGroupId: string, options?: any): AxiosPromise<OrganizationAnnotationsGroupResponse> {
            return localVarFp.getOrganizationAnnotationsGroup(organizationId, annotationsGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get organization annotations group associated items
         * @summary Get organization annotations group associated items
         * @param {string} organizationId Organization ID
         * @param {string} annotationsGroupId Organization annotations group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationAnnotationsGroupAssociatedItems(organizationId: string, annotationsGroupId: string, options?: any): AxiosPromise<OrganizationAnnotationsGroupAssociatedItemsResponseList> {
            return localVarFp.getOrganizationAnnotationsGroupAssociatedItems(organizationId, annotationsGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * List organization annotations group
         * @summary List organization annotations group
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationAnnotationsGroup(organizationId: string, options?: any): AxiosPromise<ListOrganizationAnnotationsGroup200Response> {
            return localVarFp.listOrganizationAnnotationsGroup(organizationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationAnnotationsGroupApi - object-oriented interface
 * @export
 * @class OrganizationAnnotationsGroupApi
 * @extends {BaseAPI}
 */
export class OrganizationAnnotationsGroupApi extends BaseAPI {
    /**
     * Create an organization annotations group
     * @summary Create an organization annotations group
     * @param {string} organizationId Organization ID
     * @param {OrganizationAnnotationsGroupCreateRequest} [organizationAnnotationsGroupCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationAnnotationsGroupApi
     */
    public createOrganizationAnnotationsGroup(organizationId: string, organizationAnnotationsGroupCreateRequest?: OrganizationAnnotationsGroupCreateRequest, options?: AxiosRequestConfig) {
        return OrganizationAnnotationsGroupApiFp(this.configuration).createOrganizationAnnotationsGroup(organizationId, organizationAnnotationsGroupCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete organization annotations group
     * @summary Delete organization annotations group
     * @param {string} organizationId Organization ID
     * @param {string} annotationsGroupId Organization annotations group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationAnnotationsGroupApi
     */
    public deleteOrganizationAnnotationsGroup(organizationId: string, annotationsGroupId: string, options?: AxiosRequestConfig) {
        return OrganizationAnnotationsGroupApiFp(this.configuration).deleteOrganizationAnnotationsGroup(organizationId, annotationsGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit organization annotations group
     * @summary Edit organization annotations group
     * @param {string} organizationId Organization ID
     * @param {string} annotationsGroupId Organization annotations group ID
     * @param {OrganizationAnnotationsGroupCreateRequest} [organizationAnnotationsGroupCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationAnnotationsGroupApi
     */
    public editOrganizationAnnotationsGroup(organizationId: string, annotationsGroupId: string, organizationAnnotationsGroupCreateRequest?: OrganizationAnnotationsGroupCreateRequest, options?: AxiosRequestConfig) {
        return OrganizationAnnotationsGroupApiFp(this.configuration).editOrganizationAnnotationsGroup(organizationId, annotationsGroupId, organizationAnnotationsGroupCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get organization annotations group
     * @summary Get organization annotations group
     * @param {string} organizationId Organization ID
     * @param {string} annotationsGroupId Organization annotations group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationAnnotationsGroupApi
     */
    public getOrganizationAnnotationsGroup(organizationId: string, annotationsGroupId: string, options?: AxiosRequestConfig) {
        return OrganizationAnnotationsGroupApiFp(this.configuration).getOrganizationAnnotationsGroup(organizationId, annotationsGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get organization annotations group associated items
     * @summary Get organization annotations group associated items
     * @param {string} organizationId Organization ID
     * @param {string} annotationsGroupId Organization annotations group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationAnnotationsGroupApi
     */
    public getOrganizationAnnotationsGroupAssociatedItems(organizationId: string, annotationsGroupId: string, options?: AxiosRequestConfig) {
        return OrganizationAnnotationsGroupApiFp(this.configuration).getOrganizationAnnotationsGroupAssociatedItems(organizationId, annotationsGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List organization annotations group
     * @summary List organization annotations group
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationAnnotationsGroupApi
     */
    public listOrganizationAnnotationsGroup(organizationId: string, options?: AxiosRequestConfig) {
        return OrganizationAnnotationsGroupApiFp(this.configuration).listOrganizationAnnotationsGroup(organizationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrganizationApiTokenApi - axios parameter creator
 * @export
 */
export const OrganizationApiTokenApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an organization api token. You can use the generated token to interact in a programmatic way with our API.
         * @summary Create an organization api token
         * @param {string} organizationId Organization ID
         * @param {OrganizationApiTokenCreateRequest} [organizationApiTokenCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationApiToken: async (organizationId: string, organizationApiTokenCreateRequest?: OrganizationApiTokenCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createOrganizationApiToken', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/apiToken`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationApiTokenCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete organization api token
         * @summary Delete organization api token
         * @param {string} organizationId Organization ID
         * @param {string} apiTokenId Organization Api Token ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationApiToken: async (organizationId: string, apiTokenId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteOrganizationApiToken', 'organizationId', organizationId)
            // verify required parameter 'apiTokenId' is not null or undefined
            assertParamExists('deleteOrganizationApiToken', 'apiTokenId', apiTokenId)
            const localVarPath = `/organization/{organizationId}/apiToken/{apiTokenId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"apiTokenId"}}`, encodeURIComponent(String(apiTokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List organization api tokens
         * @summary List organization api tokens
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationApiTokens: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listOrganizationApiTokens', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/apiToken`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationApiTokenApi - functional programming interface
 * @export
 */
export const OrganizationApiTokenApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationApiTokenApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an organization api token. You can use the generated token to interact in a programmatic way with our API.
         * @summary Create an organization api token
         * @param {string} organizationId Organization ID
         * @param {OrganizationApiTokenCreateRequest} [organizationApiTokenCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrganizationApiToken(organizationId: string, organizationApiTokenCreateRequest?: OrganizationApiTokenCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationApiTokenCreate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrganizationApiToken(organizationId, organizationApiTokenCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete organization api token
         * @summary Delete organization api token
         * @param {string} organizationId Organization ID
         * @param {string} apiTokenId Organization Api Token ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrganizationApiToken(organizationId: string, apiTokenId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrganizationApiToken(organizationId, apiTokenId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List organization api tokens
         * @summary List organization api tokens
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizationApiTokens(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationApiTokenResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationApiTokens(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrganizationApiTokenApi - factory interface
 * @export
 */
export const OrganizationApiTokenApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationApiTokenApiFp(configuration)
    return {
        /**
         * Create an organization api token. You can use the generated token to interact in a programmatic way with our API.
         * @summary Create an organization api token
         * @param {string} organizationId Organization ID
         * @param {OrganizationApiTokenCreateRequest} [organizationApiTokenCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationApiToken(organizationId: string, organizationApiTokenCreateRequest?: OrganizationApiTokenCreateRequest, options?: any): AxiosPromise<OrganizationApiTokenCreate> {
            return localVarFp.createOrganizationApiToken(organizationId, organizationApiTokenCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete organization api token
         * @summary Delete organization api token
         * @param {string} organizationId Organization ID
         * @param {string} apiTokenId Organization Api Token ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationApiToken(organizationId: string, apiTokenId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteOrganizationApiToken(organizationId, apiTokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * List organization api tokens
         * @summary List organization api tokens
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationApiTokens(organizationId: string, options?: any): AxiosPromise<OrganizationApiTokenResponseList> {
            return localVarFp.listOrganizationApiTokens(organizationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationApiTokenApi - object-oriented interface
 * @export
 * @class OrganizationApiTokenApi
 * @extends {BaseAPI}
 */
export class OrganizationApiTokenApi extends BaseAPI {
    /**
     * Create an organization api token. You can use the generated token to interact in a programmatic way with our API.
     * @summary Create an organization api token
     * @param {string} organizationId Organization ID
     * @param {OrganizationApiTokenCreateRequest} [organizationApiTokenCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiTokenApi
     */
    public createOrganizationApiToken(organizationId: string, organizationApiTokenCreateRequest?: OrganizationApiTokenCreateRequest, options?: AxiosRequestConfig) {
        return OrganizationApiTokenApiFp(this.configuration).createOrganizationApiToken(organizationId, organizationApiTokenCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete organization api token
     * @summary Delete organization api token
     * @param {string} organizationId Organization ID
     * @param {string} apiTokenId Organization Api Token ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiTokenApi
     */
    public deleteOrganizationApiToken(organizationId: string, apiTokenId: string, options?: AxiosRequestConfig) {
        return OrganizationApiTokenApiFp(this.configuration).deleteOrganizationApiToken(organizationId, apiTokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List organization api tokens
     * @summary List organization api tokens
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiTokenApi
     */
    public listOrganizationApiTokens(organizationId: string, options?: AxiosRequestConfig) {
        return OrganizationApiTokenApiFp(this.configuration).listOrganizationApiTokens(organizationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrganizationCustomRoleApi - axios parameter creator
 * @export
 */
export const OrganizationCustomRoleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an organization custom role
         * @summary Create an organization custom role
         * @param {string} organizationId Organization ID
         * @param {OrganizationCustomRoleCreateRequest} [organizationCustomRoleCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationCustomRole: async (organizationId: string, organizationCustomRoleCreateRequest?: OrganizationCustomRoleCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createOrganizationCustomRole', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/customRole`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationCustomRoleCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete organization custom role
         * @summary Delete organization custom role
         * @param {string} organizationId Organization ID
         * @param {string} customRoleId Custom Role ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationCustomRole: async (organizationId: string, customRoleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteOrganizationCustomRole', 'organizationId', organizationId)
            // verify required parameter 'customRoleId' is not null or undefined
            assertParamExists('deleteOrganizationCustomRole', 'customRoleId', customRoleId)
            const localVarPath = `/organization/{organizationId}/customRole/{customRoleId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"customRoleId"}}`, encodeURIComponent(String(customRoleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit an organization custom role
         * @summary Edit an organization custom role
         * @param {string} organizationId Organization ID
         * @param {string} customRoleId Custom Role ID
         * @param {OrganizationCustomRoleUpdateRequest} [organizationCustomRoleUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editOrganizationCustomRole: async (organizationId: string, customRoleId: string, organizationCustomRoleUpdateRequest?: OrganizationCustomRoleUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('editOrganizationCustomRole', 'organizationId', organizationId)
            // verify required parameter 'customRoleId' is not null or undefined
            assertParamExists('editOrganizationCustomRole', 'customRoleId', customRoleId)
            const localVarPath = `/organization/{organizationId}/customRole/{customRoleId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"customRoleId"}}`, encodeURIComponent(String(customRoleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationCustomRoleUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an organization custom role 
         * @summary Get an organization custom role 
         * @param {string} organizationId Organization ID
         * @param {string} customRoleId Custom Role ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationCustomRole: async (organizationId: string, customRoleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationCustomRole', 'organizationId', organizationId)
            // verify required parameter 'customRoleId' is not null or undefined
            assertParamExists('getOrganizationCustomRole', 'customRoleId', customRoleId)
            const localVarPath = `/organization/{organizationId}/customRole/{customRoleId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"customRoleId"}}`, encodeURIComponent(String(customRoleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List organization custom roles
         * @summary List organization custom roles
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationCustomRoles: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listOrganizationCustomRoles', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/customRole`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationCustomRoleApi - functional programming interface
 * @export
 */
export const OrganizationCustomRoleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationCustomRoleApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an organization custom role
         * @summary Create an organization custom role
         * @param {string} organizationId Organization ID
         * @param {OrganizationCustomRoleCreateRequest} [organizationCustomRoleCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrganizationCustomRole(organizationId: string, organizationCustomRoleCreateRequest?: OrganizationCustomRoleCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationCustomRole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrganizationCustomRole(organizationId, organizationCustomRoleCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete organization custom role
         * @summary Delete organization custom role
         * @param {string} organizationId Organization ID
         * @param {string} customRoleId Custom Role ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrganizationCustomRole(organizationId: string, customRoleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrganizationCustomRole(organizationId, customRoleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Edit an organization custom role
         * @summary Edit an organization custom role
         * @param {string} organizationId Organization ID
         * @param {string} customRoleId Custom Role ID
         * @param {OrganizationCustomRoleUpdateRequest} [organizationCustomRoleUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editOrganizationCustomRole(organizationId: string, customRoleId: string, organizationCustomRoleUpdateRequest?: OrganizationCustomRoleUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationCustomRole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editOrganizationCustomRole(organizationId, customRoleId, organizationCustomRoleUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get an organization custom role 
         * @summary Get an organization custom role 
         * @param {string} organizationId Organization ID
         * @param {string} customRoleId Custom Role ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationCustomRole(organizationId: string, customRoleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationCustomRole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationCustomRole(organizationId, customRoleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List organization custom roles
         * @summary List organization custom roles
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizationCustomRoles(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationCustomRoleList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationCustomRoles(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrganizationCustomRoleApi - factory interface
 * @export
 */
export const OrganizationCustomRoleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationCustomRoleApiFp(configuration)
    return {
        /**
         * Create an organization custom role
         * @summary Create an organization custom role
         * @param {string} organizationId Organization ID
         * @param {OrganizationCustomRoleCreateRequest} [organizationCustomRoleCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationCustomRole(organizationId: string, organizationCustomRoleCreateRequest?: OrganizationCustomRoleCreateRequest, options?: any): AxiosPromise<OrganizationCustomRole> {
            return localVarFp.createOrganizationCustomRole(organizationId, organizationCustomRoleCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete organization custom role
         * @summary Delete organization custom role
         * @param {string} organizationId Organization ID
         * @param {string} customRoleId Custom Role ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationCustomRole(organizationId: string, customRoleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteOrganizationCustomRole(organizationId, customRoleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit an organization custom role
         * @summary Edit an organization custom role
         * @param {string} organizationId Organization ID
         * @param {string} customRoleId Custom Role ID
         * @param {OrganizationCustomRoleUpdateRequest} [organizationCustomRoleUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editOrganizationCustomRole(organizationId: string, customRoleId: string, organizationCustomRoleUpdateRequest?: OrganizationCustomRoleUpdateRequest, options?: any): AxiosPromise<OrganizationCustomRole> {
            return localVarFp.editOrganizationCustomRole(organizationId, customRoleId, organizationCustomRoleUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an organization custom role 
         * @summary Get an organization custom role 
         * @param {string} organizationId Organization ID
         * @param {string} customRoleId Custom Role ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationCustomRole(organizationId: string, customRoleId: string, options?: any): AxiosPromise<OrganizationCustomRole> {
            return localVarFp.getOrganizationCustomRole(organizationId, customRoleId, options).then((request) => request(axios, basePath));
        },
        /**
         * List organization custom roles
         * @summary List organization custom roles
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationCustomRoles(organizationId: string, options?: any): AxiosPromise<OrganizationCustomRoleList> {
            return localVarFp.listOrganizationCustomRoles(organizationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationCustomRoleApi - object-oriented interface
 * @export
 * @class OrganizationCustomRoleApi
 * @extends {BaseAPI}
 */
export class OrganizationCustomRoleApi extends BaseAPI {
    /**
     * Create an organization custom role
     * @summary Create an organization custom role
     * @param {string} organizationId Organization ID
     * @param {OrganizationCustomRoleCreateRequest} [organizationCustomRoleCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationCustomRoleApi
     */
    public createOrganizationCustomRole(organizationId: string, organizationCustomRoleCreateRequest?: OrganizationCustomRoleCreateRequest, options?: AxiosRequestConfig) {
        return OrganizationCustomRoleApiFp(this.configuration).createOrganizationCustomRole(organizationId, organizationCustomRoleCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete organization custom role
     * @summary Delete organization custom role
     * @param {string} organizationId Organization ID
     * @param {string} customRoleId Custom Role ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationCustomRoleApi
     */
    public deleteOrganizationCustomRole(organizationId: string, customRoleId: string, options?: AxiosRequestConfig) {
        return OrganizationCustomRoleApiFp(this.configuration).deleteOrganizationCustomRole(organizationId, customRoleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit an organization custom role
     * @summary Edit an organization custom role
     * @param {string} organizationId Organization ID
     * @param {string} customRoleId Custom Role ID
     * @param {OrganizationCustomRoleUpdateRequest} [organizationCustomRoleUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationCustomRoleApi
     */
    public editOrganizationCustomRole(organizationId: string, customRoleId: string, organizationCustomRoleUpdateRequest?: OrganizationCustomRoleUpdateRequest, options?: AxiosRequestConfig) {
        return OrganizationCustomRoleApiFp(this.configuration).editOrganizationCustomRole(organizationId, customRoleId, organizationCustomRoleUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an organization custom role 
     * @summary Get an organization custom role 
     * @param {string} organizationId Organization ID
     * @param {string} customRoleId Custom Role ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationCustomRoleApi
     */
    public getOrganizationCustomRole(organizationId: string, customRoleId: string, options?: AxiosRequestConfig) {
        return OrganizationCustomRoleApiFp(this.configuration).getOrganizationCustomRole(organizationId, customRoleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List organization custom roles
     * @summary List organization custom roles
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationCustomRoleApi
     */
    public listOrganizationCustomRoles(organizationId: string, options?: AxiosRequestConfig) {
        return OrganizationCustomRoleApiFp(this.configuration).listOrganizationCustomRoles(organizationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrganizationEventApi - axios parameter creator
 * @export
 */
export const OrganizationEventApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get available event targets to filter events
         * @summary Get available event targets to filter events
         * @param {string} organizationId Organization ID
         * @param {string | null} [fromTimestamp] Display targets available since this timestamp.   A range of date can be specified by using &#x60;from-timestamp&#x60; with &#x60;to-timestamp&#x60; The format is a timestamp with nano precision 
         * @param {string | null} [toTimestamp] Display targets triggered before this timestamp.   A range of date can be specified by using &#x60;to-timestamp&#x60; with &#x60;from-timestamp&#x60; The format is a timestamp with nano precision 
         * @param {OrganizationEventType} [eventType] 
         * @param {OrganizationEventTargetType} [targetType] 
         * @param {string} [triggeredBy] Information about the owner of the event (user name / apitoken / automatic action)
         * @param {OrganizationEventOrigin} [origin] 
         * @param {string} [projectId] Mandatory when requesting an environment or a service
         * @param {string} [environmentId] Mandatory when requesting a service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationEventTargets: async (organizationId: string, fromTimestamp?: string | null, toTimestamp?: string | null, eventType?: OrganizationEventType, targetType?: OrganizationEventTargetType, triggeredBy?: string, origin?: OrganizationEventOrigin, projectId?: string, environmentId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationEventTargets', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/targets`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fromTimestamp !== undefined) {
                localVarQueryParameter['fromTimestamp'] = fromTimestamp;
            }

            if (toTimestamp !== undefined) {
                localVarQueryParameter['toTimestamp'] = toTimestamp;
            }

            if (eventType !== undefined) {
                localVarQueryParameter['eventType'] = eventType;
            }

            if (targetType !== undefined) {
                localVarQueryParameter['targetType'] = targetType;
            }

            if (triggeredBy !== undefined) {
                localVarQueryParameter['triggeredBy'] = triggeredBy;
            }

            if (origin !== undefined) {
                localVarQueryParameter['origin'] = origin;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }

            if (environmentId !== undefined) {
                localVarQueryParameter['environmentId'] = environmentId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all events inside the organization
         * @summary Get all events inside the organization
         * @param {string} organizationId Organization ID
         * @param {number | null} [pageSize] The number of events to display in the current page
         * @param {string | null} [fromTimestamp] Display events triggered since this timestamp.   A range of date can be specified by using &#x60;from-timestamp&#x60; with &#x60;to-timestamp&#x60; The format is a timestamp with nano precision 
         * @param {string | null} [toTimestamp] Display events triggered before this timestamp.   A range of date can be specified by using &#x60;to-timestamp&#x60; with &#x60;from-timestamp&#x60; The format is a timestamp with nano precision 
         * @param {string} [continueToken] Token used to fetch the next page results The format is a timestamp with nano precision 
         * @param {string} [stepBackToken] Token used to fetch the previous page results The format is a timestamp with nano precision 
         * @param {OrganizationEventType} [eventType] 
         * @param {OrganizationEventTargetType} [targetType] 
         * @param {string | null} [targetId] The target resource id to search.   Must be specified with the corresponding &#x60;target_type&#x60; 
         * @param {OrganizationEventSubTargetType} [subTargetType] 
         * @param {string} [triggeredBy] Information about the owner of the event (user name / apitoken / automatic action)
         * @param {OrganizationEventOrigin} [origin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationEvents: async (organizationId: string, pageSize?: number | null, fromTimestamp?: string | null, toTimestamp?: string | null, continueToken?: string, stepBackToken?: string, eventType?: OrganizationEventType, targetType?: OrganizationEventTargetType, targetId?: string | null, subTargetType?: OrganizationEventSubTargetType, triggeredBy?: string, origin?: OrganizationEventOrigin, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationEvents', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/events`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (fromTimestamp !== undefined) {
                localVarQueryParameter['fromTimestamp'] = fromTimestamp;
            }

            if (toTimestamp !== undefined) {
                localVarQueryParameter['toTimestamp'] = toTimestamp;
            }

            if (continueToken !== undefined) {
                localVarQueryParameter['continueToken'] = continueToken;
            }

            if (stepBackToken !== undefined) {
                localVarQueryParameter['stepBackToken'] = stepBackToken;
            }

            if (eventType !== undefined) {
                localVarQueryParameter['eventType'] = eventType;
            }

            if (targetType !== undefined) {
                localVarQueryParameter['targetType'] = targetType;
            }

            if (targetId !== undefined) {
                localVarQueryParameter['targetId'] = targetId;
            }

            if (subTargetType !== undefined) {
                localVarQueryParameter['subTargetType'] = subTargetType;
            }

            if (triggeredBy !== undefined) {
                localVarQueryParameter['triggeredBy'] = triggeredBy;
            }

            if (origin !== undefined) {
                localVarQueryParameter['origin'] = origin;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationEventApi - functional programming interface
 * @export
 */
export const OrganizationEventApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationEventApiAxiosParamCreator(configuration)
    return {
        /**
         * Get available event targets to filter events
         * @summary Get available event targets to filter events
         * @param {string} organizationId Organization ID
         * @param {string | null} [fromTimestamp] Display targets available since this timestamp.   A range of date can be specified by using &#x60;from-timestamp&#x60; with &#x60;to-timestamp&#x60; The format is a timestamp with nano precision 
         * @param {string | null} [toTimestamp] Display targets triggered before this timestamp.   A range of date can be specified by using &#x60;to-timestamp&#x60; with &#x60;from-timestamp&#x60; The format is a timestamp with nano precision 
         * @param {OrganizationEventType} [eventType] 
         * @param {OrganizationEventTargetType} [targetType] 
         * @param {string} [triggeredBy] Information about the owner of the event (user name / apitoken / automatic action)
         * @param {OrganizationEventOrigin} [origin] 
         * @param {string} [projectId] Mandatory when requesting an environment or a service
         * @param {string} [environmentId] Mandatory when requesting a service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationEventTargets(organizationId: string, fromTimestamp?: string | null, toTimestamp?: string | null, eventType?: OrganizationEventType, targetType?: OrganizationEventTargetType, triggeredBy?: string, origin?: OrganizationEventOrigin, projectId?: string, environmentId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationEventTargetResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationEventTargets(organizationId, fromTimestamp, toTimestamp, eventType, targetType, triggeredBy, origin, projectId, environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all events inside the organization
         * @summary Get all events inside the organization
         * @param {string} organizationId Organization ID
         * @param {number | null} [pageSize] The number of events to display in the current page
         * @param {string | null} [fromTimestamp] Display events triggered since this timestamp.   A range of date can be specified by using &#x60;from-timestamp&#x60; with &#x60;to-timestamp&#x60; The format is a timestamp with nano precision 
         * @param {string | null} [toTimestamp] Display events triggered before this timestamp.   A range of date can be specified by using &#x60;to-timestamp&#x60; with &#x60;from-timestamp&#x60; The format is a timestamp with nano precision 
         * @param {string} [continueToken] Token used to fetch the next page results The format is a timestamp with nano precision 
         * @param {string} [stepBackToken] Token used to fetch the previous page results The format is a timestamp with nano precision 
         * @param {OrganizationEventType} [eventType] 
         * @param {OrganizationEventTargetType} [targetType] 
         * @param {string | null} [targetId] The target resource id to search.   Must be specified with the corresponding &#x60;target_type&#x60; 
         * @param {OrganizationEventSubTargetType} [subTargetType] 
         * @param {string} [triggeredBy] Information about the owner of the event (user name / apitoken / automatic action)
         * @param {OrganizationEventOrigin} [origin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationEvents(organizationId: string, pageSize?: number | null, fromTimestamp?: string | null, toTimestamp?: string | null, continueToken?: string, stepBackToken?: string, eventType?: OrganizationEventType, targetType?: OrganizationEventTargetType, targetId?: string | null, subTargetType?: OrganizationEventSubTargetType, triggeredBy?: string, origin?: OrganizationEventOrigin, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationEventResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationEvents(organizationId, pageSize, fromTimestamp, toTimestamp, continueToken, stepBackToken, eventType, targetType, targetId, subTargetType, triggeredBy, origin, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrganizationEventApi - factory interface
 * @export
 */
export const OrganizationEventApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationEventApiFp(configuration)
    return {
        /**
         * Get available event targets to filter events
         * @summary Get available event targets to filter events
         * @param {string} organizationId Organization ID
         * @param {string | null} [fromTimestamp] Display targets available since this timestamp.   A range of date can be specified by using &#x60;from-timestamp&#x60; with &#x60;to-timestamp&#x60; The format is a timestamp with nano precision 
         * @param {string | null} [toTimestamp] Display targets triggered before this timestamp.   A range of date can be specified by using &#x60;to-timestamp&#x60; with &#x60;from-timestamp&#x60; The format is a timestamp with nano precision 
         * @param {OrganizationEventType} [eventType] 
         * @param {OrganizationEventTargetType} [targetType] 
         * @param {string} [triggeredBy] Information about the owner of the event (user name / apitoken / automatic action)
         * @param {OrganizationEventOrigin} [origin] 
         * @param {string} [projectId] Mandatory when requesting an environment or a service
         * @param {string} [environmentId] Mandatory when requesting a service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationEventTargets(organizationId: string, fromTimestamp?: string | null, toTimestamp?: string | null, eventType?: OrganizationEventType, targetType?: OrganizationEventTargetType, triggeredBy?: string, origin?: OrganizationEventOrigin, projectId?: string, environmentId?: string, options?: any): AxiosPromise<OrganizationEventTargetResponseList> {
            return localVarFp.getOrganizationEventTargets(organizationId, fromTimestamp, toTimestamp, eventType, targetType, triggeredBy, origin, projectId, environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all events inside the organization
         * @summary Get all events inside the organization
         * @param {string} organizationId Organization ID
         * @param {number | null} [pageSize] The number of events to display in the current page
         * @param {string | null} [fromTimestamp] Display events triggered since this timestamp.   A range of date can be specified by using &#x60;from-timestamp&#x60; with &#x60;to-timestamp&#x60; The format is a timestamp with nano precision 
         * @param {string | null} [toTimestamp] Display events triggered before this timestamp.   A range of date can be specified by using &#x60;to-timestamp&#x60; with &#x60;from-timestamp&#x60; The format is a timestamp with nano precision 
         * @param {string} [continueToken] Token used to fetch the next page results The format is a timestamp with nano precision 
         * @param {string} [stepBackToken] Token used to fetch the previous page results The format is a timestamp with nano precision 
         * @param {OrganizationEventType} [eventType] 
         * @param {OrganizationEventTargetType} [targetType] 
         * @param {string | null} [targetId] The target resource id to search.   Must be specified with the corresponding &#x60;target_type&#x60; 
         * @param {OrganizationEventSubTargetType} [subTargetType] 
         * @param {string} [triggeredBy] Information about the owner of the event (user name / apitoken / automatic action)
         * @param {OrganizationEventOrigin} [origin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationEvents(organizationId: string, pageSize?: number | null, fromTimestamp?: string | null, toTimestamp?: string | null, continueToken?: string, stepBackToken?: string, eventType?: OrganizationEventType, targetType?: OrganizationEventTargetType, targetId?: string | null, subTargetType?: OrganizationEventSubTargetType, triggeredBy?: string, origin?: OrganizationEventOrigin, options?: any): AxiosPromise<OrganizationEventResponseList> {
            return localVarFp.getOrganizationEvents(organizationId, pageSize, fromTimestamp, toTimestamp, continueToken, stepBackToken, eventType, targetType, targetId, subTargetType, triggeredBy, origin, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationEventApi - object-oriented interface
 * @export
 * @class OrganizationEventApi
 * @extends {BaseAPI}
 */
export class OrganizationEventApi extends BaseAPI {
    /**
     * Get available event targets to filter events
     * @summary Get available event targets to filter events
     * @param {string} organizationId Organization ID
     * @param {string | null} [fromTimestamp] Display targets available since this timestamp.   A range of date can be specified by using &#x60;from-timestamp&#x60; with &#x60;to-timestamp&#x60; The format is a timestamp with nano precision 
     * @param {string | null} [toTimestamp] Display targets triggered before this timestamp.   A range of date can be specified by using &#x60;to-timestamp&#x60; with &#x60;from-timestamp&#x60; The format is a timestamp with nano precision 
     * @param {OrganizationEventType} [eventType] 
     * @param {OrganizationEventTargetType} [targetType] 
     * @param {string} [triggeredBy] Information about the owner of the event (user name / apitoken / automatic action)
     * @param {OrganizationEventOrigin} [origin] 
     * @param {string} [projectId] Mandatory when requesting an environment or a service
     * @param {string} [environmentId] Mandatory when requesting a service
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationEventApi
     */
    public getOrganizationEventTargets(organizationId: string, fromTimestamp?: string | null, toTimestamp?: string | null, eventType?: OrganizationEventType, targetType?: OrganizationEventTargetType, triggeredBy?: string, origin?: OrganizationEventOrigin, projectId?: string, environmentId?: string, options?: AxiosRequestConfig) {
        return OrganizationEventApiFp(this.configuration).getOrganizationEventTargets(organizationId, fromTimestamp, toTimestamp, eventType, targetType, triggeredBy, origin, projectId, environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all events inside the organization
     * @summary Get all events inside the organization
     * @param {string} organizationId Organization ID
     * @param {number | null} [pageSize] The number of events to display in the current page
     * @param {string | null} [fromTimestamp] Display events triggered since this timestamp.   A range of date can be specified by using &#x60;from-timestamp&#x60; with &#x60;to-timestamp&#x60; The format is a timestamp with nano precision 
     * @param {string | null} [toTimestamp] Display events triggered before this timestamp.   A range of date can be specified by using &#x60;to-timestamp&#x60; with &#x60;from-timestamp&#x60; The format is a timestamp with nano precision 
     * @param {string} [continueToken] Token used to fetch the next page results The format is a timestamp with nano precision 
     * @param {string} [stepBackToken] Token used to fetch the previous page results The format is a timestamp with nano precision 
     * @param {OrganizationEventType} [eventType] 
     * @param {OrganizationEventTargetType} [targetType] 
     * @param {string | null} [targetId] The target resource id to search.   Must be specified with the corresponding &#x60;target_type&#x60; 
     * @param {OrganizationEventSubTargetType} [subTargetType] 
     * @param {string} [triggeredBy] Information about the owner of the event (user name / apitoken / automatic action)
     * @param {OrganizationEventOrigin} [origin] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationEventApi
     */
    public getOrganizationEvents(organizationId: string, pageSize?: number | null, fromTimestamp?: string | null, toTimestamp?: string | null, continueToken?: string, stepBackToken?: string, eventType?: OrganizationEventType, targetType?: OrganizationEventTargetType, targetId?: string | null, subTargetType?: OrganizationEventSubTargetType, triggeredBy?: string, origin?: OrganizationEventOrigin, options?: AxiosRequestConfig) {
        return OrganizationEventApiFp(this.configuration).getOrganizationEvents(organizationId, pageSize, fromTimestamp, toTimestamp, continueToken, stepBackToken, eventType, targetType, targetId, subTargetType, triggeredBy, origin, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrganizationLabelsGroupApi - axios parameter creator
 * @export
 */
export const OrganizationLabelsGroupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an organization labels group
         * @summary Create an organization labels group
         * @param {string} organizationId Organization ID
         * @param {OrganizationLabelsGroupCreateRequest} [organizationLabelsGroupCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationLabelsGroup: async (organizationId: string, organizationLabelsGroupCreateRequest?: OrganizationLabelsGroupCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createOrganizationLabelsGroup', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/labelsGroups`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationLabelsGroupCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete organization labels group
         * @summary Delete organization labels group
         * @param {string} organizationId Organization ID
         * @param {string} labelsGroupId Organization labels group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationLabelsGroup: async (organizationId: string, labelsGroupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteOrganizationLabelsGroup', 'organizationId', organizationId)
            // verify required parameter 'labelsGroupId' is not null or undefined
            assertParamExists('deleteOrganizationLabelsGroup', 'labelsGroupId', labelsGroupId)
            const localVarPath = `/organization/{organizationId}/labelsGroups/{labelsGroupId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"labelsGroupId"}}`, encodeURIComponent(String(labelsGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit organization labels group
         * @summary Edit organization labels group
         * @param {string} organizationId Organization ID
         * @param {string} labelsGroupId Organization labels group ID
         * @param {OrganizationLabelsGroupCreateRequest} [organizationLabelsGroupCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editOrganizationLabelsGroup: async (organizationId: string, labelsGroupId: string, organizationLabelsGroupCreateRequest?: OrganizationLabelsGroupCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('editOrganizationLabelsGroup', 'organizationId', organizationId)
            // verify required parameter 'labelsGroupId' is not null or undefined
            assertParamExists('editOrganizationLabelsGroup', 'labelsGroupId', labelsGroupId)
            const localVarPath = `/organization/{organizationId}/labelsGroups/{labelsGroupId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"labelsGroupId"}}`, encodeURIComponent(String(labelsGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationLabelsGroupCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get organization labels group associated items
         * @summary Get organization labels group associated items
         * @param {string} organizationId Organization ID
         * @param {string} labelsGroupId Organization labels group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationLabelsGroupAssociatedItems: async (organizationId: string, labelsGroupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationLabelsGroupAssociatedItems', 'organizationId', organizationId)
            // verify required parameter 'labelsGroupId' is not null or undefined
            assertParamExists('getOrganizationLabelsGroupAssociatedItems', 'labelsGroupId', labelsGroupId)
            const localVarPath = `/organization/{organizationId}/labelsGroups/{labelsGroupId}/associatedItems`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"labelsGroupId"}}`, encodeURIComponent(String(labelsGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get organization labels group
         * @summary Get organization labels group
         * @param {string} organizationId Organization ID
         * @param {string} labelsGroupId Organization labels group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationLabelssGroup: async (organizationId: string, labelsGroupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationLabelssGroup', 'organizationId', organizationId)
            // verify required parameter 'labelsGroupId' is not null or undefined
            assertParamExists('getOrganizationLabelssGroup', 'labelsGroupId', labelsGroupId)
            const localVarPath = `/organization/{organizationId}/labelsGroups/{labelsGroupId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"labelsGroupId"}}`, encodeURIComponent(String(labelsGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List organization labels group
         * @summary List organization labels group
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationLabelsGroup: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listOrganizationLabelsGroup', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/labelsGroups`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationLabelsGroupApi - functional programming interface
 * @export
 */
export const OrganizationLabelsGroupApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationLabelsGroupApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an organization labels group
         * @summary Create an organization labels group
         * @param {string} organizationId Organization ID
         * @param {OrganizationLabelsGroupCreateRequest} [organizationLabelsGroupCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrganizationLabelsGroup(organizationId: string, organizationLabelsGroupCreateRequest?: OrganizationLabelsGroupCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationLabelsGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrganizationLabelsGroup(organizationId, organizationLabelsGroupCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete organization labels group
         * @summary Delete organization labels group
         * @param {string} organizationId Organization ID
         * @param {string} labelsGroupId Organization labels group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrganizationLabelsGroup(organizationId: string, labelsGroupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrganizationLabelsGroup(organizationId, labelsGroupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Edit organization labels group
         * @summary Edit organization labels group
         * @param {string} organizationId Organization ID
         * @param {string} labelsGroupId Organization labels group ID
         * @param {OrganizationLabelsGroupCreateRequest} [organizationLabelsGroupCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editOrganizationLabelsGroup(organizationId: string, labelsGroupId: string, organizationLabelsGroupCreateRequest?: OrganizationLabelsGroupCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationLabelsGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editOrganizationLabelsGroup(organizationId, labelsGroupId, organizationLabelsGroupCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get organization labels group associated items
         * @summary Get organization labels group associated items
         * @param {string} organizationId Organization ID
         * @param {string} labelsGroupId Organization labels group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationLabelsGroupAssociatedItems(organizationId: string, labelsGroupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationLabelsGroupAssociatedItemsResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationLabelsGroupAssociatedItems(organizationId, labelsGroupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get organization labels group
         * @summary Get organization labels group
         * @param {string} organizationId Organization ID
         * @param {string} labelsGroupId Organization labels group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationLabelssGroup(organizationId: string, labelsGroupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationLabelsGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationLabelssGroup(organizationId, labelsGroupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List organization labels group
         * @summary List organization labels group
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizationLabelsGroup(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOrganizationLabelsGroup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationLabelsGroup(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrganizationLabelsGroupApi - factory interface
 * @export
 */
export const OrganizationLabelsGroupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationLabelsGroupApiFp(configuration)
    return {
        /**
         * Create an organization labels group
         * @summary Create an organization labels group
         * @param {string} organizationId Organization ID
         * @param {OrganizationLabelsGroupCreateRequest} [organizationLabelsGroupCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationLabelsGroup(organizationId: string, organizationLabelsGroupCreateRequest?: OrganizationLabelsGroupCreateRequest, options?: any): AxiosPromise<OrganizationLabelsGroupResponse> {
            return localVarFp.createOrganizationLabelsGroup(organizationId, organizationLabelsGroupCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete organization labels group
         * @summary Delete organization labels group
         * @param {string} organizationId Organization ID
         * @param {string} labelsGroupId Organization labels group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationLabelsGroup(organizationId: string, labelsGroupId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteOrganizationLabelsGroup(organizationId, labelsGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit organization labels group
         * @summary Edit organization labels group
         * @param {string} organizationId Organization ID
         * @param {string} labelsGroupId Organization labels group ID
         * @param {OrganizationLabelsGroupCreateRequest} [organizationLabelsGroupCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editOrganizationLabelsGroup(organizationId: string, labelsGroupId: string, organizationLabelsGroupCreateRequest?: OrganizationLabelsGroupCreateRequest, options?: any): AxiosPromise<OrganizationLabelsGroupResponse> {
            return localVarFp.editOrganizationLabelsGroup(organizationId, labelsGroupId, organizationLabelsGroupCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get organization labels group associated items
         * @summary Get organization labels group associated items
         * @param {string} organizationId Organization ID
         * @param {string} labelsGroupId Organization labels group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationLabelsGroupAssociatedItems(organizationId: string, labelsGroupId: string, options?: any): AxiosPromise<OrganizationLabelsGroupAssociatedItemsResponseList> {
            return localVarFp.getOrganizationLabelsGroupAssociatedItems(organizationId, labelsGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get organization labels group
         * @summary Get organization labels group
         * @param {string} organizationId Organization ID
         * @param {string} labelsGroupId Organization labels group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationLabelssGroup(organizationId: string, labelsGroupId: string, options?: any): AxiosPromise<OrganizationLabelsGroupResponse> {
            return localVarFp.getOrganizationLabelssGroup(organizationId, labelsGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * List organization labels group
         * @summary List organization labels group
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationLabelsGroup(organizationId: string, options?: any): AxiosPromise<ListOrganizationLabelsGroup200Response> {
            return localVarFp.listOrganizationLabelsGroup(organizationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationLabelsGroupApi - object-oriented interface
 * @export
 * @class OrganizationLabelsGroupApi
 * @extends {BaseAPI}
 */
export class OrganizationLabelsGroupApi extends BaseAPI {
    /**
     * Create an organization labels group
     * @summary Create an organization labels group
     * @param {string} organizationId Organization ID
     * @param {OrganizationLabelsGroupCreateRequest} [organizationLabelsGroupCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationLabelsGroupApi
     */
    public createOrganizationLabelsGroup(organizationId: string, organizationLabelsGroupCreateRequest?: OrganizationLabelsGroupCreateRequest, options?: AxiosRequestConfig) {
        return OrganizationLabelsGroupApiFp(this.configuration).createOrganizationLabelsGroup(organizationId, organizationLabelsGroupCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete organization labels group
     * @summary Delete organization labels group
     * @param {string} organizationId Organization ID
     * @param {string} labelsGroupId Organization labels group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationLabelsGroupApi
     */
    public deleteOrganizationLabelsGroup(organizationId: string, labelsGroupId: string, options?: AxiosRequestConfig) {
        return OrganizationLabelsGroupApiFp(this.configuration).deleteOrganizationLabelsGroup(organizationId, labelsGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit organization labels group
     * @summary Edit organization labels group
     * @param {string} organizationId Organization ID
     * @param {string} labelsGroupId Organization labels group ID
     * @param {OrganizationLabelsGroupCreateRequest} [organizationLabelsGroupCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationLabelsGroupApi
     */
    public editOrganizationLabelsGroup(organizationId: string, labelsGroupId: string, organizationLabelsGroupCreateRequest?: OrganizationLabelsGroupCreateRequest, options?: AxiosRequestConfig) {
        return OrganizationLabelsGroupApiFp(this.configuration).editOrganizationLabelsGroup(organizationId, labelsGroupId, organizationLabelsGroupCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get organization labels group associated items
     * @summary Get organization labels group associated items
     * @param {string} organizationId Organization ID
     * @param {string} labelsGroupId Organization labels group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationLabelsGroupApi
     */
    public getOrganizationLabelsGroupAssociatedItems(organizationId: string, labelsGroupId: string, options?: AxiosRequestConfig) {
        return OrganizationLabelsGroupApiFp(this.configuration).getOrganizationLabelsGroupAssociatedItems(organizationId, labelsGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get organization labels group
     * @summary Get organization labels group
     * @param {string} organizationId Organization ID
     * @param {string} labelsGroupId Organization labels group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationLabelsGroupApi
     */
    public getOrganizationLabelssGroup(organizationId: string, labelsGroupId: string, options?: AxiosRequestConfig) {
        return OrganizationLabelsGroupApiFp(this.configuration).getOrganizationLabelssGroup(organizationId, labelsGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List organization labels group
     * @summary List organization labels group
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationLabelsGroupApi
     */
    public listOrganizationLabelsGroup(organizationId: string, options?: AxiosRequestConfig) {
        return OrganizationLabelsGroupApiFp(this.configuration).listOrganizationLabelsGroup(organizationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrganizationMainCallsApi - axios parameter creator
 * @export
 */
export const OrganizationMainCallsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new git token to be used as a git provider by a service
         * @summary Create a git token
         * @param {string} organizationId Organization ID
         * @param {GitTokenRequest} [gitTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGitToken: async (organizationId: string, gitTokenRequest?: GitTokenRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createGitToken', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/gitToken`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gitTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an organization
         * @param {OrganizationRequest} [organizationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganization: async (organizationRequest?: OrganizationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/organization`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a git token
         * @param {string} organizationId Organization ID
         * @param {string} gitTokenId Git Token ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGitToken: async (organizationId: string, gitTokenId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteGitToken', 'organizationId', organizationId)
            // verify required parameter 'gitTokenId' is not null or undefined
            assertParamExists('deleteGitToken', 'gitTokenId', gitTokenId)
            const localVarPath = `/organization/{organizationId}/gitToken/{gitTokenId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"gitTokenId"}}`, encodeURIComponent(String(gitTokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To delete an organization you must have the admin permission
         * @summary Delete an organization
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganization: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteOrganization', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a git token
         * @param {string} organizationId Organization ID
         * @param {string} gitTokenId Git Token ID
         * @param {GitTokenRequest} [gitTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editGitToken: async (organizationId: string, gitTokenId: string, gitTokenRequest?: GitTokenRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('editGitToken', 'organizationId', organizationId)
            // verify required parameter 'gitTokenId' is not null or undefined
            assertParamExists('editGitToken', 'gitTokenId', gitTokenId)
            const localVarPath = `/organization/{organizationId}/gitToken/{gitTokenId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"gitTokenId"}}`, encodeURIComponent(String(gitTokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gitTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To edit an organization you must have the admin permission
         * @summary Edit an organization
         * @param {string} organizationId Organization ID
         * @param {OrganizationEditRequest} [organizationEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editOrganization: async (organizationId: string, organizationEditRequest?: OrganizationEditRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('editOrganization', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get organization git tokens associated services
         * @summary Get organization git token associated services
         * @param {string} organizationId Organization ID
         * @param {string} gitTokenId Git Token ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGitTokenAssociatedServices: async (organizationId: string, gitTokenId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getGitTokenAssociatedServices', 'organizationId', organizationId)
            // verify required parameter 'gitTokenId' is not null or undefined
            assertParamExists('getGitTokenAssociatedServices', 'gitTokenId', gitTokenId)
            const localVarPath = `/organization/{organizationId}/gitToken/{gitTokenId}/associatedServices`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"gitTokenId"}}`, encodeURIComponent(String(gitTokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get organization by ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganization', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get organization git token
         * @summary Get organization git token
         * @param {string} organizationId Organization ID
         * @param {string} gitTokenId Git Token ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationGitToken: async (organizationId: string, gitTokenId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationGitToken', 'organizationId', organizationId)
            // verify required parameter 'gitTokenId' is not null or undefined
            assertParamExists('getOrganizationGitToken', 'gitTokenId', gitTokenId)
            const localVarPath = `/organization/{organizationId}/gitToken/{gitTokenId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"gitTokenId"}}`, encodeURIComponent(String(gitTokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List user organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganization: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/organization`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List organization available roles
         * @summary List organization available roles
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationAvailableRoles: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listOrganizationAvailableRoles', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/availableRole`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List organization git tokens
         * @summary List organization git tokens
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationGitTokens: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listOrganizationGitTokens', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/gitToken`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationMainCallsApi - functional programming interface
 * @export
 */
export const OrganizationMainCallsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationMainCallsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new git token to be used as a git provider by a service
         * @summary Create a git token
         * @param {string} organizationId Organization ID
         * @param {GitTokenRequest} [gitTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGitToken(organizationId: string, gitTokenRequest?: GitTokenRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGitToken(organizationId, gitTokenRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create an organization
         * @param {OrganizationRequest} [organizationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrganization(organizationRequest?: OrganizationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrganization(organizationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a git token
         * @param {string} organizationId Organization ID
         * @param {string} gitTokenId Git Token ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGitToken(organizationId: string, gitTokenId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGitToken(organizationId, gitTokenId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * To delete an organization you must have the admin permission
         * @summary Delete an organization
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrganization(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrganization(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit a git token
         * @param {string} organizationId Organization ID
         * @param {string} gitTokenId Git Token ID
         * @param {GitTokenRequest} [gitTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editGitToken(organizationId: string, gitTokenId: string, gitTokenRequest?: GitTokenRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editGitToken(organizationId, gitTokenId, gitTokenRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * To edit an organization you must have the admin permission
         * @summary Edit an organization
         * @param {string} organizationId Organization ID
         * @param {OrganizationEditRequest} [organizationEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editOrganization(organizationId: string, organizationEditRequest?: OrganizationEditRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editOrganization(organizationId, organizationEditRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get organization git tokens associated services
         * @summary Get organization git token associated services
         * @param {string} organizationId Organization ID
         * @param {string} gitTokenId Git Token ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGitTokenAssociatedServices(organizationId: string, gitTokenId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitTokenAssociatedServicesResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGitTokenAssociatedServices(organizationId, gitTokenId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get organization by ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganization(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganization(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get organization git token
         * @summary Get organization git token
         * @param {string} organizationId Organization ID
         * @param {string} gitTokenId Git Token ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationGitToken(organizationId: string, gitTokenId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationGitToken(organizationId, gitTokenId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List user organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganization(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganization(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List organization available roles
         * @summary List organization available roles
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizationAvailableRoles(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationAvailableRoleList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationAvailableRoles(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List organization git tokens
         * @summary List organization git tokens
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizationGitTokens(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitTokenResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationGitTokens(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrganizationMainCallsApi - factory interface
 * @export
 */
export const OrganizationMainCallsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationMainCallsApiFp(configuration)
    return {
        /**
         * Create a new git token to be used as a git provider by a service
         * @summary Create a git token
         * @param {string} organizationId Organization ID
         * @param {GitTokenRequest} [gitTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGitToken(organizationId: string, gitTokenRequest?: GitTokenRequest, options?: any): AxiosPromise<GitTokenResponse> {
            return localVarFp.createGitToken(organizationId, gitTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create an organization
         * @param {OrganizationRequest} [organizationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganization(organizationRequest?: OrganizationRequest, options?: any): AxiosPromise<Organization> {
            return localVarFp.createOrganization(organizationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a git token
         * @param {string} organizationId Organization ID
         * @param {string} gitTokenId Git Token ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGitToken(organizationId: string, gitTokenId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteGitToken(organizationId, gitTokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * To delete an organization you must have the admin permission
         * @summary Delete an organization
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganization(organizationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteOrganization(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a git token
         * @param {string} organizationId Organization ID
         * @param {string} gitTokenId Git Token ID
         * @param {GitTokenRequest} [gitTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editGitToken(organizationId: string, gitTokenId: string, gitTokenRequest?: GitTokenRequest, options?: any): AxiosPromise<GitTokenResponse> {
            return localVarFp.editGitToken(organizationId, gitTokenId, gitTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * To edit an organization you must have the admin permission
         * @summary Edit an organization
         * @param {string} organizationId Organization ID
         * @param {OrganizationEditRequest} [organizationEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editOrganization(organizationId: string, organizationEditRequest?: OrganizationEditRequest, options?: any): AxiosPromise<Organization> {
            return localVarFp.editOrganization(organizationId, organizationEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get organization git tokens associated services
         * @summary Get organization git token associated services
         * @param {string} organizationId Organization ID
         * @param {string} gitTokenId Git Token ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGitTokenAssociatedServices(organizationId: string, gitTokenId: string, options?: any): AxiosPromise<GitTokenAssociatedServicesResponseList> {
            return localVarFp.getGitTokenAssociatedServices(organizationId, gitTokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get organization by ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization(organizationId: string, options?: any): AxiosPromise<Organization> {
            return localVarFp.getOrganization(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get organization git token
         * @summary Get organization git token
         * @param {string} organizationId Organization ID
         * @param {string} gitTokenId Git Token ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationGitToken(organizationId: string, gitTokenId: string, options?: any): AxiosPromise<GitTokenResponse> {
            return localVarFp.getOrganizationGitToken(organizationId, gitTokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List user organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganization(options?: any): AxiosPromise<OrganizationResponseList> {
            return localVarFp.listOrganization(options).then((request) => request(axios, basePath));
        },
        /**
         * List organization available roles
         * @summary List organization available roles
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationAvailableRoles(organizationId: string, options?: any): AxiosPromise<OrganizationAvailableRoleList> {
            return localVarFp.listOrganizationAvailableRoles(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * List organization git tokens
         * @summary List organization git tokens
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationGitTokens(organizationId: string, options?: any): AxiosPromise<GitTokenResponseList> {
            return localVarFp.listOrganizationGitTokens(organizationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationMainCallsApi - object-oriented interface
 * @export
 * @class OrganizationMainCallsApi
 * @extends {BaseAPI}
 */
export class OrganizationMainCallsApi extends BaseAPI {
    /**
     * Create a new git token to be used as a git provider by a service
     * @summary Create a git token
     * @param {string} organizationId Organization ID
     * @param {GitTokenRequest} [gitTokenRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationMainCallsApi
     */
    public createGitToken(organizationId: string, gitTokenRequest?: GitTokenRequest, options?: AxiosRequestConfig) {
        return OrganizationMainCallsApiFp(this.configuration).createGitToken(organizationId, gitTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create an organization
     * @param {OrganizationRequest} [organizationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationMainCallsApi
     */
    public createOrganization(organizationRequest?: OrganizationRequest, options?: AxiosRequestConfig) {
        return OrganizationMainCallsApiFp(this.configuration).createOrganization(organizationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a git token
     * @param {string} organizationId Organization ID
     * @param {string} gitTokenId Git Token ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationMainCallsApi
     */
    public deleteGitToken(organizationId: string, gitTokenId: string, options?: AxiosRequestConfig) {
        return OrganizationMainCallsApiFp(this.configuration).deleteGitToken(organizationId, gitTokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To delete an organization you must have the admin permission
     * @summary Delete an organization
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationMainCallsApi
     */
    public deleteOrganization(organizationId: string, options?: AxiosRequestConfig) {
        return OrganizationMainCallsApiFp(this.configuration).deleteOrganization(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a git token
     * @param {string} organizationId Organization ID
     * @param {string} gitTokenId Git Token ID
     * @param {GitTokenRequest} [gitTokenRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationMainCallsApi
     */
    public editGitToken(organizationId: string, gitTokenId: string, gitTokenRequest?: GitTokenRequest, options?: AxiosRequestConfig) {
        return OrganizationMainCallsApiFp(this.configuration).editGitToken(organizationId, gitTokenId, gitTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To edit an organization you must have the admin permission
     * @summary Edit an organization
     * @param {string} organizationId Organization ID
     * @param {OrganizationEditRequest} [organizationEditRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationMainCallsApi
     */
    public editOrganization(organizationId: string, organizationEditRequest?: OrganizationEditRequest, options?: AxiosRequestConfig) {
        return OrganizationMainCallsApiFp(this.configuration).editOrganization(organizationId, organizationEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get organization git tokens associated services
     * @summary Get organization git token associated services
     * @param {string} organizationId Organization ID
     * @param {string} gitTokenId Git Token ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationMainCallsApi
     */
    public getGitTokenAssociatedServices(organizationId: string, gitTokenId: string, options?: AxiosRequestConfig) {
        return OrganizationMainCallsApiFp(this.configuration).getGitTokenAssociatedServices(organizationId, gitTokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get organization by ID
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationMainCallsApi
     */
    public getOrganization(organizationId: string, options?: AxiosRequestConfig) {
        return OrganizationMainCallsApiFp(this.configuration).getOrganization(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get organization git token
     * @summary Get organization git token
     * @param {string} organizationId Organization ID
     * @param {string} gitTokenId Git Token ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationMainCallsApi
     */
    public getOrganizationGitToken(organizationId: string, gitTokenId: string, options?: AxiosRequestConfig) {
        return OrganizationMainCallsApiFp(this.configuration).getOrganizationGitToken(organizationId, gitTokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List user organizations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationMainCallsApi
     */
    public listOrganization(options?: AxiosRequestConfig) {
        return OrganizationMainCallsApiFp(this.configuration).listOrganization(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List organization available roles
     * @summary List organization available roles
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationMainCallsApi
     */
    public listOrganizationAvailableRoles(organizationId: string, options?: AxiosRequestConfig) {
        return OrganizationMainCallsApiFp(this.configuration).listOrganizationAvailableRoles(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List organization git tokens
     * @summary List organization git tokens
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationMainCallsApi
     */
    public listOrganizationGitTokens(organizationId: string, options?: AxiosRequestConfig) {
        return OrganizationMainCallsApiFp(this.configuration).listOrganizationGitTokens(organizationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrganizationWebhookApi - axios parameter creator
 * @export
 */
export const OrganizationWebhookApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an organization webhook.
         * @summary Create an organization webhook
         * @param {string} organizationId Organization ID
         * @param {OrganizationWebhookCreateRequest} [organizationWebhookCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationWebhook: async (organizationId: string, organizationWebhookCreateRequest?: OrganizationWebhookCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createOrganizationWebhook', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/webhook`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationWebhookCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete organization webhook
         * @summary Delete organization webhook
         * @param {string} organizationId Organization ID
         * @param {string} webhookId Webhook ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationWebhook: async (organizationId: string, webhookId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteOrganizationWebhook', 'organizationId', organizationId)
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('deleteOrganizationWebhook', 'webhookId', webhookId)
            const localVarPath = `/organization/{organizationId}/webhook/{webhookId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit an organization webhook
         * @summary Edit an organization webhook
         * @param {string} organizationId Organization ID
         * @param {string} webhookId Webhook ID
         * @param {OrganizationWebhookCreateRequest} [organizationWebhookCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editOrganizationWebhook: async (organizationId: string, webhookId: string, organizationWebhookCreateRequest?: OrganizationWebhookCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('editOrganizationWebhook', 'organizationId', organizationId)
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('editOrganizationWebhook', 'webhookId', webhookId)
            const localVarPath = `/organization/{organizationId}/webhook/{webhookId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationWebhookCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an Organization webhook
         * @summary Get an Organization webhook
         * @param {string} organizationId Organization ID
         * @param {string} webhookId Webhook ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationWebhook: async (organizationId: string, webhookId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationWebhook', 'organizationId', organizationId)
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('getOrganizationWebhook', 'webhookId', webhookId)
            const localVarPath = `/organization/{organizationId}/webhook/{webhookId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List organization webhooks
         * @summary List organization webhooks
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationWebHooks: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listOrganizationWebHooks', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/webhook`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationWebhookApi - functional programming interface
 * @export
 */
export const OrganizationWebhookApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationWebhookApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an organization webhook.
         * @summary Create an organization webhook
         * @param {string} organizationId Organization ID
         * @param {OrganizationWebhookCreateRequest} [organizationWebhookCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrganizationWebhook(organizationId: string, organizationWebhookCreateRequest?: OrganizationWebhookCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationWebhookCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrganizationWebhook(organizationId, organizationWebhookCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete organization webhook
         * @summary Delete organization webhook
         * @param {string} organizationId Organization ID
         * @param {string} webhookId Webhook ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrganizationWebhook(organizationId: string, webhookId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrganizationWebhook(organizationId, webhookId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Edit an organization webhook
         * @summary Edit an organization webhook
         * @param {string} organizationId Organization ID
         * @param {string} webhookId Webhook ID
         * @param {OrganizationWebhookCreateRequest} [organizationWebhookCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editOrganizationWebhook(organizationId: string, webhookId: string, organizationWebhookCreateRequest?: OrganizationWebhookCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationWebhookCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editOrganizationWebhook(organizationId, webhookId, organizationWebhookCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get an Organization webhook
         * @summary Get an Organization webhook
         * @param {string} organizationId Organization ID
         * @param {string} webhookId Webhook ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationWebhook(organizationId: string, webhookId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationWebhookResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationWebhook(organizationId, webhookId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List organization webhooks
         * @summary List organization webhooks
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizationWebHooks(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationWebhookResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationWebHooks(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrganizationWebhookApi - factory interface
 * @export
 */
export const OrganizationWebhookApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationWebhookApiFp(configuration)
    return {
        /**
         * Create an organization webhook.
         * @summary Create an organization webhook
         * @param {string} organizationId Organization ID
         * @param {OrganizationWebhookCreateRequest} [organizationWebhookCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationWebhook(organizationId: string, organizationWebhookCreateRequest?: OrganizationWebhookCreateRequest, options?: any): AxiosPromise<OrganizationWebhookCreateResponse> {
            return localVarFp.createOrganizationWebhook(organizationId, organizationWebhookCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete organization webhook
         * @summary Delete organization webhook
         * @param {string} organizationId Organization ID
         * @param {string} webhookId Webhook ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationWebhook(organizationId: string, webhookId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteOrganizationWebhook(organizationId, webhookId, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit an organization webhook
         * @summary Edit an organization webhook
         * @param {string} organizationId Organization ID
         * @param {string} webhookId Webhook ID
         * @param {OrganizationWebhookCreateRequest} [organizationWebhookCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editOrganizationWebhook(organizationId: string, webhookId: string, organizationWebhookCreateRequest?: OrganizationWebhookCreateRequest, options?: any): AxiosPromise<OrganizationWebhookCreateResponse> {
            return localVarFp.editOrganizationWebhook(organizationId, webhookId, organizationWebhookCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an Organization webhook
         * @summary Get an Organization webhook
         * @param {string} organizationId Organization ID
         * @param {string} webhookId Webhook ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationWebhook(organizationId: string, webhookId: string, options?: any): AxiosPromise<OrganizationWebhookResponse> {
            return localVarFp.getOrganizationWebhook(organizationId, webhookId, options).then((request) => request(axios, basePath));
        },
        /**
         * List organization webhooks
         * @summary List organization webhooks
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationWebHooks(organizationId: string, options?: any): AxiosPromise<OrganizationWebhookResponseList> {
            return localVarFp.listOrganizationWebHooks(organizationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationWebhookApi - object-oriented interface
 * @export
 * @class OrganizationWebhookApi
 * @extends {BaseAPI}
 */
export class OrganizationWebhookApi extends BaseAPI {
    /**
     * Create an organization webhook.
     * @summary Create an organization webhook
     * @param {string} organizationId Organization ID
     * @param {OrganizationWebhookCreateRequest} [organizationWebhookCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationWebhookApi
     */
    public createOrganizationWebhook(organizationId: string, organizationWebhookCreateRequest?: OrganizationWebhookCreateRequest, options?: AxiosRequestConfig) {
        return OrganizationWebhookApiFp(this.configuration).createOrganizationWebhook(organizationId, organizationWebhookCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete organization webhook
     * @summary Delete organization webhook
     * @param {string} organizationId Organization ID
     * @param {string} webhookId Webhook ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationWebhookApi
     */
    public deleteOrganizationWebhook(organizationId: string, webhookId: string, options?: AxiosRequestConfig) {
        return OrganizationWebhookApiFp(this.configuration).deleteOrganizationWebhook(organizationId, webhookId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit an organization webhook
     * @summary Edit an organization webhook
     * @param {string} organizationId Organization ID
     * @param {string} webhookId Webhook ID
     * @param {OrganizationWebhookCreateRequest} [organizationWebhookCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationWebhookApi
     */
    public editOrganizationWebhook(organizationId: string, webhookId: string, organizationWebhookCreateRequest?: OrganizationWebhookCreateRequest, options?: AxiosRequestConfig) {
        return OrganizationWebhookApiFp(this.configuration).editOrganizationWebhook(organizationId, webhookId, organizationWebhookCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an Organization webhook
     * @summary Get an Organization webhook
     * @param {string} organizationId Organization ID
     * @param {string} webhookId Webhook ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationWebhookApi
     */
    public getOrganizationWebhook(organizationId: string, webhookId: string, options?: AxiosRequestConfig) {
        return OrganizationWebhookApiFp(this.configuration).getOrganizationWebhook(organizationId, webhookId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List organization webhooks
     * @summary List organization webhooks
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationWebhookApi
     */
    public listOrganizationWebHooks(organizationId: string, options?: AxiosRequestConfig) {
        return OrganizationWebhookApiFp(this.configuration).listOrganizationWebHooks(organizationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProjectDeploymentRuleApi - axios parameter creator
 * @export
 */
export const ProjectDeploymentRuleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a deployment rule
         * @summary Create a deployment rule
         * @param {string} projectId Project ID
         * @param {ProjectDeploymentRuleRequest} [projectDeploymentRuleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeploymentRule: async (projectId: string, projectDeploymentRuleRequest?: ProjectDeploymentRuleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createDeploymentRule', 'projectId', projectId)
            const localVarPath = `/project/{projectId}/deploymentRule`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectDeploymentRuleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a project deployment rule
         * @summary Delete a project deployment rule
         * @param {string} projectId Project ID
         * @param {string} deploymentRuleId Deployment Rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectDeploymentRule: async (projectId: string, deploymentRuleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteProjectDeploymentRule', 'projectId', projectId)
            // verify required parameter 'deploymentRuleId' is not null or undefined
            assertParamExists('deleteProjectDeploymentRule', 'deploymentRuleId', deploymentRuleId)
            const localVarPath = `/project/{projectId}/deploymentRule/{deploymentRuleId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"deploymentRuleId"}}`, encodeURIComponent(String(deploymentRuleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit a project deployment rule
         * @summary Edit a project deployment rule
         * @param {string} projectId Project ID
         * @param {string} deploymentRuleId Deployment Rule ID
         * @param {ProjectDeploymentRuleRequest} [projectDeploymentRuleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editProjectDeployemtnRule: async (projectId: string, deploymentRuleId: string, projectDeploymentRuleRequest?: ProjectDeploymentRuleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('editProjectDeployemtnRule', 'projectId', projectId)
            // verify required parameter 'deploymentRuleId' is not null or undefined
            assertParamExists('editProjectDeployemtnRule', 'deploymentRuleId', deploymentRuleId)
            const localVarPath = `/project/{projectId}/deploymentRule/{deploymentRuleId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"deploymentRuleId"}}`, encodeURIComponent(String(deploymentRuleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectDeploymentRuleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a project deployment rule
         * @summary Get a project deployment rule
         * @param {string} projectId Project ID
         * @param {string} deploymentRuleId Deployment Rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectDeploymentRule: async (projectId: string, deploymentRuleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getProjectDeploymentRule', 'projectId', projectId)
            // verify required parameter 'deploymentRuleId' is not null or undefined
            assertParamExists('getProjectDeploymentRule', 'deploymentRuleId', deploymentRuleId)
            const localVarPath = `/project/{projectId}/deploymentRule/{deploymentRuleId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"deploymentRuleId"}}`, encodeURIComponent(String(deploymentRuleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List project deployment rules
         * @summary List project deployment rules
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectDeploymentRules: async (projectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('listProjectDeploymentRules', 'projectId', projectId)
            const localVarPath = `/project/{projectId}/deploymentRule`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update deployment rules priority order
         * @summary Update deployment rules priority order
         * @param {string} projectId Project ID
         * @param {ProjectDeploymentRulesPriorityOrderRequest} [projectDeploymentRulesPriorityOrderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeploymentRulesPriorityOrder: async (projectId: string, projectDeploymentRulesPriorityOrderRequest?: ProjectDeploymentRulesPriorityOrderRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateDeploymentRulesPriorityOrder', 'projectId', projectId)
            const localVarPath = `/project/{projectId}/deploymentRule/order`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectDeploymentRulesPriorityOrderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectDeploymentRuleApi - functional programming interface
 * @export
 */
export const ProjectDeploymentRuleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectDeploymentRuleApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a deployment rule
         * @summary Create a deployment rule
         * @param {string} projectId Project ID
         * @param {ProjectDeploymentRuleRequest} [projectDeploymentRuleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDeploymentRule(projectId: string, projectDeploymentRuleRequest?: ProjectDeploymentRuleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectDeploymentRule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDeploymentRule(projectId, projectDeploymentRuleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a project deployment rule
         * @summary Delete a project deployment rule
         * @param {string} projectId Project ID
         * @param {string} deploymentRuleId Deployment Rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProjectDeploymentRule(projectId: string, deploymentRuleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProjectDeploymentRule(projectId, deploymentRuleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Edit a project deployment rule
         * @summary Edit a project deployment rule
         * @param {string} projectId Project ID
         * @param {string} deploymentRuleId Deployment Rule ID
         * @param {ProjectDeploymentRuleRequest} [projectDeploymentRuleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editProjectDeployemtnRule(projectId: string, deploymentRuleId: string, projectDeploymentRuleRequest?: ProjectDeploymentRuleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectDeploymentRule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editProjectDeployemtnRule(projectId, deploymentRuleId, projectDeploymentRuleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a project deployment rule
         * @summary Get a project deployment rule
         * @param {string} projectId Project ID
         * @param {string} deploymentRuleId Deployment Rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjectDeploymentRule(projectId: string, deploymentRuleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectDeploymentRule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectDeploymentRule(projectId, deploymentRuleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List project deployment rules
         * @summary List project deployment rules
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProjectDeploymentRules(projectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectDeploymentRuleResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProjectDeploymentRules(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update deployment rules priority order
         * @summary Update deployment rules priority order
         * @param {string} projectId Project ID
         * @param {ProjectDeploymentRulesPriorityOrderRequest} [projectDeploymentRulesPriorityOrderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDeploymentRulesPriorityOrder(projectId: string, projectDeploymentRulesPriorityOrderRequest?: ProjectDeploymentRulesPriorityOrderRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDeploymentRulesPriorityOrder(projectId, projectDeploymentRulesPriorityOrderRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectDeploymentRuleApi - factory interface
 * @export
 */
export const ProjectDeploymentRuleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectDeploymentRuleApiFp(configuration)
    return {
        /**
         * Create a deployment rule
         * @summary Create a deployment rule
         * @param {string} projectId Project ID
         * @param {ProjectDeploymentRuleRequest} [projectDeploymentRuleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeploymentRule(projectId: string, projectDeploymentRuleRequest?: ProjectDeploymentRuleRequest, options?: any): AxiosPromise<ProjectDeploymentRule> {
            return localVarFp.createDeploymentRule(projectId, projectDeploymentRuleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a project deployment rule
         * @summary Delete a project deployment rule
         * @param {string} projectId Project ID
         * @param {string} deploymentRuleId Deployment Rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectDeploymentRule(projectId: string, deploymentRuleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteProjectDeploymentRule(projectId, deploymentRuleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit a project deployment rule
         * @summary Edit a project deployment rule
         * @param {string} projectId Project ID
         * @param {string} deploymentRuleId Deployment Rule ID
         * @param {ProjectDeploymentRuleRequest} [projectDeploymentRuleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editProjectDeployemtnRule(projectId: string, deploymentRuleId: string, projectDeploymentRuleRequest?: ProjectDeploymentRuleRequest, options?: any): AxiosPromise<ProjectDeploymentRule> {
            return localVarFp.editProjectDeployemtnRule(projectId, deploymentRuleId, projectDeploymentRuleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a project deployment rule
         * @summary Get a project deployment rule
         * @param {string} projectId Project ID
         * @param {string} deploymentRuleId Deployment Rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectDeploymentRule(projectId: string, deploymentRuleId: string, options?: any): AxiosPromise<ProjectDeploymentRule> {
            return localVarFp.getProjectDeploymentRule(projectId, deploymentRuleId, options).then((request) => request(axios, basePath));
        },
        /**
         * List project deployment rules
         * @summary List project deployment rules
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectDeploymentRules(projectId: string, options?: any): AxiosPromise<ProjectDeploymentRuleResponseList> {
            return localVarFp.listProjectDeploymentRules(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update deployment rules priority order
         * @summary Update deployment rules priority order
         * @param {string} projectId Project ID
         * @param {ProjectDeploymentRulesPriorityOrderRequest} [projectDeploymentRulesPriorityOrderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeploymentRulesPriorityOrder(projectId: string, projectDeploymentRulesPriorityOrderRequest?: ProjectDeploymentRulesPriorityOrderRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateDeploymentRulesPriorityOrder(projectId, projectDeploymentRulesPriorityOrderRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectDeploymentRuleApi - object-oriented interface
 * @export
 * @class ProjectDeploymentRuleApi
 * @extends {BaseAPI}
 */
export class ProjectDeploymentRuleApi extends BaseAPI {
    /**
     * Create a deployment rule
     * @summary Create a deployment rule
     * @param {string} projectId Project ID
     * @param {ProjectDeploymentRuleRequest} [projectDeploymentRuleRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDeploymentRuleApi
     */
    public createDeploymentRule(projectId: string, projectDeploymentRuleRequest?: ProjectDeploymentRuleRequest, options?: AxiosRequestConfig) {
        return ProjectDeploymentRuleApiFp(this.configuration).createDeploymentRule(projectId, projectDeploymentRuleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a project deployment rule
     * @summary Delete a project deployment rule
     * @param {string} projectId Project ID
     * @param {string} deploymentRuleId Deployment Rule ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDeploymentRuleApi
     */
    public deleteProjectDeploymentRule(projectId: string, deploymentRuleId: string, options?: AxiosRequestConfig) {
        return ProjectDeploymentRuleApiFp(this.configuration).deleteProjectDeploymentRule(projectId, deploymentRuleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit a project deployment rule
     * @summary Edit a project deployment rule
     * @param {string} projectId Project ID
     * @param {string} deploymentRuleId Deployment Rule ID
     * @param {ProjectDeploymentRuleRequest} [projectDeploymentRuleRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDeploymentRuleApi
     */
    public editProjectDeployemtnRule(projectId: string, deploymentRuleId: string, projectDeploymentRuleRequest?: ProjectDeploymentRuleRequest, options?: AxiosRequestConfig) {
        return ProjectDeploymentRuleApiFp(this.configuration).editProjectDeployemtnRule(projectId, deploymentRuleId, projectDeploymentRuleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a project deployment rule
     * @summary Get a project deployment rule
     * @param {string} projectId Project ID
     * @param {string} deploymentRuleId Deployment Rule ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDeploymentRuleApi
     */
    public getProjectDeploymentRule(projectId: string, deploymentRuleId: string, options?: AxiosRequestConfig) {
        return ProjectDeploymentRuleApiFp(this.configuration).getProjectDeploymentRule(projectId, deploymentRuleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List project deployment rules
     * @summary List project deployment rules
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDeploymentRuleApi
     */
    public listProjectDeploymentRules(projectId: string, options?: AxiosRequestConfig) {
        return ProjectDeploymentRuleApiFp(this.configuration).listProjectDeploymentRules(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update deployment rules priority order
     * @summary Update deployment rules priority order
     * @param {string} projectId Project ID
     * @param {ProjectDeploymentRulesPriorityOrderRequest} [projectDeploymentRulesPriorityOrderRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDeploymentRuleApi
     */
    public updateDeploymentRulesPriorityOrder(projectId: string, projectDeploymentRulesPriorityOrderRequest?: ProjectDeploymentRulesPriorityOrderRequest, options?: AxiosRequestConfig) {
        return ProjectDeploymentRuleApiFp(this.configuration).updateDeploymentRulesPriorityOrder(projectId, projectDeploymentRulesPriorityOrderRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProjectEnvironmentVariableApi - axios parameter creator
 * @export
 */
export const ProjectEnvironmentVariableApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * - Add an environment variable to the project.   - If the environment variable key already exists, then it will be replaced by the new one.   - If the environment variable value points toward an existing environment variable key, it will be considered as an alias. 
         * @summary Add an environment variable to the project
         * @param {string} projectId Project ID
         * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectEnvironmentVariable: async (projectId: string, environmentVariableRequest?: EnvironmentVariableRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createProjectEnvironmentVariable', 'projectId', projectId)
            const localVarPath = `/project/{projectId}/environmentVariable`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentVariableRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to add an alias at project level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at project level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - You can\'t create an alias on an alias 
         * @summary Create an environment variable alias at the project level
         * @param {string} projectId Project ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectEnvironmentVariableAlias: async (projectId: string, environmentVariableId: string, key?: Key, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createProjectEnvironmentVariableAlias', 'projectId', projectId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('createProjectEnvironmentVariableAlias', 'environmentVariableId', environmentVariableId)
            const localVarPath = `/project/{projectId}/environmentVariable/{environmentVariableId}/alias`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(key, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to override at project level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at project level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
         * @summary Create an environment variable override at the project level
         * @param {string} projectId Project ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectEnvironmentVariableOverride: async (projectId: string, environmentVariableId: string, value?: Value, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createProjectEnvironmentVariableOverride', 'projectId', projectId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('createProjectEnvironmentVariableOverride', 'environmentVariableId', environmentVariableId)
            const localVarPath = `/project/{projectId}/environmentVariable/{environmentVariableId}/override`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(value, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - To delete an environment variable you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete an environment variable from a project
         * @param {string} projectId Project ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectEnvironmentVariable: async (projectId: string, environmentVariableId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteProjectEnvironmentVariable', 'projectId', projectId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('deleteProjectEnvironmentVariable', 'environmentVariableId', environmentVariableId)
            const localVarPath = `/project/{projectId}/environmentVariable/{environmentVariableId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit an environment variable belonging to the project
         * @param {string} projectId Project ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editProjectEnvironmentVariable: async (projectId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('editProjectEnvironmentVariable', 'projectId', projectId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('editProjectEnvironmentVariable', 'environmentVariableId', environmentVariableId)
            // verify required parameter 'environmentVariableEditRequest' is not null or undefined
            assertParamExists('editProjectEnvironmentVariable', 'environmentVariableEditRequest', environmentVariableEditRequest)
            const localVarPath = `/project/{projectId}/environmentVariable/{environmentVariableId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentVariableEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List project environment variables
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectEnvironmentVariable: async (projectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('listProjectEnvironmentVariable', 'projectId', projectId)
            const localVarPath = `/project/{projectId}/environmentVariable`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectEnvironmentVariableApi - functional programming interface
 * @export
 */
export const ProjectEnvironmentVariableApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectEnvironmentVariableApiAxiosParamCreator(configuration)
    return {
        /**
         * - Add an environment variable to the project.   - If the environment variable key already exists, then it will be replaced by the new one.   - If the environment variable value points toward an existing environment variable key, it will be considered as an alias. 
         * @summary Add an environment variable to the project
         * @param {string} projectId Project ID
         * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProjectEnvironmentVariable(projectId: string, environmentVariableRequest?: EnvironmentVariableRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProjectEnvironmentVariable(projectId, environmentVariableRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - Allows you to add an alias at project level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at project level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - You can\'t create an alias on an alias 
         * @summary Create an environment variable alias at the project level
         * @param {string} projectId Project ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProjectEnvironmentVariableAlias(projectId: string, environmentVariableId: string, key?: Key, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProjectEnvironmentVariableAlias(projectId, environmentVariableId, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - Allows you to override at project level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at project level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
         * @summary Create an environment variable override at the project level
         * @param {string} projectId Project ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProjectEnvironmentVariableOverride(projectId: string, environmentVariableId: string, value?: Value, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProjectEnvironmentVariableOverride(projectId, environmentVariableId, value, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - To delete an environment variable you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete an environment variable from a project
         * @param {string} projectId Project ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProjectEnvironmentVariable(projectId: string, environmentVariableId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProjectEnvironmentVariable(projectId, environmentVariableId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit an environment variable belonging to the project
         * @param {string} projectId Project ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editProjectEnvironmentVariable(projectId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editProjectEnvironmentVariable(projectId, environmentVariableId, environmentVariableEditRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List project environment variables
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProjectEnvironmentVariable(projectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariableResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProjectEnvironmentVariable(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectEnvironmentVariableApi - factory interface
 * @export
 */
export const ProjectEnvironmentVariableApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectEnvironmentVariableApiFp(configuration)
    return {
        /**
         * - Add an environment variable to the project.   - If the environment variable key already exists, then it will be replaced by the new one.   - If the environment variable value points toward an existing environment variable key, it will be considered as an alias. 
         * @summary Add an environment variable to the project
         * @param {string} projectId Project ID
         * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectEnvironmentVariable(projectId: string, environmentVariableRequest?: EnvironmentVariableRequest, options?: any): AxiosPromise<EnvironmentVariable> {
            return localVarFp.createProjectEnvironmentVariable(projectId, environmentVariableRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to add an alias at project level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at project level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - You can\'t create an alias on an alias 
         * @summary Create an environment variable alias at the project level
         * @param {string} projectId Project ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectEnvironmentVariableAlias(projectId: string, environmentVariableId: string, key?: Key, options?: any): AxiosPromise<EnvironmentVariable> {
            return localVarFp.createProjectEnvironmentVariableAlias(projectId, environmentVariableId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to override at project level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at project level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
         * @summary Create an environment variable override at the project level
         * @param {string} projectId Project ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectEnvironmentVariableOverride(projectId: string, environmentVariableId: string, value?: Value, options?: any): AxiosPromise<EnvironmentVariable> {
            return localVarFp.createProjectEnvironmentVariableOverride(projectId, environmentVariableId, value, options).then((request) => request(axios, basePath));
        },
        /**
         * - To delete an environment variable you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete an environment variable from a project
         * @param {string} projectId Project ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectEnvironmentVariable(projectId: string, environmentVariableId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteProjectEnvironmentVariable(projectId, environmentVariableId, options).then((request) => request(axios, basePath));
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit an environment variable belonging to the project
         * @param {string} projectId Project ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editProjectEnvironmentVariable(projectId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options?: any): AxiosPromise<EnvironmentVariable> {
            return localVarFp.editProjectEnvironmentVariable(projectId, environmentVariableId, environmentVariableEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List project environment variables
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectEnvironmentVariable(projectId: string, options?: any): AxiosPromise<EnvironmentVariableResponseList> {
            return localVarFp.listProjectEnvironmentVariable(projectId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectEnvironmentVariableApi - object-oriented interface
 * @export
 * @class ProjectEnvironmentVariableApi
 * @extends {BaseAPI}
 */
export class ProjectEnvironmentVariableApi extends BaseAPI {
    /**
     * - Add an environment variable to the project.   - If the environment variable key already exists, then it will be replaced by the new one.   - If the environment variable value points toward an existing environment variable key, it will be considered as an alias. 
     * @summary Add an environment variable to the project
     * @param {string} projectId Project ID
     * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectEnvironmentVariableApi
     */
    public createProjectEnvironmentVariable(projectId: string, environmentVariableRequest?: EnvironmentVariableRequest, options?: AxiosRequestConfig) {
        return ProjectEnvironmentVariableApiFp(this.configuration).createProjectEnvironmentVariable(projectId, environmentVariableRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to add an alias at project level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at project level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - You can\'t create an alias on an alias 
     * @summary Create an environment variable alias at the project level
     * @param {string} projectId Project ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {Key} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectEnvironmentVariableApi
     */
    public createProjectEnvironmentVariableAlias(projectId: string, environmentVariableId: string, key?: Key, options?: AxiosRequestConfig) {
        return ProjectEnvironmentVariableApiFp(this.configuration).createProjectEnvironmentVariableAlias(projectId, environmentVariableId, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to override at project level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at project level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
     * @summary Create an environment variable override at the project level
     * @param {string} projectId Project ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {Value} [value] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectEnvironmentVariableApi
     */
    public createProjectEnvironmentVariableOverride(projectId: string, environmentVariableId: string, value?: Value, options?: AxiosRequestConfig) {
        return ProjectEnvironmentVariableApiFp(this.configuration).createProjectEnvironmentVariableOverride(projectId, environmentVariableId, value, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - To delete an environment variable you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
     * @summary Delete an environment variable from a project
     * @param {string} projectId Project ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectEnvironmentVariableApi
     */
    public deleteProjectEnvironmentVariable(projectId: string, environmentVariableId: string, options?: AxiosRequestConfig) {
        return ProjectEnvironmentVariableApiFp(this.configuration).deleteProjectEnvironmentVariable(projectId, environmentVariableId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
     * @summary Edit an environment variable belonging to the project
     * @param {string} projectId Project ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectEnvironmentVariableApi
     */
    public editProjectEnvironmentVariable(projectId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options?: AxiosRequestConfig) {
        return ProjectEnvironmentVariableApiFp(this.configuration).editProjectEnvironmentVariable(projectId, environmentVariableId, environmentVariableEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List project environment variables
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectEnvironmentVariableApi
     */
    public listProjectEnvironmentVariable(projectId: string, options?: AxiosRequestConfig) {
        return ProjectEnvironmentVariableApiFp(this.configuration).listProjectEnvironmentVariable(projectId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProjectMainCallsApi - axios parameter creator
 * @export
 */
export const ProjectMainCallsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * To delete a project you must have the admin permission
         * @summary Delete a project
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject: async (projectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteProject', 'projectId', projectId)
            const localVarPath = `/project/{projectId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To edit a project you must have the admin permission
         * @summary Edit a project
         * @param {string} projectId Project ID
         * @param {ProjectRequest} [projectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editProject: async (projectId: string, projectRequest?: ProjectRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('editProject', 'projectId', projectId)
            const localVarPath = `/project/{projectId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get project by ID
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject: async (projectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getProject', 'projectId', projectId)
            const localVarPath = `/project/{projectId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectMainCallsApi - functional programming interface
 * @export
 */
export const ProjectMainCallsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectMainCallsApiAxiosParamCreator(configuration)
    return {
        /**
         * To delete a project you must have the admin permission
         * @summary Delete a project
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProject(projectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProject(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * To edit a project you must have the admin permission
         * @summary Edit a project
         * @param {string} projectId Project ID
         * @param {ProjectRequest} [projectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editProject(projectId: string, projectRequest?: ProjectRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editProject(projectId, projectRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get project by ID
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProject(projectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProject(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectMainCallsApi - factory interface
 * @export
 */
export const ProjectMainCallsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectMainCallsApiFp(configuration)
    return {
        /**
         * To delete a project you must have the admin permission
         * @summary Delete a project
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject(projectId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteProject(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * To edit a project you must have the admin permission
         * @summary Edit a project
         * @param {string} projectId Project ID
         * @param {ProjectRequest} [projectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editProject(projectId: string, projectRequest?: ProjectRequest, options?: any): AxiosPromise<Project> {
            return localVarFp.editProject(projectId, projectRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get project by ID
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject(projectId: string, options?: any): AxiosPromise<Project> {
            return localVarFp.getProject(projectId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectMainCallsApi - object-oriented interface
 * @export
 * @class ProjectMainCallsApi
 * @extends {BaseAPI}
 */
export class ProjectMainCallsApi extends BaseAPI {
    /**
     * To delete a project you must have the admin permission
     * @summary Delete a project
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectMainCallsApi
     */
    public deleteProject(projectId: string, options?: AxiosRequestConfig) {
        return ProjectMainCallsApiFp(this.configuration).deleteProject(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To edit a project you must have the admin permission
     * @summary Edit a project
     * @param {string} projectId Project ID
     * @param {ProjectRequest} [projectRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectMainCallsApi
     */
    public editProject(projectId: string, projectRequest?: ProjectRequest, options?: AxiosRequestConfig) {
        return ProjectMainCallsApiFp(this.configuration).editProject(projectId, projectRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get project by ID
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectMainCallsApi
     */
    public getProject(projectId: string, options?: AxiosRequestConfig) {
        return ProjectMainCallsApiFp(this.configuration).getProject(projectId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProjectSecretApi - axios parameter creator
 * @export
 */
export const ProjectSecretApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * - Add a secret to the project.   - If the secret key already exists, then it will be replaced by the new one.   - If the secret value points toward an existing secret key, it will be considered as an alias. 
         * @summary Add a secret to the project
         * @param {string} projectId Project ID
         * @param {SecretRequest} [secretRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectSecret: async (projectId: string, secretRequest?: SecretRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createProjectSecret', 'projectId', projectId)
            const localVarPath = `/project/{projectId}/secret`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(secretRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to add an alias at project level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at project level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - You can\'t create an alias on an alias 
         * @summary Create a secret alias at the project level
         * @param {string} projectId Project ID
         * @param {string} secretId Secret ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectSecretAlias: async (projectId: string, secretId: string, key?: Key, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createProjectSecretAlias', 'projectId', projectId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('createProjectSecretAlias', 'secretId', secretId)
            const localVarPath = `/project/{projectId}/secret/{secretId}/alias`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(key, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to override at project level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at project level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
         * @summary Create a secret override at the project level
         * @param {string} projectId Project ID
         * @param {string} secretId Secret ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectSecretOverride: async (projectId: string, secretId: string, value?: Value, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createProjectSecretOverride', 'projectId', projectId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('createProjectSecretOverride', 'secretId', secretId)
            const localVarPath = `/project/{projectId}/secret/{secretId}/override`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(value, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well  operationId: deleteProjectSecret 
         * @summary Delete a secret from a project
         * @param {string} projectId Project ID
         * @param {string} secretId Secret ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectSecret: async (projectId: string, secretId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteProjectSecret', 'projectId', projectId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('deleteProjectSecret', 'secretId', secretId)
            const localVarPath = `/project/{projectId}/secret/{secretId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit a secret belonging to the project
         * @param {string} projectId Project ID
         * @param {string} secretId Secret ID
         * @param {SecretEditRequest} secretEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editProjectSecret: async (projectId: string, secretId: string, secretEditRequest: SecretEditRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('editProjectSecret', 'projectId', projectId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('editProjectSecret', 'secretId', secretId)
            // verify required parameter 'secretEditRequest' is not null or undefined
            assertParamExists('editProjectSecret', 'secretEditRequest', secretEditRequest)
            const localVarPath = `/project/{projectId}/secret/{secretId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(secretEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List project secrets
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectSecrets: async (projectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('listProjectSecrets', 'projectId', projectId)
            const localVarPath = `/project/{projectId}/secret`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectSecretApi - functional programming interface
 * @export
 */
export const ProjectSecretApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectSecretApiAxiosParamCreator(configuration)
    return {
        /**
         * - Add a secret to the project.   - If the secret key already exists, then it will be replaced by the new one.   - If the secret value points toward an existing secret key, it will be considered as an alias. 
         * @summary Add a secret to the project
         * @param {string} projectId Project ID
         * @param {SecretRequest} [secretRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProjectSecret(projectId: string, secretRequest?: SecretRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProjectSecret(projectId, secretRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - Allows you to add an alias at project level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at project level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - You can\'t create an alias on an alias 
         * @summary Create a secret alias at the project level
         * @param {string} projectId Project ID
         * @param {string} secretId Secret ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProjectSecretAlias(projectId: string, secretId: string, key?: Key, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProjectSecretAlias(projectId, secretId, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - Allows you to override at project level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at project level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
         * @summary Create a secret override at the project level
         * @param {string} projectId Project ID
         * @param {string} secretId Secret ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProjectSecretOverride(projectId: string, secretId: string, value?: Value, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProjectSecretOverride(projectId, secretId, value, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well  operationId: deleteProjectSecret 
         * @summary Delete a secret from a project
         * @param {string} projectId Project ID
         * @param {string} secretId Secret ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProjectSecret(projectId: string, secretId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProjectSecret(projectId, secretId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit a secret belonging to the project
         * @param {string} projectId Project ID
         * @param {string} secretId Secret ID
         * @param {SecretEditRequest} secretEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editProjectSecret(projectId: string, secretId: string, secretEditRequest: SecretEditRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editProjectSecret(projectId, secretId, secretEditRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List project secrets
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProjectSecrets(projectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecretResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProjectSecrets(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectSecretApi - factory interface
 * @export
 */
export const ProjectSecretApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectSecretApiFp(configuration)
    return {
        /**
         * - Add a secret to the project.   - If the secret key already exists, then it will be replaced by the new one.   - If the secret value points toward an existing secret key, it will be considered as an alias. 
         * @summary Add a secret to the project
         * @param {string} projectId Project ID
         * @param {SecretRequest} [secretRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectSecret(projectId: string, secretRequest?: SecretRequest, options?: any): AxiosPromise<Secret> {
            return localVarFp.createProjectSecret(projectId, secretRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to add an alias at project level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at project level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - You can\'t create an alias on an alias 
         * @summary Create a secret alias at the project level
         * @param {string} projectId Project ID
         * @param {string} secretId Secret ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectSecretAlias(projectId: string, secretId: string, key?: Key, options?: any): AxiosPromise<Secret> {
            return localVarFp.createProjectSecretAlias(projectId, secretId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to override at project level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at project level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
         * @summary Create a secret override at the project level
         * @param {string} projectId Project ID
         * @param {string} secretId Secret ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectSecretOverride(projectId: string, secretId: string, value?: Value, options?: any): AxiosPromise<Secret> {
            return localVarFp.createProjectSecretOverride(projectId, secretId, value, options).then((request) => request(axios, basePath));
        },
        /**
         * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well  operationId: deleteProjectSecret 
         * @summary Delete a secret from a project
         * @param {string} projectId Project ID
         * @param {string} secretId Secret ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectSecret(projectId: string, secretId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteProjectSecret(projectId, secretId, options).then((request) => request(axios, basePath));
        },
        /**
         * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit a secret belonging to the project
         * @param {string} projectId Project ID
         * @param {string} secretId Secret ID
         * @param {SecretEditRequest} secretEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editProjectSecret(projectId: string, secretId: string, secretEditRequest: SecretEditRequest, options?: any): AxiosPromise<Secret> {
            return localVarFp.editProjectSecret(projectId, secretId, secretEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List project secrets
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectSecrets(projectId: string, options?: any): AxiosPromise<SecretResponseList> {
            return localVarFp.listProjectSecrets(projectId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectSecretApi - object-oriented interface
 * @export
 * @class ProjectSecretApi
 * @extends {BaseAPI}
 */
export class ProjectSecretApi extends BaseAPI {
    /**
     * - Add a secret to the project.   - If the secret key already exists, then it will be replaced by the new one.   - If the secret value points toward an existing secret key, it will be considered as an alias. 
     * @summary Add a secret to the project
     * @param {string} projectId Project ID
     * @param {SecretRequest} [secretRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSecretApi
     */
    public createProjectSecret(projectId: string, secretRequest?: SecretRequest, options?: AxiosRequestConfig) {
        return ProjectSecretApiFp(this.configuration).createProjectSecret(projectId, secretRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to add an alias at project level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at project level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - You can\'t create an alias on an alias 
     * @summary Create a secret alias at the project level
     * @param {string} projectId Project ID
     * @param {string} secretId Secret ID
     * @param {Key} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSecretApi
     */
    public createProjectSecretAlias(projectId: string, secretId: string, key?: Key, options?: AxiosRequestConfig) {
        return ProjectSecretApiFp(this.configuration).createProjectSecretAlias(projectId, secretId, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to override at project level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at project level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
     * @summary Create a secret override at the project level
     * @param {string} projectId Project ID
     * @param {string} secretId Secret ID
     * @param {Value} [value] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSecretApi
     */
    public createProjectSecretOverride(projectId: string, secretId: string, value?: Value, options?: AxiosRequestConfig) {
        return ProjectSecretApiFp(this.configuration).createProjectSecretOverride(projectId, secretId, value, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well  operationId: deleteProjectSecret 
     * @summary Delete a secret from a project
     * @param {string} projectId Project ID
     * @param {string} secretId Secret ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSecretApi
     */
    public deleteProjectSecret(projectId: string, secretId: string, options?: AxiosRequestConfig) {
        return ProjectSecretApiFp(this.configuration).deleteProjectSecret(projectId, secretId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
     * @summary Edit a secret belonging to the project
     * @param {string} projectId Project ID
     * @param {string} secretId Secret ID
     * @param {SecretEditRequest} secretEditRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSecretApi
     */
    public editProjectSecret(projectId: string, secretId: string, secretEditRequest: SecretEditRequest, options?: AxiosRequestConfig) {
        return ProjectSecretApiFp(this.configuration).editProjectSecret(projectId, secretId, secretEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List project secrets
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSecretApi
     */
    public listProjectSecrets(projectId: string, options?: AxiosRequestConfig) {
        return ProjectSecretApiFp(this.configuration).listProjectSecrets(projectId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProjectsApi - axios parameter creator
 * @export
 */
export const ProjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a project
         * @param {string} organizationId Organization ID
         * @param {ProjectRequest} [projectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject: async (organizationId: string, projectRequest?: ProjectRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createProject', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/project`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of project ids, and for each its total numberof services and environments
         * @summary List total number of services and environments for each project of the organization
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationProjectStats: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationProjectStats', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/project/stats`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List projects
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProject: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listProject', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/project`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsApi - functional programming interface
 * @export
 */
export const ProjectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a project
         * @param {string} organizationId Organization ID
         * @param {ProjectRequest} [projectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProject(organizationId: string, projectRequest?: ProjectRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProject(organizationId, projectRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of project ids, and for each its total numberof services and environments
         * @summary List total number of services and environments for each project of the organization
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationProjectStats(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectStatsResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationProjectStats(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List projects
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProject(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProject(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectsApi - factory interface
 * @export
 */
export const ProjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a project
         * @param {string} organizationId Organization ID
         * @param {ProjectRequest} [projectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject(organizationId: string, projectRequest?: ProjectRequest, options?: any): AxiosPromise<Project> {
            return localVarFp.createProject(organizationId, projectRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of project ids, and for each its total numberof services and environments
         * @summary List total number of services and environments for each project of the organization
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationProjectStats(organizationId: string, options?: any): AxiosPromise<ProjectStatsResponseList> {
            return localVarFp.getOrganizationProjectStats(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List projects
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProject(organizationId: string, options?: any): AxiosPromise<ProjectResponseList> {
            return localVarFp.listProject(organizationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectsApi - object-oriented interface
 * @export
 * @class ProjectsApi
 * @extends {BaseAPI}
 */
export class ProjectsApi extends BaseAPI {
    /**
     * 
     * @summary Create a project
     * @param {string} organizationId Organization ID
     * @param {ProjectRequest} [projectRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public createProject(organizationId: string, projectRequest?: ProjectRequest, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).createProject(organizationId, projectRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of project ids, and for each its total numberof services and environments
     * @summary List total number of services and environments for each project of the organization
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getOrganizationProjectStats(organizationId: string, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).getOrganizationProjectStats(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List projects
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public listProject(organizationId: string, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).listProject(organizationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReferralRewardsApi - axios parameter creator
 * @export
 */
export const ReferralRewardsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get your referral information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountReferral: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/referral`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A same code can be claimed only 3 times at max
         * @summary Claim a reward
         * @param {RewardClaim} [rewardClaim] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAccountRewardClaim: async (rewardClaim?: RewardClaim, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/rewardClaim`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rewardClaim, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReferralRewardsApi - functional programming interface
 * @export
 */
export const ReferralRewardsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReferralRewardsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get your referral information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountReferral(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Referral>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountReferral(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A same code can be claimed only 3 times at max
         * @summary Claim a reward
         * @param {RewardClaim} [rewardClaim] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAccountRewardClaim(rewardClaim?: RewardClaim, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postAccountRewardClaim(rewardClaim, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ReferralRewardsApi - factory interface
 * @export
 */
export const ReferralRewardsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReferralRewardsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get your referral information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountReferral(options?: any): AxiosPromise<Referral> {
            return localVarFp.getAccountReferral(options).then((request) => request(axios, basePath));
        },
        /**
         * A same code can be claimed only 3 times at max
         * @summary Claim a reward
         * @param {RewardClaim} [rewardClaim] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAccountRewardClaim(rewardClaim?: RewardClaim, options?: any): AxiosPromise<void> {
            return localVarFp.postAccountRewardClaim(rewardClaim, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReferralRewardsApi - object-oriented interface
 * @export
 * @class ReferralRewardsApi
 * @extends {BaseAPI}
 */
export class ReferralRewardsApi extends BaseAPI {
    /**
     * 
     * @summary Get your referral information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferralRewardsApi
     */
    public getAccountReferral(options?: AxiosRequestConfig) {
        return ReferralRewardsApiFp(this.configuration).getAccountReferral(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A same code can be claimed only 3 times at max
     * @summary Claim a reward
     * @param {RewardClaim} [rewardClaim] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferralRewardsApi
     */
    public postAccountRewardClaim(rewardClaim?: RewardClaim, options?: AxiosRequestConfig) {
        return ReferralRewardsApiFp(this.configuration).postAccountRewardClaim(rewardClaim, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserSignUpApi - axios parameter creator
 * @export
 */
export const UserSignUpApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Send a Sign Up request containing the user information
         * @summary Send Sign Up request
         * @param {SignUpRequest} [signUpRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserSignUp: async (signUpRequest?: SignUpRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/userSignUp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signUpRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the Sign Up information of the user
         * @summary Get Sign up information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSignUp: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/userSignUp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserSignUpApi - functional programming interface
 * @export
 */
export const UserSignUpApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserSignUpApiAxiosParamCreator(configuration)
    return {
        /**
         * Send a Sign Up request containing the user information
         * @summary Send Sign Up request
         * @param {SignUpRequest} [signUpRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserSignUp(signUpRequest?: SignUpRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserSignUp(signUpRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve the Sign Up information of the user
         * @summary Get Sign up information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserSignUp(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignUp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserSignUp(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserSignUpApi - factory interface
 * @export
 */
export const UserSignUpApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserSignUpApiFp(configuration)
    return {
        /**
         * Send a Sign Up request containing the user information
         * @summary Send Sign Up request
         * @param {SignUpRequest} [signUpRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserSignUp(signUpRequest?: SignUpRequest, options?: any): AxiosPromise<void> {
            return localVarFp.createUserSignUp(signUpRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the Sign Up information of the user
         * @summary Get Sign up information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSignUp(options?: any): AxiosPromise<SignUp> {
            return localVarFp.getUserSignUp(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserSignUpApi - object-oriented interface
 * @export
 * @class UserSignUpApi
 * @extends {BaseAPI}
 */
export class UserSignUpApi extends BaseAPI {
    /**
     * Send a Sign Up request containing the user information
     * @summary Send Sign Up request
     * @param {SignUpRequest} [signUpRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSignUpApi
     */
    public createUserSignUp(signUpRequest?: SignUpRequest, options?: AxiosRequestConfig) {
        return UserSignUpApiFp(this.configuration).createUserSignUp(signUpRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the Sign Up information of the user
     * @summary Get Sign up information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSignUpApi
     */
    public getUserSignUp(options?: AxiosRequestConfig) {
        return UserSignUpApiFp(this.configuration).getUserSignUp(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VariableMainCallsApi - axios parameter creator
 * @export
 */
export const VariableMainCallsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * - Create a variable with the scope defined in the request body. 
         * @summary Create a variable
         * @param {VariableRequest} [variableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVariable: async (variableRequest?: VariableRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/variable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(variableRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to create an alias of one of the existing variables. - You have to specify an alias (key) in the request body, the scope and the parent id of the alias (project id, environment id or service id) - The system will create a new variable at the requested level with the same value as the one corresponding to the variable id passed as path parameter. - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" or in the \"aliased_secret\" field of the newly created variable - You can\'t create an alias on an alias 
         * @summary Create a variable alias
         * @param {string} variableId Variable ID
         * @param {VariableAliasRequest} [variableAliasRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVariableAlias: async (variableId: string, variableAliasRequest?: VariableAliasRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'variableId' is not null or undefined
            assertParamExists('createVariableAlias', 'variableId', variableId)
            const localVarPath = `/variable/{variableId}/alias`
                .replace(`{${"variableId"}}`, encodeURIComponent(String(variableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(variableAliasRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to override a variable that has a higher scope. - You have to specify a value (override) in the request body and the scope and the parent id of the variable to override (project id, environment id or service id) - The system will create a new environment variable at the requested level with the same key as the one corresponding to the variable id passed as path parameter. - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" or in the \"overridden_secret\" field of the newly created variable 
         * @summary Create a variable override
         * @param {string} variableId Variable ID
         * @param {VariableOverrideRequest} [variableOverrideRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVariableOverride: async (variableId: string, variableOverrideRequest?: VariableOverrideRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'variableId' is not null or undefined
            assertParamExists('createVariableOverride', 'variableId', variableId)
            const localVarPath = `/variable/{variableId}/override`
                .replace(`{${"variableId"}}`, encodeURIComponent(String(variableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(variableOverrideRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - To delete a variable - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete a variable
         * @param {string} variableId Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVariable: async (variableId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'variableId' is not null or undefined
            assertParamExists('deleteVariable', 'variableId', variableId)
            const localVarPath = `/variable/{variableId}`
                .replace(`{${"variableId"}}`, encodeURIComponent(String(variableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value 
         * @summary Edit a variable
         * @param {string} variableId Variable ID
         * @param {VariableEditRequest} variableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editVariable: async (variableId: string, variableEditRequest: VariableEditRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'variableId' is not null or undefined
            assertParamExists('editVariable', 'variableId', variableId)
            // verify required parameter 'variableEditRequest' is not null or undefined
            assertParamExists('editVariable', 'variableEditRequest', variableEditRequest)
            const localVarPath = `/variable/{variableId}`
                .replace(`{${"variableId"}}`, encodeURIComponent(String(variableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(variableEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Import environment variables in a defined scope, with a defined visibility.
         * @summary Import variables
         * @param {string} serviceId service id
         * @param {ServiceTypeForVariableEnum} serviceType service type
         * @param {VariableImportRequest} [variableImportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importEnvironmentVariables: async (serviceId: string, serviceType: ServiceTypeForVariableEnum, variableImportRequest?: VariableImportRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('importEnvironmentVariables', 'serviceId', serviceId)
            // verify required parameter 'serviceType' is not null or undefined
            assertParamExists('importEnvironmentVariables', 'serviceType', serviceType)
            const localVarPath = `/variable/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (serviceId !== undefined) {
                localVarQueryParameter['service_id'] = serviceId;
            }

            if (serviceType !== undefined) {
                localVarQueryParameter['service_type'] = serviceType;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(variableImportRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of variables. The result can be filtered by using the query parameters.
         * @summary List variables
         * @param {string} parentId it filters the list by returning only the variables accessible by the selected parent_id. This field shall contain the id of a project, environment or service depending on the selected scope. Example, if scope &#x3D; APPLICATION and parent_id&#x3D;&lt;application_id&gt;, the result will contain any variable accessible by the application. The result will contain also any variable declared at an higher scope.
         * @param {APIVariableScopeEnum} scope the type of the parent_id (application, project, environment etc..).
         * @param {boolean | null} [isSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVariables: async (parentId: string, scope: APIVariableScopeEnum, isSecret?: boolean | null, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'parentId' is not null or undefined
            assertParamExists('listVariables', 'parentId', parentId)
            // verify required parameter 'scope' is not null or undefined
            assertParamExists('listVariables', 'scope', scope)
            const localVarPath = `/variable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (parentId !== undefined) {
                localVarQueryParameter['parent_id'] = parentId;
            }

            if (scope !== undefined) {
                localVarQueryParameter['scope'] = scope;
            }

            if (isSecret !== undefined) {
                localVarQueryParameter['is_secret'] = isSecret;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VariableMainCallsApi - functional programming interface
 * @export
 */
export const VariableMainCallsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VariableMainCallsApiAxiosParamCreator(configuration)
    return {
        /**
         * - Create a variable with the scope defined in the request body. 
         * @summary Create a variable
         * @param {VariableRequest} [variableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVariable(variableRequest?: VariableRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariableResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVariable(variableRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - Allows you to create an alias of one of the existing variables. - You have to specify an alias (key) in the request body, the scope and the parent id of the alias (project id, environment id or service id) - The system will create a new variable at the requested level with the same value as the one corresponding to the variable id passed as path parameter. - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" or in the \"aliased_secret\" field of the newly created variable - You can\'t create an alias on an alias 
         * @summary Create a variable alias
         * @param {string} variableId Variable ID
         * @param {VariableAliasRequest} [variableAliasRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVariableAlias(variableId: string, variableAliasRequest?: VariableAliasRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariableResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVariableAlias(variableId, variableAliasRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - Allows you to override a variable that has a higher scope. - You have to specify a value (override) in the request body and the scope and the parent id of the variable to override (project id, environment id or service id) - The system will create a new environment variable at the requested level with the same key as the one corresponding to the variable id passed as path parameter. - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" or in the \"overridden_secret\" field of the newly created variable 
         * @summary Create a variable override
         * @param {string} variableId Variable ID
         * @param {VariableOverrideRequest} [variableOverrideRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVariableOverride(variableId: string, variableOverrideRequest?: VariableOverrideRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariableResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVariableOverride(variableId, variableOverrideRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - To delete a variable - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete a variable
         * @param {string} variableId Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteVariable(variableId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteVariable(variableId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value 
         * @summary Edit a variable
         * @param {string} variableId Variable ID
         * @param {VariableEditRequest} variableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editVariable(variableId: string, variableEditRequest: VariableEditRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariableResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editVariable(variableId, variableEditRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Import environment variables in a defined scope, with a defined visibility.
         * @summary Import variables
         * @param {string} serviceId service id
         * @param {ServiceTypeForVariableEnum} serviceType service type
         * @param {VariableImportRequest} [variableImportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importEnvironmentVariables(serviceId: string, serviceType: ServiceTypeForVariableEnum, variableImportRequest?: VariableImportRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariableImport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importEnvironmentVariables(serviceId, serviceType, variableImportRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of variables. The result can be filtered by using the query parameters.
         * @summary List variables
         * @param {string} parentId it filters the list by returning only the variables accessible by the selected parent_id. This field shall contain the id of a project, environment or service depending on the selected scope. Example, if scope &#x3D; APPLICATION and parent_id&#x3D;&lt;application_id&gt;, the result will contain any variable accessible by the application. The result will contain also any variable declared at an higher scope.
         * @param {APIVariableScopeEnum} scope the type of the parent_id (application, project, environment etc..).
         * @param {boolean | null} [isSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listVariables(parentId: string, scope: APIVariableScopeEnum, isSecret?: boolean | null, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariableResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listVariables(parentId, scope, isSecret, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * VariableMainCallsApi - factory interface
 * @export
 */
export const VariableMainCallsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VariableMainCallsApiFp(configuration)
    return {
        /**
         * - Create a variable with the scope defined in the request body. 
         * @summary Create a variable
         * @param {VariableRequest} [variableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVariable(variableRequest?: VariableRequest, options?: any): AxiosPromise<VariableResponse> {
            return localVarFp.createVariable(variableRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to create an alias of one of the existing variables. - You have to specify an alias (key) in the request body, the scope and the parent id of the alias (project id, environment id or service id) - The system will create a new variable at the requested level with the same value as the one corresponding to the variable id passed as path parameter. - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" or in the \"aliased_secret\" field of the newly created variable - You can\'t create an alias on an alias 
         * @summary Create a variable alias
         * @param {string} variableId Variable ID
         * @param {VariableAliasRequest} [variableAliasRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVariableAlias(variableId: string, variableAliasRequest?: VariableAliasRequest, options?: any): AxiosPromise<VariableResponse> {
            return localVarFp.createVariableAlias(variableId, variableAliasRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to override a variable that has a higher scope. - You have to specify a value (override) in the request body and the scope and the parent id of the variable to override (project id, environment id or service id) - The system will create a new environment variable at the requested level with the same key as the one corresponding to the variable id passed as path parameter. - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" or in the \"overridden_secret\" field of the newly created variable 
         * @summary Create a variable override
         * @param {string} variableId Variable ID
         * @param {VariableOverrideRequest} [variableOverrideRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVariableOverride(variableId: string, variableOverrideRequest?: VariableOverrideRequest, options?: any): AxiosPromise<VariableResponse> {
            return localVarFp.createVariableOverride(variableId, variableOverrideRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * - To delete a variable - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete a variable
         * @param {string} variableId Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVariable(variableId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteVariable(variableId, options).then((request) => request(axios, basePath));
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value 
         * @summary Edit a variable
         * @param {string} variableId Variable ID
         * @param {VariableEditRequest} variableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editVariable(variableId: string, variableEditRequest: VariableEditRequest, options?: any): AxiosPromise<VariableResponse> {
            return localVarFp.editVariable(variableId, variableEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Import environment variables in a defined scope, with a defined visibility.
         * @summary Import variables
         * @param {string} serviceId service id
         * @param {ServiceTypeForVariableEnum} serviceType service type
         * @param {VariableImportRequest} [variableImportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importEnvironmentVariables(serviceId: string, serviceType: ServiceTypeForVariableEnum, variableImportRequest?: VariableImportRequest, options?: any): AxiosPromise<VariableImport> {
            return localVarFp.importEnvironmentVariables(serviceId, serviceType, variableImportRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of variables. The result can be filtered by using the query parameters.
         * @summary List variables
         * @param {string} parentId it filters the list by returning only the variables accessible by the selected parent_id. This field shall contain the id of a project, environment or service depending on the selected scope. Example, if scope &#x3D; APPLICATION and parent_id&#x3D;&lt;application_id&gt;, the result will contain any variable accessible by the application. The result will contain also any variable declared at an higher scope.
         * @param {APIVariableScopeEnum} scope the type of the parent_id (application, project, environment etc..).
         * @param {boolean | null} [isSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVariables(parentId: string, scope: APIVariableScopeEnum, isSecret?: boolean | null, options?: any): AxiosPromise<VariableResponseList> {
            return localVarFp.listVariables(parentId, scope, isSecret, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VariableMainCallsApi - object-oriented interface
 * @export
 * @class VariableMainCallsApi
 * @extends {BaseAPI}
 */
export class VariableMainCallsApi extends BaseAPI {
    /**
     * - Create a variable with the scope defined in the request body. 
     * @summary Create a variable
     * @param {VariableRequest} [variableRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariableMainCallsApi
     */
    public createVariable(variableRequest?: VariableRequest, options?: AxiosRequestConfig) {
        return VariableMainCallsApiFp(this.configuration).createVariable(variableRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to create an alias of one of the existing variables. - You have to specify an alias (key) in the request body, the scope and the parent id of the alias (project id, environment id or service id) - The system will create a new variable at the requested level with the same value as the one corresponding to the variable id passed as path parameter. - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" or in the \"aliased_secret\" field of the newly created variable - You can\'t create an alias on an alias 
     * @summary Create a variable alias
     * @param {string} variableId Variable ID
     * @param {VariableAliasRequest} [variableAliasRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariableMainCallsApi
     */
    public createVariableAlias(variableId: string, variableAliasRequest?: VariableAliasRequest, options?: AxiosRequestConfig) {
        return VariableMainCallsApiFp(this.configuration).createVariableAlias(variableId, variableAliasRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to override a variable that has a higher scope. - You have to specify a value (override) in the request body and the scope and the parent id of the variable to override (project id, environment id or service id) - The system will create a new environment variable at the requested level with the same key as the one corresponding to the variable id passed as path parameter. - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" or in the \"overridden_secret\" field of the newly created variable 
     * @summary Create a variable override
     * @param {string} variableId Variable ID
     * @param {VariableOverrideRequest} [variableOverrideRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariableMainCallsApi
     */
    public createVariableOverride(variableId: string, variableOverrideRequest?: VariableOverrideRequest, options?: AxiosRequestConfig) {
        return VariableMainCallsApiFp(this.configuration).createVariableOverride(variableId, variableOverrideRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - To delete a variable - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
     * @summary Delete a variable
     * @param {string} variableId Variable ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariableMainCallsApi
     */
    public deleteVariable(variableId: string, options?: AxiosRequestConfig) {
        return VariableMainCallsApiFp(this.configuration).deleteVariable(variableId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value 
     * @summary Edit a variable
     * @param {string} variableId Variable ID
     * @param {VariableEditRequest} variableEditRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariableMainCallsApi
     */
    public editVariable(variableId: string, variableEditRequest: VariableEditRequest, options?: AxiosRequestConfig) {
        return VariableMainCallsApiFp(this.configuration).editVariable(variableId, variableEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Import environment variables in a defined scope, with a defined visibility.
     * @summary Import variables
     * @param {string} serviceId service id
     * @param {ServiceTypeForVariableEnum} serviceType service type
     * @param {VariableImportRequest} [variableImportRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariableMainCallsApi
     */
    public importEnvironmentVariables(serviceId: string, serviceType: ServiceTypeForVariableEnum, variableImportRequest?: VariableImportRequest, options?: AxiosRequestConfig) {
        return VariableMainCallsApiFp(this.configuration).importEnvironmentVariables(serviceId, serviceType, variableImportRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of variables. The result can be filtered by using the query parameters.
     * @summary List variables
     * @param {string} parentId it filters the list by returning only the variables accessible by the selected parent_id. This field shall contain the id of a project, environment or service depending on the selected scope. Example, if scope &#x3D; APPLICATION and parent_id&#x3D;&lt;application_id&gt;, the result will contain any variable accessible by the application. The result will contain also any variable declared at an higher scope.
     * @param {APIVariableScopeEnum} scope the type of the parent_id (application, project, environment etc..).
     * @param {boolean | null} [isSecret] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariableMainCallsApi
     */
    public listVariables(parentId: string, scope: APIVariableScopeEnum, isSecret?: boolean | null, options?: AxiosRequestConfig) {
        return VariableMainCallsApiFp(this.configuration).listVariables(parentId, scope, isSecret, options).then((request) => request(this.axios, this.basePath));
    }
}



