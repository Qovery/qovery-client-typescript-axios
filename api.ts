/* tslint:disable */
/* eslint-disable */
/**
 * Qovery API
 * - Qovery is the fastest way to deploy your full-stack apps on any Cloud provider. - ℹ️ The API is stable and still in development. 
 *
 * The version of the OpenAPI document: 1.0.3
 * Contact: support+api+documentation@qovery.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @enum {string}
 */

export enum APIVariableScopeEnum {
    APPLICATION = 'APPLICATION',
    BUILT_IN = 'BUILT_IN',
    ENVIRONMENT = 'ENVIRONMENT',
    PROJECT = 'PROJECT',
    CONTAINER = 'CONTAINER',
    JOB = 'JOB'
}

/**
 * type of the environment variable (VALUE, FILE, ALIAS, OVERRIDE or BUIT_IN)  
 * @export
 * @enum {string}
 */

export enum APIVariableTypeEnum {
    VALUE = 'VALUE',
    ALIAS = 'ALIAS',
    OVERRIDE = 'OVERRIDE',
    BUILT_IN = 'BUILT_IN',
    FILE = 'FILE'
}

/**
 * 
 * @export
 * @interface AccountInfo
 */
export interface AccountInfo {
    /**
     * 
     * @type {string}
     * @memberof AccountInfo
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountInfo
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountInfo
     */
    'nickname'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountInfo
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountInfo
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountInfo
     */
    'profile_picture_url'?: string;
}
/**
 * 
 * @export
 * @interface AccountInfoEditRequest
 */
export interface AccountInfoEditRequest {
    /**
     * 
     * @type {string}
     * @memberof AccountInfoEditRequest
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountInfoEditRequest
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountInfoEditRequest
     */
    'profile_picture_url'?: string;
}
/**
 * 
 * @export
 * @interface Application
 */
export interface Application {
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    'updated_at'?: string;
    /**
     * 
     * @type {Array<ServiceStorageStorage>}
     * @memberof Application
     */
    'storage'?: Array<ServiceStorageStorage>;
    /**
     * 
     * @type {ReferenceObject}
     * @memberof Application
     */
    'environment'?: ReferenceObject;
    /**
     * 
     * @type {ApplicationGitRepository}
     * @memberof Application
     */
    'git_repository'?: ApplicationGitRepository;
    /**
     * Maximum cpu that can be allocated to the application based on organization cluster configuration. unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof Application
     */
    'maximum_cpu'?: number;
    /**
     * Maximum memory that can be allocated to the application based on organization cluster configuration. unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof Application
     */
    'maximum_memory'?: number;
    /**
     * name is case insensitive
     * @type {string}
     * @memberof Application
     */
    'name'?: string;
    /**
     * give a description to this application
     * @type {string}
     * @memberof Application
     */
    'description'?: string | null;
    /**
     * 
     * @type {BuildModeEnum}
     * @memberof Application
     */
    'build_mode'?: BuildModeEnum;
    /**
     * The path of the associated Dockerfile. Only if you are using build_mode = DOCKER
     * @type {string}
     * @memberof Application
     */
    'dockerfile_path'?: string | null;
    /**
     * 
     * @type {BuildPackLanguageEnum}
     * @memberof Application
     */
    'buildpack_language'?: BuildPackLanguageEnum | null;
    /**
     * unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof Application
     */
    'cpu'?: number;
    /**
     * unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof Application
     */
    'memory'?: number;
    /**
     * Minimum number of instances running. This resource auto-scale based on the CPU and Memory consumption. Note: 0 means that there is no application running. 
     * @type {number}
     * @memberof Application
     */
    'min_running_instances'?: number;
    /**
     * Maximum number of instances running. This resource auto-scale based on the CPU and Memory consumption. Note: -1 means that there is no limit. 
     * @type {number}
     * @memberof Application
     */
    'max_running_instances'?: number;
    /**
     * 
     * @type {Healthcheck}
     * @memberof Application
     */
    'healthchecks'?: Healthcheck;
    /**
     * Specify if the environment preview option is activated or not for this application.   If activated, a preview environment will be automatically cloned at each pull request.   If not specified, it takes the value of the `auto_preview` property from the associated environment. 
     * @type {boolean}
     * @memberof Application
     */
    'auto_preview'?: boolean;
    /**
     * 
     * @type {Array<ServicePort>}
     * @memberof Application
     */
    'ports'?: Array<ServicePort>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Application
     */
    'arguments'?: Array<string>;
    /**
     * optional entrypoint when launching container
     * @type {string}
     * @memberof Application
     */
    'entrypoint'?: string;
}
/**
 * 
 * @export
 * @interface ApplicationAdvancedSettings
 */
export interface ApplicationAdvancedSettings {
    /**
     * please use `readiness_probe.initial_delay_seconds` and `liveness_probe.initial_delay_seconds` instead
     * @type {number}
     * @memberof ApplicationAdvancedSettings
     * @deprecated
     */
    'deployment.delay_start_time_sec'?: number;
    /**
     * disable custom domain check when deploying an application
     * @type {boolean}
     * @memberof ApplicationAdvancedSettings
     */
    'deployment.custom_domain_check_enabled'?: boolean;
    /**
     * define how long in seconds an application is supposed to be stopped gracefully
     * @type {number}
     * @memberof ApplicationAdvancedSettings
     */
    'deployment.termination_grace_period_seconds'?: number;
    /**
     * * `RollingUpdate` gracefully rollout new versions, and automatically rollback if the new version fails to start * `Recreate` stop all current versions and create new ones once all old ones have been shutdown 
     * @type {string}
     * @memberof ApplicationAdvancedSettings
     */
    'deployment.update_strategy.type'?: ApplicationAdvancedSettingsDeploymentUpdateStrategyTypeEnum;
    /**
     * Define the percentage of a maximum number of pods that can be unavailable during the update process
     * @type {number}
     * @memberof ApplicationAdvancedSettings
     */
    'deployment.update_strategy.rolling_update.max_unavailable_percent'?: number;
    /**
     * Define the percentage of the maximum number of pods that can be created over the desired number of pods
     * @type {number}
     * @memberof ApplicationAdvancedSettings
     */
    'deployment.update_strategy.rolling_update.max_surge_percent'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApplicationAdvancedSettings
     */
    'build.timeout_max_sec'?: number;
    /**
     * define the max cpu resources (in milli)
     * @type {number}
     * @memberof ApplicationAdvancedSettings
     */
    'build.cpu_max_in_milli'?: number;
    /**
     * define the max ram resources (in gib)
     * @type {number}
     * @memberof ApplicationAdvancedSettings
     */
    'build.ram_max_in_gib'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApplicationAdvancedSettings
     */
    'network.ingress.proxy_body_size_mb'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationAdvancedSettings
     */
    'network.ingress.enable_cors'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ApplicationAdvancedSettings
     */
    'network.ingress.cors_allow_origin'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationAdvancedSettings
     */
    'network.ingress.cors_allow_methods'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationAdvancedSettings
     */
    'network.ingress.cors_allow_headers'?: string;
    /**
     * header buffer size used while reading response header from upstream
     * @type {number}
     * @memberof ApplicationAdvancedSettings
     */
    'network.ingress.proxy_buffer_size_kb'?: number;
    /**
     * Limits the maximum time (in seconds) during which requests can be processed through one keepalive connection
     * @type {number}
     * @memberof ApplicationAdvancedSettings
     */
    'network.ingress.keepalive_time_seconds'?: number;
    /**
     * Sets a timeout (in seconds) during which an idle keepalive connection to an upstream server will stay open.
     * @type {number}
     * @memberof ApplicationAdvancedSettings
     */
    'network.ingress.keepalive_timeout_seconds'?: number;
    /**
     * Sets a timeout (in seconds) for transmitting a response to the client
     * @type {number}
     * @memberof ApplicationAdvancedSettings
     */
    'network.ingress.send_timeout_seconds'?: number;
    /**
     * Sets a timeout (in seconds) for establishing a connection to a proxied server
     * @type {number}
     * @memberof ApplicationAdvancedSettings
     */
    'network.ingress.proxy_connect_timeout_seconds'?: number;
    /**
     * Sets a timeout (in seconds) for transmitting a request to the proxied server
     * @type {number}
     * @memberof ApplicationAdvancedSettings
     */
    'network.ingress.proxy_send_timeout_seconds'?: number;
    /**
     * Sets a timeout (in seconds) for reading a response from the proxied server
     * @type {number}
     * @memberof ApplicationAdvancedSettings
     */
    'network.ingress.proxy_read_timeout_seconds'?: number;
    /**
     * list of source ranges to allow access to ingress proxy.  This property can be used to whitelist source IP ranges for ingress proxy. The value is a comma separated list of CIDRs, e.g. 10.0.0.0/24,172.10.0.1 To allow all source ranges, set 0.0.0.0/0. 
     * @type {string}
     * @memberof ApplicationAdvancedSettings
     */
    'network.ingress.whitelist_source_range'?: string;
    /**
     * list of source ranges to deny access to ingress proxy.  This property can be used to blacklist source IP ranges for ingress proxy. The value is a comma separated list of CIDRs, e.g. 10.0.0.0/24,172.10.0.1 
     * @type {string}
     * @memberof ApplicationAdvancedSettings
     */
    'network.ingress.denylist_source_range'?: string;
    /**
     * Set the name of an environment variable to use as a basic authentication (`login:crypted_password`) from `htpasswd` command. 
     * @type {string}
     * @memberof ApplicationAdvancedSettings
     */
    'network.ingress.basic_auth_env_var'?: string;
    /**
     * Enable the load balancer to bind a user\'s session to a specific target. This ensures that all requests from the user during the session are sent to the same target 
     * @type {boolean}
     * @memberof ApplicationAdvancedSettings
     */
    'network.ingress.enable_sticky_session'?: boolean;
    /**
     * Sets a timeout (in seconds) for transmitting a request to the grpc server
     * @type {number}
     * @memberof ApplicationAdvancedSettings
     */
    'network.ingress.grpc_send_timeout_seconds'?: number;
    /**
     * Sets a timeout (in seconds) for transmitting a request to the grpc server
     * @type {number}
     * @memberof ApplicationAdvancedSettings
     */
    'network.ingress.grpc_read_timeout_seconds'?: number;
    /**
     * Percentage value of cpu usage at which point pods should scale up.
     * @type {number}
     * @memberof ApplicationAdvancedSettings
     */
    'hpa.cpu.average_utilization_percent'?: number;
    /**
     * Allows you to set an existing Kubernetes service account name 
     * @type {string}
     * @memberof ApplicationAdvancedSettings
     */
    'security.service_account_name'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ApplicationAdvancedSettingsDeploymentUpdateStrategyTypeEnum {
    ROLLING_UPDATE = 'RollingUpdate',
    RECREATE = 'Recreate'
}

/**
 * 
 * @export
 * @interface ApplicationAllOf
 */
export interface ApplicationAllOf {
    /**
     * 
     * @type {ReferenceObject}
     * @memberof ApplicationAllOf
     */
    'environment'?: ReferenceObject;
    /**
     * 
     * @type {ApplicationGitRepository}
     * @memberof ApplicationAllOf
     */
    'git_repository'?: ApplicationGitRepository;
    /**
     * Maximum cpu that can be allocated to the application based on organization cluster configuration. unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof ApplicationAllOf
     */
    'maximum_cpu'?: number;
    /**
     * Maximum memory that can be allocated to the application based on organization cluster configuration. unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof ApplicationAllOf
     */
    'maximum_memory'?: number;
    /**
     * name is case insensitive
     * @type {string}
     * @memberof ApplicationAllOf
     */
    'name'?: string;
    /**
     * give a description to this application
     * @type {string}
     * @memberof ApplicationAllOf
     */
    'description'?: string | null;
    /**
     * 
     * @type {BuildModeEnum}
     * @memberof ApplicationAllOf
     */
    'build_mode'?: BuildModeEnum;
    /**
     * The path of the associated Dockerfile. Only if you are using build_mode = DOCKER
     * @type {string}
     * @memberof ApplicationAllOf
     */
    'dockerfile_path'?: string | null;
    /**
     * 
     * @type {BuildPackLanguageEnum}
     * @memberof ApplicationAllOf
     */
    'buildpack_language'?: BuildPackLanguageEnum | null;
    /**
     * unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof ApplicationAllOf
     */
    'cpu'?: number;
    /**
     * unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof ApplicationAllOf
     */
    'memory'?: number;
    /**
     * Minimum number of instances running. This resource auto-scale based on the CPU and Memory consumption. Note: 0 means that there is no application running. 
     * @type {number}
     * @memberof ApplicationAllOf
     */
    'min_running_instances'?: number;
    /**
     * Maximum number of instances running. This resource auto-scale based on the CPU and Memory consumption. Note: -1 means that there is no limit. 
     * @type {number}
     * @memberof ApplicationAllOf
     */
    'max_running_instances'?: number;
    /**
     * 
     * @type {Healthcheck}
     * @memberof ApplicationAllOf
     */
    'healthchecks'?: Healthcheck;
    /**
     * Specify if the environment preview option is activated or not for this application.   If activated, a preview environment will be automatically cloned at each pull request.   If not specified, it takes the value of the `auto_preview` property from the associated environment. 
     * @type {boolean}
     * @memberof ApplicationAllOf
     */
    'auto_preview'?: boolean;
    /**
     * 
     * @type {Array<ServicePort>}
     * @memberof ApplicationAllOf
     */
    'ports'?: Array<ServicePort>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApplicationAllOf
     */
    'arguments'?: Array<string>;
    /**
     * optional entrypoint when launching container
     * @type {string}
     * @memberof ApplicationAllOf
     */
    'entrypoint'?: string;
}
/**
 * 
 * @export
 * @interface ApplicationCurrentScale
 */
export interface ApplicationCurrentScale {
    /**
     * 
     * @type {number}
     * @memberof ApplicationCurrentScale
     */
    'min'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApplicationCurrentScale
     */
    'max'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApplicationCurrentScale
     */
    'running'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApplicationCurrentScale
     */
    'running_in_percent'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApplicationCurrentScale
     */
    'warning_threshold_in_percent'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApplicationCurrentScale
     */
    'alert_threshold_in_percent'?: number;
    /**
     * 
     * @type {ThresholdMetricStatusEnum}
     * @memberof ApplicationCurrentScale
     */
    'status'?: ThresholdMetricStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ApplicationCurrentScale
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface ApplicationDeploymentRestriction
 */
export interface ApplicationDeploymentRestriction {
    /**
     * 
     * @type {string}
     * @memberof ApplicationDeploymentRestriction
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationDeploymentRestriction
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationDeploymentRestriction
     */
    'updated_at'?: string;
    /**
     * 
     * @type {DeploymentRestrictionModeEnum}
     * @memberof ApplicationDeploymentRestriction
     */
    'mode': DeploymentRestrictionModeEnum;
    /**
     * 
     * @type {DeploymentRestrictionTypeEnum}
     * @memberof ApplicationDeploymentRestriction
     */
    'type': DeploymentRestrictionTypeEnum;
    /**
     * For `PATH` restrictions, the value must not start with `/`
     * @type {string}
     * @memberof ApplicationDeploymentRestriction
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface ApplicationDeploymentRestrictionRequest
 */
export interface ApplicationDeploymentRestrictionRequest {
    /**
     * 
     * @type {DeploymentRestrictionModeEnum}
     * @memberof ApplicationDeploymentRestrictionRequest
     */
    'mode': DeploymentRestrictionModeEnum;
    /**
     * 
     * @type {DeploymentRestrictionTypeEnum}
     * @memberof ApplicationDeploymentRestrictionRequest
     */
    'type': DeploymentRestrictionTypeEnum;
    /**
     * For `PATH` restrictions, the value must not start with `/`
     * @type {string}
     * @memberof ApplicationDeploymentRestrictionRequest
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface ApplicationDeploymentRestrictionResponseList
 */
export interface ApplicationDeploymentRestrictionResponseList {
    /**
     * 
     * @type {Array<ApplicationDeploymentRestriction>}
     * @memberof ApplicationDeploymentRestrictionResponseList
     */
    'deployment_restrictions'?: Array<ApplicationDeploymentRestriction>;
}
/**
 * 
 * @export
 * @interface ApplicationEditRequest
 */
export interface ApplicationEditRequest {
    /**
     * 
     * @type {Array<ServiceStorageRequestStorage>}
     * @memberof ApplicationEditRequest
     */
    'storage'?: Array<ServiceStorageRequestStorage>;
    /**
     * name is case insensitive
     * @type {string}
     * @memberof ApplicationEditRequest
     */
    'name'?: string;
    /**
     * give a description to this application
     * @type {string}
     * @memberof ApplicationEditRequest
     */
    'description'?: string;
    /**
     * 
     * @type {ApplicationGitRepositoryRequest}
     * @memberof ApplicationEditRequest
     */
    'git_repository'?: ApplicationGitRepositoryRequest;
    /**
     * 
     * @type {BuildModeEnum}
     * @memberof ApplicationEditRequest
     */
    'build_mode'?: BuildModeEnum;
    /**
     * The path of the associated Dockerfile
     * @type {string}
     * @memberof ApplicationEditRequest
     */
    'dockerfile_path'?: string;
    /**
     * 
     * @type {BuildPackLanguageEnum}
     * @memberof ApplicationEditRequest
     */
    'buildpack_language'?: BuildPackLanguageEnum | null;
    /**
     * unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof ApplicationEditRequest
     */
    'cpu'?: number;
    /**
     * unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof ApplicationEditRequest
     */
    'memory'?: number;
    /**
     * Minimum number of instances running. This resource auto-scale based on the CPU and Memory consumption. Note: 0 means that there is no application running. 
     * @type {number}
     * @memberof ApplicationEditRequest
     */
    'min_running_instances'?: number;
    /**
     * Maximum number of instances running. This resource auto-scale based on the CPU and Memory consumption. Note: -1 means that there is no limit. 
     * @type {number}
     * @memberof ApplicationEditRequest
     */
    'max_running_instances'?: number;
    /**
     * 
     * @type {Healthcheck}
     * @memberof ApplicationEditRequest
     */
    'healthchecks'?: Healthcheck;
    /**
     * Specify if the environment preview option is activated or not for this application.   If activated, a preview environment will be automatically cloned at each pull request.   If not specified, it takes the value of the `auto_preview` property from the associated environment. 
     * @type {boolean}
     * @memberof ApplicationEditRequest
     */
    'auto_preview'?: boolean;
    /**
     * 
     * @type {Array<ServicePort>}
     * @memberof ApplicationEditRequest
     */
    'ports'?: Array<ServicePort>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApplicationEditRequest
     */
    'arguments'?: Array<string>;
    /**
     * optional entrypoint when launching container
     * @type {string}
     * @memberof ApplicationEditRequest
     */
    'entrypoint'?: string;
}
/**
 * 
 * @export
 * @interface ApplicationEditRequestAllOf
 */
export interface ApplicationEditRequestAllOf {
    /**
     * name is case insensitive
     * @type {string}
     * @memberof ApplicationEditRequestAllOf
     */
    'name'?: string;
    /**
     * give a description to this application
     * @type {string}
     * @memberof ApplicationEditRequestAllOf
     */
    'description'?: string;
    /**
     * 
     * @type {ApplicationGitRepositoryRequest}
     * @memberof ApplicationEditRequestAllOf
     */
    'git_repository'?: ApplicationGitRepositoryRequest;
    /**
     * 
     * @type {BuildModeEnum}
     * @memberof ApplicationEditRequestAllOf
     */
    'build_mode'?: BuildModeEnum;
    /**
     * The path of the associated Dockerfile
     * @type {string}
     * @memberof ApplicationEditRequestAllOf
     */
    'dockerfile_path'?: string;
    /**
     * 
     * @type {BuildPackLanguageEnum}
     * @memberof ApplicationEditRequestAllOf
     */
    'buildpack_language'?: BuildPackLanguageEnum | null;
    /**
     * unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof ApplicationEditRequestAllOf
     */
    'cpu'?: number;
    /**
     * unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof ApplicationEditRequestAllOf
     */
    'memory'?: number;
    /**
     * Minimum number of instances running. This resource auto-scale based on the CPU and Memory consumption. Note: 0 means that there is no application running. 
     * @type {number}
     * @memberof ApplicationEditRequestAllOf
     */
    'min_running_instances'?: number;
    /**
     * Maximum number of instances running. This resource auto-scale based on the CPU and Memory consumption. Note: -1 means that there is no limit. 
     * @type {number}
     * @memberof ApplicationEditRequestAllOf
     */
    'max_running_instances'?: number;
    /**
     * 
     * @type {Healthcheck}
     * @memberof ApplicationEditRequestAllOf
     */
    'healthchecks'?: Healthcheck;
    /**
     * Specify if the environment preview option is activated or not for this application.   If activated, a preview environment will be automatically cloned at each pull request.   If not specified, it takes the value of the `auto_preview` property from the associated environment. 
     * @type {boolean}
     * @memberof ApplicationEditRequestAllOf
     */
    'auto_preview'?: boolean;
    /**
     * 
     * @type {Array<ServicePort>}
     * @memberof ApplicationEditRequestAllOf
     */
    'ports'?: Array<ServicePort>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApplicationEditRequestAllOf
     */
    'arguments'?: Array<string>;
    /**
     * optional entrypoint when launching container
     * @type {string}
     * @memberof ApplicationEditRequestAllOf
     */
    'entrypoint'?: string;
}
/**
 * 
 * @export
 * @interface ApplicationGitRepository
 */
export interface ApplicationGitRepository {
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationGitRepository
     */
    'has_access'?: boolean;
    /**
     * 
     * @type {GitProviderEnum}
     * @memberof ApplicationGitRepository
     */
    'provider'?: GitProviderEnum;
    /**
     * 
     * @type {string}
     * @memberof ApplicationGitRepository
     */
    'owner'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationGitRepository
     */
    'url'?: string;
    /**
     * repository name
     * @type {string}
     * @memberof ApplicationGitRepository
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationGitRepository
     */
    'branch'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationGitRepository
     */
    'root_path'?: string;
    /**
     * Git commit ID corresponding to the deployed version of the app
     * @type {string}
     * @memberof ApplicationGitRepository
     */
    'deployed_commit_id'?: string;
    /**
     * Git commit date corresponding to the deployed version of the app
     * @type {string}
     * @memberof ApplicationGitRepository
     */
    'deployed_commit_date'?: string;
    /**
     * Git commit user corresponding to the deployed version of the app
     * @type {string}
     * @memberof ApplicationGitRepository
     */
    'deployed_commit_contributor'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationGitRepository
     */
    'deployed_commit_tag'?: string;
}
/**
 * 
 * @export
 * @interface ApplicationGitRepositoryRequest
 */
export interface ApplicationGitRepositoryRequest {
    /**
     * application git repository URL
     * @type {string}
     * @memberof ApplicationGitRepositoryRequest
     */
    'url': string;
    /**
     * Name of the branch to use. This is optional If not specified, then the branch used is the `main` or `master` one 
     * @type {string}
     * @memberof ApplicationGitRepositoryRequest
     */
    'branch'?: string;
    /**
     * indicates the root path of the application.
     * @type {string}
     * @memberof ApplicationGitRepositoryRequest
     */
    'root_path'?: string;
}
/**
 * 
 * @export
 * @interface ApplicationNetwork
 */
export interface ApplicationNetwork {
    /**
     * Specify if the sticky session option (also called persistant session) is activated or not for this application. If activated, user will be redirected by the load balancer to the same instance each time he access to the application.  
     * @type {boolean}
     * @memberof ApplicationNetwork
     */
    'sticky_session'?: boolean;
}
/**
 * 
 * @export
 * @interface ApplicationNetworkRequest
 */
export interface ApplicationNetworkRequest {
    /**
     * Specify if the sticky session option (also called persistant session) is activated or not for this application. If activated, user will be redirected by the load balancer to the same instance each time he access to the application.  
     * @type {boolean}
     * @memberof ApplicationNetworkRequest
     */
    'sticky_session'?: boolean;
}
/**
 * 
 * @export
 * @interface ApplicationRequest
 */
export interface ApplicationRequest {
    /**
     * 
     * @type {Array<ServiceStorageRequestStorage>}
     * @memberof ApplicationRequest
     */
    'storage'?: Array<ServiceStorageRequestStorage>;
    /**
     * 
     * @type {Array<ServicePortRequestPorts>}
     * @memberof ApplicationRequest
     */
    'ports'?: Array<ServicePortRequestPorts>;
    /**
     * name is case insensitive
     * @type {string}
     * @memberof ApplicationRequest
     */
    'name': string;
    /**
     * give a description to this application
     * @type {string}
     * @memberof ApplicationRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {ApplicationGitRepositoryRequest}
     * @memberof ApplicationRequest
     */
    'git_repository': ApplicationGitRepositoryRequest;
    /**
     * 
     * @type {BuildModeEnum}
     * @memberof ApplicationRequest
     */
    'build_mode'?: BuildModeEnum;
    /**
     * The path of the associated Dockerfile. Only if you are using build_mode = DOCKER
     * @type {string}
     * @memberof ApplicationRequest
     */
    'dockerfile_path'?: string | null;
    /**
     * 
     * @type {BuildPackLanguageEnum}
     * @memberof ApplicationRequest
     */
    'buildpack_language'?: BuildPackLanguageEnum | null;
    /**
     * unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof ApplicationRequest
     */
    'cpu'?: number;
    /**
     * unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof ApplicationRequest
     */
    'memory'?: number;
    /**
     * Minimum number of instances running. This resource auto-scale based on the CPU and Memory consumption. Note: 0 means that there is no application running. 
     * @type {number}
     * @memberof ApplicationRequest
     */
    'min_running_instances'?: number;
    /**
     * Maximum number of instances running. This resource auto-scale based on the CPU and Memory consumption. Note: -1 means that there is no limit. 
     * @type {number}
     * @memberof ApplicationRequest
     */
    'max_running_instances'?: number;
    /**
     * 
     * @type {Healthcheck}
     * @memberof ApplicationRequest
     */
    'healthchecks'?: Healthcheck;
    /**
     * Specify if the environment preview option is activated or not for this application.   If activated, a preview environment will be automatically cloned at each pull request.   If not specified, it takes the value of the `auto_preview` property from the associated environment. 
     * @type {boolean}
     * @memberof ApplicationRequest
     */
    'auto_preview'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApplicationRequest
     */
    'arguments'?: Array<string>;
    /**
     * optional entrypoint when launching container
     * @type {string}
     * @memberof ApplicationRequest
     */
    'entrypoint'?: string;
}
/**
 * 
 * @export
 * @interface ApplicationRequestAllOf
 */
export interface ApplicationRequestAllOf {
    /**
     * name is case insensitive
     * @type {string}
     * @memberof ApplicationRequestAllOf
     */
    'name': string;
    /**
     * give a description to this application
     * @type {string}
     * @memberof ApplicationRequestAllOf
     */
    'description'?: string | null;
    /**
     * 
     * @type {ApplicationGitRepositoryRequest}
     * @memberof ApplicationRequestAllOf
     */
    'git_repository': ApplicationGitRepositoryRequest;
    /**
     * 
     * @type {BuildModeEnum}
     * @memberof ApplicationRequestAllOf
     */
    'build_mode'?: BuildModeEnum;
    /**
     * The path of the associated Dockerfile. Only if you are using build_mode = DOCKER
     * @type {string}
     * @memberof ApplicationRequestAllOf
     */
    'dockerfile_path'?: string | null;
    /**
     * 
     * @type {BuildPackLanguageEnum}
     * @memberof ApplicationRequestAllOf
     */
    'buildpack_language'?: BuildPackLanguageEnum | null;
    /**
     * unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof ApplicationRequestAllOf
     */
    'cpu'?: number;
    /**
     * unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof ApplicationRequestAllOf
     */
    'memory'?: number;
    /**
     * Minimum number of instances running. This resource auto-scale based on the CPU and Memory consumption. Note: 0 means that there is no application running. 
     * @type {number}
     * @memberof ApplicationRequestAllOf
     */
    'min_running_instances'?: number;
    /**
     * Maximum number of instances running. This resource auto-scale based on the CPU and Memory consumption. Note: -1 means that there is no limit. 
     * @type {number}
     * @memberof ApplicationRequestAllOf
     */
    'max_running_instances'?: number;
    /**
     * 
     * @type {Healthcheck}
     * @memberof ApplicationRequestAllOf
     */
    'healthchecks'?: Healthcheck;
    /**
     * Specify if the environment preview option is activated or not for this application.   If activated, a preview environment will be automatically cloned at each pull request.   If not specified, it takes the value of the `auto_preview` property from the associated environment. 
     * @type {boolean}
     * @memberof ApplicationRequestAllOf
     */
    'auto_preview'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApplicationRequestAllOf
     */
    'arguments'?: Array<string>;
    /**
     * optional entrypoint when launching container
     * @type {string}
     * @memberof ApplicationRequestAllOf
     */
    'entrypoint'?: string;
}
/**
 * 
 * @export
 * @interface ApplicationResponseList
 */
export interface ApplicationResponseList {
    /**
     * 
     * @type {Array<Application>}
     * @memberof ApplicationResponseList
     */
    'results'?: Array<Application>;
}
/**
 * 
 * @export
 * @interface AvailableContainerRegistryResponse
 */
export interface AvailableContainerRegistryResponse {
    /**
     * 
     * @type {ContainerRegistryKindEnum}
     * @memberof AvailableContainerRegistryResponse
     */
    'kind'?: ContainerRegistryKindEnum;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof AvailableContainerRegistryResponse
     */
    'required_config'?: { [key: string]: object; };
    /**
     * 
     * @type {boolean}
     * @memberof AvailableContainerRegistryResponse
     */
    'is_mandatory'?: boolean;
}
/**
 * 
 * @export
 * @interface AvailableContainerRegistryResponseList
 */
export interface AvailableContainerRegistryResponseList {
    /**
     * 
     * @type {Array<AvailableContainerRegistryResponse>}
     * @memberof AvailableContainerRegistryResponseList
     */
    'results'?: Array<AvailableContainerRegistryResponse>;
}
/**
 * 
 * @export
 * @interface AwsCredentialsRequest
 */
export interface AwsCredentialsRequest {
    /**
     * 
     * @type {string}
     * @memberof AwsCredentialsRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AwsCredentialsRequest
     */
    'access_key_id': string;
    /**
     * 
     * @type {string}
     * @memberof AwsCredentialsRequest
     */
    'secret_access_key': string;
}
/**
 * 
 * @export
 * @interface Backup
 */
export interface Backup {
    /**
     * 
     * @type {string}
     * @memberof Backup
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Backup
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Backup
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Backup
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Backup
     */
    'message': string;
    /**
     * 
     * @type {Status}
     * @memberof Backup
     */
    'status'?: Status;
}
/**
 * 
 * @export
 * @interface BackupAllOf
 */
export interface BackupAllOf {
    /**
     * 
     * @type {Status}
     * @memberof BackupAllOf
     */
    'status'?: Status;
}
/**
 * 
 * @export
 * @interface BackupPaginatedResponseList
 */
export interface BackupPaginatedResponseList {
    /**
     * 
     * @type {number}
     * @memberof BackupPaginatedResponseList
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof BackupPaginatedResponseList
     */
    'page_size': number;
    /**
     * 
     * @type {Array<Backup>}
     * @memberof BackupPaginatedResponseList
     */
    'results'?: Array<Backup>;
}
/**
 * 
 * @export
 * @interface BackupRequest
 */
export interface BackupRequest {
    /**
     * 
     * @type {string}
     * @memberof BackupRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BackupRequest
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface BackupResponseList
 */
export interface BackupResponseList {
    /**
     * 
     * @type {Array<Backup>}
     * @memberof BackupResponseList
     */
    'results'?: Array<Backup>;
}
/**
 * 
 * @export
 * @interface Base
 */
export interface Base {
    /**
     * 
     * @type {string}
     * @memberof Base
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Base
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Base
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface BillingEnd
 */
export interface BillingEnd {
    /**
     * 
     * @type {string}
     * @memberof BillingEnd
     */
    'billing_ended_on'?: string;
}
/**
 * 
 * @export
 * @interface BillingInfo
 */
export interface BillingInfo {
    /**
     * 
     * @type {string}
     * @memberof BillingInfo
     */
    'first_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BillingInfo
     */
    'last_name'?: string | null;
    /**
     * email used for billing, and to receive all invoices by email
     * @type {string}
     * @memberof BillingInfo
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BillingInfo
     */
    'address'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BillingInfo
     */
    'city'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BillingInfo
     */
    'zip'?: string | null;
    /**
     * only for US
     * @type {string}
     * @memberof BillingInfo
     */
    'state'?: string | null;
    /**
     * ISO code of the country
     * @type {string}
     * @memberof BillingInfo
     */
    'country_code'?: string | null;
    /**
     * name of the company to bill
     * @type {string}
     * @memberof BillingInfo
     */
    'company'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BillingInfo
     */
    'vat_number'?: string | null;
}
/**
 * 
 * @export
 * @interface BillingInfoRequest
 */
export interface BillingInfoRequest {
    /**
     * 
     * @type {string}
     * @memberof BillingInfoRequest
     */
    'first_name': string;
    /**
     * 
     * @type {string}
     * @memberof BillingInfoRequest
     */
    'last_name': string;
    /**
     * email used for billing, and to receive all invoices by email
     * @type {string}
     * @memberof BillingInfoRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof BillingInfoRequest
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof BillingInfoRequest
     */
    'city': string;
    /**
     * 
     * @type {string}
     * @memberof BillingInfoRequest
     */
    'zip': string;
    /**
     * only for US
     * @type {string}
     * @memberof BillingInfoRequest
     */
    'state'?: string;
    /**
     * ISO code of the country
     * @type {string}
     * @memberof BillingInfoRequest
     */
    'country_code': string;
    /**
     * name of the company to bill
     * @type {string}
     * @memberof BillingInfoRequest
     */
    'company'?: string;
    /**
     * 
     * @type {string}
     * @memberof BillingInfoRequest
     */
    'vat_number'?: string;
}
/**
 * 
 * @export
 * @interface BillingPeriod
 */
export interface BillingPeriod {
    /**
     * 
     * @type {string}
     * @memberof BillingPeriod
     */
    'billing_started_on'?: string;
    /**
     * 
     * @type {string}
     * @memberof BillingPeriod
     */
    'billing_ended_on'?: string;
}
/**
 * 
 * @export
 * @interface BillingStart
 */
export interface BillingStart {
    /**
     * 
     * @type {string}
     * @memberof BillingStart
     */
    'billing_started_on'?: string;
}
/**
 * 
 * @export
 * @interface BillingStatus
 */
export interface BillingStatus {
    /**
     * 
     * @type {boolean}
     * @memberof BillingStatus
     */
    'is_valid'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof BillingStatus
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface Budget
 */
export interface Budget {
    /**
     * 
     * @type {number}
     * @memberof Budget
     */
    'total_in_cents'?: number;
    /**
     * 
     * @type {number}
     * @memberof Budget
     */
    'total'?: number;
    /**
     * 
     * @type {string}
     * @memberof Budget
     */
    'currency_code'?: string;
}
/**
 * 
 * @export
 * @interface BudgetThreshold
 */
export interface BudgetThreshold {
    /**
     * 
     * @type {number}
     * @memberof BudgetThreshold
     */
    'total_in_cents'?: number;
    /**
     * 
     * @type {number}
     * @memberof BudgetThreshold
     */
    'total'?: number;
    /**
     * 
     * @type {string}
     * @memberof BudgetThreshold
     */
    'currency_code'?: string;
}
/**
 * `DOCKER` requires `dockerfile_path` `BUILDPACKS` does not require any `dockerfile_path` 
 * @export
 * @enum {string}
 */

export enum BuildModeEnum {
    BUILDPACKS = 'BUILDPACKS',
    DOCKER = 'DOCKER'
}

/**
 * Development language of the application
 * @export
 * @enum {string}
 */

export enum BuildPackLanguageEnum {
    CLOJURE = 'CLOJURE',
    GO = 'GO',
    GRADLE = 'GRADLE',
    GRAILS = 'GRAILS',
    JAVA = 'JAVA',
    JVM = 'JVM',
    NODE_JS = 'NODE_JS',
    PHP = 'PHP',
    PLAY = 'PLAY',
    PYTHON = 'PYTHON',
    SCALA = 'SCALA'
}

/**
 * 
 * @export
 * @interface CloneApplicationRequest
 */
export interface CloneApplicationRequest {
    /**
     * 
     * @type {string}
     * @memberof CloneApplicationRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CloneApplicationRequest
     */
    'environment_id': string;
}
/**
 * 
 * @export
 * @interface CloneContainerRequest
 */
export interface CloneContainerRequest {
    /**
     * 
     * @type {string}
     * @memberof CloneContainerRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CloneContainerRequest
     */
    'environment_id': string;
}
/**
 * 
 * @export
 * @interface CloneDatabaseRequest
 */
export interface CloneDatabaseRequest {
    /**
     * 
     * @type {string}
     * @memberof CloneDatabaseRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CloneDatabaseRequest
     */
    'environment_id': string;
}
/**
 * 
 * @export
 * @interface CloneJobRequest
 */
export interface CloneJobRequest {
    /**
     * 
     * @type {string}
     * @memberof CloneJobRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CloneJobRequest
     */
    'environment_id': string;
}
/**
 * 
 * @export
 * @interface CloneRequest
 */
export interface CloneRequest {
    /**
     * name is case insensitive
     * @type {string}
     * @memberof CloneRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CloneRequest
     */
    'cluster_id'?: string;
    /**
     * 
     * @type {EnvironmentModeEnum}
     * @memberof CloneRequest
     */
    'mode'?: EnvironmentModeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof CloneRequest
     */
    'apply_deployment_rule'?: boolean;
}
/**
 * 
 * @export
 * @interface CloudProvider
 */
export interface CloudProvider {
    /**
     * 
     * @type {string}
     * @memberof CloudProvider
     */
    'short_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CloudProvider
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CloudProvider
     */
    'logo_url'?: string;
    /**
     * 
     * @type {Array<ClusterRegion>}
     * @memberof CloudProvider
     */
    'regions'?: Array<ClusterRegion>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum CloudProviderEnum {
    AWS = 'AWS',
    DO = 'DO',
    SCW = 'SCW'
}

/**
 * 
 * @export
 * @interface CloudProviderResponseList
 */
export interface CloudProviderResponseList {
    /**
     * 
     * @type {Array<CloudProvider>}
     * @memberof CloudProviderResponseList
     */
    'results'?: Array<CloudProvider>;
}
/**
 * 
 * @export
 * @interface Cluster
 */
export interface Cluster {
    /**
     * 
     * @type {string}
     * @memberof Cluster
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Cluster
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Cluster
     */
    'updated_at'?: string;
    /**
     * name is case-insensitive
     * @type {string}
     * @memberof Cluster
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Cluster
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Cluster
     */
    'region': string;
    /**
     * 
     * @type {CloudProviderEnum}
     * @memberof Cluster
     */
    'cloud_provider': CloudProviderEnum;
    /**
     * 
     * @type {number}
     * @memberof Cluster
     */
    'min_running_nodes'?: number;
    /**
     * 
     * @type {number}
     * @memberof Cluster
     */
    'max_running_nodes'?: number;
    /**
     * Unit is in GB. The disk size to be used for the node configuration
     * @type {number}
     * @memberof Cluster
     */
    'disk_size'?: number;
    /**
     * the instance type to be used for this cluster. The list of values can be retrieved via the endpoint /{CloudProvider}/instanceType
     * @type {string}
     * @memberof Cluster
     */
    'instance_type'?: string;
    /**
     * 
     * @type {KubernetesEnum}
     * @memberof Cluster
     */
    'kubernetes'?: KubernetesEnum;
    /**
     * unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof Cluster
     */
    'cpu'?: number;
    /**
     * unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof Cluster
     */
    'memory'?: number;
    /**
     * This is an estimation of the cost this cluster will represent on your cloud proider bill, based on your current configuration
     * @type {number}
     * @memberof Cluster
     */
    'estimated_cloud_provider_cost'?: number;
    /**
     * 
     * @type {StateEnum}
     * @memberof Cluster
     */
    'status'?: StateEnum;
    /**
     * 
     * @type {boolean}
     * @memberof Cluster
     */
    'has_access'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Cluster
     */
    'version'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Cluster
     */
    'is_default'?: boolean;
    /**
     * specific flag to indicate that this cluster is a production one
     * @type {boolean}
     * @memberof Cluster
     */
    'production'?: boolean;
    /**
     * Indicate your public ssh_key to remotely connect to your EC2 instance.
     * @type {Array<string>}
     * @memberof Cluster
     */
    'ssh_keys'?: Array<string>;
    /**
     * 
     * @type {Array<ClusterFeature>}
     * @memberof Cluster
     */
    'features'?: Array<ClusterFeature>;
}
/**
 * 
 * @export
 * @interface ClusterAdvancedSettings
 */
export interface ClusterAdvancedSettings {
    /**
     * Set the number of retention days for EKS Cloudwatch logs
     * @type {number}
     * @memberof ClusterAdvancedSettings
     */
    'aws.cloudwatch.eks_logs_retention_days'?: number;
    /**
     * Enable flow logs for on the VPC and store them in an S3 bucket
     * @type {boolean}
     * @memberof ClusterAdvancedSettings
     */
    'aws.vpc.enable_s3_flow_logs'?: boolean;
    /**
     * Set the number of retention days for flow logs. Disable with value \"0\"
     * @type {number}
     * @memberof ClusterAdvancedSettings
     */
    'aws.vpc.flow_logs_retention_days'?: number;
    /**
     * For how long in week loki is going to keep logs of your applications
     * @type {number}
     * @memberof ClusterAdvancedSettings
     */
    'loki.log_retention_in_week'?: number;
    /**
     * Configure the number of seconds before cleaning images in the registry
     * @type {number}
     * @memberof ClusterAdvancedSettings
     */
    'registry.image_retention_time'?: number;
    /**
     * Add additional tags on the cluster dedicated registry
     * @type {{ [key: string]: string; }}
     * @memberof ClusterAdvancedSettings
     */
    'cloud_provider.container_registry.tags'?: { [key: string]: string; };
    /**
     * Select the size of the main load_balancer (only effective for Scaleway)
     * @type {string}
     * @memberof ClusterAdvancedSettings
     */
    'load_balancer.size'?: string;
    /**
     * Deny public access to any PostgreSQL database
     * @type {boolean}
     * @memberof ClusterAdvancedSettings
     */
    'database.postgresql.deny_public_access'?: boolean;
    /**
     * List of CIDRs allowed to access the PostgreSQL database
     * @type {Array<string>}
     * @memberof ClusterAdvancedSettings
     */
    'database.postgresql.allowed_cidrs'?: Array<string>;
    /**
     * Deny public access to any MySql database
     * @type {boolean}
     * @memberof ClusterAdvancedSettings
     */
    'database.mysql.deny_public_access'?: boolean;
    /**
     * List of CIDRs allowed to access the MySql database
     * @type {Array<string>}
     * @memberof ClusterAdvancedSettings
     */
    'database.mysql.allowed_cidrs'?: Array<string>;
    /**
     * Deny public access to any MongoDB/DocumentDB database
     * @type {boolean}
     * @memberof ClusterAdvancedSettings
     */
    'database.mongodb.deny_public_access'?: boolean;
    /**
     * List of CIDRs allowed to access the MongoDB/DocumentDB database
     * @type {Array<string>}
     * @memberof ClusterAdvancedSettings
     */
    'database.mongodb.allowed_cidrs'?: Array<string>;
    /**
     * Deny public access to any Redis database
     * @type {boolean}
     * @memberof ClusterAdvancedSettings
     */
    'database.redis.deny_public_access'?: boolean;
    /**
     * List of CIDRs allowed to access the Redis database
     * @type {Array<string>}
     * @memberof ClusterAdvancedSettings
     */
    'database.redis.allowed_cidrs'?: Array<string>;
    /**
     * AWS IAM group name with cluster access
     * @type {string}
     * @memberof ClusterAdvancedSettings
     */
    'aws.iam.admin_group'?: string;
    /**
     * Specify the [IMDS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html) version you want to use:   * `required`: IMDS V2 only   * `optional`: IMDS V1 + V2 
     * @type {string}
     * @memberof ClusterAdvancedSettings
     */
    'aws.eks.ec2.metadata_imds'?: ClusterAdvancedSettingsAwsEksEc2MetadataImdsEnum;
    /**
     * 
     * @type {number}
     * @memberof ClusterAdvancedSettings
     * @deprecated
     */
    'pleco.resources_ttl'?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum ClusterAdvancedSettingsAwsEksEc2MetadataImdsEnum {
    OPTIONAL = 'optional',
    REQUIRED = 'required'
}

/**
 * 
 * @export
 * @interface ClusterAllOf
 */
export interface ClusterAllOf {
    /**
     * name is case-insensitive
     * @type {string}
     * @memberof ClusterAllOf
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ClusterAllOf
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterAllOf
     */
    'region': string;
    /**
     * 
     * @type {CloudProviderEnum}
     * @memberof ClusterAllOf
     */
    'cloud_provider': CloudProviderEnum;
    /**
     * 
     * @type {number}
     * @memberof ClusterAllOf
     */
    'min_running_nodes'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterAllOf
     */
    'max_running_nodes'?: number;
    /**
     * Unit is in GB. The disk size to be used for the node configuration
     * @type {number}
     * @memberof ClusterAllOf
     */
    'disk_size'?: number;
    /**
     * the instance type to be used for this cluster. The list of values can be retrieved via the endpoint /{CloudProvider}/instanceType
     * @type {string}
     * @memberof ClusterAllOf
     */
    'instance_type'?: string;
    /**
     * 
     * @type {KubernetesEnum}
     * @memberof ClusterAllOf
     */
    'kubernetes'?: KubernetesEnum;
    /**
     * unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof ClusterAllOf
     */
    'cpu'?: number;
    /**
     * unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof ClusterAllOf
     */
    'memory'?: number;
    /**
     * This is an estimation of the cost this cluster will represent on your cloud proider bill, based on your current configuration
     * @type {number}
     * @memberof ClusterAllOf
     */
    'estimated_cloud_provider_cost'?: number;
    /**
     * 
     * @type {StateEnum}
     * @memberof ClusterAllOf
     */
    'status'?: StateEnum;
    /**
     * 
     * @type {boolean}
     * @memberof ClusterAllOf
     */
    'has_access'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ClusterAllOf
     */
    'version'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ClusterAllOf
     */
    'is_default'?: boolean;
    /**
     * specific flag to indicate that this cluster is a production one
     * @type {boolean}
     * @memberof ClusterAllOf
     */
    'production'?: boolean;
    /**
     * Indicate your public ssh_key to remotely connect to your EC2 instance.
     * @type {Array<string>}
     * @memberof ClusterAllOf
     */
    'ssh_keys'?: Array<string>;
    /**
     * 
     * @type {Array<ClusterFeature>}
     * @memberof ClusterAllOf
     */
    'features'?: Array<ClusterFeature>;
}
/**
 * 
 * @export
 * @interface ClusterCloudProviderInfo
 */
export interface ClusterCloudProviderInfo {
    /**
     * 
     * @type {CloudProviderEnum}
     * @memberof ClusterCloudProviderInfo
     */
    'cloud_provider'?: CloudProviderEnum;
    /**
     * 
     * @type {ClusterCloudProviderInfoCredentials}
     * @memberof ClusterCloudProviderInfo
     */
    'credentials'?: ClusterCloudProviderInfoCredentials;
    /**
     * 
     * @type {string}
     * @memberof ClusterCloudProviderInfo
     */
    'region'?: string;
}
/**
 * 
 * @export
 * @interface ClusterCloudProviderInfoCredentials
 */
export interface ClusterCloudProviderInfoCredentials {
    /**
     * 
     * @type {string}
     * @memberof ClusterCloudProviderInfoCredentials
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterCloudProviderInfoCredentials
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface ClusterCloudProviderInfoRequest
 */
export interface ClusterCloudProviderInfoRequest {
    /**
     * 
     * @type {CloudProviderEnum}
     * @memberof ClusterCloudProviderInfoRequest
     */
    'cloud_provider'?: CloudProviderEnum;
    /**
     * 
     * @type {ClusterCloudProviderInfoCredentials}
     * @memberof ClusterCloudProviderInfoRequest
     */
    'credentials'?: ClusterCloudProviderInfoCredentials;
    /**
     * 
     * @type {string}
     * @memberof ClusterCloudProviderInfoRequest
     */
    'region'?: string;
}
/**
 * 
 * @export
 * @interface ClusterCredentials
 */
export interface ClusterCredentials {
    /**
     * 
     * @type {string}
     * @memberof ClusterCredentials
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ClusterCredentials
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ClusterCredentialsResponseList
 */
export interface ClusterCredentialsResponseList {
    /**
     * 
     * @type {Array<ClusterCredentials>}
     * @memberof ClusterCredentialsResponseList
     */
    'results'?: Array<ClusterCredentials>;
}
/**
 * 
 * @export
 * @interface ClusterFeature
 */
export interface ClusterFeature {
    /**
     * 
     * @type {string}
     * @memberof ClusterFeature
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterFeature
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterFeature
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ClusterFeature
     */
    'cost_per_month_in_cents'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ClusterFeature
     */
    'cost_per_month'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ClusterFeature
     */
    'currency_code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ClusterFeature
     */
    'value_type'?: ClusterFeatureValueTypeEnum;
    /**
     * 
     * @type {string | boolean}
     * @memberof ClusterFeature
     */
    'value'?: string | boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof ClusterFeature
     */
    'is_value_updatable'?: boolean;
    /**
     * 
     * @type {Array<string | boolean>}
     * @memberof ClusterFeature
     */
    'accepted_values'?: Array<string | boolean>;
}

/**
    * @export
    * @enum {string}
    */
export enum ClusterFeatureValueTypeEnum {
    BOOLEAN = 'BOOLEAN'
}

/**
 * 
 * @export
 * @interface ClusterFeatureResponseList
 */
export interface ClusterFeatureResponseList {
    /**
     * 
     * @type {Array<ClusterFeature>}
     * @memberof ClusterFeatureResponseList
     */
    'results'?: Array<ClusterFeature>;
}
/**
 * 
 * @export
 * @interface ClusterInstanceTypeResponseList
 */
export interface ClusterInstanceTypeResponseList {
    /**
     * 
     * @type {Array<ClusterInstanceTypeResponseListResults>}
     * @memberof ClusterInstanceTypeResponseList
     */
    'results'?: Array<ClusterInstanceTypeResponseListResults>;
}
/**
 * 
 * @export
 * @interface ClusterInstanceTypeResponseListResults
 */
export interface ClusterInstanceTypeResponseListResults {
    /**
     * 
     * @type {string}
     * @memberof ClusterInstanceTypeResponseListResults
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof ClusterInstanceTypeResponseListResults
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof ClusterInstanceTypeResponseListResults
     */
    'cpu': number;
    /**
     * 
     * @type {number}
     * @memberof ClusterInstanceTypeResponseListResults
     */
    'ram_in_gb': number;
    /**
     * 
     * @type {string}
     * @memberof ClusterInstanceTypeResponseListResults
     */
    'bandwidth_in_gbps': string;
    /**
     * 
     * @type {string}
     * @memberof ClusterInstanceTypeResponseListResults
     */
    'bandwidth_guarantee': string;
    /**
     * 
     * @type {string}
     * @memberof ClusterInstanceTypeResponseListResults
     */
    'architecture'?: string;
}
/**
 * 
 * @export
 * @interface ClusterLogs
 */
export interface ClusterLogs {
    /**
     * log level
     * @type {string}
     * @memberof ClusterLogs
     */
    'type'?: string;
    /**
     * log date creation
     * @type {string}
     * @memberof ClusterLogs
     */
    'timestamp'?: string;
    /**
     * log step
     * @type {string}
     * @memberof ClusterLogs
     */
    'step'?: ClusterLogsStepEnum;
    /**
     * 
     * @type {ClusterLogsMessage}
     * @memberof ClusterLogs
     */
    'message'?: ClusterLogsMessage;
    /**
     * 
     * @type {ClusterLogsError}
     * @memberof ClusterLogs
     */
    'error'?: ClusterLogsError;
    /**
     * 
     * @type {ClusterLogsDetails}
     * @memberof ClusterLogs
     */
    'details'?: ClusterLogsDetails;
}

/**
    * @export
    * @enum {string}
    */
export enum ClusterLogsStepEnum {
    LOAD_CONFIGURATION = 'LoadConfiguration',
    CREATE = 'Create',
    CREATED = 'Created',
    CREATE_ERROR = 'CreateError',
    PAUSE = 'Pause',
    PAUSED = 'Paused',
    PAUSE_ERROR = 'PauseError',
    DELETE = 'Delete',
    DELETED = 'Deleted',
    DELETE_ERROR = 'DeleteError',
    RETRIEVE_CLUSTER_CONFIG = 'RetrieveClusterConfig',
    RETRIEVE_CLUSTER_RESOURCES = 'RetrieveClusterResources',
    VALIDATE_SYSTEM_REQUIREMENTS = 'ValidateSystemRequirements',
    UNDER_MIGRATION = 'UnderMigration',
    UNKNOWN = 'Unknown'
}

/**
 * Present only for `info`, `warning` and `debug` logs
 * @export
 * @interface ClusterLogsDetails
 */
export interface ClusterLogsDetails {
    /**
     * cloud provider used
     * @type {string}
     * @memberof ClusterLogsDetails
     */
    'provider_kind'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterLogsDetails
     */
    'region'?: string;
    /**
     * 
     * @type {ClusterLogsErrorEventDetailsTransmitter}
     * @memberof ClusterLogsDetails
     */
    'transmitter'?: ClusterLogsErrorEventDetailsTransmitter;
}
/**
 * Present only for `error` log
 * @export
 * @interface ClusterLogsError
 */
export interface ClusterLogsError {
    /**
     * log error tag
     * @type {string}
     * @memberof ClusterLogsError
     */
    'tag'?: string;
    /**
     * log details about the error
     * @type {string}
     * @memberof ClusterLogsError
     */
    'user_log_message'?: string;
    /**
     * link to our documentation
     * @type {string}
     * @memberof ClusterLogsError
     */
    'link'?: string;
    /**
     * hint the user can follow
     * @type {string}
     * @memberof ClusterLogsError
     */
    'hint_message'?: string;
    /**
     * 
     * @type {ClusterLogsErrorEventDetails}
     * @memberof ClusterLogsError
     */
    'event_details'?: ClusterLogsErrorEventDetails;
    /**
     * 
     * @type {ClusterLogsErrorUnderlyingError}
     * @memberof ClusterLogsError
     */
    'underlying_error'?: ClusterLogsErrorUnderlyingError;
}
/**
 * 
 * @export
 * @interface ClusterLogsErrorEventDetails
 */
export interface ClusterLogsErrorEventDetails {
    /**
     * cloud provider used
     * @type {string}
     * @memberof ClusterLogsErrorEventDetails
     */
    'provider_kind'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterLogsErrorEventDetails
     */
    'region'?: string;
    /**
     * 
     * @type {ClusterLogsErrorEventDetailsTransmitter}
     * @memberof ClusterLogsErrorEventDetails
     */
    'transmitter'?: ClusterLogsErrorEventDetailsTransmitter;
}
/**
 * 
 * @export
 * @interface ClusterLogsErrorEventDetailsTransmitter
 */
export interface ClusterLogsErrorEventDetailsTransmitter {
    /**
     * 
     * @type {string}
     * @memberof ClusterLogsErrorEventDetailsTransmitter
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterLogsErrorEventDetailsTransmitter
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterLogsErrorEventDetailsTransmitter
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface ClusterLogsErrorUnderlyingError
 */
export interface ClusterLogsErrorUnderlyingError {
    /**
     * technical details about the error
     * @type {string}
     * @memberof ClusterLogsErrorUnderlyingError
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ClusterLogsMessage
 */
export interface ClusterLogsMessage {
    /**
     * log global message
     * @type {string}
     * @memberof ClusterLogsMessage
     */
    'safe_message'?: string;
}
/**
 * 
 * @export
 * @interface ClusterLogsResponseList
 */
export interface ClusterLogsResponseList {
    /**
     * 
     * @type {Array<ClusterLogs>}
     * @memberof ClusterLogsResponseList
     */
    'results'?: Array<ClusterLogs>;
}
/**
 * 
 * @export
 * @interface ClusterReadinessStatus
 */
export interface ClusterReadinessStatus {
    /**
     * 
     * @type {boolean}
     * @memberof ClusterReadinessStatus
     */
    'is_ready'?: boolean;
}
/**
 * 
 * @export
 * @interface ClusterRegion
 */
export interface ClusterRegion {
    /**
     * 
     * @type {string}
     * @memberof ClusterRegion
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ClusterRegion
     */
    'country_code': string;
    /**
     * 
     * @type {string}
     * @memberof ClusterRegion
     */
    'country': string;
    /**
     * 
     * @type {string}
     * @memberof ClusterRegion
     */
    'city': string;
}
/**
 * 
 * @export
 * @interface ClusterRegionResponseList
 */
export interface ClusterRegionResponseList {
    /**
     * 
     * @type {Array<ClusterRegion>}
     * @memberof ClusterRegionResponseList
     */
    'results'?: Array<ClusterRegion>;
}
/**
 * 
 * @export
 * @interface ClusterRequest
 */
export interface ClusterRequest {
    /**
     * name is case-insensitive
     * @type {string}
     * @memberof ClusterRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ClusterRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterRequest
     */
    'region': string;
    /**
     * 
     * @type {CloudProviderEnum}
     * @memberof ClusterRequest
     */
    'cloud_provider': CloudProviderEnum;
    /**
     * 
     * @type {number}
     * @memberof ClusterRequest
     */
    'min_running_nodes'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterRequest
     */
    'max_running_nodes'?: number;
    /**
     * Unit is in GB. The disk size to be used for the node configuration
     * @type {number}
     * @memberof ClusterRequest
     */
    'disk_size'?: number;
    /**
     * the instance type to be used for this cluster. The list of values can be retrieved via the endpoint /{CloudProvider}/instanceType
     * @type {string}
     * @memberof ClusterRequest
     */
    'instance_type'?: string;
    /**
     * 
     * @type {KubernetesEnum}
     * @memberof ClusterRequest
     */
    'kubernetes'?: KubernetesEnum;
    /**
     * specific flag to indicate that this cluster is a production one
     * @type {boolean}
     * @memberof ClusterRequest
     */
    'production'?: boolean;
    /**
     * Indicate your public ssh_key to remotely connect to your EC2 instance.
     * @type {Array<string>}
     * @memberof ClusterRequest
     */
    'ssh_keys'?: Array<string>;
    /**
     * 
     * @type {Array<ClusterRequestFeatures>}
     * @memberof ClusterRequest
     */
    'features'?: Array<ClusterRequestFeatures>;
}
/**
 * 
 * @export
 * @interface ClusterRequestFeatures
 */
export interface ClusterRequestFeatures {
    /**
     * 
     * @type {string}
     * @memberof ClusterRequestFeatures
     */
    'id'?: string;
    /**
     * 
     * @type {string | boolean}
     * @memberof ClusterRequestFeatures
     */
    'value'?: string | boolean | null;
}
/**
 * 
 * @export
 * @interface ClusterResponseList
 */
export interface ClusterResponseList {
    /**
     * 
     * @type {Array<Cluster>}
     * @memberof ClusterResponseList
     */
    'results'?: Array<Cluster>;
}
/**
 * 
 * @export
 * @interface ClusterRoutingTable
 */
export interface ClusterRoutingTable {
    /**
     * 
     * @type {Array<ClusterRoutingTableResults>}
     * @memberof ClusterRoutingTable
     */
    'results'?: Array<ClusterRoutingTableResults>;
}
/**
 * 
 * @export
 * @interface ClusterRoutingTableRequest
 */
export interface ClusterRoutingTableRequest {
    /**
     * 
     * @type {Array<ClusterRoutingTableRequestRoutes>}
     * @memberof ClusterRoutingTableRequest
     */
    'routes': Array<ClusterRoutingTableRequestRoutes>;
}
/**
 * 
 * @export
 * @interface ClusterRoutingTableRequestRoutes
 */
export interface ClusterRoutingTableRequestRoutes {
    /**
     * 
     * @type {string}
     * @memberof ClusterRoutingTableRequestRoutes
     */
    'destination': string;
    /**
     * 
     * @type {string}
     * @memberof ClusterRoutingTableRequestRoutes
     */
    'target': string;
    /**
     * 
     * @type {string}
     * @memberof ClusterRoutingTableRequestRoutes
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface ClusterRoutingTableResults
 */
export interface ClusterRoutingTableResults {
    /**
     * 
     * @type {string}
     * @memberof ClusterRoutingTableResults
     */
    'destination'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterRoutingTableResults
     */
    'target'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterRoutingTableResults
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface ClusterStatus
 */
export interface ClusterStatus {
    /**
     * 
     * @type {string}
     * @memberof ClusterStatus
     */
    'cluster_id'?: string;
    /**
     * 
     * @type {StateEnum}
     * @memberof ClusterStatus
     */
    'status'?: StateEnum;
    /**
     * 
     * @type {boolean}
     * @memberof ClusterStatus
     */
    'is_deployed'?: boolean;
}
/**
 * 
 * @export
 * @interface ClusterStatusGet
 */
export interface ClusterStatusGet {
    /**
     * 
     * @type {string}
     * @memberof ClusterStatusGet
     */
    'cluster_id'?: string;
    /**
     * 
     * @type {StateEnum}
     * @memberof ClusterStatusGet
     */
    'status'?: StateEnum;
    /**
     * 
     * @type {boolean}
     * @memberof ClusterStatusGet
     */
    'is_deployed'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ClusterStatusGet
     */
    'last_execution_id'?: string;
}
/**
 * 
 * @export
 * @interface ClusterStatusResponseList
 */
export interface ClusterStatusResponseList {
    /**
     * 
     * @type {Array<ClusterStatusGet>}
     * @memberof ClusterStatusResponseList
     */
    'results'?: Array<ClusterStatusGet>;
}
/**
 * 
 * @export
 * @interface Commit
 */
export interface Commit {
    /**
     * 
     * @type {string}
     * @memberof Commit
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Commit
     */
    'git_commit_id': string;
    /**
     * 
     * @type {string}
     * @memberof Commit
     */
    'tag': string;
    /**
     * 
     * @type {string}
     * @memberof Commit
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof Commit
     */
    'author_name': string;
    /**
     * 
     * @type {string}
     * @memberof Commit
     */
    'author_avatar_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof Commit
     */
    'commit_page_url'?: string;
}
/**
 * 
 * @export
 * @interface CommitPaginatedResponseList
 */
export interface CommitPaginatedResponseList {
    /**
     * 
     * @type {Array<Commit>}
     * @memberof CommitPaginatedResponseList
     */
    'results'?: Array<Commit>;
    /**
     * 
     * @type {number}
     * @memberof CommitPaginatedResponseList
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof CommitPaginatedResponseList
     */
    'page_size': number;
}
/**
 * 
 * @export
 * @interface CommitPaginatedResponseListAllOf
 */
export interface CommitPaginatedResponseListAllOf {
    /**
     * 
     * @type {Array<Commit>}
     * @memberof CommitPaginatedResponseListAllOf
     */
    'results'?: Array<Commit>;
}
/**
 * 
 * @export
 * @interface CommitResponseList
 */
export interface CommitResponseList {
    /**
     * 
     * @type {Array<Commit>}
     * @memberof CommitResponseList
     */
    'results'?: Array<Commit>;
}
/**
 * 
 * @export
 * @interface CommunityUsage
 */
export interface CommunityUsage {
    /**
     * 
     * @type {Array<ProjectCurrentCost>}
     * @memberof CommunityUsage
     */
    'projects'?: Array<ProjectCurrentCost>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum CompanySizeEnum {
    _1_10 = '1-10',
    _11_50 = '11-50',
    _51_200 = '51-200',
    _201_500 = '201-500',
    _500 = '500+'
}

/**
 * 
 * @export
 * @interface ContainerAdvancedSettings
 */
export interface ContainerAdvancedSettings {
    /**
     * disable custom domain check when deploying an application
     * @type {boolean}
     * @memberof ContainerAdvancedSettings
     */
    'deployment.custom_domain_check_enabled'?: boolean;
    /**
     * define how long in seconds an application is supposed to be stopped gracefully
     * @type {number}
     * @memberof ContainerAdvancedSettings
     */
    'deployment.termination_grace_period_seconds'?: number;
    /**
     * * `RollingUpdate` gracefully rollout new versions, and automatically rollback if the new version fails to start * `Recreate` stop all current versions and create new ones once all old ones have been shutdown 
     * @type {string}
     * @memberof ContainerAdvancedSettings
     */
    'deployment.update_strategy.type'?: ContainerAdvancedSettingsDeploymentUpdateStrategyTypeEnum;
    /**
     * Define the percentage of a maximum number of pods that can be unavailable during the update process
     * @type {number}
     * @memberof ContainerAdvancedSettings
     */
    'deployment.update_strategy.rolling_update.max_unavailable_percent'?: number;
    /**
     * Define the percentage of the maximum number of pods that can be created over the desired number of pods
     * @type {number}
     * @memberof ContainerAdvancedSettings
     */
    'deployment.update_strategy.rolling_update.max_surge_percent'?: number;
    /**
     * 
     * @type {number}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.proxy_body_size_mb'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.enable_cors'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.cors_allow_origin'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.cors_allow_methods'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.cors_allow_headers'?: string;
    /**
     * header buffer size used while reading response header from upstream
     * @type {number}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.proxy_buffer_size_kb'?: number;
    /**
     * Limits the maximum time (in seconds) during which requests can be processed through one keepalive connection
     * @type {number}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.keepalive_time_seconds'?: number;
    /**
     * Sets a timeout (in seconds) during which an idle keepalive connection to an upstream server will stay open.
     * @type {number}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.keepalive_timeout_seconds'?: number;
    /**
     * Sets a timeout (in seconds) for transmitting a response to the client
     * @type {number}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.send_timeout_seconds'?: number;
    /**
     * Sets a timeout (in seconds) for establishing a connection to a proxied server
     * @type {number}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.proxy_connect_timeout_seconds'?: number;
    /**
     * Sets a timeout (in seconds) for transmitting a request to the proxied server
     * @type {number}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.proxy_send_timeout_seconds'?: number;
    /**
     * Sets a timeout (in seconds) for reading a response from the proxied server
     * @type {number}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.proxy_read_timeout_seconds'?: number;
    /**
     * Sets a timeout (in seconds) for transmitting a request to the grpc server
     * @type {number}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.grpc_send_timeout_seconds'?: number;
    /**
     * Sets a timeout (in seconds) for transmitting a request to the grpc server
     * @type {number}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.grpc_read_timeout_seconds'?: number;
    /**
     * list of source ranges to allow access to ingress proxy.  This property can be used to whitelist source IP ranges for ingress proxy. The value is a comma separated list of CIDRs, e.g. 10.0.0.0/24,172.10.0.1 To allow all source ranges, set 0.0.0.0/0. 
     * @type {string}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.whitelist_source_range'?: string;
    /**
     * list of source ranges to deny access to ingress proxy.  This property can be used to blacklist source IP ranges for ingress proxy. The value is a comma separated list of CIDRs, e.g. 10.0.0.0/24,172.10.0.1 
     * @type {string}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.denylist_source_range'?: string;
    /**
     * Set the name of an environment variable to use as a basic authentication (`login:crypted_password`) from `htpasswd` command. You can add multiples comma separated values. 
     * @type {string}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.basic_auth_env_var'?: string;
    /**
     * Enable the load balancer to bind a user\'s session to a specific target. This ensures that all requests from the user during the session are sent to the same target 
     * @type {boolean}
     * @memberof ContainerAdvancedSettings
     */
    'network.ingress.enable_sticky_session'?: boolean;
    /**
     * Allows you to set an existing Kubernetes service account name 
     * @type {string}
     * @memberof ContainerAdvancedSettings
     */
    'security.service_account_name'?: string;
    /**
     * Percentage value of cpu usage at which point pods should scale up.
     * @type {number}
     * @memberof ContainerAdvancedSettings
     */
    'hpa.cpu.average_utilization_percent'?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum ContainerAdvancedSettingsDeploymentUpdateStrategyTypeEnum {
    ROLLING_UPDATE = 'RollingUpdate',
    RECREATE = 'Recreate'
}

/**
 * 
 * @export
 * @interface ContainerCurrentScale
 */
export interface ContainerCurrentScale {
    /**
     * 
     * @type {number}
     * @memberof ContainerCurrentScale
     */
    'min'?: number;
    /**
     * 
     * @type {number}
     * @memberof ContainerCurrentScale
     */
    'max'?: number;
    /**
     * 
     * @type {number}
     * @memberof ContainerCurrentScale
     */
    'running'?: number;
    /**
     * 
     * @type {number}
     * @memberof ContainerCurrentScale
     */
    'running_in_percent'?: number;
    /**
     * 
     * @type {number}
     * @memberof ContainerCurrentScale
     */
    'warning_threshold_in_percent'?: number;
    /**
     * 
     * @type {number}
     * @memberof ContainerCurrentScale
     */
    'alert_threshold_in_percent'?: number;
    /**
     * 
     * @type {ThresholdMetricStatusEnum}
     * @memberof ContainerCurrentScale
     */
    'status'?: ThresholdMetricStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ContainerCurrentScale
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface ContainerDeployRequest
 */
export interface ContainerDeployRequest {
    /**
     * Image tag to deploy
     * @type {string}
     * @memberof ContainerDeployRequest
     */
    'image_tag': string;
}
/**
 * 
 * @export
 * @interface ContainerNetwork
 */
export interface ContainerNetwork {
    /**
     * Specify if the sticky session option (also called persistant session) is activated or not for this container. If activated, user will be redirected by the load balancer to the same instance each time he access to the container.  
     * @type {boolean}
     * @memberof ContainerNetwork
     */
    'sticky_session'?: boolean;
}
/**
 * 
 * @export
 * @interface ContainerNetworkRequest
 */
export interface ContainerNetworkRequest {
    /**
     * Specify if the sticky session option (also called persistant session) is activated or not for this container. If activated, user will be redirected by the load balancer to the same instance each time he access to the container.  
     * @type {boolean}
     * @memberof ContainerNetworkRequest
     */
    'sticky_session'?: boolean;
}
/**
 * The type of your container registry
 * @export
 * @enum {string}
 */

export enum ContainerRegistryKindEnum {
    ECR = 'ECR',
    SCALEWAY_CR = 'SCALEWAY_CR',
    DOCKER_HUB = 'DOCKER_HUB',
    PUBLIC_ECR = 'PUBLIC_ECR',
    DOCR = 'DOCR'
}

/**
 * 
 * @export
 * @interface ContainerRegistryRequest
 */
export interface ContainerRegistryRequest {
    /**
     * 
     * @type {string}
     * @memberof ContainerRegistryRequest
     */
    'name': string;
    /**
     * 
     * @type {ContainerRegistryKindEnum}
     * @memberof ContainerRegistryRequest
     */
    'kind': ContainerRegistryKindEnum;
    /**
     * 
     * @type {string}
     * @memberof ContainerRegistryRequest
     */
    'description'?: string;
    /**
     * URL of the container registry: * For `DOCKER_HUB`: it must be `https://docker.io` (default with \'https://docker.io\' if no url provided for DOCKER_HUB) * For others: it\'s required and must start by `https://` 
     * @type {string}
     * @memberof ContainerRegistryRequest
     */
    'url'?: string;
    /**
     * 
     * @type {ContainerRegistryRequestConfig}
     * @memberof ContainerRegistryRequest
     */
    'config': ContainerRegistryRequestConfig;
}
/**
 * This field is dependent of the container registry kind: * `ECR` needs in the config: region, access_key_id, secret_access_key * `SCALEWAY_CR` needs in the config: region, scaleway_access_key, scaleway_secret_key * `DOCKER_HUB` needs in the config (optional): username, password * `PUBLIC_ECR` doesn\'t need credentials info * `DOCR` is not supported anymore 
 * @export
 * @interface ContainerRegistryRequestConfig
 */
export interface ContainerRegistryRequestConfig {
    /**
     * Required if kind is `ECR` or `PUBLIC_ECR`
     * @type {string}
     * @memberof ContainerRegistryRequestConfig
     */
    'access_key_id'?: string;
    /**
     * Required if kind is `ECR` or `PUBLIC_ECR`
     * @type {string}
     * @memberof ContainerRegistryRequestConfig
     */
    'secret_access_key'?: string;
    /**
     * Required if kind is `ECR` or `SCALEWAY_CR`
     * @type {string}
     * @memberof ContainerRegistryRequestConfig
     */
    'region'?: string;
    /**
     * Required if kind is `SCALEWAY_CR`
     * @type {string}
     * @memberof ContainerRegistryRequestConfig
     */
    'scaleway_access_key'?: string;
    /**
     * Required if kind is `SCALEWAY_CR`
     * @type {string}
     * @memberof ContainerRegistryRequestConfig
     */
    'scaleway_secret_key'?: string;
    /**
     * optional, for kind `DOCKER_HUB`   We encourage you to set credentials for Docker Hub due to the limits on the pull rate 
     * @type {string}
     * @memberof ContainerRegistryRequestConfig
     */
    'username'?: string;
    /**
     * optional, for kind `DOCKER_HUB`   We encourage you to set credentials for Docker Hub due to the limits on the pull rate 
     * @type {string}
     * @memberof ContainerRegistryRequestConfig
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface ContainerRegistryResponse
 */
export interface ContainerRegistryResponse {
    /**
     * 
     * @type {string}
     * @memberof ContainerRegistryResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ContainerRegistryResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ContainerRegistryResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerRegistryResponse
     */
    'name'?: string;
    /**
     * 
     * @type {ContainerRegistryKindEnum}
     * @memberof ContainerRegistryResponse
     */
    'kind'?: ContainerRegistryKindEnum;
    /**
     * 
     * @type {string}
     * @memberof ContainerRegistryResponse
     */
    'description'?: string;
    /**
     * URL of the container registry
     * @type {string}
     * @memberof ContainerRegistryResponse
     */
    'url'?: string;
    /**
     * 
     * @type {Base & object}
     * @memberof ContainerRegistryResponse
     */
    'cluster'?: Base & object;
}
/**
 * 
 * @export
 * @interface ContainerRegistryResponseAllOf
 */
export interface ContainerRegistryResponseAllOf {
    /**
     * 
     * @type {string}
     * @memberof ContainerRegistryResponseAllOf
     */
    'name'?: string;
    /**
     * 
     * @type {ContainerRegistryKindEnum}
     * @memberof ContainerRegistryResponseAllOf
     */
    'kind'?: ContainerRegistryKindEnum;
    /**
     * 
     * @type {string}
     * @memberof ContainerRegistryResponseAllOf
     */
    'description'?: string;
    /**
     * URL of the container registry
     * @type {string}
     * @memberof ContainerRegistryResponseAllOf
     */
    'url'?: string;
    /**
     * 
     * @type {Base & object}
     * @memberof ContainerRegistryResponseAllOf
     */
    'cluster'?: Base & object;
}
/**
 * 
 * @export
 * @interface ContainerRegistryResponseList
 */
export interface ContainerRegistryResponseList {
    /**
     * 
     * @type {Array<ContainerRegistryResponse>}
     * @memberof ContainerRegistryResponseList
     */
    'results'?: Array<ContainerRegistryResponse>;
}
/**
 * 
 * @export
 * @interface ContainerRequest
 */
export interface ContainerRequest {
    /**
     * 
     * @type {Array<ServiceStorageRequestStorage>}
     * @memberof ContainerRequest
     */
    'storage'?: Array<ServiceStorageRequestStorage>;
    /**
     * 
     * @type {Array<ServicePortRequestPorts>}
     * @memberof ContainerRequest
     */
    'ports'?: Array<ServicePortRequestPorts>;
    /**
     * name is case insensitive
     * @type {string}
     * @memberof ContainerRequest
     */
    'name': string;
    /**
     * give a description to this container
     * @type {string}
     * @memberof ContainerRequest
     */
    'description'?: string;
    /**
     * id of the linked registry
     * @type {string}
     * @memberof ContainerRequest
     */
    'registry_id': string;
    /**
     * The image name pattern differs according to chosen container registry provider:   * `ECR`: `repository` * `SCALEWAY_CR`: `namespace/image` * `DOCKER_HUB`: `image` or `repository/image` * `PUBLIC_ECR`: `registry_alias/repository` 
     * @type {string}
     * @memberof ContainerRequest
     */
    'image_name': string;
    /**
     * tag of the image container
     * @type {string}
     * @memberof ContainerRequest
     */
    'tag': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ContainerRequest
     */
    'arguments'?: Array<string>;
    /**
     * optional entrypoint when launching container
     * @type {string}
     * @memberof ContainerRequest
     */
    'entrypoint'?: string;
    /**
     * unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof ContainerRequest
     */
    'cpu'?: number;
    /**
     * unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof ContainerRequest
     */
    'memory'?: number;
    /**
     * Minimum number of instances running. This resource auto-scale based on the CPU and Memory consumption. Note: 0 means that there is no container running. 
     * @type {number}
     * @memberof ContainerRequest
     */
    'min_running_instances'?: number;
    /**
     * Maximum number of instances running. This resource auto-scale based on the CPU and Memory consumption. Note: -1 means that there is no limit. 
     * @type {number}
     * @memberof ContainerRequest
     */
    'max_running_instances'?: number;
    /**
     * 
     * @type {Healthcheck}
     * @memberof ContainerRequest
     */
    'healthchecks'?: Healthcheck;
    /**
     * Indicates if the \'environment preview option\' is enabled for this container.   If enabled, a preview environment will be automatically cloned when `/preview` endpoint is called.   If not specified, it takes the value of the `auto_preview` property from the associated environment. 
     * @type {boolean}
     * @memberof ContainerRequest
     */
    'auto_preview'?: boolean;
}
/**
 * 
 * @export
 * @interface ContainerRequestAllOf
 */
export interface ContainerRequestAllOf {
    /**
     * name is case insensitive
     * @type {string}
     * @memberof ContainerRequestAllOf
     */
    'name': string;
    /**
     * give a description to this container
     * @type {string}
     * @memberof ContainerRequestAllOf
     */
    'description'?: string;
    /**
     * id of the linked registry
     * @type {string}
     * @memberof ContainerRequestAllOf
     */
    'registry_id': string;
    /**
     * The image name pattern differs according to chosen container registry provider:   * `ECR`: `repository` * `SCALEWAY_CR`: `namespace/image` * `DOCKER_HUB`: `image` or `repository/image` * `PUBLIC_ECR`: `registry_alias/repository` 
     * @type {string}
     * @memberof ContainerRequestAllOf
     */
    'image_name': string;
    /**
     * tag of the image container
     * @type {string}
     * @memberof ContainerRequestAllOf
     */
    'tag': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ContainerRequestAllOf
     */
    'arguments'?: Array<string>;
    /**
     * optional entrypoint when launching container
     * @type {string}
     * @memberof ContainerRequestAllOf
     */
    'entrypoint'?: string;
    /**
     * unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof ContainerRequestAllOf
     */
    'cpu'?: number;
    /**
     * unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof ContainerRequestAllOf
     */
    'memory'?: number;
    /**
     * Minimum number of instances running. This resource auto-scale based on the CPU and Memory consumption. Note: 0 means that there is no container running. 
     * @type {number}
     * @memberof ContainerRequestAllOf
     */
    'min_running_instances'?: number;
    /**
     * Maximum number of instances running. This resource auto-scale based on the CPU and Memory consumption. Note: -1 means that there is no limit. 
     * @type {number}
     * @memberof ContainerRequestAllOf
     */
    'max_running_instances'?: number;
    /**
     * 
     * @type {Healthcheck}
     * @memberof ContainerRequestAllOf
     */
    'healthchecks'?: Healthcheck;
    /**
     * Indicates if the \'environment preview option\' is enabled for this container.   If enabled, a preview environment will be automatically cloned when `/preview` endpoint is called.   If not specified, it takes the value of the `auto_preview` property from the associated environment. 
     * @type {boolean}
     * @memberof ContainerRequestAllOf
     */
    'auto_preview'?: boolean;
}
/**
 * 
 * @export
 * @interface ContainerResponse
 */
export interface ContainerResponse {
    /**
     * 
     * @type {string}
     * @memberof ContainerResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ContainerResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ContainerResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {Array<ServiceStorageStorage>}
     * @memberof ContainerResponse
     */
    'storage'?: Array<ServiceStorageStorage>;
    /**
     * 
     * @type {ReferenceObject}
     * @memberof ContainerResponse
     */
    'environment': ReferenceObject;
    /**
     * 
     * @type {ReferenceObject}
     * @memberof ContainerResponse
     */
    'registry': ReferenceObject;
    /**
     * Maximum cpu that can be allocated to the container based on organization cluster configuration. unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof ContainerResponse
     */
    'maximum_cpu': number;
    /**
     * Maximum memory that can be allocated to the container based on organization cluster configuration. unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof ContainerResponse
     */
    'maximum_memory': number;
    /**
     * name is case insensitive
     * @type {string}
     * @memberof ContainerResponse
     */
    'name': string;
    /**
     * give a description to this container
     * @type {string}
     * @memberof ContainerResponse
     */
    'description'?: string;
    /**
     * name of the image container
     * @type {string}
     * @memberof ContainerResponse
     */
    'image_name': string;
    /**
     * tag of the image container
     * @type {string}
     * @memberof ContainerResponse
     */
    'tag': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ContainerResponse
     */
    'arguments'?: Array<string>;
    /**
     * optional entrypoint when launching container
     * @type {string}
     * @memberof ContainerResponse
     */
    'entrypoint'?: string;
    /**
     * unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof ContainerResponse
     */
    'cpu': number;
    /**
     * unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof ContainerResponse
     */
    'memory': number;
    /**
     * Minimum number of instances running. This resource auto-scale based on the CPU and Memory consumption. Note: 0 means that there is no container running. 
     * @type {number}
     * @memberof ContainerResponse
     */
    'min_running_instances': number;
    /**
     * Maximum number of instances running. This resource auto-scale based on the CPU and Memory consumption. Note: -1 means that there is no limit. 
     * @type {number}
     * @memberof ContainerResponse
     */
    'max_running_instances': number;
    /**
     * 
     * @type {Healthcheck}
     * @memberof ContainerResponse
     */
    'healthchecks'?: Healthcheck;
    /**
     * Indicates if the \'environment preview option\' is enabled for this container.   If enabled, a preview environment will be automatically cloned when `/preview` endpoint is called.   If not specified, it takes the value of the `auto_preview` property from the associated environment. 
     * @type {boolean}
     * @memberof ContainerResponse
     */
    'auto_preview': boolean;
    /**
     * 
     * @type {Array<ServicePort>}
     * @memberof ContainerResponse
     */
    'ports'?: Array<ServicePort>;
}
/**
 * 
 * @export
 * @interface ContainerResponseAllOf
 */
export interface ContainerResponseAllOf {
    /**
     * 
     * @type {ReferenceObject}
     * @memberof ContainerResponseAllOf
     */
    'environment': ReferenceObject;
    /**
     * 
     * @type {ReferenceObject}
     * @memberof ContainerResponseAllOf
     */
    'registry': ReferenceObject;
    /**
     * Maximum cpu that can be allocated to the container based on organization cluster configuration. unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof ContainerResponseAllOf
     */
    'maximum_cpu': number;
    /**
     * Maximum memory that can be allocated to the container based on organization cluster configuration. unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof ContainerResponseAllOf
     */
    'maximum_memory': number;
    /**
     * name is case insensitive
     * @type {string}
     * @memberof ContainerResponseAllOf
     */
    'name': string;
    /**
     * give a description to this container
     * @type {string}
     * @memberof ContainerResponseAllOf
     */
    'description'?: string;
    /**
     * name of the image container
     * @type {string}
     * @memberof ContainerResponseAllOf
     */
    'image_name': string;
    /**
     * tag of the image container
     * @type {string}
     * @memberof ContainerResponseAllOf
     */
    'tag': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ContainerResponseAllOf
     */
    'arguments'?: Array<string>;
    /**
     * optional entrypoint when launching container
     * @type {string}
     * @memberof ContainerResponseAllOf
     */
    'entrypoint'?: string;
    /**
     * unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof ContainerResponseAllOf
     */
    'cpu': number;
    /**
     * unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof ContainerResponseAllOf
     */
    'memory': number;
    /**
     * Minimum number of instances running. This resource auto-scale based on the CPU and Memory consumption. Note: 0 means that there is no container running. 
     * @type {number}
     * @memberof ContainerResponseAllOf
     */
    'min_running_instances': number;
    /**
     * Maximum number of instances running. This resource auto-scale based on the CPU and Memory consumption. Note: -1 means that there is no limit. 
     * @type {number}
     * @memberof ContainerResponseAllOf
     */
    'max_running_instances': number;
    /**
     * 
     * @type {Healthcheck}
     * @memberof ContainerResponseAllOf
     */
    'healthchecks'?: Healthcheck;
    /**
     * Indicates if the \'environment preview option\' is enabled for this container.   If enabled, a preview environment will be automatically cloned when `/preview` endpoint is called.   If not specified, it takes the value of the `auto_preview` property from the associated environment. 
     * @type {boolean}
     * @memberof ContainerResponseAllOf
     */
    'auto_preview': boolean;
    /**
     * 
     * @type {Array<ServicePort>}
     * @memberof ContainerResponseAllOf
     */
    'ports'?: Array<ServicePort>;
}
/**
 * 
 * @export
 * @interface ContainerResponseList
 */
export interface ContainerResponseList {
    /**
     * 
     * @type {Array<ContainerResponse>}
     * @memberof ContainerResponseList
     */
    'results'?: Array<ContainerResponse>;
}
/**
 * 
 * @export
 * @interface Cost
 */
export interface Cost {
    /**
     * 
     * @type {number}
     * @memberof Cost
     */
    'total_in_cents': number;
    /**
     * 
     * @type {number}
     * @memberof Cost
     */
    'total': number;
    /**
     * 
     * @type {string}
     * @memberof Cost
     */
    'currency_code': string;
}
/**
 * 
 * @export
 * @interface CostRange
 */
export interface CostRange {
    /**
     * 
     * @type {number}
     * @memberof CostRange
     */
    'min_cost_in_cents'?: number;
    /**
     * 
     * @type {number}
     * @memberof CostRange
     */
    'min_cost'?: number;
    /**
     * 
     * @type {number}
     * @memberof CostRange
     */
    'max_cost_in_cents'?: number;
    /**
     * 
     * @type {number}
     * @memberof CostRange
     */
    'max_cost'?: number;
    /**
     * 
     * @type {string}
     * @memberof CostRange
     */
    'currency_code': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum CreateEnvironmentModeEnum {
    DEVELOPMENT = 'DEVELOPMENT',
    PRODUCTION = 'PRODUCTION',
    STAGING = 'STAGING'
}

/**
 * 
 * @export
 * @interface CreateEnvironmentRequest
 */
export interface CreateEnvironmentRequest {
    /**
     * name is case insensitive
     * @type {string}
     * @memberof CreateEnvironmentRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateEnvironmentRequest
     */
    'cluster'?: string;
    /**
     * 
     * @type {CreateEnvironmentModeEnum}
     * @memberof CreateEnvironmentRequest
     */
    'mode'?: CreateEnvironmentModeEnum;
}
/**
 * 
 * @export
 * @interface Credentials
 */
export interface Credentials {
    /**
     * 
     * @type {string}
     * @memberof Credentials
     */
    'host': string;
    /**
     * 
     * @type {number}
     * @memberof Credentials
     */
    'port': number;
    /**
     * 
     * @type {string}
     * @memberof Credentials
     */
    'login': string;
    /**
     * 
     * @type {string}
     * @memberof Credentials
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface CredentialsRequest
 */
export interface CredentialsRequest {
    /**
     * 
     * @type {string}
     * @memberof CredentialsRequest
     */
    'login': string;
    /**
     * 
     * @type {string}
     * @memberof CredentialsRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface CreditCard
 */
export interface CreditCard {
    /**
     * 
     * @type {string}
     * @memberof CreditCard
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CreditCard
     */
    'created_at': string;
    /**
     * 
     * @type {number}
     * @memberof CreditCard
     */
    'expiry_month': number;
    /**
     * 
     * @type {number}
     * @memberof CreditCard
     */
    'expiry_year': number;
    /**
     * 
     * @type {string}
     * @memberof CreditCard
     */
    'last_digit': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreditCard
     */
    'is_expired': boolean;
}
/**
 * 
 * @export
 * @interface CreditCardRequest
 */
export interface CreditCardRequest {
    /**
     * 
     * @type {string}
     * @memberof CreditCardRequest
     */
    'number': string;
    /**
     * 
     * @type {string}
     * @memberof CreditCardRequest
     */
    'cvv': string;
    /**
     * 
     * @type {number}
     * @memberof CreditCardRequest
     */
    'expiry_month': number;
    /**
     * 
     * @type {number}
     * @memberof CreditCardRequest
     */
    'expiry_year': number;
}
/**
 * 
 * @export
 * @interface CreditCardResponseList
 */
export interface CreditCardResponseList {
    /**
     * 
     * @type {Array<CreditCard>}
     * @memberof CreditCardResponseList
     */
    'results'?: Array<CreditCard>;
}
/**
 * 
 * @export
 * @interface CurrentCost
 */
export interface CurrentCost {
    /**
     * 
     * @type {PlanEnum}
     * @memberof CurrentCost
     */
    'plan'?: PlanEnum;
    /**
     * number of days remaining before the end of the trial period
     * @type {number}
     * @memberof CurrentCost
     */
    'remaining_trial_day'?: number;
    /**
     * 
     * @type {RemainingCredits}
     * @memberof CurrentCost
     */
    'remaining_credits'?: RemainingCredits;
    /**
     * 
     * @type {Cost}
     * @memberof CurrentCost
     */
    'cost'?: Cost;
}
/**
 * 
 * @export
 * @interface CustomDomain
 */
export interface CustomDomain {
    /**
     * 
     * @type {string}
     * @memberof CustomDomain
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CustomDomain
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof CustomDomain
     */
    'updated_at'?: string;
    /**
     * your custom domain
     * @type {string}
     * @memberof CustomDomain
     */
    'domain': string;
    /**
     * URL provided by Qovery. You must create a CNAME on your DNS provider using that URL
     * @type {string}
     * @memberof CustomDomain
     */
    'validation_domain'?: string;
    /**
     * 
     * @type {CustomDomainStatusEnum}
     * @memberof CustomDomain
     */
    'status'?: CustomDomainStatusEnum;
}
/**
 * 
 * @export
 * @interface CustomDomainAllOf
 */
export interface CustomDomainAllOf {
    /**
     * URL provided by Qovery. You must create a CNAME on your DNS provider using that URL
     * @type {string}
     * @memberof CustomDomainAllOf
     */
    'validation_domain'?: string;
    /**
     * 
     * @type {CustomDomainStatusEnum}
     * @memberof CustomDomainAllOf
     */
    'status'?: CustomDomainStatusEnum;
}
/**
 * 
 * @export
 * @interface CustomDomainRequest
 */
export interface CustomDomainRequest {
    /**
     * your custom domain
     * @type {string}
     * @memberof CustomDomainRequest
     */
    'domain': string;
}
/**
 * 
 * @export
 * @interface CustomDomainResponseList
 */
export interface CustomDomainResponseList {
    /**
     * 
     * @type {Array<CustomDomain>}
     * @memberof CustomDomainResponseList
     */
    'results'?: Array<CustomDomain>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum CustomDomainStatusEnum {
    VALIDATION_PENDING = 'VALIDATION_PENDING'
}

/**
 * 
 * @export
 * @interface Database
 */
export interface Database {
    /**
     * 
     * @type {string}
     * @memberof Database
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Database
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Database
     */
    'updated_at'?: string;
    /**
     * name is case insensitive
     * @type {string}
     * @memberof Database
     */
    'name': string;
    /**
     * give a description to this database
     * @type {string}
     * @memberof Database
     */
    'description'?: string;
    /**
     * 
     * @type {DatabaseTypeEnum}
     * @memberof Database
     */
    'type': DatabaseTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Database
     */
    'version': string;
    /**
     * 
     * @type {DatabaseModeEnum}
     * @memberof Database
     */
    'mode': DatabaseModeEnum;
    /**
     * 
     * @type {DatabaseAccessibilityEnum}
     * @memberof Database
     */
    'accessibility'?: DatabaseAccessibilityEnum;
    /**
     * unit is millicores (m). 1000m = 1 cpu This field will be ignored for managed DB (instance type will be used instead). 
     * @type {number}
     * @memberof Database
     */
    'cpu'?: number;
    /**
     * Database instance type to be used for this database. The list of values can be retrieved via the endpoint /{CloudProvider}/managedDatabase/instanceType/{region}/{dbType}. This field is null for container DB.
     * @type {string}
     * @memberof Database
     */
    'instance_type'?: string;
    /**
     * unit is MB. 1024 MB = 1GB This field will be ignored for managed DB (instance type will be used instead). Default value is linked to the database type: - MANAGED: `100` - CONTAINER   - POSTGRES: `100`   - REDIS: `100`   - MYSQL: `512`   - MONGODB: `256` 
     * @type {number}
     * @memberof Database
     */
    'memory'?: number;
    /**
     * unit is GB
     * @type {number}
     * @memberof Database
     */
    'storage'?: number;
    /**
     * 
     * @type {ReferenceObject}
     * @memberof Database
     */
    'environment'?: ReferenceObject;
    /**
     * 
     * @type {string}
     * @memberof Database
     */
    'host'?: string;
    /**
     * 
     * @type {number}
     * @memberof Database
     */
    'port'?: number;
    /**
     * Maximum cpu that can be allocated to the database based on organization cluster configuration. unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof Database
     */
    'maximum_cpu'?: number;
    /**
     * Maximum memory that can be allocated to the database based on organization cluster configuration. unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof Database
     */
    'maximum_memory'?: number;
    /**
     * indicates if the database disk is encrypted or not
     * @type {boolean}
     * @memberof Database
     */
    'disk_encrypted'?: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum DatabaseAccessibilityEnum {
    PRIVATE = 'PRIVATE',
    PUBLIC = 'PUBLIC'
}

/**
 * 
 * @export
 * @interface DatabaseAllOf
 */
export interface DatabaseAllOf {
    /**
     * 
     * @type {ReferenceObject}
     * @memberof DatabaseAllOf
     */
    'environment'?: ReferenceObject;
    /**
     * 
     * @type {string}
     * @memberof DatabaseAllOf
     */
    'host'?: string;
    /**
     * 
     * @type {number}
     * @memberof DatabaseAllOf
     */
    'port'?: number;
    /**
     * Maximum cpu that can be allocated to the database based on organization cluster configuration. unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof DatabaseAllOf
     */
    'maximum_cpu'?: number;
    /**
     * Maximum memory that can be allocated to the database based on organization cluster configuration. unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof DatabaseAllOf
     */
    'maximum_memory'?: number;
    /**
     * indicates if the database disk is encrypted or not
     * @type {boolean}
     * @memberof DatabaseAllOf
     */
    'disk_encrypted'?: boolean;
    /**
     * Database instance type to be used for this database. The list of values can be retrieved via the endpoint /{CloudProvider}/managedDatabase/instanceType/{region}/{dbType}. This field is null for container DB.
     * @type {string}
     * @memberof DatabaseAllOf
     */
    'instance_type'?: string;
}
/**
 * 
 * @export
 * @interface DatabaseConfiguration
 */
export interface DatabaseConfiguration {
    /**
     * 
     * @type {DatabaseTypeEnum}
     * @memberof DatabaseConfiguration
     */
    'database_type'?: DatabaseTypeEnum;
    /**
     * 
     * @type {Array<DatabaseVersionMode>}
     * @memberof DatabaseConfiguration
     */
    'version'?: Array<DatabaseVersionMode>;
}
/**
 * 
 * @export
 * @interface DatabaseConfigurationResponseList
 */
export interface DatabaseConfigurationResponseList {
    /**
     * 
     * @type {Array<DatabaseConfiguration>}
     * @memberof DatabaseConfigurationResponseList
     */
    'results'?: Array<DatabaseConfiguration>;
}
/**
 * 
 * @export
 * @interface DatabaseCurrentMetric
 */
export interface DatabaseCurrentMetric {
    /**
     * 
     * @type {DatabaseCurrentMetricCpu}
     * @memberof DatabaseCurrentMetric
     */
    'cpu'?: DatabaseCurrentMetricCpu;
    /**
     * 
     * @type {DatabaseCurrentMetricMemory}
     * @memberof DatabaseCurrentMetric
     */
    'memory'?: DatabaseCurrentMetricMemory;
    /**
     * 
     * @type {DatabaseCurrentMetricStorage}
     * @memberof DatabaseCurrentMetric
     */
    'storage'?: DatabaseCurrentMetricStorage;
}
/**
 * 
 * @export
 * @interface DatabaseCurrentMetricCpu
 */
export interface DatabaseCurrentMetricCpu {
    /**
     * 
     * @type {number}
     * @memberof DatabaseCurrentMetricCpu
     */
    'requested_in_float'?: number;
    /**
     * 
     * @type {number}
     * @memberof DatabaseCurrentMetricCpu
     */
    'consumed_in_number'?: number;
    /**
     * 
     * @type {number}
     * @memberof DatabaseCurrentMetricCpu
     */
    'consumed_in_percent'?: number;
    /**
     * 
     * @type {number}
     * @memberof DatabaseCurrentMetricCpu
     */
    'warning_threshold_in_percent'?: number;
    /**
     * 
     * @type {number}
     * @memberof DatabaseCurrentMetricCpu
     */
    'alert_threshold_in_percent'?: number;
    /**
     * 
     * @type {ThresholdMetricStatusEnum}
     * @memberof DatabaseCurrentMetricCpu
     */
    'status'?: ThresholdMetricStatusEnum;
}
/**
 * 
 * @export
 * @interface DatabaseCurrentMetricMemory
 */
export interface DatabaseCurrentMetricMemory {
    /**
     * 
     * @type {number}
     * @memberof DatabaseCurrentMetricMemory
     */
    'requested_in_mb'?: number;
    /**
     * 
     * @type {number}
     * @memberof DatabaseCurrentMetricMemory
     */
    'consumed_in_mb'?: number;
    /**
     * 
     * @type {number}
     * @memberof DatabaseCurrentMetricMemory
     */
    'consumed_in_percent'?: number;
    /**
     * 
     * @type {number}
     * @memberof DatabaseCurrentMetricMemory
     */
    'warning_threshold_in_percent'?: number;
    /**
     * 
     * @type {number}
     * @memberof DatabaseCurrentMetricMemory
     */
    'alert_threshold_in_percent'?: number;
    /**
     * 
     * @type {ThresholdMetricStatusEnum}
     * @memberof DatabaseCurrentMetricMemory
     */
    'status'?: ThresholdMetricStatusEnum;
}
/**
 * 
 * @export
 * @interface DatabaseCurrentMetricStorage
 */
export interface DatabaseCurrentMetricStorage {
    /**
     * 
     * @type {number}
     * @memberof DatabaseCurrentMetricStorage
     */
    'requested_in_gb'?: number;
    /**
     * 
     * @type {number}
     * @memberof DatabaseCurrentMetricStorage
     */
    'consumed_in_gb'?: number;
    /**
     * 
     * @type {number}
     * @memberof DatabaseCurrentMetricStorage
     */
    'consumed_in_percent'?: number;
    /**
     * 
     * @type {number}
     * @memberof DatabaseCurrentMetricStorage
     */
    'warning_threshold_in_percent'?: number;
    /**
     * 
     * @type {number}
     * @memberof DatabaseCurrentMetricStorage
     */
    'alert_threshold_in_percent'?: number;
    /**
     * 
     * @type {ThresholdMetricStatusEnum}
     * @memberof DatabaseCurrentMetricStorage
     */
    'status'?: ThresholdMetricStatusEnum;
}
/**
 * 
 * @export
 * @interface DatabaseEditRequest
 */
export interface DatabaseEditRequest {
    /**
     * name is case-insensitive
     * @type {string}
     * @memberof DatabaseEditRequest
     */
    'name'?: string;
    /**
     * give a description to this database
     * @type {string}
     * @memberof DatabaseEditRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof DatabaseEditRequest
     */
    'version'?: string;
    /**
     * 
     * @type {DatabaseAccessibilityEnum}
     * @memberof DatabaseEditRequest
     */
    'accessibility'?: DatabaseAccessibilityEnum;
    /**
     * unit is millicores (m). 1000m = 1 cpu. This field will be ignored for managed DB (instance type will be used instead). 
     * @type {number}
     * @memberof DatabaseEditRequest
     */
    'cpu'?: number;
    /**
     * unit is MB. 1024 MB = 1GB This field will be ignored for managed DB (instance type will be used instead). Default value is linked to the database type: - MANAGED: 100 - CONTAINER   - POSTGRES: 100   - REDIS: 100   - MYSQL: 512   - MONGODB: 256 
     * @type {number}
     * @memberof DatabaseEditRequest
     */
    'memory'?: number;
    /**
     * unit is GB
     * @type {number}
     * @memberof DatabaseEditRequest
     */
    'storage'?: number;
    /**
     * Database instance type to be used for this database. The list of values can be retrieved via the endpoint /{CloudProvider}/managedDatabase/instanceType/{region}/{dbType}. This field SHOULD NOT be set for container DB.
     * @type {string}
     * @memberof DatabaseEditRequest
     */
    'instance_type'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum DatabaseModeEnum {
    CONTAINER = 'CONTAINER',
    MANAGED = 'MANAGED'
}

/**
 * 
 * @export
 * @interface DatabaseRequest
 */
export interface DatabaseRequest {
    /**
     * name is case insensitive
     * @type {string}
     * @memberof DatabaseRequest
     */
    'name': string;
    /**
     * give a description to this database
     * @type {string}
     * @memberof DatabaseRequest
     */
    'description'?: string;
    /**
     * 
     * @type {DatabaseTypeEnum}
     * @memberof DatabaseRequest
     */
    'type': DatabaseTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof DatabaseRequest
     */
    'version': string;
    /**
     * 
     * @type {DatabaseModeEnum}
     * @memberof DatabaseRequest
     */
    'mode': DatabaseModeEnum;
    /**
     * 
     * @type {DatabaseAccessibilityEnum}
     * @memberof DatabaseRequest
     */
    'accessibility'?: DatabaseAccessibilityEnum;
    /**
     * unit is millicores (m). 1000m = 1 cpu This field will be ignored for managed DB (instance type will be used instead). 
     * @type {number}
     * @memberof DatabaseRequest
     */
    'cpu'?: number;
    /**
     * Database instance type to be used for this database. The list of values can be retrieved via the endpoint /{CloudProvider}/managedDatabase/instanceType/{region}/{dbType}. This field SHOULD NOT be set for container DB.
     * @type {string}
     * @memberof DatabaseRequest
     */
    'instance_type'?: string;
    /**
     * unit is MB. 1024 MB = 1GB This field will be ignored for managed DB (instance type will be used instead). Default value is linked to the database type: - MANAGED: `100` - CONTAINER   - POSTGRES: `100`   - REDIS: `100`   - MYSQL: `512`   - MONGODB: `256` 
     * @type {number}
     * @memberof DatabaseRequest
     */
    'memory'?: number;
    /**
     * unit is GB
     * @type {number}
     * @memberof DatabaseRequest
     */
    'storage'?: number;
}
/**
 * 
 * @export
 * @interface DatabaseResponseList
 */
export interface DatabaseResponseList {
    /**
     * 
     * @type {Array<Database>}
     * @memberof DatabaseResponseList
     */
    'results'?: Array<Database>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum DatabaseTypeEnum {
    MONGODB = 'MONGODB',
    MYSQL = 'MYSQL',
    POSTGRESQL = 'POSTGRESQL',
    REDIS = 'REDIS'
}

/**
 * 
 * @export
 * @interface DatabaseVersionMode
 */
export interface DatabaseVersionMode {
    /**
     * 
     * @type {string}
     * @memberof DatabaseVersionMode
     */
    'name'?: string;
    /**
     * 
     * @type {DatabaseModeEnum}
     * @memberof DatabaseVersionMode
     */
    'supported_mode'?: DatabaseModeEnum;
}
/**
 * 
 * @export
 * @interface DeployAllRequest
 */
export interface DeployAllRequest {
    /**
     * 
     * @type {Array<DeployAllRequestApplications>}
     * @memberof DeployAllRequest
     */
    'applications'?: Array<DeployAllRequestApplications>;
    /**
     * 
     * @type {Array<string>}
     * @memberof DeployAllRequest
     */
    'databases'?: Array<string>;
    /**
     * 
     * @type {Array<DeployAllRequestContainers>}
     * @memberof DeployAllRequest
     */
    'containers'?: Array<DeployAllRequestContainers>;
    /**
     * 
     * @type {Array<DeployAllRequestJobs>}
     * @memberof DeployAllRequest
     */
    'jobs'?: Array<DeployAllRequestJobs>;
}
/**
 * 
 * @export
 * @interface DeployAllRequestApplications
 */
export interface DeployAllRequestApplications {
    /**
     * id of the application to be deployed.
     * @type {string}
     * @memberof DeployAllRequestApplications
     */
    'application_id': string;
    /**
     * Commit ID to deploy. Can be empty only if the service has been already deployed (in this case the service version won\'t be changed)
     * @type {string}
     * @memberof DeployAllRequestApplications
     */
    'git_commit_id'?: string;
}
/**
 * 
 * @export
 * @interface DeployAllRequestContainers
 */
export interface DeployAllRequestContainers {
    /**
     * id of the container to be updated.
     * @type {string}
     * @memberof DeployAllRequestContainers
     */
    'id': string;
    /**
     * new tag for the container. Can be empty only if the service has been already deployed (in this case the service version won\'t be changed)
     * @type {string}
     * @memberof DeployAllRequestContainers
     */
    'image_tag'?: string;
}
/**
 * 
 * @export
 * @interface DeployAllRequestJobs
 */
export interface DeployAllRequestJobs {
    /**
     * id of the job to be updated.
     * @type {string}
     * @memberof DeployAllRequestJobs
     */
    'id'?: string;
    /**
     * new tag for the job image. Use only if job is an image source. Can be empty only if the service has been already deployed (in this case the service version won\'t be changed)
     * @type {string}
     * @memberof DeployAllRequestJobs
     */
    'image_tag'?: string;
    /**
     * Commit ID to deploy. Use only if job is a repository source. Can be empty only if the service has been already deployed (in this case the service version won\'t be changed)
     * @type {string}
     * @memberof DeployAllRequestJobs
     */
    'git_commit_id'?: string;
}
/**
 * 
 * @export
 * @interface DeployRequest
 */
export interface DeployRequest {
    /**
     * Commit ID to deploy
     * @type {string}
     * @memberof DeployRequest
     */
    'git_commit_id': string;
}
/**
 * 
 * @export
 * @interface DeploymentHistory
 */
export interface DeploymentHistory {
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistory
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistory
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistory
     */
    'updated_at'?: string;
    /**
     * name of the service
     * @type {string}
     * @memberof DeploymentHistory
     */
    'name'?: string;
    /**
     * 
     * @type {Commit}
     * @memberof DeploymentHistory
     */
    'commit'?: Commit;
    /**
     * 
     * @type {DeploymentHistoryStatusEnum}
     * @memberof DeploymentHistory
     */
    'status'?: DeploymentHistoryStatusEnum;
}
/**
 * 
 * @export
 * @interface DeploymentHistoryAllOf
 */
export interface DeploymentHistoryAllOf {
    /**
     * name of the service
     * @type {string}
     * @memberof DeploymentHistoryAllOf
     */
    'name'?: string;
    /**
     * 
     * @type {Commit}
     * @memberof DeploymentHistoryAllOf
     */
    'commit'?: Commit;
    /**
     * 
     * @type {DeploymentHistoryStatusEnum}
     * @memberof DeploymentHistoryAllOf
     */
    'status'?: DeploymentHistoryStatusEnum;
}
/**
 * 
 * @export
 * @interface DeploymentHistoryApplication
 */
export interface DeploymentHistoryApplication {
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryApplication
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryApplication
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryApplication
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryApplication
     */
    'name'?: string;
    /**
     * 
     * @type {Commit}
     * @memberof DeploymentHistoryApplication
     */
    'commit'?: Commit;
    /**
     * 
     * @type {StateEnum}
     * @memberof DeploymentHistoryApplication
     */
    'status'?: StateEnum;
}
/**
 * 
 * @export
 * @interface DeploymentHistoryApplicationAllOf
 */
export interface DeploymentHistoryApplicationAllOf {
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryApplicationAllOf
     */
    'name'?: string;
    /**
     * 
     * @type {Commit}
     * @memberof DeploymentHistoryApplicationAllOf
     */
    'commit'?: Commit;
    /**
     * 
     * @type {StateEnum}
     * @memberof DeploymentHistoryApplicationAllOf
     */
    'status'?: StateEnum;
}
/**
 * 
 * @export
 * @interface DeploymentHistoryContainer
 */
export interface DeploymentHistoryContainer {
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryContainer
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryContainer
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryContainer
     */
    'updated_at'?: string;
    /**
     * name of the container
     * @type {string}
     * @memberof DeploymentHistoryContainer
     */
    'name'?: string;
    /**
     * 
     * @type {StateEnum}
     * @memberof DeploymentHistoryContainer
     */
    'status'?: StateEnum;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryContainer
     */
    'image_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryContainer
     */
    'tag'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DeploymentHistoryContainer
     */
    'arguments'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryContainer
     */
    'entrypoint'?: string;
}
/**
 * 
 * @export
 * @interface DeploymentHistoryContainerAllOf
 */
export interface DeploymentHistoryContainerAllOf {
    /**
     * name of the container
     * @type {string}
     * @memberof DeploymentHistoryContainerAllOf
     */
    'name'?: string;
    /**
     * 
     * @type {StateEnum}
     * @memberof DeploymentHistoryContainerAllOf
     */
    'status'?: StateEnum;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryContainerAllOf
     */
    'image_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryContainerAllOf
     */
    'tag'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DeploymentHistoryContainerAllOf
     */
    'arguments'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryContainerAllOf
     */
    'entrypoint'?: string;
}
/**
 * 
 * @export
 * @interface DeploymentHistoryDatabase
 */
export interface DeploymentHistoryDatabase {
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryDatabase
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryDatabase
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryDatabase
     */
    'updated_at'?: string;
    /**
     * name of the service
     * @type {string}
     * @memberof DeploymentHistoryDatabase
     */
    'name'?: string;
    /**
     * 
     * @type {StateEnum}
     * @memberof DeploymentHistoryDatabase
     */
    'status'?: StateEnum;
}
/**
 * 
 * @export
 * @interface DeploymentHistoryDatabaseAllOf
 */
export interface DeploymentHistoryDatabaseAllOf {
    /**
     * name of the service
     * @type {string}
     * @memberof DeploymentHistoryDatabaseAllOf
     */
    'name'?: string;
    /**
     * 
     * @type {StateEnum}
     * @memberof DeploymentHistoryDatabaseAllOf
     */
    'status'?: StateEnum;
}
/**
 * 
 * @export
 * @interface DeploymentHistoryEnvironment
 */
export interface DeploymentHistoryEnvironment {
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryEnvironment
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryEnvironment
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryEnvironment
     */
    'updated_at'?: string;
    /**
     * 
     * @type {StateEnum}
     * @memberof DeploymentHistoryEnvironment
     */
    'status'?: StateEnum;
    /**
     * 
     * @type {Array<DeploymentHistoryApplication>}
     * @memberof DeploymentHistoryEnvironment
     */
    'applications'?: Array<DeploymentHistoryApplication>;
    /**
     * 
     * @type {Array<DeploymentHistoryContainer>}
     * @memberof DeploymentHistoryEnvironment
     */
    'containers'?: Array<DeploymentHistoryContainer>;
    /**
     * 
     * @type {Array<DeploymentHistoryDatabase>}
     * @memberof DeploymentHistoryEnvironment
     */
    'databases'?: Array<DeploymentHistoryDatabase>;
    /**
     * 
     * @type {Array<DeploymentHistoryJobResponse>}
     * @memberof DeploymentHistoryEnvironment
     */
    'jobs'?: Array<DeploymentHistoryJobResponse>;
}
/**
 * 
 * @export
 * @interface DeploymentHistoryEnvironmentAllOf
 */
export interface DeploymentHistoryEnvironmentAllOf {
    /**
     * 
     * @type {StateEnum}
     * @memberof DeploymentHistoryEnvironmentAllOf
     */
    'status'?: StateEnum;
    /**
     * 
     * @type {Array<DeploymentHistoryApplication>}
     * @memberof DeploymentHistoryEnvironmentAllOf
     */
    'applications'?: Array<DeploymentHistoryApplication>;
    /**
     * 
     * @type {Array<DeploymentHistoryContainer>}
     * @memberof DeploymentHistoryEnvironmentAllOf
     */
    'containers'?: Array<DeploymentHistoryContainer>;
    /**
     * 
     * @type {Array<DeploymentHistoryDatabase>}
     * @memberof DeploymentHistoryEnvironmentAllOf
     */
    'databases'?: Array<DeploymentHistoryDatabase>;
    /**
     * 
     * @type {Array<DeploymentHistoryJobResponse>}
     * @memberof DeploymentHistoryEnvironmentAllOf
     */
    'jobs'?: Array<DeploymentHistoryJobResponse>;
}
/**
 * 
 * @export
 * @interface DeploymentHistoryEnvironmentPaginatedResponseList
 */
export interface DeploymentHistoryEnvironmentPaginatedResponseList {
    /**
     * 
     * @type {number}
     * @memberof DeploymentHistoryEnvironmentPaginatedResponseList
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof DeploymentHistoryEnvironmentPaginatedResponseList
     */
    'page_size': number;
    /**
     * 
     * @type {Array<DeploymentHistoryEnvironment>}
     * @memberof DeploymentHistoryEnvironmentPaginatedResponseList
     */
    'results'?: Array<DeploymentHistoryEnvironment>;
}
/**
 * 
 * @export
 * @interface DeploymentHistoryEnvironmentPaginatedResponseListAllOf
 */
export interface DeploymentHistoryEnvironmentPaginatedResponseListAllOf {
    /**
     * 
     * @type {Array<DeploymentHistoryEnvironment>}
     * @memberof DeploymentHistoryEnvironmentPaginatedResponseListAllOf
     */
    'results'?: Array<DeploymentHistoryEnvironment>;
}
/**
 * 
 * @export
 * @interface DeploymentHistoryJobResponse
 */
export interface DeploymentHistoryJobResponse {
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryJobResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryJobResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryJobResponse
     */
    'updated_at'?: string;
    /**
     * name of the job
     * @type {string}
     * @memberof DeploymentHistoryJobResponse
     */
    'name'?: string;
    /**
     * 
     * @type {StateEnum}
     * @memberof DeploymentHistoryJobResponse
     */
    'status'?: StateEnum;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryJobResponse
     */
    'image_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryJobResponse
     */
    'tag'?: string;
    /**
     * 
     * @type {Commit}
     * @memberof DeploymentHistoryJobResponse
     */
    'commit'?: Commit;
    /**
     * 
     * @type {DeploymentHistoryJobResponseAllOfSchedule}
     * @memberof DeploymentHistoryJobResponse
     */
    'schedule'?: DeploymentHistoryJobResponseAllOfSchedule;
    /**
     * 
     * @type {Array<string>}
     * @memberof DeploymentHistoryJobResponse
     */
    'arguments'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryJobResponse
     */
    'entrypoint'?: string;
}
/**
 * 
 * @export
 * @interface DeploymentHistoryJobResponseAllOf
 */
export interface DeploymentHistoryJobResponseAllOf {
    /**
     * name of the job
     * @type {string}
     * @memberof DeploymentHistoryJobResponseAllOf
     */
    'name'?: string;
    /**
     * 
     * @type {StateEnum}
     * @memberof DeploymentHistoryJobResponseAllOf
     */
    'status'?: StateEnum;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryJobResponseAllOf
     */
    'image_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryJobResponseAllOf
     */
    'tag'?: string;
    /**
     * 
     * @type {Commit}
     * @memberof DeploymentHistoryJobResponseAllOf
     */
    'commit'?: Commit;
    /**
     * 
     * @type {DeploymentHistoryJobResponseAllOfSchedule}
     * @memberof DeploymentHistoryJobResponseAllOf
     */
    'schedule'?: DeploymentHistoryJobResponseAllOfSchedule;
    /**
     * 
     * @type {Array<string>}
     * @memberof DeploymentHistoryJobResponseAllOf
     */
    'arguments'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DeploymentHistoryJobResponseAllOf
     */
    'entrypoint'?: string;
}
/**
 * 
 * @export
 * @interface DeploymentHistoryJobResponseAllOfSchedule
 */
export interface DeploymentHistoryJobResponseAllOfSchedule {
    /**
     * 
     * @type {JobScheduleEvent}
     * @memberof DeploymentHistoryJobResponseAllOfSchedule
     */
    'event'?: JobScheduleEvent;
    /**
     * Can only be set if the event is CRON. Represent the cron format for the job schedule without seconds. For example: `* * * * *` represent the cron to launch the job every minute. See https://crontab.guru/ to WISIWIG interface. Timezone is UTC 
     * @type {string}
     * @memberof DeploymentHistoryJobResponseAllOfSchedule
     */
    'schedule_at'?: string | null;
}
/**
 * 
 * @export
 * @interface DeploymentHistoryPaginatedResponseList
 */
export interface DeploymentHistoryPaginatedResponseList {
    /**
     * 
     * @type {number}
     * @memberof DeploymentHistoryPaginatedResponseList
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof DeploymentHistoryPaginatedResponseList
     */
    'page_size': number;
    /**
     * 
     * @type {Array<DeploymentHistory>}
     * @memberof DeploymentHistoryPaginatedResponseList
     */
    'results'?: Array<DeploymentHistory>;
}
/**
 * 
 * @export
 * @interface DeploymentHistoryPaginatedResponseListAllOf
 */
export interface DeploymentHistoryPaginatedResponseListAllOf {
    /**
     * 
     * @type {Array<DeploymentHistory>}
     * @memberof DeploymentHistoryPaginatedResponseListAllOf
     */
    'results'?: Array<DeploymentHistory>;
}
/**
 * 
 * @export
 * @interface DeploymentHistoryResponseList
 */
export interface DeploymentHistoryResponseList {
    /**
     * 
     * @type {Array<DeploymentHistory>}
     * @memberof DeploymentHistoryResponseList
     */
    'results'?: Array<DeploymentHistory>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum DeploymentHistoryStatusEnum {
    FAILED = 'FAILED',
    SUCCESS = 'SUCCESS'
}

/**
 * Match mode will rebuild app only if specified items are updated. Exclude mode will not rebuild app if specified items are updated.
 * @export
 * @enum {string}
 */

export enum DeploymentRestrictionModeEnum {
    EXCLUDE = 'EXCLUDE',
    MATCH = 'MATCH'
}

/**
 * 
 * @export
 * @enum {string}
 */

export enum DeploymentRestrictionTypeEnum {
    PATH = 'PATH'
}

/**
 * 
 * @export
 * @interface DeploymentRuleRequest
 */
export interface DeploymentRuleRequest {
    /**
     * name is case insensitive
     * @type {string}
     * @memberof DeploymentRuleRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentRuleRequest
     */
    'description'?: string;
    /**
     * 
     * @type {EnvironmentModeEnum}
     * @memberof DeploymentRuleRequest
     */
    'mode': EnvironmentModeEnum;
    /**
     * 
     * @type {string}
     * @memberof DeploymentRuleRequest
     */
    'cluster': string;
    /**
     * 
     * @type {boolean}
     * @memberof DeploymentRuleRequest
     */
    'auto_deploy'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeploymentRuleRequest
     */
    'auto_stop': boolean;
    /**
     * specify value only if auto_stop = false
     * @type {string}
     * @memberof DeploymentRuleRequest
     */
    'timezone'?: string;
    /**
     * specify value only if auto_stop = false
     * @type {string}
     * @memberof DeploymentRuleRequest
     */
    'start_time'?: string | null;
    /**
     * specify value only if auto_stop = false
     * @type {string}
     * @memberof DeploymentRuleRequest
     */
    'stop_time'?: string | null;
    /**
     * specify value only if auto_stop = false
     * @type {Array<WeekdayEnum>}
     * @memberof DeploymentRuleRequest
     */
    'weekdays'?: Array<WeekdayEnum> | null;
}
/**
 * 
 * @export
 * @interface DeploymentStageRequest
 */
export interface DeploymentStageRequest {
    /**
     * The name of the deployment stage
     * @type {string}
     * @memberof DeploymentStageRequest
     */
    'name': string;
    /**
     * free test describing this stage
     * @type {string}
     * @memberof DeploymentStageRequest
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface DeploymentStageResponse
 */
export interface DeploymentStageResponse {
    /**
     * 
     * @type {string}
     * @memberof DeploymentStageResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentStageResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentStageResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {ReferenceObject}
     * @memberof DeploymentStageResponse
     */
    'environment': ReferenceObject;
    /**
     * name is case insensitive
     * @type {string}
     * @memberof DeploymentStageResponse
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentStageResponse
     */
    'description'?: string;
    /**
     * Position of the deployment stage within the environment
     * @type {number}
     * @memberof DeploymentStageResponse
     */
    'deployment_order'?: number;
    /**
     * 
     * @type {Array<DeploymentStageServiceResponse>}
     * @memberof DeploymentStageResponse
     */
    'services'?: Array<DeploymentStageServiceResponse>;
}
/**
 * 
 * @export
 * @interface DeploymentStageResponseAllOf
 */
export interface DeploymentStageResponseAllOf {
    /**
     * 
     * @type {ReferenceObject}
     * @memberof DeploymentStageResponseAllOf
     */
    'environment': ReferenceObject;
    /**
     * name is case insensitive
     * @type {string}
     * @memberof DeploymentStageResponseAllOf
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentStageResponseAllOf
     */
    'description'?: string;
    /**
     * Position of the deployment stage within the environment
     * @type {number}
     * @memberof DeploymentStageResponseAllOf
     */
    'deployment_order'?: number;
    /**
     * 
     * @type {Array<DeploymentStageServiceResponse>}
     * @memberof DeploymentStageResponseAllOf
     */
    'services'?: Array<DeploymentStageServiceResponse>;
}
/**
 * 
 * @export
 * @interface DeploymentStageResponseList
 */
export interface DeploymentStageResponseList {
    /**
     * 
     * @type {Array<DeploymentStageResponse>}
     * @memberof DeploymentStageResponseList
     */
    'results'?: Array<DeploymentStageResponse>;
}
/**
 * 
 * @export
 * @interface DeploymentStageServiceResponse
 */
export interface DeploymentStageServiceResponse {
    /**
     * 
     * @type {string}
     * @memberof DeploymentStageServiceResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentStageServiceResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentStageServiceResponse
     */
    'updated_at'?: string;
    /**
     * id of the service attached to the stage
     * @type {string}
     * @memberof DeploymentStageServiceResponse
     */
    'service_id'?: string;
    /**
     * type of the service (i.e APPLICATION, JOB, DATABASE, ...)
     * @type {string}
     * @memberof DeploymentStageServiceResponse
     */
    'service_type'?: string;
}
/**
 * 
 * @export
 * @interface DeploymentStageServiceResponseAllOf
 */
export interface DeploymentStageServiceResponseAllOf {
    /**
     * id of the service attached to the stage
     * @type {string}
     * @memberof DeploymentStageServiceResponseAllOf
     */
    'service_id'?: string;
    /**
     * type of the service (i.e APPLICATION, JOB, DATABASE, ...)
     * @type {string}
     * @memberof DeploymentStageServiceResponseAllOf
     */
    'service_type'?: string;
}
/**
 * 
 * @export
 * @interface DeploymentStageWithServiceStatusesList
 */
export interface DeploymentStageWithServiceStatusesList {
    /**
     * 
     * @type {Array<DeploymentStageWithServicesStatuses>}
     * @memberof DeploymentStageWithServiceStatusesList
     */
    'results'?: Array<DeploymentStageWithServicesStatuses>;
}
/**
 * 
 * @export
 * @interface DeploymentStageWithServicesStatuses
 */
export interface DeploymentStageWithServicesStatuses {
    /**
     * 
     * @type {Array<Status>}
     * @memberof DeploymentStageWithServicesStatuses
     */
    'applications'?: Array<Status>;
    /**
     * 
     * @type {Array<Status>}
     * @memberof DeploymentStageWithServicesStatuses
     */
    'containers'?: Array<Status>;
    /**
     * 
     * @type {Array<Status>}
     * @memberof DeploymentStageWithServicesStatuses
     */
    'jobs'?: Array<Status>;
    /**
     * 
     * @type {Array<Status>}
     * @memberof DeploymentStageWithServicesStatuses
     */
    'databases'?: Array<Status>;
    /**
     * 
     * @type {Stage}
     * @memberof DeploymentStageWithServicesStatuses
     */
    'stage'?: Stage;
}
/**
 * 
 * @export
 * @interface DoCredentialsRequest
 */
export interface DoCredentialsRequest {
    /**
     * 
     * @type {string}
     * @memberof DoCredentialsRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof DoCredentialsRequest
     */
    'token'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoCredentialsRequest
     */
    'spaces_access_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoCredentialsRequest
     */
    'spaces_secret_key'?: string;
}
/**
 * 
 * @export
 * @interface Environment
 */
export interface Environment {
    /**
     * 
     * @type {string}
     * @memberof Environment
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Environment
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Environment
     */
    'updated_at'?: string;
    /**
     * name is case insensitive
     * @type {string}
     * @memberof Environment
     */
    'name': string;
    /**
     * 
     * @type {ReferenceObject}
     * @memberof Environment
     */
    'project'?: ReferenceObject;
    /**
     * uuid of the user that made the last update
     * @type {string}
     * @memberof Environment
     */
    'last_updated_by'?: string;
    /**
     * 
     * @type {EnvironmentAllOfCloudProvider}
     * @memberof Environment
     */
    'cloud_provider': EnvironmentAllOfCloudProvider;
    /**
     * 
     * @type {EnvironmentModeEnum}
     * @memberof Environment
     */
    'mode': EnvironmentModeEnum;
    /**
     * 
     * @type {string}
     * @memberof Environment
     */
    'cluster_id': string;
    /**
     * 
     * @type {string}
     * @memberof Environment
     */
    'cluster_name'?: string;
}
/**
 * 
 * @export
 * @interface EnvironmentAllOf
 */
export interface EnvironmentAllOf {
    /**
     * name is case insensitive
     * @type {string}
     * @memberof EnvironmentAllOf
     */
    'name': string;
    /**
     * 
     * @type {ReferenceObject}
     * @memberof EnvironmentAllOf
     */
    'project'?: ReferenceObject;
    /**
     * uuid of the user that made the last update
     * @type {string}
     * @memberof EnvironmentAllOf
     */
    'last_updated_by'?: string;
    /**
     * 
     * @type {EnvironmentAllOfCloudProvider}
     * @memberof EnvironmentAllOf
     */
    'cloud_provider': EnvironmentAllOfCloudProvider;
    /**
     * 
     * @type {EnvironmentModeEnum}
     * @memberof EnvironmentAllOf
     */
    'mode': EnvironmentModeEnum;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentAllOf
     */
    'cluster_id': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentAllOf
     */
    'cluster_name'?: string;
}
/**
 * 
 * @export
 * @interface EnvironmentAllOfCloudProvider
 */
export interface EnvironmentAllOfCloudProvider {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentAllOfCloudProvider
     */
    'provider'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentAllOfCloudProvider
     */
    'cluster'?: string;
}
/**
 * 
 * @export
 * @interface EnvironmentApplicationsCurrentScale
 */
export interface EnvironmentApplicationsCurrentScale {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentApplicationsCurrentScale
     */
    'application'?: string;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentApplicationsCurrentScale
     */
    'min'?: number;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentApplicationsCurrentScale
     */
    'max'?: number;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentApplicationsCurrentScale
     */
    'running'?: number;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentApplicationsCurrentScale
     */
    'running_in_percent'?: number;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentApplicationsCurrentScale
     */
    'warning_threshold_in_percent'?: number;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentApplicationsCurrentScale
     */
    'alert_threshold_in_percent'?: number;
    /**
     * 
     * @type {ThresholdMetricStatusEnum}
     * @memberof EnvironmentApplicationsCurrentScale
     */
    'status'?: ThresholdMetricStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentApplicationsCurrentScale
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface EnvironmentApplicationsCurrentScaleResponseList
 */
export interface EnvironmentApplicationsCurrentScaleResponseList {
    /**
     * 
     * @type {Array<EnvironmentApplicationsCurrentScale>}
     * @memberof EnvironmentApplicationsCurrentScaleResponseList
     */
    'results'?: Array<EnvironmentApplicationsCurrentScale>;
}
/**
 * 
 * @export
 * @interface EnvironmentApplicationsInstanceResponseList
 */
export interface EnvironmentApplicationsInstanceResponseList {
    /**
     * 
     * @type {Array<EnvironmentApplicationsInstanceResponseListResults>}
     * @memberof EnvironmentApplicationsInstanceResponseList
     */
    'results'?: Array<EnvironmentApplicationsInstanceResponseListResults>;
}
/**
 * 
 * @export
 * @interface EnvironmentApplicationsInstanceResponseListResults
 */
export interface EnvironmentApplicationsInstanceResponseListResults {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentApplicationsInstanceResponseListResults
     */
    'application': string;
    /**
     * 
     * @type {Array<Instance>}
     * @memberof EnvironmentApplicationsInstanceResponseListResults
     */
    'instances': Array<Instance>;
}
/**
 * 
 * @export
 * @interface EnvironmentApplicationsStorage
 */
export interface EnvironmentApplicationsStorage {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentApplicationsStorage
     */
    'application': string;
    /**
     * 
     * @type {Array<StorageDisk>}
     * @memberof EnvironmentApplicationsStorage
     */
    'disks'?: Array<StorageDisk>;
}
/**
 * 
 * @export
 * @interface EnvironmentApplicationsStorageResponseList
 */
export interface EnvironmentApplicationsStorageResponseList {
    /**
     * 
     * @type {Array<EnvironmentApplicationsStorage>}
     * @memberof EnvironmentApplicationsStorageResponseList
     */
    'results'?: Array<EnvironmentApplicationsStorage>;
}
/**
 * 
 * @export
 * @interface EnvironmentApplicationsSupportedLanguage
 */
export interface EnvironmentApplicationsSupportedLanguage {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentApplicationsSupportedLanguage
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface EnvironmentApplicationsSupportedLanguageList
 */
export interface EnvironmentApplicationsSupportedLanguageList {
    /**
     * 
     * @type {Array<EnvironmentApplicationsSupportedLanguage>}
     * @memberof EnvironmentApplicationsSupportedLanguageList
     */
    'results'?: Array<EnvironmentApplicationsSupportedLanguage>;
}
/**
 * 
 * @export
 * @interface EnvironmentContainersCurrentScale
 */
export interface EnvironmentContainersCurrentScale {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentContainersCurrentScale
     */
    'container'?: string;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentContainersCurrentScale
     */
    'min'?: number;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentContainersCurrentScale
     */
    'max'?: number;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentContainersCurrentScale
     */
    'running'?: number;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentContainersCurrentScale
     */
    'running_in_percent'?: number;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentContainersCurrentScale
     */
    'warning_threshold_in_percent'?: number;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentContainersCurrentScale
     */
    'alert_threshold_in_percent'?: number;
    /**
     * 
     * @type {ThresholdMetricStatusEnum}
     * @memberof EnvironmentContainersCurrentScale
     */
    'status'?: ThresholdMetricStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentContainersCurrentScale
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface EnvironmentContainersCurrentScaleResponseList
 */
export interface EnvironmentContainersCurrentScaleResponseList {
    /**
     * 
     * @type {Array<EnvironmentContainersCurrentScale>}
     * @memberof EnvironmentContainersCurrentScaleResponseList
     */
    'results'?: Array<EnvironmentContainersCurrentScale>;
}
/**
 * 
 * @export
 * @interface EnvironmentContainersStorage
 */
export interface EnvironmentContainersStorage {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentContainersStorage
     */
    'container': string;
    /**
     * 
     * @type {Array<StorageDisk>}
     * @memberof EnvironmentContainersStorage
     */
    'disks'?: Array<StorageDisk>;
}
/**
 * 
 * @export
 * @interface EnvironmentContainersStorageResponseList
 */
export interface EnvironmentContainersStorageResponseList {
    /**
     * 
     * @type {Array<EnvironmentContainersStorage>}
     * @memberof EnvironmentContainersStorageResponseList
     */
    'results'?: Array<EnvironmentContainersStorage>;
}
/**
 * 
 * @export
 * @interface EnvironmentDatabasesCurrentMetric
 */
export interface EnvironmentDatabasesCurrentMetric {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentDatabasesCurrentMetric
     */
    'database'?: string;
    /**
     * 
     * @type {EnvironmentDatabasesCurrentMetricCpu}
     * @memberof EnvironmentDatabasesCurrentMetric
     */
    'cpu'?: EnvironmentDatabasesCurrentMetricCpu;
    /**
     * 
     * @type {EnvironmentDatabasesCurrentMetricMemory}
     * @memberof EnvironmentDatabasesCurrentMetric
     */
    'memory'?: EnvironmentDatabasesCurrentMetricMemory;
    /**
     * 
     * @type {EnvironmentDatabasesCurrentMetricStorage}
     * @memberof EnvironmentDatabasesCurrentMetric
     */
    'storage'?: EnvironmentDatabasesCurrentMetricStorage;
}
/**
 * 
 * @export
 * @interface EnvironmentDatabasesCurrentMetricCpu
 */
export interface EnvironmentDatabasesCurrentMetricCpu {
    /**
     * unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof EnvironmentDatabasesCurrentMetricCpu
     */
    'requested_in_float'?: number;
    /**
     * unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof EnvironmentDatabasesCurrentMetricCpu
     */
    'consumed_in_number'?: number;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentDatabasesCurrentMetricCpu
     */
    'consumed_in_percent'?: number;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentDatabasesCurrentMetricCpu
     */
    'warning_threshold_in_percent'?: number;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentDatabasesCurrentMetricCpu
     */
    'alert_threshold_in_percent'?: number;
    /**
     * 
     * @type {ThresholdMetricStatusEnum}
     * @memberof EnvironmentDatabasesCurrentMetricCpu
     */
    'status'?: ThresholdMetricStatusEnum;
}
/**
 * 
 * @export
 * @interface EnvironmentDatabasesCurrentMetricMemory
 */
export interface EnvironmentDatabasesCurrentMetricMemory {
    /**
     * unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof EnvironmentDatabasesCurrentMetricMemory
     */
    'requested_in_mb'?: number;
    /**
     * unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof EnvironmentDatabasesCurrentMetricMemory
     */
    'consumed_in_mb'?: number;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentDatabasesCurrentMetricMemory
     */
    'consumed_in_percent'?: number;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentDatabasesCurrentMetricMemory
     */
    'warning_threshold_in_percent'?: number;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentDatabasesCurrentMetricMemory
     */
    'alert_threshold_in_percent'?: number;
    /**
     * 
     * @type {ThresholdMetricStatusEnum}
     * @memberof EnvironmentDatabasesCurrentMetricMemory
     */
    'status'?: ThresholdMetricStatusEnum;
}
/**
 * 
 * @export
 * @interface EnvironmentDatabasesCurrentMetricResponseList
 */
export interface EnvironmentDatabasesCurrentMetricResponseList {
    /**
     * 
     * @type {Array<EnvironmentDatabasesCurrentMetric>}
     * @memberof EnvironmentDatabasesCurrentMetricResponseList
     */
    'results'?: Array<EnvironmentDatabasesCurrentMetric>;
}
/**
 * 
 * @export
 * @interface EnvironmentDatabasesCurrentMetricStorage
 */
export interface EnvironmentDatabasesCurrentMetricStorage {
    /**
     * Unit is in GB.
     * @type {number}
     * @memberof EnvironmentDatabasesCurrentMetricStorage
     */
    'requested_in_gb'?: number;
    /**
     * Unit is in GB.
     * @type {number}
     * @memberof EnvironmentDatabasesCurrentMetricStorage
     */
    'consumed_in_gb'?: number;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentDatabasesCurrentMetricStorage
     */
    'consumed_in_percent'?: number;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentDatabasesCurrentMetricStorage
     */
    'warning_threshold_in_percent'?: number;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentDatabasesCurrentMetricStorage
     */
    'alert_threshold_in_percent'?: number;
    /**
     * 
     * @type {ThresholdMetricStatusEnum}
     * @memberof EnvironmentDatabasesCurrentMetricStorage
     */
    'status'?: ThresholdMetricStatusEnum;
}
/**
 * 
 * @export
 * @interface EnvironmentDeploymentRule
 */
export interface EnvironmentDeploymentRule {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentDeploymentRule
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentDeploymentRule
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentDeploymentRule
     */
    'updated_at'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EnvironmentDeploymentRule
     */
    'auto_deploy'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EnvironmentDeploymentRule
     */
    'on_demand_preview'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EnvironmentDeploymentRule
     */
    'auto_stop'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EnvironmentDeploymentRule
     */
    'auto_preview'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentDeploymentRule
     */
    'timezone': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentDeploymentRule
     */
    'start_time': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentDeploymentRule
     */
    'stop_time': string;
    /**
     * 
     * @type {Array<WeekdayEnum>}
     * @memberof EnvironmentDeploymentRule
     */
    'weekdays': Array<WeekdayEnum>;
}
/**
 * 
 * @export
 * @interface EnvironmentDeploymentRuleAllOf
 */
export interface EnvironmentDeploymentRuleAllOf {
    /**
     * 
     * @type {boolean}
     * @memberof EnvironmentDeploymentRuleAllOf
     */
    'auto_deploy'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EnvironmentDeploymentRuleAllOf
     */
    'on_demand_preview'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EnvironmentDeploymentRuleAllOf
     */
    'auto_stop'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EnvironmentDeploymentRuleAllOf
     */
    'auto_preview'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentDeploymentRuleAllOf
     */
    'timezone': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentDeploymentRuleAllOf
     */
    'start_time': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentDeploymentRuleAllOf
     */
    'stop_time': string;
    /**
     * 
     * @type {Array<WeekdayEnum>}
     * @memberof EnvironmentDeploymentRuleAllOf
     */
    'weekdays': Array<WeekdayEnum>;
}
/**
 * 
 * @export
 * @interface EnvironmentDeploymentRuleEditRequest
 */
export interface EnvironmentDeploymentRuleEditRequest {
    /**
     * 
     * @type {boolean}
     * @memberof EnvironmentDeploymentRuleEditRequest
     */
    'auto_deploy'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EnvironmentDeploymentRuleEditRequest
     */
    'on_demand_preview'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EnvironmentDeploymentRuleEditRequest
     */
    'auto_preview'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EnvironmentDeploymentRuleEditRequest
     */
    'auto_stop'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentDeploymentRuleEditRequest
     */
    'timezone': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentDeploymentRuleEditRequest
     */
    'start_time': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentDeploymentRuleEditRequest
     */
    'stop_time': string;
    /**
     * 
     * @type {Array<WeekdayEnum>}
     * @memberof EnvironmentDeploymentRuleEditRequest
     */
    'weekdays': Array<WeekdayEnum>;
}
/**
 * 
 * @export
 * @interface EnvironmentEditRequest
 */
export interface EnvironmentEditRequest {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentEditRequest
     */
    'name'?: string;
    /**
     * 
     * @type {CreateEnvironmentModeEnum}
     * @memberof EnvironmentEditRequest
     */
    'mode'?: CreateEnvironmentModeEnum;
}
/**
 * 
 * @export
 * @interface EnvironmentLog
 */
export interface EnvironmentLog {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLog
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLog
     */
    'created_at': string;
    /**
     * 
     * @type {EnvironmentLogScope}
     * @memberof EnvironmentLog
     */
    'scope'?: EnvironmentLogScope;
    /**
     * 
     * @type {StatusKindEnum}
     * @memberof EnvironmentLog
     */
    'state'?: StatusKindEnum;
    /**
     * Log message
     * @type {string}
     * @memberof EnvironmentLog
     */
    'message': string | null;
    /**
     * Only for errors. Helps Qovery team to investigate.
     * @type {string}
     * @memberof EnvironmentLog
     */
    'execution_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLog
     */
    'hint'?: string;
}
/**
 * 
 * @export
 * @interface EnvironmentLogPaginatedResponseList
 */
export interface EnvironmentLogPaginatedResponseList {
    /**
     * 
     * @type {number}
     * @memberof EnvironmentLogPaginatedResponseList
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentLogPaginatedResponseList
     */
    'page_size': number;
    /**
     * 
     * @type {Array<EnvironmentLog>}
     * @memberof EnvironmentLogPaginatedResponseList
     */
    'results'?: Array<EnvironmentLog>;
}
/**
 * 
 * @export
 * @interface EnvironmentLogPaginatedResponseListAllOf
 */
export interface EnvironmentLogPaginatedResponseListAllOf {
    /**
     * 
     * @type {Array<EnvironmentLog>}
     * @memberof EnvironmentLogPaginatedResponseListAllOf
     */
    'results'?: Array<EnvironmentLog>;
}
/**
 * 
 * @export
 * @interface EnvironmentLogResponseList
 */
export interface EnvironmentLogResponseList {
    /**
     * 
     * @type {Array<EnvironmentLog>}
     * @memberof EnvironmentLogResponseList
     */
    'results'?: Array<EnvironmentLog>;
}
/**
 * 
 * @export
 * @interface EnvironmentLogScope
 */
export interface EnvironmentLogScope {
    /**
     * 
     * @type {EnvironmentLogTypeEnum}
     * @memberof EnvironmentLogScope
     */
    'type'?: EnvironmentLogTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogScope
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogScope
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum EnvironmentLogTypeEnum {
    APPLICATION = 'APPLICATION',
    DATABASE = 'DATABASE',
    ENVIRONMENT = 'ENVIRONMENT'
}

/**
 * 
 * @export
 * @interface EnvironmentLogs
 */
export interface EnvironmentLogs {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogs
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogs
     */
    'timestamp': string;
    /**
     * 
     * @type {EnvironmentLogsDetails}
     * @memberof EnvironmentLogs
     */
    'details': EnvironmentLogsDetails;
    /**
     * 
     * @type {EnvironmentLogsError}
     * @memberof EnvironmentLogs
     */
    'error'?: EnvironmentLogsError | null;
    /**
     * 
     * @type {EnvironmentLogsMessage}
     * @memberof EnvironmentLogs
     */
    'message'?: EnvironmentLogsMessage | null;
}
/**
 * 
 * @export
 * @interface EnvironmentLogsDetails
 */
export interface EnvironmentLogsDetails {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogsDetails
     */
    'organization_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogsDetails
     */
    'cluster_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogsDetails
     */
    'execution_id'?: string;
    /**
     * 
     * @type {EnvironmentLogsDetailsTransmitter}
     * @memberof EnvironmentLogsDetails
     */
    'transmitter'?: EnvironmentLogsDetailsTransmitter;
    /**
     * 
     * @type {EnvironmentLogsDetailsStage}
     * @memberof EnvironmentLogsDetails
     */
    'stage'?: EnvironmentLogsDetailsStage;
}
/**
 * 
 * @export
 * @interface EnvironmentLogsDetailsStage
 */
export interface EnvironmentLogsDetailsStage {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogsDetailsStage
     */
    'step'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogsDetailsStage
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogsDetailsStage
     */
    'name'?: string | null;
}
/**
 * 
 * @export
 * @interface EnvironmentLogsDetailsTransmitter
 */
export interface EnvironmentLogsDetailsTransmitter {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogsDetailsTransmitter
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogsDetailsTransmitter
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogsDetailsTransmitter
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface EnvironmentLogsError
 */
export interface EnvironmentLogsError {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogsError
     */
    'tag'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogsError
     */
    'user_log_message'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogsError
     */
    'link'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogsError
     */
    'hint_message'?: string;
    /**
     * 
     * @type {EnvironmentLogsErrorUnderlyingError}
     * @memberof EnvironmentLogsError
     */
    'underlying_error'?: EnvironmentLogsErrorUnderlyingError;
}
/**
 * 
 * @export
 * @interface EnvironmentLogsErrorUnderlyingError
 */
export interface EnvironmentLogsErrorUnderlyingError {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogsErrorUnderlyingError
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogsErrorUnderlyingError
     */
    'full_details'?: string;
}
/**
 * 
 * @export
 * @interface EnvironmentLogsMessage
 */
export interface EnvironmentLogsMessage {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogsMessage
     */
    'safe_message'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentLogsMessage
     */
    'full_details'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum EnvironmentModeEnum {
    DEVELOPMENT = 'DEVELOPMENT',
    PREVIEW = 'PREVIEW',
    PRODUCTION = 'PRODUCTION',
    STAGING = 'STAGING'
}

/**
 * 
 * @export
 * @interface EnvironmentResponseList
 */
export interface EnvironmentResponseList {
    /**
     * 
     * @type {Array<Environment>}
     * @memberof EnvironmentResponseList
     */
    'results'?: Array<Environment>;
}
/**
 * 
 * @export
 * @interface EnvironmentStats
 */
export interface EnvironmentStats {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentStats
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentStats
     */
    'service_total_number'?: number;
}
/**
 * 
 * @export
 * @interface EnvironmentStatsResponseList
 */
export interface EnvironmentStatsResponseList {
    /**
     * 
     * @type {Array<EnvironmentStats>}
     * @memberof EnvironmentStatsResponseList
     */
    'results'?: Array<EnvironmentStats>;
}
/**
 * 
 * @export
 * @interface EnvironmentStatus
 */
export interface EnvironmentStatus {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentStatus
     */
    'id': string;
    /**
     * 
     * @type {StateEnum}
     * @memberof EnvironmentStatus
     */
    'state': StateEnum;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentStatus
     */
    'last_deployment_date'?: string | null;
    /**
     * 
     * @type {StateEnum}
     * @memberof EnvironmentStatus
     */
    'last_deployment_state': StateEnum;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentStatus
     */
    'last_deployment_id'?: string | null;
}
/**
 * 
 * @export
 * @interface EnvironmentStatusList
 */
export interface EnvironmentStatusList {
    /**
     * 
     * @type {Array<EnvironmentStatus>}
     * @memberof EnvironmentStatusList
     */
    'results'?: Array<EnvironmentStatus>;
}
/**
 * 
 * @export
 * @interface EnvironmentTotalNumber
 */
export interface EnvironmentTotalNumber {
    /**
     * 
     * @type {number}
     * @memberof EnvironmentTotalNumber
     */
    'environment_total_number'?: number;
}
/**
 * 
 * @export
 * @interface EnvironmentVariable
 */
export interface EnvironmentVariable {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentVariable
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentVariable
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentVariable
     */
    'updated_at'?: string;
    /**
     * key is case sensitive.
     * @type {string}
     * @memberof EnvironmentVariable
     */
    'key': string;
    /**
     * value of the env variable.
     * @type {string}
     * @memberof EnvironmentVariable
     */
    'value'?: string;
    /**
     * should be set for file only. variable mount path makes variable a file (where file should be mounted).
     * @type {string}
     * @memberof EnvironmentVariable
     */
    'mount_path'?: string | null;
    /**
     * 
     * @type {EnvironmentVariableOverride}
     * @memberof EnvironmentVariable
     */
    'overridden_variable'?: EnvironmentVariableOverride;
    /**
     * 
     * @type {EnvironmentVariableAlias}
     * @memberof EnvironmentVariable
     */
    'aliased_variable'?: EnvironmentVariableAlias;
    /**
     * 
     * @type {APIVariableScopeEnum}
     * @memberof EnvironmentVariable
     */
    'scope': APIVariableScopeEnum;
    /**
     * 
     * @type {APIVariableTypeEnum}
     * @memberof EnvironmentVariable
     */
    'variable_type'?: APIVariableTypeEnum;
    /**
     * present only for `BUILT_IN` variable
     * @type {string}
     * @memberof EnvironmentVariable
     */
    'service_id'?: string;
    /**
     * present only for `BUILT_IN` variable
     * @type {string}
     * @memberof EnvironmentVariable
     */
    'service_name'?: string;
    /**
     * 
     * @type {LinkedServiceTypeEnum}
     * @memberof EnvironmentVariable
     */
    'service_type'?: LinkedServiceTypeEnum;
    /**
     * Entity that created/own the variable (i.e: Qovery, Doppler)
     * @type {string}
     * @memberof EnvironmentVariable
     */
    'owned_by'?: string;
}
/**
 * 
 * @export
 * @interface EnvironmentVariableAlias
 */
export interface EnvironmentVariableAlias {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentVariableAlias
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentVariableAlias
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentVariableAlias
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentVariableAlias
     */
    'mount_path': string;
    /**
     * 
     * @type {APIVariableScopeEnum}
     * @memberof EnvironmentVariableAlias
     */
    'scope': APIVariableScopeEnum;
    /**
     * 
     * @type {APIVariableTypeEnum}
     * @memberof EnvironmentVariableAlias
     */
    'variable_type': APIVariableTypeEnum;
}
/**
 * 
 * @export
 * @interface EnvironmentVariableAllOf
 */
export interface EnvironmentVariableAllOf {
    /**
     * 
     * @type {EnvironmentVariableOverride}
     * @memberof EnvironmentVariableAllOf
     */
    'overridden_variable'?: EnvironmentVariableOverride;
    /**
     * 
     * @type {EnvironmentVariableAlias}
     * @memberof EnvironmentVariableAllOf
     */
    'aliased_variable'?: EnvironmentVariableAlias;
    /**
     * 
     * @type {APIVariableScopeEnum}
     * @memberof EnvironmentVariableAllOf
     */
    'scope': APIVariableScopeEnum;
    /**
     * 
     * @type {APIVariableTypeEnum}
     * @memberof EnvironmentVariableAllOf
     */
    'variable_type'?: APIVariableTypeEnum;
    /**
     * present only for `BUILT_IN` variable
     * @type {string}
     * @memberof EnvironmentVariableAllOf
     */
    'service_id'?: string;
    /**
     * present only for `BUILT_IN` variable
     * @type {string}
     * @memberof EnvironmentVariableAllOf
     */
    'service_name'?: string;
    /**
     * 
     * @type {LinkedServiceTypeEnum}
     * @memberof EnvironmentVariableAllOf
     */
    'service_type'?: LinkedServiceTypeEnum;
    /**
     * Entity that created/own the variable (i.e: Qovery, Doppler)
     * @type {string}
     * @memberof EnvironmentVariableAllOf
     */
    'owned_by'?: string;
}
/**
 * 
 * @export
 * @interface EnvironmentVariableEditRequest
 */
export interface EnvironmentVariableEditRequest {
    /**
     * key is case sensitive
     * @type {string}
     * @memberof EnvironmentVariableEditRequest
     */
    'key': string;
    /**
     * value of the env variable.
     * @type {string}
     * @memberof EnvironmentVariableEditRequest
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface EnvironmentVariableOverride
 */
export interface EnvironmentVariableOverride {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentVariableOverride
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentVariableOverride
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentVariableOverride
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentVariableOverride
     */
    'mount_path': string;
    /**
     * 
     * @type {APIVariableScopeEnum}
     * @memberof EnvironmentVariableOverride
     */
    'scope': APIVariableScopeEnum;
    /**
     * 
     * @type {APIVariableTypeEnum}
     * @memberof EnvironmentVariableOverride
     */
    'variable_type': APIVariableTypeEnum;
}
/**
 * 
 * @export
 * @interface EnvironmentVariableRequest
 */
export interface EnvironmentVariableRequest {
    /**
     * key is case sensitive.
     * @type {string}
     * @memberof EnvironmentVariableRequest
     */
    'key': string;
    /**
     * value of the env variable.
     * @type {string}
     * @memberof EnvironmentVariableRequest
     */
    'value'?: string;
    /**
     * should be set for file only. variable mount path makes variable a file (where file should be mounted).
     * @type {string}
     * @memberof EnvironmentVariableRequest
     */
    'mount_path'?: string | null;
}
/**
 * 
 * @export
 * @interface EnvironmentVariableResponseList
 */
export interface EnvironmentVariableResponseList {
    /**
     * 
     * @type {Array<EnvironmentVariable>}
     * @memberof EnvironmentVariableResponseList
     */
    'results'?: Array<EnvironmentVariable>;
}
/**
 * 
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'updated_at'?: string;
    /**
     * 
     * @type {User}
     * @memberof Event
     */
    'user'?: User;
    /**
     * 
     * @type {Commit}
     * @memberof Event
     */
    'commit'?: Commit;
    /**
     * 
     * @type {Status}
     * @memberof Event
     */
    'status'?: Status;
    /**
     * DRAFT - we have to specify here all the possible events
     * @type {string}
     * @memberof Event
     */
    'type'?: string;
    /**
     * 
     * @type {ReferenceObject}
     * @memberof Event
     */
    'log'?: ReferenceObject;
}
/**
 * 
 * @export
 * @interface EventAllOf
 */
export interface EventAllOf {
    /**
     * 
     * @type {User}
     * @memberof EventAllOf
     */
    'user'?: User;
    /**
     * 
     * @type {Commit}
     * @memberof EventAllOf
     */
    'commit'?: Commit;
    /**
     * 
     * @type {Status}
     * @memberof EventAllOf
     */
    'status'?: Status;
    /**
     * DRAFT - we have to specify here all the possible events
     * @type {string}
     * @memberof EventAllOf
     */
    'type'?: string;
    /**
     * 
     * @type {ReferenceObject}
     * @memberof EventAllOf
     */
    'log'?: ReferenceObject;
}
/**
 * 
 * @export
 * @interface EventPaginatedResponseList
 */
export interface EventPaginatedResponseList {
    /**
     * 
     * @type {number}
     * @memberof EventPaginatedResponseList
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof EventPaginatedResponseList
     */
    'page_size': number;
    /**
     * 
     * @type {Array<Event>}
     * @memberof EventPaginatedResponseList
     */
    'results'?: Array<Event>;
}
/**
 * 
 * @export
 * @interface EventPaginatedResponseListAllOf
 */
export interface EventPaginatedResponseListAllOf {
    /**
     * 
     * @type {Array<Event>}
     * @memberof EventPaginatedResponseListAllOf
     */
    'results'?: Array<Event>;
}
/**
 * 
 * @export
 * @interface EventResponseList
 */
export interface EventResponseList {
    /**
     * 
     * @type {Array<Event>}
     * @memberof EventResponseList
     */
    'results'?: Array<Event>;
}
/**
 * 
 * @export
 * @interface GenericObjectCurrentCost
 */
export interface GenericObjectCurrentCost {
    /**
     * 
     * @type {string}
     * @memberof GenericObjectCurrentCost
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GenericObjectCurrentCost
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof GenericObjectCurrentCost
     */
    'consumed_time_in_seconds': number;
    /**
     * 
     * @type {Cost}
     * @memberof GenericObjectCurrentCost
     */
    'cost': Cost;
}
/**
 * 
 * @export
 * @interface GitAuthProvider
 */
export interface GitAuthProvider {
    /**
     * 
     * @type {string}
     * @memberof GitAuthProvider
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GitAuthProvider
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GitAuthProvider
     */
    'owner': string;
    /**
     * 
     * @type {boolean}
     * @memberof GitAuthProvider
     */
    'use_bot'?: boolean;
}
/**
 * 
 * @export
 * @interface GitAuthProviderResponseList
 */
export interface GitAuthProviderResponseList {
    /**
     * 
     * @type {Array<GitAuthProvider>}
     * @memberof GitAuthProviderResponseList
     */
    'results'?: Array<GitAuthProvider>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum GitProviderEnum {
    BITBUCKET = 'BITBUCKET',
    GITHUB = 'GITHUB',
    GITLAB = 'GITLAB'
}

/**
 * 
 * @export
 * @interface GitRepository
 */
export interface GitRepository {
    /**
     * 
     * @type {string}
     * @memberof GitRepository
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GitRepository
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GitRepository
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof GitRepository
     */
    'default_branch'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GitRepository
     */
    'is_private'?: boolean;
}
/**
 * 
 * @export
 * @interface GitRepositoryBranch
 */
export interface GitRepositoryBranch {
    /**
     * 
     * @type {string}
     * @memberof GitRepositoryBranch
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface GitRepositoryBranchResponseList
 */
export interface GitRepositoryBranchResponseList {
    /**
     * 
     * @type {Array<GitRepositoryBranch>}
     * @memberof GitRepositoryBranchResponseList
     */
    'results'?: Array<GitRepositoryBranch>;
}
/**
 * 
 * @export
 * @interface GitRepositoryResponseList
 */
export interface GitRepositoryResponseList {
    /**
     * 
     * @type {Array<GitRepository>}
     * @memberof GitRepositoryResponseList
     */
    'results'?: Array<GitRepository>;
}
/**
 * 
 * @export
 * @interface Healthcheck
 */
export interface Healthcheck {
    /**
     * 
     * @type {Probe}
     * @memberof Healthcheck
     */
    'readiness_probe'?: Probe;
    /**
     * 
     * @type {Probe}
     * @memberof Healthcheck
     */
    'liveness_probe'?: Probe;
}
/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * 
     * @type {string}
     * @memberof InlineObject
     */
    'user_id': string;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {EnvironmentStatus}
     * @memberof InlineResponse200
     */
    'environment'?: EnvironmentStatus;
    /**
     * 
     * @type {Array<Status>}
     * @memberof InlineResponse200
     */
    'applications'?: Array<Status>;
    /**
     * 
     * @type {Array<Status>}
     * @memberof InlineResponse200
     */
    'containers'?: Array<Status>;
    /**
     * 
     * @type {Array<Status>}
     * @memberof InlineResponse200
     */
    'jobs'?: Array<Status>;
    /**
     * 
     * @type {Array<Status>}
     * @memberof InlineResponse200
     */
    'databases'?: Array<Status>;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * 
     * @type {EnvironmentStatus}
     * @memberof InlineResponse2001
     */
    'environment'?: EnvironmentStatus;
    /**
     * 
     * @type {DeploymentStageWithServiceStatusesList}
     * @memberof InlineResponse2001
     */
    'stages'?: DeploymentStageWithServiceStatusesList;
}
/**
 * 
 * @export
 * @interface Instance
 */
export interface Instance {
    /**
     * 
     * @type {string}
     * @memberof Instance
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Instance
     */
    'name'?: string;
    /**
     * 
     * @type {EnvironmentDatabasesCurrentMetricCpu}
     * @memberof Instance
     */
    'cpu'?: EnvironmentDatabasesCurrentMetricCpu;
    /**
     * 
     * @type {InstanceMemory}
     * @memberof Instance
     */
    'memory'?: InstanceMemory;
}
/**
 * 
 * @export
 * @interface InstanceMemory
 */
export interface InstanceMemory {
    /**
     * unit is MB. 1024 MB = 1GB.
     * @type {number}
     * @memberof InstanceMemory
     */
    'requested_in_mb'?: number;
    /**
     * unit is MB. 1024 MB = 1GB.
     * @type {number}
     * @memberof InstanceMemory
     */
    'consumed_in_mb'?: number;
    /**
     * 
     * @type {number}
     * @memberof InstanceMemory
     */
    'consumed_in_percent'?: number;
    /**
     * 
     * @type {number}
     * @memberof InstanceMemory
     */
    'warning_threshold_in_percent'?: number;
    /**
     * 
     * @type {number}
     * @memberof InstanceMemory
     */
    'alert_threshold_in_percent'?: number;
    /**
     * 
     * @type {ThresholdMetricStatusEnum}
     * @memberof InstanceMemory
     */
    'status'?: ThresholdMetricStatusEnum;
}
/**
 * 
 * @export
 * @interface InstanceResponseList
 */
export interface InstanceResponseList {
    /**
     * 
     * @type {Array<Instance>}
     * @memberof InstanceResponseList
     */
    'results'?: Array<Instance>;
}
/**
 * 
 * @export
 * @interface InviteMember
 */
export interface InviteMember {
    /**
     * 
     * @type {string}
     * @memberof InviteMember
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof InviteMember
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof InviteMember
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof InviteMember
     */
    'email': string;
    /**
     * 
     * @type {InviteMemberRoleEnum}
     * @memberof InviteMember
     */
    'role': InviteMemberRoleEnum;
    /**
     * 
     * @type {string}
     * @memberof InviteMember
     */
    'invitation_link': string;
    /**
     * 
     * @type {InviteStatusEnum}
     * @memberof InviteMember
     */
    'invitation_status': InviteStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof InviteMember
     */
    'organization_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof InviteMember
     */
    'inviter': string;
    /**
     * 
     * @type {string}
     * @memberof InviteMember
     */
    'logo_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof InviteMember
     */
    'role_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof InviteMember
     */
    'role_name'?: string;
}
/**
 * 
 * @export
 * @interface InviteMemberAllOf
 */
export interface InviteMemberAllOf {
    /**
     * 
     * @type {string}
     * @memberof InviteMemberAllOf
     */
    'email': string;
    /**
     * 
     * @type {InviteMemberRoleEnum}
     * @memberof InviteMemberAllOf
     */
    'role': InviteMemberRoleEnum;
    /**
     * 
     * @type {string}
     * @memberof InviteMemberAllOf
     */
    'invitation_link': string;
    /**
     * 
     * @type {InviteStatusEnum}
     * @memberof InviteMemberAllOf
     */
    'invitation_status': InviteStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof InviteMemberAllOf
     */
    'organization_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof InviteMemberAllOf
     */
    'inviter': string;
    /**
     * 
     * @type {string}
     * @memberof InviteMemberAllOf
     */
    'logo_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof InviteMemberAllOf
     */
    'role_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof InviteMemberAllOf
     */
    'role_name'?: string;
}
/**
 * 
 * @export
 * @interface InviteMemberRequest
 */
export interface InviteMemberRequest {
    /**
     * 
     * @type {string}
     * @memberof InviteMemberRequest
     */
    'email': string;
    /**
     * 
     * @type {InviteMemberRoleEnum}
     * @memberof InviteMemberRequest
     */
    'role'?: InviteMemberRoleEnum;
    /**
     * the target role to attribute to the new member
     * @type {string}
     * @memberof InviteMemberRequest
     */
    'role_id'?: string;
}
/**
 * 
 * @export
 * @interface InviteMemberResponseList
 */
export interface InviteMemberResponseList {
    /**
     * 
     * @type {Array<InviteMember>}
     * @memberof InviteMemberResponseList
     */
    'results'?: Array<InviteMember>;
}
/**
 * deprecated
 * @export
 * @enum {string}
 */

export enum InviteMemberRoleEnum {
    ADMIN = 'ADMIN',
    DEVELOPER = 'DEVELOPER',
    OWNER = 'OWNER',
    VIEWER = 'VIEWER'
}

/**
 * 
 * @export
 * @enum {string}
 */

export enum InviteStatusEnum {
    EXPIRED = 'EXPIRED',
    PENDING = 'PENDING'
}

/**
 * 
 * @export
 * @interface Invoice
 */
export interface Invoice {
    /**
     * 
     * @type {number}
     * @memberof Invoice
     */
    'total_in_cents': number;
    /**
     * 
     * @type {number}
     * @memberof Invoice
     */
    'total': number;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'currency_code': string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'created_at': string;
    /**
     * 
     * @type {InvoiceStatusEnum}
     * @memberof Invoice
     */
    'status': InvoiceStatusEnum;
}
/**
 * 
 * @export
 * @interface InvoiceAllOf
 */
export interface InvoiceAllOf {
    /**
     * 
     * @type {string}
     * @memberof InvoiceAllOf
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceAllOf
     */
    'created_at': string;
    /**
     * 
     * @type {InvoiceStatusEnum}
     * @memberof InvoiceAllOf
     */
    'status': InvoiceStatusEnum;
}
/**
 * 
 * @export
 * @interface InvoiceResponseList
 */
export interface InvoiceResponseList {
    /**
     * 
     * @type {Array<Invoice>}
     * @memberof InvoiceResponseList
     */
    'results'?: Array<Invoice>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum InvoiceStatusEnum {
    NOT_PAID = 'NOT_PAID',
    PAID = 'PAID',
    PAYMENT_DUE = 'PAYMENT_DUE',
    PENDING = 'PENDING',
    POSTED = 'POSTED',
    UNKNOWN = 'UNKNOWN',
    VOIDED = 'VOIDED'
}

/**
 * 
 * @export
 * @interface JobAdvancedSettings
 */
export interface JobAdvancedSettings {
    /**
     * define the max timeout for the build
     * @type {number}
     * @memberof JobAdvancedSettings
     */
    'build.timeout_max_sec'?: number;
    /**
     * define the max cpu resources (in milli)
     * @type {number}
     * @memberof JobAdvancedSettings
     */
    'build.cpu_max_in_milli'?: number;
    /**
     * define the max ram resources (in gib)
     * @type {number}
     * @memberof JobAdvancedSettings
     */
    'build.ram_max_in_gib'?: number;
    /**
     * define how long in seconds an application is supposed to be stopped gracefully
     * @type {number}
     * @memberof JobAdvancedSettings
     */
    'deployment.termination_grace_period_seconds'?: number;
    /**
     * 
     * @type {number}
     * @memberof JobAdvancedSettings
     */
    'job.delete_ttl_seconds_after_finished'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof JobAdvancedSettings
     */
    'cronjob.concurrency_policy'?: string;
    /**
     * 
     * @type {number}
     * @memberof JobAdvancedSettings
     */
    'cronjob.failed_jobs_history_limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof JobAdvancedSettings
     */
    'cronjob.success_jobs_history_limit'?: number;
    /**
     * Allows you to set an existing Kubernetes service account name 
     * @type {string}
     * @memberof JobAdvancedSettings
     */
    'security.service_account_name'?: string;
}
/**
 * 
 * @export
 * @interface JobDeployRequest
 */
export interface JobDeployRequest {
    /**
     * Image tag to deploy.   Cannot be set if `git_commit_id` is defined 
     * @type {string}
     * @memberof JobDeployRequest
     */
    'image_tag'?: string;
    /**
     * Commit to deploy Cannot be set if `image_tag` is defined 
     * @type {string}
     * @memberof JobDeployRequest
     */
    'git_commit_id'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum JobForceEvent {
    START = 'START',
    STOP = 'STOP',
    DELETE = 'DELETE',
    CRON = 'CRON'
}

/**
 * 
 * @export
 * @interface JobRequest
 */
export interface JobRequest {
    /**
     * name is case insensitive
     * @type {string}
     * @memberof JobRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof JobRequest
     */
    'description'?: string;
    /**
     * unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof JobRequest
     */
    'cpu'?: number;
    /**
     * unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof JobRequest
     */
    'memory'?: number;
    /**
     * Maximum number of restart allowed before the job is considered as failed 0 means that no restart/crash of the job is allowed 
     * @type {number}
     * @memberof JobRequest
     */
    'max_nb_restart'?: number;
    /**
     * Maximum number of seconds allowed for the job to run before killing it and mark it as failed 
     * @type {number}
     * @memberof JobRequest
     */
    'max_duration_seconds'?: number;
    /**
     * Indicates if the \'environment preview option\' is enabled for this container.   If enabled, a preview environment will be automatically cloned when `/preview` endpoint is called.   If not specified, it takes the value of the `auto_preview` property from the associated environment. 
     * @type {boolean}
     * @memberof JobRequest
     */
    'auto_preview'?: boolean;
    /**
     * Port where to run readiness and liveliness probes checks. The port will not be exposed externally
     * @type {number}
     * @memberof JobRequest
     */
    'port'?: number | null;
    /**
     * 
     * @type {JobRequestAllOfSource}
     * @memberof JobRequest
     */
    'source'?: JobRequestAllOfSource;
    /**
     * 
     * @type {Healthcheck}
     * @memberof JobRequest
     */
    'healthchecks'?: Healthcheck;
    /**
     * 
     * @type {JobRequestAllOfSchedule}
     * @memberof JobRequest
     */
    'schedule'?: JobRequestAllOfSchedule;
}
/**
 * 
 * @export
 * @interface JobRequestAllOf
 */
export interface JobRequestAllOf {
    /**
     * name is case insensitive
     * @type {string}
     * @memberof JobRequestAllOf
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof JobRequestAllOf
     */
    'description'?: string;
    /**
     * unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof JobRequestAllOf
     */
    'cpu'?: number;
    /**
     * unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof JobRequestAllOf
     */
    'memory'?: number;
    /**
     * Maximum number of restart allowed before the job is considered as failed 0 means that no restart/crash of the job is allowed 
     * @type {number}
     * @memberof JobRequestAllOf
     */
    'max_nb_restart'?: number;
    /**
     * Maximum number of seconds allowed for the job to run before killing it and mark it as failed 
     * @type {number}
     * @memberof JobRequestAllOf
     */
    'max_duration_seconds'?: number;
    /**
     * Indicates if the \'environment preview option\' is enabled for this container.   If enabled, a preview environment will be automatically cloned when `/preview` endpoint is called.   If not specified, it takes the value of the `auto_preview` property from the associated environment. 
     * @type {boolean}
     * @memberof JobRequestAllOf
     */
    'auto_preview'?: boolean;
    /**
     * Port where to run readiness and liveliness probes checks. The port will not be exposed externally
     * @type {number}
     * @memberof JobRequestAllOf
     */
    'port'?: number | null;
    /**
     * 
     * @type {JobRequestAllOfSource}
     * @memberof JobRequestAllOf
     */
    'source'?: JobRequestAllOfSource;
    /**
     * 
     * @type {Healthcheck}
     * @memberof JobRequestAllOf
     */
    'healthchecks'?: Healthcheck;
    /**
     * 
     * @type {JobRequestAllOfSchedule}
     * @memberof JobRequestAllOf
     */
    'schedule'?: JobRequestAllOfSchedule;
}
/**
 * If you want to define a Cron job, only the `cronjob` property must be filled   A Lifecycle job should contain at least one property `on_XXX` among the 3 properties: `on_start`, `on_stop`, `on_delete` 
 * @export
 * @interface JobRequestAllOfSchedule
 */
export interface JobRequestAllOfSchedule {
    /**
     * 
     * @type {JobRequestAllOfScheduleOnStart}
     * @memberof JobRequestAllOfSchedule
     */
    'on_start'?: JobRequestAllOfScheduleOnStart;
    /**
     * 
     * @type {JobRequestAllOfScheduleOnStart}
     * @memberof JobRequestAllOfSchedule
     */
    'on_stop'?: JobRequestAllOfScheduleOnStart;
    /**
     * 
     * @type {JobRequestAllOfScheduleOnStart}
     * @memberof JobRequestAllOfSchedule
     */
    'on_delete'?: JobRequestAllOfScheduleOnStart;
    /**
     * 
     * @type {JobRequestAllOfScheduleCronjob}
     * @memberof JobRequestAllOfSchedule
     */
    'cronjob'?: JobRequestAllOfScheduleCronjob;
}
/**
 * 
 * @export
 * @interface JobRequestAllOfScheduleCronjob
 */
export interface JobRequestAllOfScheduleCronjob {
    /**
     * 
     * @type {Array<string>}
     * @memberof JobRequestAllOfScheduleCronjob
     */
    'arguments'?: Array<string>;
    /**
     * optional entrypoint when launching container
     * @type {string}
     * @memberof JobRequestAllOfScheduleCronjob
     */
    'entrypoint'?: string;
    /**
     * Can only be set if the event is CRON.   Represent the cron format for the job schedule without seconds.   For example: `* * * * *` represent the cron to launch the job every minute.   See https://crontab.guru/ to WISIWIG interface.   Timezone is UTC 
     * @type {string}
     * @memberof JobRequestAllOfScheduleCronjob
     */
    'scheduled_at': string;
}
/**
 * 
 * @export
 * @interface JobRequestAllOfScheduleOnStart
 */
export interface JobRequestAllOfScheduleOnStart {
    /**
     * 
     * @type {Array<string>}
     * @memberof JobRequestAllOfScheduleOnStart
     */
    'arguments'?: Array<string>;
    /**
     * optional entrypoint when launching container
     * @type {string}
     * @memberof JobRequestAllOfScheduleOnStart
     */
    'entrypoint'?: string;
}
/**
 * 
 * @export
 * @interface JobRequestAllOfSource
 */
export interface JobRequestAllOfSource {
    /**
     * 
     * @type {JobRequestAllOfSourceImage}
     * @memberof JobRequestAllOfSource
     */
    'image'?: JobRequestAllOfSourceImage | null;
    /**
     * 
     * @type {JobRequestAllOfSourceDocker}
     * @memberof JobRequestAllOfSource
     */
    'docker'?: JobRequestAllOfSourceDocker | null;
}
/**
 * 
 * @export
 * @interface JobRequestAllOfSourceDocker
 */
export interface JobRequestAllOfSourceDocker {
    /**
     * The path of the associated Dockerfile. Only if you are using build_mode = DOCKER
     * @type {string}
     * @memberof JobRequestAllOfSourceDocker
     */
    'dockerfile_path'?: string | null;
    /**
     * 
     * @type {ApplicationGitRepositoryRequest}
     * @memberof JobRequestAllOfSourceDocker
     */
    'git_repository'?: ApplicationGitRepositoryRequest;
}
/**
 * 
 * @export
 * @interface JobRequestAllOfSourceImage
 */
export interface JobRequestAllOfSourceImage {
    /**
     * The image name pattern differs according to chosen container registry provider:   * `ECR`: `repository` * `SCALEWAY_CR`: `namespace/image` * `DOCKER_HUB`: `image` or `repository/image` * `PUBLIC_ECR`: `registry_alias/repository` 
     * @type {string}
     * @memberof JobRequestAllOfSourceImage
     */
    'image_name'?: string;
    /**
     * tag of the image container
     * @type {string}
     * @memberof JobRequestAllOfSourceImage
     */
    'tag'?: string;
    /**
     * tag of the image container
     * @type {string}
     * @memberof JobRequestAllOfSourceImage
     */
    'registry_id'?: string;
}
/**
 * 
 * @export
 * @interface JobResponse
 */
export interface JobResponse {
    /**
     * 
     * @type {string}
     * @memberof JobResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof JobResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof JobResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {ReferenceObject}
     * @memberof JobResponse
     */
    'environment': ReferenceObject;
    /**
     * 
     * @type {ReferenceObject}
     * @memberof JobResponse
     */
    'registry': ReferenceObject;
    /**
     * Maximum cpu that can be allocated to the job based on organization cluster configuration. unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof JobResponse
     */
    'maximum_cpu': number;
    /**
     * Maximum memory that can be allocated to the job based on organization cluster configuration. unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof JobResponse
     */
    'maximum_memory': number;
    /**
     * name is case insensitive
     * @type {string}
     * @memberof JobResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof JobResponse
     */
    'description'?: string;
    /**
     * unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof JobResponse
     */
    'cpu': number;
    /**
     * unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof JobResponse
     */
    'memory': number;
    /**
     * Maximum number of restart allowed before the job is considered as failed 0 means that no restart/crash of the job is allowed 
     * @type {number}
     * @memberof JobResponse
     */
    'max_nb_restart'?: number;
    /**
     * Maximum number of seconds allowed for the job to run before killing it and mark it as failed 
     * @type {number}
     * @memberof JobResponse
     */
    'max_duration_seconds'?: number;
    /**
     * Indicates if the \'environment preview option\' is enabled for this container.   If enabled, a preview environment will be automatically cloned when `/preview` endpoint is called.   If not specified, it takes the value of the `auto_preview` property from the associated environment. 
     * @type {boolean}
     * @memberof JobResponse
     */
    'auto_preview': boolean;
    /**
     * Port where to run readiness and liveliness probes checks. The port will not be exposed externally
     * @type {number}
     * @memberof JobResponse
     */
    'port'?: number | null;
    /**
     * 
     * @type {JobResponseAllOfSource}
     * @memberof JobResponse
     */
    'source'?: JobResponseAllOfSource;
    /**
     * 
     * @type {Healthcheck}
     * @memberof JobResponse
     */
    'healthchecks'?: Healthcheck;
    /**
     * 
     * @type {JobResponseAllOfSchedule}
     * @memberof JobResponse
     */
    'schedule'?: JobResponseAllOfSchedule;
}
/**
 * 
 * @export
 * @interface JobResponseAllOf
 */
export interface JobResponseAllOf {
    /**
     * 
     * @type {ReferenceObject}
     * @memberof JobResponseAllOf
     */
    'environment': ReferenceObject;
    /**
     * 
     * @type {ReferenceObject}
     * @memberof JobResponseAllOf
     */
    'registry': ReferenceObject;
    /**
     * Maximum cpu that can be allocated to the job based on organization cluster configuration. unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof JobResponseAllOf
     */
    'maximum_cpu': number;
    /**
     * Maximum memory that can be allocated to the job based on organization cluster configuration. unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof JobResponseAllOf
     */
    'maximum_memory': number;
    /**
     * name is case insensitive
     * @type {string}
     * @memberof JobResponseAllOf
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof JobResponseAllOf
     */
    'description'?: string;
    /**
     * unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof JobResponseAllOf
     */
    'cpu': number;
    /**
     * unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof JobResponseAllOf
     */
    'memory': number;
    /**
     * Maximum number of restart allowed before the job is considered as failed 0 means that no restart/crash of the job is allowed 
     * @type {number}
     * @memberof JobResponseAllOf
     */
    'max_nb_restart'?: number;
    /**
     * Maximum number of seconds allowed for the job to run before killing it and mark it as failed 
     * @type {number}
     * @memberof JobResponseAllOf
     */
    'max_duration_seconds'?: number;
    /**
     * Indicates if the \'environment preview option\' is enabled for this container.   If enabled, a preview environment will be automatically cloned when `/preview` endpoint is called.   If not specified, it takes the value of the `auto_preview` property from the associated environment. 
     * @type {boolean}
     * @memberof JobResponseAllOf
     */
    'auto_preview': boolean;
    /**
     * Port where to run readiness and liveliness probes checks. The port will not be exposed externally
     * @type {number}
     * @memberof JobResponseAllOf
     */
    'port'?: number | null;
    /**
     * 
     * @type {JobResponseAllOfSource}
     * @memberof JobResponseAllOf
     */
    'source'?: JobResponseAllOfSource;
    /**
     * 
     * @type {Healthcheck}
     * @memberof JobResponseAllOf
     */
    'healthchecks'?: Healthcheck;
    /**
     * 
     * @type {JobResponseAllOfSchedule}
     * @memberof JobResponseAllOf
     */
    'schedule'?: JobResponseAllOfSchedule;
}
/**
 * If you want to define a Cron job, only the `cronjob` property must be filled   A Lifecycle job should contain at least one property `on_XXX` among the 3 properties: `on_start`, `on_stop`, `on_delete` 
 * @export
 * @interface JobResponseAllOfSchedule
 */
export interface JobResponseAllOfSchedule {
    /**
     * 
     * @type {JobRequestAllOfScheduleOnStart}
     * @memberof JobResponseAllOfSchedule
     */
    'on_start'?: JobRequestAllOfScheduleOnStart;
    /**
     * 
     * @type {JobRequestAllOfScheduleOnStart}
     * @memberof JobResponseAllOfSchedule
     */
    'on_stop'?: JobRequestAllOfScheduleOnStart;
    /**
     * 
     * @type {JobRequestAllOfScheduleOnStart}
     * @memberof JobResponseAllOfSchedule
     */
    'on_delete'?: JobRequestAllOfScheduleOnStart;
    /**
     * 
     * @type {JobResponseAllOfScheduleCronjob}
     * @memberof JobResponseAllOfSchedule
     */
    'cronjob'?: JobResponseAllOfScheduleCronjob;
}
/**
 * 
 * @export
 * @interface JobResponseAllOfScheduleCronjob
 */
export interface JobResponseAllOfScheduleCronjob {
    /**
     * 
     * @type {Array<string>}
     * @memberof JobResponseAllOfScheduleCronjob
     */
    'arguments'?: Array<string>;
    /**
     * optional entrypoint when launching container
     * @type {string}
     * @memberof JobResponseAllOfScheduleCronjob
     */
    'entrypoint'?: string;
    /**
     * Can only be set if the event is CRON.   Represent the cron format for the job schedule without seconds.   For example: `* * * * *` represent the cron to launch the job every minute.   See https://crontab.guru/ to WISIWIG interface.   Timezone is UT 
     * @type {string}
     * @memberof JobResponseAllOfScheduleCronjob
     */
    'scheduled_at': string;
}
/**
 * 
 * @export
 * @interface JobResponseAllOfSource
 */
export interface JobResponseAllOfSource {
    /**
     * 
     * @type {JobRequestAllOfSourceImage}
     * @memberof JobResponseAllOfSource
     */
    'image'?: JobRequestAllOfSourceImage | null;
    /**
     * 
     * @type {JobResponseAllOfSourceDocker}
     * @memberof JobResponseAllOfSource
     */
    'docker'?: JobResponseAllOfSourceDocker | null;
}
/**
 * 
 * @export
 * @interface JobResponseAllOfSourceDocker
 */
export interface JobResponseAllOfSourceDocker {
    /**
     * The path of the associated Dockerfile. Only if you are using build_mode = DOCKER
     * @type {string}
     * @memberof JobResponseAllOfSourceDocker
     */
    'dockerfile_path'?: string | null;
    /**
     * 
     * @type {ApplicationGitRepository}
     * @memberof JobResponseAllOfSourceDocker
     */
    'git_repository'?: ApplicationGitRepository;
}
/**
 * 
 * @export
 * @interface JobResponseList
 */
export interface JobResponseList {
    /**
     * 
     * @type {Array<JobResponse>}
     * @memberof JobResponseList
     */
    'results'?: Array<JobResponse>;
}
/**
 * On which event the job is going to run.   ON_START means when a deployment is requested for the environment   ON_STOP means when a stop of the environment is requested   ON_DELETE means when an environment delete is requested   CRON means at a scheduled interval   
 * @export
 * @enum {string}
 */

export enum JobScheduleEvent {
    ON_START = 'ON_START',
    ON_STOP = 'ON_STOP',
    ON_DELETE = 'ON_DELETE',
    CRON = 'CRON'
}

/**
 * 
 * @export
 * @interface Key
 */
export interface Key {
    /**
     * 
     * @type {string}
     * @memberof Key
     */
    'key': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum KubernetesEnum {
    K3_S = 'K3S',
    MANAGED = 'MANAGED'
}

/**
 * 
 * @export
 * @interface Link
 */
export interface Link {
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'url'?: string;
    /**
     * 
     * @type {number}
     * @memberof Link
     */
    'internal_port'?: number;
    /**
     * 
     * @type {number}
     * @memberof Link
     */
    'external_port'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Link
     */
    'is_qovery_domain'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Link
     */
    'is_default'?: boolean;
}
/**
 * 
 * @export
 * @interface LinkResponseList
 */
export interface LinkResponseList {
    /**
     * 
     * @type {Array<Link>}
     * @memberof LinkResponseList
     */
    'results'?: Array<Link>;
}
/**
 * type of the service (application, database, job, gateway...)   present only for `BUILT_IN` variable 
 * @export
 * @enum {string}
 */

export enum LinkedServiceTypeEnum {
    APPLICATION = 'APPLICATION',
    CONTAINER = 'CONTAINER',
    DATABASE = 'DATABASE',
    JOB = 'JOB'
}

/**
 * 
 * @export
 * @interface Log
 */
export interface Log {
    /**
     * 
     * @type {string}
     * @memberof Log
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Log
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Log
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof Log
     */
    'pod_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Log
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface LogPaginatedResponseList
 */
export interface LogPaginatedResponseList {
    /**
     * 
     * @type {number}
     * @memberof LogPaginatedResponseList
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof LogPaginatedResponseList
     */
    'page_size': number;
    /**
     * 
     * @type {Array<Log>}
     * @memberof LogPaginatedResponseList
     */
    'results'?: Array<Log>;
}
/**
 * 
 * @export
 * @interface LogPaginatedResponseListAllOf
 */
export interface LogPaginatedResponseListAllOf {
    /**
     * 
     * @type {Array<Log>}
     * @memberof LogPaginatedResponseListAllOf
     */
    'results'?: Array<Log>;
}
/**
 * 
 * @export
 * @interface LogResponseList
 */
export interface LogResponseList {
    /**
     * 
     * @type {Array<Log>}
     * @memberof LogResponseList
     */
    'results'?: Array<Log>;
}
/**
 * 
 * @export
 * @interface ManagedDatabaseInstanceTypeResponse
 */
export interface ManagedDatabaseInstanceTypeResponse {
    /**
     * 
     * @type {string}
     * @memberof ManagedDatabaseInstanceTypeResponse
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ManagedDatabaseInstanceTypeResponseList
 */
export interface ManagedDatabaseInstanceTypeResponseList {
    /**
     * 
     * @type {Array<ManagedDatabaseInstanceTypeResponse>}
     * @memberof ManagedDatabaseInstanceTypeResponseList
     */
    'results'?: Array<ManagedDatabaseInstanceTypeResponse>;
}
/**
 * 
 * @export
 * @interface ManagedDatabaseTypeResponse
 */
export interface ManagedDatabaseTypeResponse {
    /**
     * 
     * @type {string}
     * @memberof ManagedDatabaseTypeResponse
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ManagedDatabaseTypeResponseList
 */
export interface ManagedDatabaseTypeResponseList {
    /**
     * 
     * @type {Array<ManagedDatabaseTypeResponse>}
     * @memberof ManagedDatabaseTypeResponseList
     */
    'results'?: Array<ManagedDatabaseTypeResponse>;
}
/**
 * 
 * @export
 * @interface Member
 */
export interface Member {
    /**
     * 
     * @type {string}
     * @memberof Member
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Member
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Member
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Member
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Member
     */
    'nickname'?: string;
    /**
     * 
     * @type {string}
     * @memberof Member
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof Member
     */
    'profile_picture_url'?: string;
    /**
     * last time the user was connected
     * @type {string}
     * @memberof Member
     */
    'last_activity_at'?: string;
    /**
     * 
     * @type {InviteMemberRoleEnum}
     * @memberof Member
     */
    'role'?: InviteMemberRoleEnum;
    /**
     * the role linked to the user
     * @type {string}
     * @memberof Member
     */
    'role_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Member
     */
    'role_id'?: string;
}
/**
 * 
 * @export
 * @interface MemberAllOf
 */
export interface MemberAllOf {
    /**
     * 
     * @type {string}
     * @memberof MemberAllOf
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof MemberAllOf
     */
    'nickname'?: string;
    /**
     * 
     * @type {string}
     * @memberof MemberAllOf
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof MemberAllOf
     */
    'profile_picture_url'?: string;
    /**
     * last time the user was connected
     * @type {string}
     * @memberof MemberAllOf
     */
    'last_activity_at'?: string;
    /**
     * 
     * @type {InviteMemberRoleEnum}
     * @memberof MemberAllOf
     */
    'role'?: InviteMemberRoleEnum;
    /**
     * the role linked to the user
     * @type {string}
     * @memberof MemberAllOf
     */
    'role_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof MemberAllOf
     */
    'role_id'?: string;
}
/**
 * 
 * @export
 * @interface MemberResponseList
 */
export interface MemberResponseList {
    /**
     * 
     * @type {Array<Member>}
     * @memberof MemberResponseList
     */
    'results'?: Array<Member>;
}
/**
 * 
 * @export
 * @interface MemberRoleUpdateRequest
 */
export interface MemberRoleUpdateRequest {
    /**
     * specify the git provider user id
     * @type {string}
     * @memberof MemberRoleUpdateRequest
     */
    'user_id': string;
    /**
     * 
     * @type {string}
     * @memberof MemberRoleUpdateRequest
     */
    'role_id': string;
}
/**
 * 
 * @export
 * @interface MetricCPU
 */
export interface MetricCPU {
    /**
     * 
     * @type {string}
     * @memberof MetricCPU
     */
    'instance_name': string;
    /**
     * 
     * @type {Array<MetricCPUDatapoint>}
     * @memberof MetricCPU
     */
    'data': Array<MetricCPUDatapoint>;
}
/**
 * 
 * @export
 * @interface MetricCPUDatapoint
 */
export interface MetricCPUDatapoint {
    /**
     * 
     * @type {string}
     * @memberof MetricCPUDatapoint
     */
    'created_at': string;
    /**
     * unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof MetricCPUDatapoint
     */
    'requested_in_number'?: number;
    /**
     * unit is millicores (m). 1000m = 1 cpu
     * @type {number}
     * @memberof MetricCPUDatapoint
     */
    'consumed_in_number': number;
    /**
     * 
     * @type {number}
     * @memberof MetricCPUDatapoint
     */
    'consumed_in_percent': number;
}
/**
 * 
 * @export
 * @interface MetricCPUDatapointResponseList
 */
export interface MetricCPUDatapointResponseList {
    /**
     * 
     * @type {Array<MetricCPUDatapoint>}
     * @memberof MetricCPUDatapointResponseList
     */
    'results'?: Array<MetricCPUDatapoint>;
}
/**
 * 
 * @export
 * @interface MetricCPUResponseList
 */
export interface MetricCPUResponseList {
    /**
     * 
     * @type {Array<MetricCPU>}
     * @memberof MetricCPUResponseList
     */
    'results'?: Array<MetricCPU>;
}
/**
 * 
 * @export
 * @interface MetricGeneric
 */
export interface MetricGeneric {
    /**
     * 
     * @type {string}
     * @memberof MetricGeneric
     */
    'instance_name': string;
    /**
     * 
     * @type {Array<MetricGenericDatapoint>}
     * @memberof MetricGeneric
     */
    'data': Array<MetricGenericDatapoint>;
}
/**
 * 
 * @export
 * @interface MetricGenericDatapoint
 */
export interface MetricGenericDatapoint {
    /**
     * 
     * @type {string}
     * @memberof MetricGenericDatapoint
     */
    'created_at': string;
    /**
     * 
     * @type {number}
     * @memberof MetricGenericDatapoint
     */
    'value': number;
}
/**
 * 
 * @export
 * @interface MetricGenericResponseList
 */
export interface MetricGenericResponseList {
    /**
     * 
     * @type {Array<MetricGeneric>}
     * @memberof MetricGenericResponseList
     */
    'results'?: Array<MetricGeneric>;
}
/**
 * 
 * @export
 * @interface MetricMemory
 */
export interface MetricMemory {
    /**
     * 
     * @type {string}
     * @memberof MetricMemory
     */
    'instance_name': string;
    /**
     * 
     * @type {Array<MetricMemoryDatapoint>}
     * @memberof MetricMemory
     */
    'data': Array<MetricMemoryDatapoint>;
}
/**
 * 
 * @export
 * @interface MetricMemoryDatapoint
 */
export interface MetricMemoryDatapoint {
    /**
     * 
     * @type {string}
     * @memberof MetricMemoryDatapoint
     */
    'created_at': string;
    /**
     * unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof MetricMemoryDatapoint
     */
    'requested_in_mb': number;
    /**
     * unit is MB. 1024 MB = 1GB
     * @type {number}
     * @memberof MetricMemoryDatapoint
     */
    'consumed_in_mb': number;
    /**
     * 
     * @type {number}
     * @memberof MetricMemoryDatapoint
     */
    'consumed_in_percent': number;
}
/**
 * 
 * @export
 * @interface MetricMemoryDatapointResponseList
 */
export interface MetricMemoryDatapointResponseList {
    /**
     * 
     * @type {Array<MetricMemoryDatapoint>}
     * @memberof MetricMemoryDatapointResponseList
     */
    'results'?: Array<MetricMemoryDatapoint>;
}
/**
 * 
 * @export
 * @interface MetricMemoryResponseList
 */
export interface MetricMemoryResponseList {
    /**
     * 
     * @type {Array<MetricMemory>}
     * @memberof MetricMemoryResponseList
     */
    'results'?: Array<MetricMemory>;
}
/**
 * 
 * @export
 * @interface MetricStorage
 */
export interface MetricStorage {
    /**
     * 
     * @type {string}
     * @memberof MetricStorage
     */
    'storage_id'?: string;
    /**
     * 
     * @type {Array<MetricStorageDatapoint>}
     * @memberof MetricStorage
     */
    'data': Array<MetricStorageDatapoint>;
}
/**
 * 
 * @export
 * @interface MetricStorageDatapoint
 */
export interface MetricStorageDatapoint {
    /**
     * 
     * @type {string}
     * @memberof MetricStorageDatapoint
     */
    'created_at': string;
    /**
     * Unit is in GB.
     * @type {number}
     * @memberof MetricStorageDatapoint
     */
    'requested_in_gb'?: number;
    /**
     * Unit is in GB.
     * @type {number}
     * @memberof MetricStorageDatapoint
     */
    'consumed_in_gb'?: number;
    /**
     * 
     * @type {number}
     * @memberof MetricStorageDatapoint
     */
    'consumed_in_percent': number;
}
/**
 * 
 * @export
 * @interface MetricStorageDatapointResponseList
 */
export interface MetricStorageDatapointResponseList {
    /**
     * 
     * @type {Array<MetricStorageDatapoint>}
     * @memberof MetricStorageDatapointResponseList
     */
    'results'?: Array<MetricStorageDatapoint>;
}
/**
 * 
 * @export
 * @interface MetricStorageResponseList
 */
export interface MetricStorageResponseList {
    /**
     * 
     * @type {Array<MetricStorage>}
     * @memberof MetricStorageResponseList
     */
    'results'?: Array<MetricStorage>;
}
/**
 * 
 * @export
 * @interface Name
 */
export interface Name {
    /**
     * 
     * @type {string}
     * @memberof Name
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface Organization
 */
export interface Organization {
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'updated_at'?: string;
    /**
     * name is case insensitive
     * @type {string}
     * @memberof Organization
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'description'?: string | null;
    /**
     * 
     * @type {PlanEnum}
     * @memberof Organization
     */
    'plan': PlanEnum;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'website_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'repository'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'logo_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'icon_url'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof Organization
     */
    'admin_emails'?: Array<string> | null;
    /**
     * uuid of the user owning the organization
     * @type {string}
     * @memberof Organization
     */
    'owner'?: string;
}
/**
 * 
 * @export
 * @interface OrganizationAllOf
 */
export interface OrganizationAllOf {
    /**
     * uuid of the user owning the organization
     * @type {string}
     * @memberof OrganizationAllOf
     */
    'owner'?: string;
}
/**
 * 
 * @export
 * @interface OrganizationApiToken
 */
export interface OrganizationApiToken {
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiToken
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiToken
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiToken
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiToken
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiToken
     */
    'description'?: string;
    /**
     * 
     * @type {OrganizationApiTokenScope}
     * @memberof OrganizationApiToken
     */
    'scope'?: OrganizationApiTokenScope;
}
/**
 * 
 * @export
 * @interface OrganizationApiTokenAllOf
 */
export interface OrganizationApiTokenAllOf {
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiTokenAllOf
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiTokenAllOf
     */
    'description'?: string;
    /**
     * 
     * @type {OrganizationApiTokenScope}
     * @memberof OrganizationApiTokenAllOf
     */
    'scope'?: OrganizationApiTokenScope;
}
/**
 * 
 * @export
 * @interface OrganizationApiTokenCreate
 */
export interface OrganizationApiTokenCreate {
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiTokenCreate
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiTokenCreate
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiTokenCreate
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiTokenCreate
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiTokenCreate
     */
    'description'?: string;
    /**
     * the generated token to send in \'Authorization\' header prefixed by \'Token \'
     * @type {string}
     * @memberof OrganizationApiTokenCreate
     */
    'token'?: string;
    /**
     * 
     * @type {OrganizationApiTokenScope}
     * @memberof OrganizationApiTokenCreate
     */
    'scope'?: OrganizationApiTokenScope;
}
/**
 * 
 * @export
 * @interface OrganizationApiTokenCreateAllOf
 */
export interface OrganizationApiTokenCreateAllOf {
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiTokenCreateAllOf
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiTokenCreateAllOf
     */
    'description'?: string;
    /**
     * the generated token to send in \'Authorization\' header prefixed by \'Token \'
     * @type {string}
     * @memberof OrganizationApiTokenCreateAllOf
     */
    'token'?: string;
    /**
     * 
     * @type {OrganizationApiTokenScope}
     * @memberof OrganizationApiTokenCreateAllOf
     */
    'scope'?: OrganizationApiTokenScope;
}
/**
 * 
 * @export
 * @interface OrganizationApiTokenCreateRequest
 */
export interface OrganizationApiTokenCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiTokenCreateRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationApiTokenCreateRequest
     */
    'description'?: string;
    /**
     * 
     * @type {OrganizationApiTokenScope}
     * @memberof OrganizationApiTokenCreateRequest
     */
    'scope': OrganizationApiTokenScope;
}
/**
 * 
 * @export
 * @interface OrganizationApiTokenResponseList
 */
export interface OrganizationApiTokenResponseList {
    /**
     * 
     * @type {Array<OrganizationApiToken>}
     * @memberof OrganizationApiTokenResponseList
     */
    'results'?: Array<OrganizationApiToken>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum OrganizationApiTokenScope {
    ADMIN = 'ADMIN'
}

/**
 * 
 * @export
 * @interface OrganizationAvailableRole
 */
export interface OrganizationAvailableRole {
    /**
     * 
     * @type {string}
     * @memberof OrganizationAvailableRole
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationAvailableRole
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface OrganizationAvailableRoleList
 */
export interface OrganizationAvailableRoleList {
    /**
     * 
     * @type {Array<OrganizationAvailableRole>}
     * @memberof OrganizationAvailableRoleList
     */
    'results'?: Array<OrganizationAvailableRole>;
}
/**
 * 
 * @export
 * @interface OrganizationChangePlanRequest
 */
export interface OrganizationChangePlanRequest {
    /**
     * 
     * @type {string}
     * @memberof OrganizationChangePlanRequest
     */
    'plan'?: string;
}
/**
 * 
 * @export
 * @interface OrganizationContainerAutoDeployRequest
 */
export interface OrganizationContainerAutoDeployRequest {
    /**
     * the container image name to deploy
     * @type {string}
     * @memberof OrganizationContainerAutoDeployRequest
     */
    'image_name'?: string;
    /**
     * the new tag to deploy
     * @type {string}
     * @memberof OrganizationContainerAutoDeployRequest
     */
    'tag'?: string;
}
/**
 * 
 * @export
 * @interface OrganizationContainerPreviewRequest
 */
export interface OrganizationContainerPreviewRequest {
    /**
     * the container image name to trigger preview environment
     * @type {string}
     * @memberof OrganizationContainerPreviewRequest
     */
    'image_name'?: string;
    /**
     * the tag to be used in the preview environment
     * @type {string}
     * @memberof OrganizationContainerPreviewRequest
     */
    'tag'?: string;
}
/**
 * 
 * @export
 * @interface OrganizationCreditCodeRequest
 */
export interface OrganizationCreditCodeRequest {
    /**
     * 
     * @type {string}
     * @memberof OrganizationCreditCodeRequest
     */
    'code'?: string;
}
/**
 * 
 * @export
 * @interface OrganizationCurrentCost
 */
export interface OrganizationCurrentCost {
    /**
     * 
     * @type {PlanEnum}
     * @memberof OrganizationCurrentCost
     */
    'plan'?: PlanEnum;
    /**
     * number of days remaining before the end of the trial period
     * @type {number}
     * @memberof OrganizationCurrentCost
     */
    'remaining_trial_day'?: number;
    /**
     * 
     * @type {RemainingCredits}
     * @memberof OrganizationCurrentCost
     */
    'remaining_credits'?: RemainingCredits;
    /**
     * 
     * @type {Cost}
     * @memberof OrganizationCurrentCost
     */
    'cost'?: Cost;
    /**
     * 
     * @type {PaidUsage}
     * @memberof OrganizationCurrentCost
     */
    'paid_usage'?: PaidUsage;
}
/**
 * 
 * @export
 * @interface OrganizationCurrentCostAllOf
 */
export interface OrganizationCurrentCostAllOf {
    /**
     * 
     * @type {PaidUsage}
     * @memberof OrganizationCurrentCostAllOf
     */
    'paid_usage'?: PaidUsage;
}
/**
 * 
 * @export
 * @interface OrganizationCustomRole
 */
export interface OrganizationCustomRole {
    /**
     * 
     * @type {string}
     * @memberof OrganizationCustomRole
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationCustomRole
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationCustomRole
     */
    'description'?: string;
    /**
     * 
     * @type {Array<OrganizationCustomRoleClusterPermissions>}
     * @memberof OrganizationCustomRole
     */
    'cluster_permissions'?: Array<OrganizationCustomRoleClusterPermissions>;
    /**
     * 
     * @type {Array<OrganizationCustomRoleProjectPermissions>}
     * @memberof OrganizationCustomRole
     */
    'project_permissions'?: Array<OrganizationCustomRoleProjectPermissions>;
}
/**
 * Indicates the permission for a target cluster, from the lowest to the highest: - `VIEWER` user has only read access on target cluster - `ENV_CREATOR` user can deploy on the cluster - `ADMIN` user can modify the cluster settings 
 * @export
 * @enum {string}
 */

export enum OrganizationCustomRoleClusterPermission {
    VIEWER = 'VIEWER',
    ENV_CREATOR = 'ENV_CREATOR',
    ADMIN = 'ADMIN'
}

/**
 * 
 * @export
 * @interface OrganizationCustomRoleClusterPermissions
 */
export interface OrganizationCustomRoleClusterPermissions {
    /**
     * 
     * @type {string}
     * @memberof OrganizationCustomRoleClusterPermissions
     */
    'cluster_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationCustomRoleClusterPermissions
     */
    'cluster_name'?: string;
    /**
     * 
     * @type {OrganizationCustomRoleClusterPermission}
     * @memberof OrganizationCustomRoleClusterPermissions
     */
    'permission'?: OrganizationCustomRoleClusterPermission;
}
/**
 * 
 * @export
 * @interface OrganizationCustomRoleCreateRequest
 */
export interface OrganizationCustomRoleCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof OrganizationCustomRoleCreateRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationCustomRoleCreateRequest
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface OrganizationCustomRoleList
 */
export interface OrganizationCustomRoleList {
    /**
     * 
     * @type {Array<OrganizationCustomRole>}
     * @memberof OrganizationCustomRoleList
     */
    'results'?: Array<OrganizationCustomRole>;
}
/**
 * Indicates the permission for a target project and a given environment type, from the lowest to the highest: - `NO_ACCESS` user has no access - `VIEWER` user can access the environment (and applications / containers / databases / variables) - `DEPLOYER` user can deploy the environment (dependent on the required cluster permission `ENV_CREATOR`) - `MANAGER` user can create an environment (and applications / containers / databases / variables) 
 * @export
 * @enum {string}
 */

export enum OrganizationCustomRoleProjectPermission {
    NO_ACCESS = 'NO_ACCESS',
    VIEWER = 'VIEWER',
    DEPLOYER = 'DEPLOYER',
    MANAGER = 'MANAGER'
}

/**
 * 
 * @export
 * @interface OrganizationCustomRoleProjectPermissions
 */
export interface OrganizationCustomRoleProjectPermissions {
    /**
     * 
     * @type {string}
     * @memberof OrganizationCustomRoleProjectPermissions
     */
    'project_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationCustomRoleProjectPermissions
     */
    'project_name'?: string;
    /**
     * If `is_admin` is `true`, the user is: - automatically `MANAGER` for each environment type - allowed to manage project deployment rules - able to delete the project    Note that `permissions` can then be ignored for this project 
     * @type {boolean}
     * @memberof OrganizationCustomRoleProjectPermissions
     */
    'is_admin'?: boolean;
    /**
     * 
     * @type {Array<OrganizationCustomRoleUpdateRequestPermissions>}
     * @memberof OrganizationCustomRoleProjectPermissions
     */
    'permissions'?: Array<OrganizationCustomRoleUpdateRequestPermissions>;
}
/**
 * 
 * @export
 * @interface OrganizationCustomRoleUpdateRequest
 */
export interface OrganizationCustomRoleUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof OrganizationCustomRoleUpdateRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationCustomRoleUpdateRequest
     */
    'description'?: string;
    /**
     * Should contain an entry for every existing cluster
     * @type {Array<OrganizationCustomRoleUpdateRequestClusterPermissions>}
     * @memberof OrganizationCustomRoleUpdateRequest
     */
    'cluster_permissions': Array<OrganizationCustomRoleUpdateRequestClusterPermissions>;
    /**
     * Should contain an entry for every existing project
     * @type {Array<OrganizationCustomRoleUpdateRequestProjectPermissions>}
     * @memberof OrganizationCustomRoleUpdateRequest
     */
    'project_permissions': Array<OrganizationCustomRoleUpdateRequestProjectPermissions>;
}
/**
 * 
 * @export
 * @interface OrganizationCustomRoleUpdateRequestClusterPermissions
 */
export interface OrganizationCustomRoleUpdateRequestClusterPermissions {
    /**
     * 
     * @type {string}
     * @memberof OrganizationCustomRoleUpdateRequestClusterPermissions
     */
    'cluster_id'?: string;
    /**
     * 
     * @type {OrganizationCustomRoleClusterPermission}
     * @memberof OrganizationCustomRoleUpdateRequestClusterPermissions
     */
    'permission'?: OrganizationCustomRoleClusterPermission;
}
/**
 * 
 * @export
 * @interface OrganizationCustomRoleUpdateRequestPermissions
 */
export interface OrganizationCustomRoleUpdateRequestPermissions {
    /**
     * 
     * @type {EnvironmentModeEnum}
     * @memberof OrganizationCustomRoleUpdateRequestPermissions
     */
    'environment_type'?: EnvironmentModeEnum;
    /**
     * 
     * @type {OrganizationCustomRoleProjectPermission}
     * @memberof OrganizationCustomRoleUpdateRequestPermissions
     */
    'permission'?: OrganizationCustomRoleProjectPermission;
}
/**
 * 
 * @export
 * @interface OrganizationCustomRoleUpdateRequestProjectPermissions
 */
export interface OrganizationCustomRoleUpdateRequestProjectPermissions {
    /**
     * 
     * @type {string}
     * @memberof OrganizationCustomRoleUpdateRequestProjectPermissions
     */
    'project_id'?: string;
    /**
     * If `is_admin` is `true`, the user is: - automatically `MANAGER` for each environment type - allowed to manage project deployment rules - able to delete the project    Note that `permissions` can then be ignored for this project 
     * @type {boolean}
     * @memberof OrganizationCustomRoleUpdateRequestProjectPermissions
     */
    'is_admin'?: boolean;
    /**
     * Mandatory if `is_admin` is `false`   Should contain an entry for every environment type: - `DEVELOPMENT` - `PREVIEW` - `STAGING` - `PRODUCTION` 
     * @type {Array<OrganizationCustomRoleUpdateRequestPermissions>}
     * @memberof OrganizationCustomRoleUpdateRequestProjectPermissions
     */
    'permissions'?: Array<OrganizationCustomRoleUpdateRequestPermissions>;
}
/**
 * 
 * @export
 * @interface OrganizationEditRequest
 */
export interface OrganizationEditRequest {
    /**
     * name is case insensitive
     * @type {string}
     * @memberof OrganizationEditRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationEditRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationEditRequest
     */
    'website_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationEditRequest
     */
    'repository'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationEditRequest
     */
    'logo_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationEditRequest
     */
    'icon_url'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof OrganizationEditRequest
     */
    'admin_emails'?: Array<string> | null;
}
/**
 * Origin of the organization event
 * @export
 * @enum {string}
 */

export enum OrganizationEventOrigin {
    API = 'API',
    CLI = 'CLI',
    CONSOLE = 'CONSOLE',
    GIT = 'GIT',
    QOVERY_INTERNAL = 'QOVERY_INTERNAL',
    TERRAFORM_PROVIDER = 'TERRAFORM_PROVIDER'
}

/**
 * 
 * @export
 * @interface OrganizationEventResponse
 */
export interface OrganizationEventResponse {
    /**
     * 
     * @type {string}
     * @memberof OrganizationEventResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationEventResponse
     */
    'timestamp'?: string;
    /**
     * 
     * @type {OrganizationEventType}
     * @memberof OrganizationEventResponse
     */
    'event_type'?: OrganizationEventType;
    /**
     * 
     * @type {string}
     * @memberof OrganizationEventResponse
     */
    'target_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationEventResponse
     */
    'target_name'?: string;
    /**
     * 
     * @type {OrganizationEventTargetType}
     * @memberof OrganizationEventResponse
     */
    'target_type'?: OrganizationEventTargetType;
    /**
     * 
     * @type {OrganizationEventSubTargetType}
     * @memberof OrganizationEventResponse
     */
    'sub_target_type'?: OrganizationEventSubTargetType;
    /**
     * 
     * @type {string}
     * @memberof OrganizationEventResponse
     */
    'change'?: string;
    /**
     * 
     * @type {OrganizationEventOrigin}
     * @memberof OrganizationEventResponse
     */
    'origin'?: OrganizationEventOrigin;
    /**
     * 
     * @type {string}
     * @memberof OrganizationEventResponse
     */
    'triggered_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationEventResponse
     */
    'project_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationEventResponse
     */
    'project_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationEventResponse
     */
    'environment_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationEventResponse
     */
    'environment_name'?: string;
}
/**
 * 
 * @export
 * @interface OrganizationEventResponseList
 */
export interface OrganizationEventResponseList {
    /**
     * 
     * @type {OrganizationEventResponseListLinks}
     * @memberof OrganizationEventResponseList
     */
    'links'?: OrganizationEventResponseListLinks;
    /**
     * 
     * @type {Array<OrganizationEventResponse>}
     * @memberof OrganizationEventResponseList
     */
    'events'?: Array<OrganizationEventResponse>;
}
/**
 * 
 * @export
 * @interface OrganizationEventResponseListLinks
 */
export interface OrganizationEventResponseListLinks {
    /**
     * 
     * @type {string}
     * @memberof OrganizationEventResponseListLinks
     */
    'previous'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationEventResponseListLinks
     */
    'next'?: string;
}
/**
 * Type of the organization event
 * @export
 * @enum {string}
 */

export enum OrganizationEventSubTargetType {
    ADVANCED_SETTINGS = 'ADVANCED_SETTINGS',
    API_TOKEN = 'API_TOKEN',
    BILLING_INFO = 'BILLING_INFO',
    CLOUD_PROVIDER_CREDENTIALS = 'CLOUD_PROVIDER_CREDENTIALS',
    CLUSTER_CREDENTIALS = 'CLUSTER_CREDENTIALS',
    CLUSTER_ROUTING_TABLE = 'CLUSTER_ROUTING_TABLE',
    CONFIG = 'CONFIG',
    CREDIT_CARD = 'CREDIT_CARD',
    CREDIT_CODE = 'CREDIT_CODE',
    CUSTOM_DOMAIN = 'CUSTOM_DOMAIN',
    CUSTOM_ROLE = 'CUSTOM_ROLE',
    DEPLOYMENT_RULE = 'DEPLOYMENT_RULE',
    DEPLOYMENT_STAGE = 'DEPLOYMENT_STAGE',
    GITHUB_APP = 'GITHUB_APP',
    GIT_REPOSITORY = 'GIT_REPOSITORY',
    INVITATION = 'INVITATION',
    MEMBER_ROLE = 'MEMBER_ROLE',
    PLAN = 'PLAN',
    SECRET = 'SECRET',
    TERRAFORM = 'TERRAFORM',
    TRANSFER_OWNERSHIP = 'TRANSFER_OWNERSHIP',
    VARIABLE = 'VARIABLE'
}

/**
 * 
 * @export
 * @interface OrganizationEventTargetResponseList
 */
export interface OrganizationEventTargetResponseList {
    /**
     * 
     * @type {Array<ClusterCloudProviderInfoCredentials>}
     * @memberof OrganizationEventTargetResponseList
     */
    'targets'?: Array<ClusterCloudProviderInfoCredentials>;
}
/**
 * Type of the organization event
 * @export
 * @enum {string}
 */

export enum OrganizationEventTargetType {
    APPLICATION = 'APPLICATION',
    CLUSTER = 'CLUSTER',
    CONTAINER = 'CONTAINER',
    CONTAINER_REGISTRY = 'CONTAINER_REGISTRY',
    DATABASE = 'DATABASE',
    ENVIRONMENT = 'ENVIRONMENT',
    JOB = 'JOB',
    MEMBERS_AND_ROLES = 'MEMBERS_AND_ROLES',
    ORGANIZATION = 'ORGANIZATION',
    PROJECT = 'PROJECT',
    WEBHOOK = 'WEBHOOK'
}

/**
 * Type of the organization event
 * @export
 * @enum {string}
 */

export enum OrganizationEventType {
    CREATE = 'CREATE',
    UPDATE = 'UPDATE',
    DELETE = 'DELETE',
    ACCEPT = 'ACCEPT',
    EXPORT = 'EXPORT',
    TRIGGER_DEPLOY = 'TRIGGER_DEPLOY',
    TRIGGER_REDEPLOY = 'TRIGGER_REDEPLOY',
    TRIGGER_STOP = 'TRIGGER_STOP',
    TRIGGER_CANCEL = 'TRIGGER_CANCEL',
    TRIGGER_RESTART = 'TRIGGER_RESTART',
    TRIGGER_DELETE = 'TRIGGER_DELETE'
}

/**
 * 
 * @export
 * @interface OrganizationGithubAppConnectRequest
 */
export interface OrganizationGithubAppConnectRequest {
    /**
     * 
     * @type {string}
     * @memberof OrganizationGithubAppConnectRequest
     */
    'installation_id': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationGithubAppConnectRequest
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface OrganizationRequest
 */
export interface OrganizationRequest {
    /**
     * name is case insensitive
     * @type {string}
     * @memberof OrganizationRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {PlanEnum}
     * @memberof OrganizationRequest
     */
    'plan': PlanEnum;
    /**
     * 
     * @type {string}
     * @memberof OrganizationRequest
     */
    'website_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationRequest
     */
    'repository'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationRequest
     */
    'logo_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationRequest
     */
    'icon_url'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof OrganizationRequest
     */
    'admin_emails'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface OrganizationResponseList
 */
export interface OrganizationResponseList {
    /**
     * 
     * @type {Array<Organization>}
     * @memberof OrganizationResponseList
     */
    'results'?: Array<Organization>;
}
/**
 * 
 * @export
 * @interface OrganizationWebhookCreateRequest
 */
export interface OrganizationWebhookCreateRequest {
    /**
     * 
     * @type {OrganizationWebhookKindEnum}
     * @memberof OrganizationWebhookCreateRequest
     */
    'kind': OrganizationWebhookKindEnum;
    /**
     * Set the public HTTP or HTTPS endpoint that will receive the specified events. The target URL must starts with `http://` or `https://` 
     * @type {string}
     * @memberof OrganizationWebhookCreateRequest
     */
    'target_url': string;
    /**
     * Make sure you receive a payload to sign the Qovery request with your secret. Qovery will add a HTTP header `Qovery-Signature: <Your Secret>` to every webhook requests sent to your target URL. 
     * @type {string}
     * @memberof OrganizationWebhookCreateRequest
     */
    'target_secret'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationWebhookCreateRequest
     */
    'description'?: string;
    /**
     * Turn on or off your endpoint.
     * @type {boolean}
     * @memberof OrganizationWebhookCreateRequest
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {Array<OrganizationWebhookEventEnum>}
     * @memberof OrganizationWebhookCreateRequest
     */
    'events': Array<OrganizationWebhookEventEnum>;
    /**
     * Specify the project names you want to filter to.  This webhook will be triggered only if the event is coming from the specified Project IDs. Notes: 1. Wildcard is accepted E.g. `product*`. 2. Name is case insensitive. 
     * @type {Array<string>}
     * @memberof OrganizationWebhookCreateRequest
     */
    'project_names_filter'?: Array<string>;
    /**
     * Specify the environment modes you want to filter to. This webhook will be triggered only if the event is coming from an environment with the specified mode. 
     * @type {Array<EnvironmentModeEnum>}
     * @memberof OrganizationWebhookCreateRequest
     */
    'environment_types_filter'?: Array<EnvironmentModeEnum>;
}
/**
 * 
 * @export
 * @interface OrganizationWebhookCreateResponse
 */
export interface OrganizationWebhookCreateResponse {
    /**
     * 
     * @type {string}
     * @memberof OrganizationWebhookCreateResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationWebhookCreateResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationWebhookCreateResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {OrganizationWebhookKindEnum}
     * @memberof OrganizationWebhookCreateResponse
     */
    'kind'?: OrganizationWebhookKindEnum;
    /**
     * Set the public HTTP or HTTPS endpoint that will receive the specified events. The target URL must starts with `http://` or `https://` 
     * @type {string}
     * @memberof OrganizationWebhookCreateResponse
     */
    'target_url'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationWebhookCreateResponse
     */
    'target_secret_set'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OrganizationWebhookCreateResponse
     */
    'description'?: string;
    /**
     * Turn on or off your endpoint.
     * @type {boolean}
     * @memberof OrganizationWebhookCreateResponse
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {Array<OrganizationWebhookEventEnum>}
     * @memberof OrganizationWebhookCreateResponse
     */
    'events'?: Array<OrganizationWebhookEventEnum>;
    /**
     * Specify the project names you want to filter to.  This webhook will be triggered only if the event is coming from the specified Project IDs. Notes: 1. Wildcard is accepted E.g. `product*`. 2. Name is case insensitive. 
     * @type {Array<string>}
     * @memberof OrganizationWebhookCreateResponse
     */
    'project_names_filter'?: Array<string>;
    /**
     * Specify the environment modes you want to filter to. This webhook will be triggered only if the event is coming from an environment with the specified mode. 
     * @type {Array<EnvironmentModeEnum>}
     * @memberof OrganizationWebhookCreateResponse
     */
    'environment_types_filter'?: Array<EnvironmentModeEnum>;
}
/**
 * 
 * @export
 * @interface OrganizationWebhookCreateResponseAllOf
 */
export interface OrganizationWebhookCreateResponseAllOf {
    /**
     * 
     * @type {OrganizationWebhookKindEnum}
     * @memberof OrganizationWebhookCreateResponseAllOf
     */
    'kind'?: OrganizationWebhookKindEnum;
    /**
     * Set the public HTTP or HTTPS endpoint that will receive the specified events. The target URL must starts with `http://` or `https://` 
     * @type {string}
     * @memberof OrganizationWebhookCreateResponseAllOf
     */
    'target_url'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationWebhookCreateResponseAllOf
     */
    'target_secret_set'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OrganizationWebhookCreateResponseAllOf
     */
    'description'?: string;
    /**
     * Turn on or off your endpoint.
     * @type {boolean}
     * @memberof OrganizationWebhookCreateResponseAllOf
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {Array<OrganizationWebhookEventEnum>}
     * @memberof OrganizationWebhookCreateResponseAllOf
     */
    'events'?: Array<OrganizationWebhookEventEnum>;
    /**
     * Specify the project names you want to filter to.  This webhook will be triggered only if the event is coming from the specified Project IDs. Notes: 1. Wildcard is accepted E.g. `product*`. 2. Name is case insensitive. 
     * @type {Array<string>}
     * @memberof OrganizationWebhookCreateResponseAllOf
     */
    'project_names_filter'?: Array<string>;
    /**
     * Specify the environment modes you want to filter to. This webhook will be triggered only if the event is coming from an environment with the specified mode. 
     * @type {Array<EnvironmentModeEnum>}
     * @memberof OrganizationWebhookCreateResponseAllOf
     */
    'environment_types_filter'?: Array<EnvironmentModeEnum>;
}
/**
 * Events to subscribe to and send to the `target_url`. - `DEPLOYMENT_STARTED` send an event when a deployment is started and going to be executed - `DEPLOYMENT_CANCELLED` send an event when a deployment is cancelled - `DEPLOYMENT_FAILURE` send an event when a deployment failed - `DEPLOYMENT_SUCCESSFUL` send an event when a deployment is successful 
 * @export
 * @enum {string}
 */

export enum OrganizationWebhookEventEnum {
    STARTED = 'DEPLOYMENT_STARTED',
    CANCELLED = 'DEPLOYMENT_CANCELLED',
    FAILURE = 'DEPLOYMENT_FAILURE',
    SUCCESSFUL = 'DEPLOYMENT_SUCCESSFUL'
}

/**
 * Define the type of the webhook. `SLACK` is a special webhook type to push notifications directly to slack. The `target_url` must be a Slack compatible endpoint.
 * @export
 * @enum {string}
 */

export enum OrganizationWebhookKindEnum {
    STANDARD = 'STANDARD',
    SLACK = 'SLACK'
}

/**
 * 
 * @export
 * @interface OrganizationWebhookResponse
 */
export interface OrganizationWebhookResponse {
    /**
     * 
     * @type {string}
     * @memberof OrganizationWebhookResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationWebhookResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationWebhookResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {OrganizationWebhookKindEnum}
     * @memberof OrganizationWebhookResponse
     */
    'kind'?: OrganizationWebhookKindEnum;
    /**
     * Set the public HTTP or HTTPS endpoint that will receive the specified events. The target URL must starts with `http://` or `https://` 
     * @type {string}
     * @memberof OrganizationWebhookResponse
     */
    'target_url'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationWebhookResponse
     */
    'target_secret_set'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OrganizationWebhookResponse
     */
    'description'?: string;
    /**
     * Turn on or off your endpoint.
     * @type {boolean}
     * @memberof OrganizationWebhookResponse
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {Array<OrganizationWebhookEventEnum>}
     * @memberof OrganizationWebhookResponse
     */
    'events'?: Array<OrganizationWebhookEventEnum>;
    /**
     * Specify the project names you want to filter to.  This webhook will be triggered only if the event is coming from the specified Project IDs. Notes: 1. Wildcard is accepted E.g. `product*`. 2. Name is case insensitive. 
     * @type {Array<string>}
     * @memberof OrganizationWebhookResponse
     */
    'project_names_filter'?: Array<string>;
    /**
     * Specify the environment modes you want to filter to. This webhook will be triggered only if the event is coming from an environment with the specified mode. 
     * @type {Array<EnvironmentModeEnum>}
     * @memberof OrganizationWebhookResponse
     */
    'environment_types_filter'?: Array<EnvironmentModeEnum>;
}
/**
 * 
 * @export
 * @interface OrganizationWebhookResponseList
 */
export interface OrganizationWebhookResponseList {
    /**
     * 
     * @type {Array<OrganizationWebhookResponse>}
     * @memberof OrganizationWebhookResponseList
     */
    'results'?: Array<OrganizationWebhookResponse>;
}
/**
 * 
 * @export
 * @interface PaginationData
 */
export interface PaginationData {
    /**
     * 
     * @type {number}
     * @memberof PaginationData
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof PaginationData
     */
    'page_size': number;
}
/**
 * 
 * @export
 * @interface PaidUsage
 */
export interface PaidUsage {
    /**
     * 
     * @type {number}
     * @memberof PaidUsage
     */
    'max_deployments_per_month'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaidUsage
     */
    'consumed_deployments'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaidUsage
     */
    'monthly_plan_cost'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaidUsage
     */
    'monthly_plan_cost_in_cents'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaidUsage
     */
    'remaining_deployments'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PaidUsage
     */
    'deployments_exceeded'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PaidUsage
     */
    'renewal_at'?: string | null;
}
/**
 * BUSINESS & PROFESSIONAL are deprecated
 * @export
 * @enum {string}
 */

export enum PlanEnum {
    FREE = 'FREE',
    TEAM = 'TEAM',
    TEAM_YEARLY = 'TEAM_YEARLY',
    ENTERPRISE = 'ENTERPRISE',
    ENTERPRISE_YEARLY = 'ENTERPRISE_YEARLY',
    PROFESSIONAL = 'PROFESSIONAL',
    BUSINESS = 'BUSINESS'
}

/**
 * 
 * @export
 * @enum {string}
 */

export enum PortProtocolEnum {
    HTTP = 'HTTP',
    GRPC = 'GRPC'
}

/**
 * 
 * @export
 * @interface Probe
 */
export interface Probe {
    /**
     * 
     * @type {ProbeType}
     * @memberof Probe
     */
    'type'?: ProbeType;
    /**
     * 
     * @type {number}
     * @memberof Probe
     */
    'initial_delay_seconds'?: number;
    /**
     * 
     * @type {number}
     * @memberof Probe
     */
    'period_seconds'?: number;
    /**
     * 
     * @type {number}
     * @memberof Probe
     */
    'timeout_seconds'?: number;
    /**
     * 
     * @type {number}
     * @memberof Probe
     */
    'success_threshold'?: number;
    /**
     * 
     * @type {number}
     * @memberof Probe
     */
    'failure_threshold'?: number;
}
/**
 * 
 * @export
 * @interface ProbeType
 */
export interface ProbeType {
    /**
     * 
     * @type {ProbeTypeTcp}
     * @memberof ProbeType
     */
    'tcp'?: ProbeTypeTcp | null;
    /**
     * 
     * @type {ProbeTypeHttp}
     * @memberof ProbeType
     */
    'http'?: ProbeTypeHttp | null;
    /**
     * 
     * @type {ProbeTypeExec}
     * @memberof ProbeType
     */
    'exec'?: ProbeTypeExec | null;
    /**
     * 
     * @type {ProbeTypeGrpc}
     * @memberof ProbeType
     */
    'grpc'?: ProbeTypeGrpc | null;
}
/**
 * 
 * @export
 * @interface ProbeTypeExec
 */
export interface ProbeTypeExec {
    /**
     * 
     * @type {Array<string>}
     * @memberof ProbeTypeExec
     */
    'command'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ProbeTypeGrpc
 */
export interface ProbeTypeGrpc {
    /**
     * 
     * @type {string}
     * @memberof ProbeTypeGrpc
     */
    'service'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ProbeTypeGrpc
     */
    'port'?: number;
}
/**
 * 
 * @export
 * @interface ProbeTypeHttp
 */
export interface ProbeTypeHttp {
    /**
     * 
     * @type {string}
     * @memberof ProbeTypeHttp
     */
    'path'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProbeTypeHttp
     */
    'scheme'?: string;
    /**
     * 
     * @type {number}
     * @memberof ProbeTypeHttp
     */
    'port'?: number;
}
/**
 * 
 * @export
 * @interface ProbeTypeTcp
 */
export interface ProbeTypeTcp {
    /**
     * 
     * @type {number}
     * @memberof ProbeTypeTcp
     */
    'port'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProbeTypeTcp
     */
    'host'?: string | null;
}
/**
 * 
 * @export
 * @interface Project
 */
export interface Project {
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'description'?: string;
    /**
     * 
     * @type {ReferenceObject}
     * @memberof Project
     */
    'organization'?: ReferenceObject;
}
/**
 * 
 * @export
 * @interface ProjectAllOf
 */
export interface ProjectAllOf {
    /**
     * 
     * @type {string}
     * @memberof ProjectAllOf
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectAllOf
     */
    'description'?: string;
    /**
     * 
     * @type {ReferenceObject}
     * @memberof ProjectAllOf
     */
    'organization'?: ReferenceObject;
}
/**
 * 
 * @export
 * @interface ProjectCurrentCost
 */
export interface ProjectCurrentCost {
    /**
     * 
     * @type {string}
     * @memberof ProjectCurrentCost
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectCurrentCost
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof ProjectCurrentCost
     */
    'consumed_time_in_seconds': number;
    /**
     * 
     * @type {Cost}
     * @memberof ProjectCurrentCost
     */
    'cost': Cost;
    /**
     * 
     * @type {Array<GenericObjectCurrentCost>}
     * @memberof ProjectCurrentCost
     */
    'environments'?: Array<GenericObjectCurrentCost>;
}
/**
 * 
 * @export
 * @interface ProjectCurrentCostAllOf
 */
export interface ProjectCurrentCostAllOf {
    /**
     * 
     * @type {Array<GenericObjectCurrentCost>}
     * @memberof ProjectCurrentCostAllOf
     */
    'environments'?: Array<GenericObjectCurrentCost>;
}
/**
 * 
 * @export
 * @interface ProjectCurrentCostResponseList
 */
export interface ProjectCurrentCostResponseList {
    /**
     * 
     * @type {Array<ProjectCurrentCost>}
     * @memberof ProjectCurrentCostResponseList
     */
    'projects'?: Array<ProjectCurrentCost>;
}
/**
 * 
 * @export
 * @interface ProjectDeploymentRule
 */
export interface ProjectDeploymentRule {
    /**
     * 
     * @type {string}
     * @memberof ProjectDeploymentRule
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectDeploymentRule
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectDeploymentRule
     */
    'updated_at'?: string;
    /**
     * name is case insensitive
     * @type {string}
     * @memberof ProjectDeploymentRule
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectDeploymentRule
     */
    'description'?: string | null;
    /**
     * 
     * @type {EnvironmentModeEnum}
     * @memberof ProjectDeploymentRule
     */
    'mode': EnvironmentModeEnum;
    /**
     * 
     * @type {string}
     * @memberof ProjectDeploymentRule
     */
    'cluster_id': string;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectDeploymentRule
     */
    'auto_deploy'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectDeploymentRule
     */
    'auto_stop'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ProjectDeploymentRule
     */
    'timezone': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectDeploymentRule
     */
    'start_time': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectDeploymentRule
     */
    'stop_time': string;
    /**
     * 
     * @type {Array<WeekdayEnum>}
     * @memberof ProjectDeploymentRule
     */
    'weekdays': Array<WeekdayEnum>;
    /**
     * wildcard pattern composed of \'?\' and/or \'*\' used to target new created environments
     * @type {string}
     * @memberof ProjectDeploymentRule
     */
    'wildcard': string;
    /**
     * used to select the first deployment rule to match new created environments
     * @type {number}
     * @memberof ProjectDeploymentRule
     */
    'priority_index'?: number;
}
/**
 * 
 * @export
 * @interface ProjectDeploymentRuleAllOf
 */
export interface ProjectDeploymentRuleAllOf {
    /**
     * used to select the first deployment rule to match new created environments
     * @type {number}
     * @memberof ProjectDeploymentRuleAllOf
     */
    'priority_index'?: number;
}
/**
 * 
 * @export
 * @interface ProjectDeploymentRuleRequest
 */
export interface ProjectDeploymentRuleRequest {
    /**
     * name is case insensitive
     * @type {string}
     * @memberof ProjectDeploymentRuleRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectDeploymentRuleRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {EnvironmentModeEnum}
     * @memberof ProjectDeploymentRuleRequest
     */
    'mode': EnvironmentModeEnum;
    /**
     * 
     * @type {string}
     * @memberof ProjectDeploymentRuleRequest
     */
    'cluster_id': string;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectDeploymentRuleRequest
     */
    'auto_deploy'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectDeploymentRuleRequest
     */
    'auto_stop'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ProjectDeploymentRuleRequest
     */
    'timezone': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectDeploymentRuleRequest
     */
    'start_time': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectDeploymentRuleRequest
     */
    'stop_time': string;
    /**
     * 
     * @type {Array<WeekdayEnum>}
     * @memberof ProjectDeploymentRuleRequest
     */
    'weekdays': Array<WeekdayEnum>;
    /**
     * wildcard pattern composed of \'?\' and/or \'*\' used to target new created environments
     * @type {string}
     * @memberof ProjectDeploymentRuleRequest
     */
    'wildcard': string;
}
/**
 * 
 * @export
 * @interface ProjectDeploymentRuleResponseList
 */
export interface ProjectDeploymentRuleResponseList {
    /**
     * 
     * @type {Array<ProjectDeploymentRule>}
     * @memberof ProjectDeploymentRuleResponseList
     */
    'results'?: Array<ProjectDeploymentRule>;
}
/**
 * 
 * @export
 * @interface ProjectDeploymentRulesPriorityOrderRequest
 */
export interface ProjectDeploymentRulesPriorityOrderRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof ProjectDeploymentRulesPriorityOrderRequest
     */
    'project_deployment_rule_ids_in_order'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ProjectRequest
 */
export interface ProjectRequest {
    /**
     * name is case insensitive
     * @type {string}
     * @memberof ProjectRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectRequest
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface ProjectResponseList
 */
export interface ProjectResponseList {
    /**
     * 
     * @type {Array<Project>}
     * @memberof ProjectResponseList
     */
    'results'?: Array<Project>;
}
/**
 * 
 * @export
 * @interface ProjectStats
 */
export interface ProjectStats {
    /**
     * 
     * @type {string}
     * @memberof ProjectStats
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof ProjectStats
     */
    'service_total_number'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProjectStats
     */
    'environment_total_number'?: number;
}
/**
 * 
 * @export
 * @interface ProjectStatsResponseList
 */
export interface ProjectStatsResponseList {
    /**
     * 
     * @type {Array<ProjectStats>}
     * @memberof ProjectStatsResponseList
     */
    'results'?: Array<ProjectStats>;
}
/**
 * 
 * @export
 * @interface RebootServicesRequest
 */
export interface RebootServicesRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof RebootServicesRequest
     */
    'applicationIds'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof RebootServicesRequest
     */
    'databaseIds'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof RebootServicesRequest
     */
    'containerIds'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ReferenceObject
 */
export interface ReferenceObject {
    /**
     * 
     * @type {string}
     * @memberof ReferenceObject
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface ReferenceObjectStatus
 */
export interface ReferenceObjectStatus {
    /**
     * 
     * @type {string}
     * @memberof ReferenceObjectStatus
     */
    'id': string;
    /**
     * 
     * @type {StateEnum}
     * @memberof ReferenceObjectStatus
     */
    'state': StateEnum;
    /**
     * 
     * @type {ServiceDeploymentStatusEnum}
     * @memberof ReferenceObjectStatus
     */
    'service_deployment_status': ServiceDeploymentStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ReferenceObjectStatus
     */
    'last_deployment_date'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ReferenceObjectStatus
     */
    'is_part_last_deployment'?: boolean;
}
/**
 * 
 * @export
 * @interface ReferenceObjectStatusResponseList
 */
export interface ReferenceObjectStatusResponseList {
    /**
     * 
     * @type {Array<ReferenceObjectStatus>}
     * @memberof ReferenceObjectStatusResponseList
     */
    'results'?: Array<ReferenceObjectStatus>;
}
/**
 * 
 * @export
 * @interface Referral
 */
export interface Referral {
    /**
     * 
     * @type {number}
     * @memberof Referral
     */
    'total_invited'?: number;
    /**
     * 
     * @type {string}
     * @memberof Referral
     */
    'invitation_link'?: string;
}
/**
 * 
 * @export
 * @interface RemainingCredits
 */
export interface RemainingCredits {
    /**
     * 
     * @type {number}
     * @memberof RemainingCredits
     */
    'total_in_cents': number;
    /**
     * 
     * @type {number}
     * @memberof RemainingCredits
     */
    'total': number;
    /**
     * 
     * @type {string}
     * @memberof RemainingCredits
     */
    'currency_code': string;
}
/**
 * 
 * @export
 * @interface RewardClaim
 */
export interface RewardClaim {
    /**
     * 
     * @type {string}
     * @memberof RewardClaim
     */
    'type'?: RewardClaimTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof RewardClaim
     */
    'code'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum RewardClaimTypeEnum {
    INVITATION = 'INVITATION'
}

/**
 * 
 * @export
 * @interface ScalewayCredentialsRequest
 */
export interface ScalewayCredentialsRequest {
    /**
     * 
     * @type {string}
     * @memberof ScalewayCredentialsRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ScalewayCredentialsRequest
     */
    'scaleway_access_key'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScalewayCredentialsRequest
     */
    'scaleway_secret_key'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScalewayCredentialsRequest
     */
    'scaleway_project_id'?: string;
}
/**
 * 
 * @export
 * @interface Secret
 */
export interface Secret {
    /**
     * 
     * @type {string}
     * @memberof Secret
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Secret
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Secret
     */
    'updated_at'?: string;
    /**
     * key is case sensitive
     * @type {string}
     * @memberof Secret
     */
    'key': string;
    /**
     * 
     * @type {SecretOverride}
     * @memberof Secret
     */
    'overridden_secret'?: SecretOverride;
    /**
     * 
     * @type {SecretAlias}
     * @memberof Secret
     */
    'aliased_secret'?: SecretAlias;
    /**
     * 
     * @type {APIVariableScopeEnum}
     * @memberof Secret
     */
    'scope': APIVariableScopeEnum;
    /**
     * 
     * @type {APIVariableTypeEnum}
     * @memberof Secret
     */
    'variable_type'?: APIVariableTypeEnum;
    /**
     * present only for `BUILT_IN` variable
     * @type {string}
     * @memberof Secret
     */
    'service_id'?: string;
    /**
     * present only for `BUILT_IN` variable
     * @type {string}
     * @memberof Secret
     */
    'service_name'?: string;
    /**
     * 
     * @type {LinkedServiceTypeEnum}
     * @memberof Secret
     */
    'service_type'?: LinkedServiceTypeEnum;
    /**
     * Entity that created/own the variable (i.e: Qovery, Doppler)
     * @type {string}
     * @memberof Secret
     */
    'owned_by'?: string;
}
/**
 * 
 * @export
 * @interface SecretAlias
 */
export interface SecretAlias {
    /**
     * 
     * @type {string}
     * @memberof SecretAlias
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SecretAlias
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof SecretAlias
     */
    'mount_path': string;
    /**
     * 
     * @type {APIVariableScopeEnum}
     * @memberof SecretAlias
     */
    'scope': APIVariableScopeEnum;
    /**
     * 
     * @type {APIVariableTypeEnum}
     * @memberof SecretAlias
     */
    'variable_type': APIVariableTypeEnum;
}
/**
 * 
 * @export
 * @interface SecretAllOf
 */
export interface SecretAllOf {
    /**
     * key is case sensitive
     * @type {string}
     * @memberof SecretAllOf
     */
    'key': string;
    /**
     * 
     * @type {SecretOverride}
     * @memberof SecretAllOf
     */
    'overridden_secret'?: SecretOverride;
    /**
     * 
     * @type {SecretAlias}
     * @memberof SecretAllOf
     */
    'aliased_secret'?: SecretAlias;
    /**
     * 
     * @type {APIVariableScopeEnum}
     * @memberof SecretAllOf
     */
    'scope': APIVariableScopeEnum;
    /**
     * 
     * @type {APIVariableTypeEnum}
     * @memberof SecretAllOf
     */
    'variable_type'?: APIVariableTypeEnum;
    /**
     * present only for `BUILT_IN` variable
     * @type {string}
     * @memberof SecretAllOf
     */
    'service_id'?: string;
    /**
     * present only for `BUILT_IN` variable
     * @type {string}
     * @memberof SecretAllOf
     */
    'service_name'?: string;
    /**
     * 
     * @type {LinkedServiceTypeEnum}
     * @memberof SecretAllOf
     */
    'service_type'?: LinkedServiceTypeEnum;
    /**
     * Entity that created/own the variable (i.e: Qovery, Doppler)
     * @type {string}
     * @memberof SecretAllOf
     */
    'owned_by'?: string;
}
/**
 * 
 * @export
 * @interface SecretEditRequest
 */
export interface SecretEditRequest {
    /**
     * 
     * @type {string}
     * @memberof SecretEditRequest
     */
    'value'?: string;
    /**
     * 
     * @type {string}
     * @memberof SecretEditRequest
     */
    'key': string;
}
/**
 * 
 * @export
 * @interface SecretOverride
 */
export interface SecretOverride {
    /**
     * 
     * @type {string}
     * @memberof SecretOverride
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SecretOverride
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof SecretOverride
     */
    'mount_path': string;
    /**
     * 
     * @type {APIVariableScopeEnum}
     * @memberof SecretOverride
     */
    'scope': APIVariableScopeEnum;
    /**
     * 
     * @type {APIVariableTypeEnum}
     * @memberof SecretOverride
     */
    'variable_type': APIVariableTypeEnum;
}
/**
 * 
 * @export
 * @interface SecretRequest
 */
export interface SecretRequest {
    /**
     * key is case sensitive
     * @type {string}
     * @memberof SecretRequest
     */
    'key': string;
    /**
     * value of the secret. Clear value will never be returned
     * @type {string}
     * @memberof SecretRequest
     */
    'value'?: string;
    /**
     * should be set for file only. variable mount path make secret a file (where file should be mounted).
     * @type {string}
     * @memberof SecretRequest
     */
    'mount_path'?: string | null;
}
/**
 * 
 * @export
 * @interface SecretResponseList
 */
export interface SecretResponseList {
    /**
     * 
     * @type {Array<Secret>}
     * @memberof SecretResponseList
     */
    'results'?: Array<Secret>;
}
/**
 * 
 * @export
 * @interface Service
 */
export interface Service {
    /**
     * uuid of the associated service (application, database, job, gateway...)
     * @type {string}
     * @memberof Service
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Service
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Service
     */
    'updated_at'?: string;
    /**
     * 
     * @type {ServiceTypeEnum}
     * @memberof Service
     */
    'type'?: ServiceTypeEnum;
    /**
     * name of the service
     * @type {string}
     * @memberof Service
     */
    'name'?: string;
    /**
     * Git commit ID corresponding to the deployed version of the application
     * @type {string}
     * @memberof Service
     */
    'deployed_commit_id'?: string;
    /**
     * uuid of the user that made the last update
     * @type {string}
     * @memberof Service
     */
    'last_updated_by'?: string;
    /**
     * global overview of resources consumption of the service
     * @type {number}
     * @memberof Service
     */
    'consumed_resources_in_percent'?: number;
    /**
     * describes the typology of service (container, postgresl, redis...)
     * @type {string}
     * @memberof Service
     */
    'service_typology'?: string;
    /**
     * for databases this field exposes the database version
     * @type {string}
     * @memberof Service
     */
    'service_version'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Service
     */
    'to_update'?: boolean;
}
/**
 * 
 * @export
 * @interface ServiceAllOf
 */
export interface ServiceAllOf {
    /**
     * 
     * @type {ServiceTypeEnum}
     * @memberof ServiceAllOf
     */
    'type'?: ServiceTypeEnum;
    /**
     * name of the service
     * @type {string}
     * @memberof ServiceAllOf
     */
    'name'?: string;
    /**
     * uuid of the associated service (application, database, job, gateway...)
     * @type {string}
     * @memberof ServiceAllOf
     */
    'id': string;
    /**
     * Git commit ID corresponding to the deployed version of the application
     * @type {string}
     * @memberof ServiceAllOf
     */
    'deployed_commit_id'?: string;
    /**
     * uuid of the user that made the last update
     * @type {string}
     * @memberof ServiceAllOf
     */
    'last_updated_by'?: string;
    /**
     * global overview of resources consumption of the service
     * @type {number}
     * @memberof ServiceAllOf
     */
    'consumed_resources_in_percent'?: number;
    /**
     * describes the typology of service (container, postgresl, redis...)
     * @type {string}
     * @memberof ServiceAllOf
     */
    'service_typology'?: string;
    /**
     * for databases this field exposes the database version
     * @type {string}
     * @memberof ServiceAllOf
     */
    'service_version'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceAllOf
     */
    'to_update'?: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum ServiceDeploymentStatusEnum {
    NEVER_DEPLOYED = 'NEVER_DEPLOYED',
    OUT_OF_DATE = 'OUT_OF_DATE',
    UP_TO_DATE = 'UP_TO_DATE'
}

/**
 * 
 * @export
 * @interface ServicePort
 */
export interface ServicePort {
    /**
     * 
     * @type {string}
     * @memberof ServicePort
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ServicePort
     */
    'name'?: string;
    /**
     * The listening port of your service.
     * @type {number}
     * @memberof ServicePort
     */
    'internal_port': number;
    /**
     * The exposed port for your service. This is optional. If not set a default port will be used.
     * @type {number}
     * @memberof ServicePort
     */
    'external_port'?: number;
    /**
     * Expose the port to the world
     * @type {boolean}
     * @memberof ServicePort
     */
    'publicly_accessible': boolean;
    /**
     * is the default port to use for domain
     * @type {boolean}
     * @memberof ServicePort
     */
    'is_default'?: boolean;
    /**
     * 
     * @type {PortProtocolEnum}
     * @memberof ServicePort
     */
    'protocol': PortProtocolEnum;
}
/**
 * 
 * @export
 * @interface ServicePortRequest
 */
export interface ServicePortRequest {
    /**
     * 
     * @type {Array<ServicePortRequestPorts>}
     * @memberof ServicePortRequest
     */
    'ports'?: Array<ServicePortRequestPorts>;
}
/**
 * 
 * @export
 * @interface ServicePortRequestPorts
 */
export interface ServicePortRequestPorts {
    /**
     * 
     * @type {string}
     * @memberof ServicePortRequestPorts
     */
    'name'?: string;
    /**
     * The listening port of your service.
     * @type {number}
     * @memberof ServicePortRequestPorts
     */
    'internal_port': number;
    /**
     * The exposed port for your service. This is optional. If not set a default port will be used.
     * @type {number}
     * @memberof ServicePortRequestPorts
     */
    'external_port'?: number;
    /**
     * Expose the port to the world
     * @type {boolean}
     * @memberof ServicePortRequestPorts
     */
    'publicly_accessible': boolean;
    /**
     * is the default port to use for domain
     * @type {boolean}
     * @memberof ServicePortRequestPorts
     */
    'is_default'?: boolean;
    /**
     * 
     * @type {PortProtocolEnum}
     * @memberof ServicePortRequestPorts
     */
    'protocol'?: PortProtocolEnum;
}
/**
 * 
 * @export
 * @interface ServiceResponseList
 */
export interface ServiceResponseList {
    /**
     * 
     * @type {Array<Service>}
     * @memberof ServiceResponseList
     */
    'results'?: Array<Service>;
}
/**
 * 
 * @export
 * @interface ServiceStorage
 */
export interface ServiceStorage {
    /**
     * 
     * @type {Array<ServiceStorageStorage>}
     * @memberof ServiceStorage
     */
    'storage'?: Array<ServiceStorageStorage>;
}
/**
 * 
 * @export
 * @interface ServiceStorageRequest
 */
export interface ServiceStorageRequest {
    /**
     * 
     * @type {Array<ServiceStorageRequestStorage>}
     * @memberof ServiceStorageRequest
     */
    'storage'?: Array<ServiceStorageRequestStorage>;
}
/**
 * 
 * @export
 * @interface ServiceStorageRequestStorage
 */
export interface ServiceStorageRequestStorage {
    /**
     * 
     * @type {string}
     * @memberof ServiceStorageRequestStorage
     */
    'id'?: string;
    /**
     * 
     * @type {StorageTypeEnum}
     * @memberof ServiceStorageRequestStorage
     */
    'type': StorageTypeEnum;
    /**
     * unit is GB Minimum size is 4 GB 
     * @type {number}
     * @memberof ServiceStorageRequestStorage
     */
    'size': number;
    /**
     * 
     * @type {string}
     * @memberof ServiceStorageRequestStorage
     */
    'mount_point': string;
}
/**
 * 
 * @export
 * @interface ServiceStorageStorage
 */
export interface ServiceStorageStorage {
    /**
     * 
     * @type {string}
     * @memberof ServiceStorageStorage
     */
    'id': string;
    /**
     * 
     * @type {StorageTypeEnum}
     * @memberof ServiceStorageStorage
     */
    'type': StorageTypeEnum;
    /**
     * unit is GB
     * @type {number}
     * @memberof ServiceStorageStorage
     */
    'size': number;
    /**
     * 
     * @type {string}
     * @memberof ServiceStorageStorage
     */
    'mount_point': string;
}
/**
 * 
 * @export
 * @interface ServiceTotalNumber
 */
export interface ServiceTotalNumber {
    /**
     * 
     * @type {number}
     * @memberof ServiceTotalNumber
     */
    'service_total_number'?: number;
}
/**
 * type of the service (application, database, job, gateway...)
 * @export
 * @enum {string}
 */

export enum ServiceTypeEnum {
    APPLICATION = 'APPLICATION',
    DATABASE = 'DATABASE'
}

/**
 * 
 * @export
 * @interface SignUp
 */
export interface SignUp {
    /**
     * 
     * @type {string}
     * @memberof SignUp
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SignUp
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof SignUp
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignUp
     */
    'first_name': string;
    /**
     * 
     * @type {string}
     * @memberof SignUp
     */
    'last_name': string;
    /**
     * 
     * @type {string}
     * @memberof SignUp
     */
    'user_email': string;
    /**
     * 
     * @type {TypeOfUseEnum}
     * @memberof SignUp
     */
    'type_of_use': TypeOfUseEnum;
    /**
     * 
     * @type {string}
     * @memberof SignUp
     */
    'qovery_usage': string;
    /**
     * 
     * @type {string}
     * @memberof SignUp
     */
    'company_name'?: string | null;
    /**
     * 
     * @type {CompanySizeEnum}
     * @memberof SignUp
     */
    'company_size'?: CompanySizeEnum;
    /**
     * 
     * @type {string}
     * @memberof SignUp
     */
    'user_role'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SignUp
     */
    'qovery_usage_other'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SignUp
     */
    'user_questions'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SignUp
     */
    'current_step'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof SignUp
     */
    'dx_auth'?: boolean | null;
}
/**
 * 
 * @export
 * @interface SignUpRequest
 */
export interface SignUpRequest {
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    'first_name': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    'last_name': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    'user_email': string;
    /**
     * 
     * @type {TypeOfUseEnum}
     * @memberof SignUpRequest
     */
    'type_of_use': TypeOfUseEnum;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    'qovery_usage': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    'company_name'?: string | null;
    /**
     * 
     * @type {CompanySizeEnum}
     * @memberof SignUpRequest
     */
    'company_size'?: CompanySizeEnum;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    'user_role'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    'qovery_usage_other'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    'user_questions'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    'current_step'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof SignUpRequest
     */
    'dx_auth'?: boolean | null;
}
/**
 * 
 * @export
 * @interface Stage
 */
export interface Stage {
    /**
     * 
     * @type {string}
     * @memberof Stage
     */
    'id': string;
    /**
     * stage name
     * @type {string}
     * @memberof Stage
     */
    'name': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum StateEnum {
    BUILDING = 'BUILDING',
    BUILD_ERROR = 'BUILD_ERROR',
    CANCELED = 'CANCELED',
    CANCELING = 'CANCELING',
    DELETED = 'DELETED',
    DELETE_ERROR = 'DELETE_ERROR',
    DELETE_QUEUED = 'DELETE_QUEUED',
    DELETING = 'DELETING',
    DEPLOYED = 'DEPLOYED',
    DEPLOYING = 'DEPLOYING',
    DEPLOYMENT_ERROR = 'DEPLOYMENT_ERROR',
    DEPLOYMENT_QUEUED = 'DEPLOYMENT_QUEUED',
    QUEUED = 'QUEUED',
    READY = 'READY',
    STOPPED = 'STOPPED',
    STOPPING = 'STOPPING',
    STOP_ERROR = 'STOP_ERROR',
    STOP_QUEUED = 'STOP_QUEUED',
    RESTART_QUEUED = 'RESTART_QUEUED',
    RESTARTING = 'RESTARTING',
    RESTARTED = 'RESTARTED',
    RESTART_ERROR = 'RESTART_ERROR'
}

/**
 * 
 * @export
 * @interface Status
 */
export interface Status {
    /**
     * 
     * @type {string}
     * @memberof Status
     */
    'id': string;
    /**
     * 
     * @type {StateEnum}
     * @memberof Status
     */
    'state': StateEnum;
    /**
     * 
     * @type {ServiceDeploymentStatusEnum}
     * @memberof Status
     */
    'service_deployment_status': ServiceDeploymentStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Status
     */
    'last_deployment_date'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Status
     */
    'is_part_last_deployment'?: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum StatusKindEnum {
    CANCELED = 'CANCELED',
    CANCELING = 'CANCELING',
    DELETED = 'DELETED',
    DELETE_ERROR = 'DELETE_ERROR',
    DELETE_IN_PROGRESS = 'DELETE_IN_PROGRESS',
    DEPLOYED = 'DEPLOYED',
    DEPLOYMENT_ERROR = 'DEPLOYMENT_ERROR',
    DEPLOYMENT_IN_PROGRESS = 'DEPLOYMENT_IN_PROGRESS',
    ERROR = 'ERROR',
    PAUSED = 'PAUSED',
    PAUSE_ERROR = 'PAUSE_ERROR',
    PAUSE_IN_PROGRESS = 'PAUSE_IN_PROGRESS',
    WAITING = 'WAITING'
}

/**
 * 
 * @export
 * @interface StorageDisk
 */
export interface StorageDisk {
    /**
     * 
     * @type {string}
     * @memberof StorageDisk
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof StorageDisk
     */
    'storage_id'?: string;
    /**
     * Unit is in GB.
     * @type {number}
     * @memberof StorageDisk
     */
    'requested_in_gb'?: number;
    /**
     * Unit is in GB.
     * @type {number}
     * @memberof StorageDisk
     */
    'consumed_in_gb'?: number;
    /**
     * 
     * @type {number}
     * @memberof StorageDisk
     */
    'consumed_in_percent'?: number;
    /**
     * 
     * @type {number}
     * @memberof StorageDisk
     */
    'warning_threshold_in_percent'?: number;
    /**
     * 
     * @type {number}
     * @memberof StorageDisk
     */
    'alert_threshold_in_percent'?: number;
    /**
     * 
     * @type {ThresholdMetricStatusEnum}
     * @memberof StorageDisk
     */
    'status'?: ThresholdMetricStatusEnum;
}
/**
 * 
 * @export
 * @interface StorageDiskResponseList
 */
export interface StorageDiskResponseList {
    /**
     * 
     * @type {Array<StorageDisk>}
     * @memberof StorageDiskResponseList
     */
    'results'?: Array<StorageDisk>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum StorageTypeEnum {
    FAST_SSD = 'FAST_SSD'
}

/**
 * 
 * @export
 * @interface Tag
 */
export interface Tag {
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface TagRequest
 */
export interface TagRequest {
    /**
     * 
     * @type {string}
     * @memberof TagRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface TagResponseList
 */
export interface TagResponseList {
    /**
     * 
     * @type {Array<Tag>}
     * @memberof TagResponseList
     */
    'results'?: Array<Tag>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum ThresholdMetricStatusEnum {
    ALERT = 'Alert',
    OK = 'OK',
    WARNING = 'Warning'
}

/**
 * 
 * @export
 * @interface TransferOwnershipRequest
 */
export interface TransferOwnershipRequest {
    /**
     * 
     * @type {string}
     * @memberof TransferOwnershipRequest
     */
    'user_id': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum TypeOfUseEnum {
    PERSONAL = 'PERSONAL',
    SCHOOL = 'SCHOOL',
    WORK = 'WORK'
}

/**
 * 
 * @export
 * @interface UnexpectedError
 */
export interface UnexpectedError {
    /**
     * 
     * @type {string}
     * @memberof UnexpectedError
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'profile_picture_url'?: string;
}
/**
 * 
 * @export
 * @interface UserResponseList
 */
export interface UserResponseList {
    /**
     * 
     * @type {Array<User>}
     * @memberof UserResponseList
     */
    'results'?: Array<User>;
}
/**
 * 
 * @export
 * @interface Value
 */
export interface Value {
    /**
     * 
     * @type {string}
     * @memberof Value
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface VariableAlias
 */
export interface VariableAlias {
    /**
     * 
     * @type {string}
     * @memberof VariableAlias
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof VariableAlias
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof VariableAlias
     */
    'value'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VariableAlias
     */
    'mount_path': string;
    /**
     * 
     * @type {APIVariableScopeEnum}
     * @memberof VariableAlias
     */
    'scope': APIVariableScopeEnum;
    /**
     * 
     * @type {APIVariableTypeEnum}
     * @memberof VariableAlias
     */
    'variable_type': APIVariableTypeEnum;
}
/**
 * 
 * @export
 * @interface VariableAliasRequest
 */
export interface VariableAliasRequest {
    /**
     * 
     * @type {string}
     * @memberof VariableAliasRequest
     */
    'key': string;
    /**
     * 
     * @type {APIVariableScopeEnum}
     * @memberof VariableAliasRequest
     */
    'alias_scope': APIVariableScopeEnum;
    /**
     * 
     * @type {string}
     * @memberof VariableAliasRequest
     */
    'alias_parent_id': string;
}
/**
 * 
 * @export
 * @interface VariableEditRequest
 */
export interface VariableEditRequest {
    /**
     * 
     * @type {string}
     * @memberof VariableEditRequest
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof VariableEditRequest
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface VariableImport
 */
export interface VariableImport {
    /**
     * 
     * @type {number}
     * @memberof VariableImport
     */
    'total_variables_to_import': number;
    /**
     * 
     * @type {Array<VariableImportSuccessfulImportedVariables>}
     * @memberof VariableImport
     */
    'successful_imported_variables': Array<VariableImportSuccessfulImportedVariables>;
}
/**
 * 
 * @export
 * @interface VariableImportRequest
 */
export interface VariableImportRequest {
    /**
     * 
     * @type {boolean}
     * @memberof VariableImportRequest
     */
    'overwrite': boolean;
    /**
     * 
     * @type {Array<VariableImportRequestVars>}
     * @memberof VariableImportRequest
     */
    'vars': Array<VariableImportRequestVars>;
}
/**
 * 
 * @export
 * @interface VariableImportRequestVars
 */
export interface VariableImportRequestVars {
    /**
     * 
     * @type {string}
     * @memberof VariableImportRequestVars
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof VariableImportRequestVars
     */
    'value': string;
    /**
     * 
     * @type {APIVariableScopeEnum}
     * @memberof VariableImportRequestVars
     */
    'scope': APIVariableScopeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof VariableImportRequestVars
     */
    'is_secret': boolean;
}
/**
 * 
 * @export
 * @interface VariableImportSuccessfulImportedVariables
 */
export interface VariableImportSuccessfulImportedVariables {
    /**
     * 
     * @type {string}
     * @memberof VariableImportSuccessfulImportedVariables
     */
    'name': string;
    /**
     * Optional if the variable is secret
     * @type {string}
     * @memberof VariableImportSuccessfulImportedVariables
     */
    'value'?: string;
    /**
     * 
     * @type {APIVariableScopeEnum}
     * @memberof VariableImportSuccessfulImportedVariables
     */
    'scope': APIVariableScopeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof VariableImportSuccessfulImportedVariables
     */
    'is_secret': boolean;
}
/**
 * 
 * @export
 * @interface VariableOverride
 */
export interface VariableOverride {
    /**
     * 
     * @type {string}
     * @memberof VariableOverride
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof VariableOverride
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof VariableOverride
     */
    'value'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VariableOverride
     */
    'mount_path': string;
    /**
     * 
     * @type {APIVariableScopeEnum}
     * @memberof VariableOverride
     */
    'scope': APIVariableScopeEnum;
    /**
     * 
     * @type {APIVariableTypeEnum}
     * @memberof VariableOverride
     */
    'variable_type': APIVariableTypeEnum;
}
/**
 * 
 * @export
 * @interface VariableOverrideRequest
 */
export interface VariableOverrideRequest {
    /**
     * 
     * @type {string}
     * @memberof VariableOverrideRequest
     */
    'value': string;
    /**
     * 
     * @type {APIVariableScopeEnum}
     * @memberof VariableOverrideRequest
     */
    'alias_scope': APIVariableScopeEnum;
    /**
     * 
     * @type {string}
     * @memberof VariableOverrideRequest
     */
    'alias_parent_id': string;
}
/**
 * 
 * @export
 * @interface VariableRequest
 */
export interface VariableRequest {
    /**
     * 
     * @type {string}
     * @memberof VariableRequest
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof VariableRequest
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof VariableRequest
     */
    'mount_path'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof VariableRequest
     */
    'is_secret': boolean;
    /**
     * 
     * @type {APIVariableScopeEnum}
     * @memberof VariableRequest
     */
    'variable_scope': APIVariableScopeEnum;
    /**
     * 
     * @type {string}
     * @memberof VariableRequest
     */
    'variable_parent_id': string;
}
/**
 * 
 * @export
 * @interface VariableResponse
 */
export interface VariableResponse {
    /**
     * 
     * @type {string}
     * @memberof VariableResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof VariableResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof VariableResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {VariableOverride}
     * @memberof VariableResponse
     */
    'overridden_variable'?: VariableOverride;
    /**
     * 
     * @type {VariableAlias}
     * @memberof VariableResponse
     */
    'aliased_variable'?: VariableAlias;
    /**
     * 
     * @type {APIVariableScopeEnum}
     * @memberof VariableResponse
     */
    'scope': APIVariableScopeEnum;
    /**
     * 
     * @type {APIVariableTypeEnum}
     * @memberof VariableResponse
     */
    'variable_type'?: APIVariableTypeEnum;
    /**
     * present only for `BUILT_IN` variable
     * @type {string}
     * @memberof VariableResponse
     */
    'service_id'?: string;
    /**
     * present only for `BUILT_IN` variable
     * @type {string}
     * @memberof VariableResponse
     */
    'service_name'?: string;
    /**
     * 
     * @type {LinkedServiceTypeEnum}
     * @memberof VariableResponse
     */
    'service_type'?: LinkedServiceTypeEnum;
    /**
     * Entity that created/own the variable (i.e: Qovery, Doppler)
     * @type {string}
     * @memberof VariableResponse
     */
    'owned_by'?: string;
}
/**
 * 
 * @export
 * @interface VariableResponseAllOf
 */
export interface VariableResponseAllOf {
    /**
     * 
     * @type {VariableOverride}
     * @memberof VariableResponseAllOf
     */
    'overridden_variable'?: VariableOverride;
    /**
     * 
     * @type {VariableAlias}
     * @memberof VariableResponseAllOf
     */
    'aliased_variable'?: VariableAlias;
    /**
     * 
     * @type {APIVariableScopeEnum}
     * @memberof VariableResponseAllOf
     */
    'scope': APIVariableScopeEnum;
    /**
     * 
     * @type {APIVariableTypeEnum}
     * @memberof VariableResponseAllOf
     */
    'variable_type'?: APIVariableTypeEnum;
    /**
     * present only for `BUILT_IN` variable
     * @type {string}
     * @memberof VariableResponseAllOf
     */
    'service_id'?: string;
    /**
     * present only for `BUILT_IN` variable
     * @type {string}
     * @memberof VariableResponseAllOf
     */
    'service_name'?: string;
    /**
     * 
     * @type {LinkedServiceTypeEnum}
     * @memberof VariableResponseAllOf
     */
    'service_type'?: LinkedServiceTypeEnum;
    /**
     * Entity that created/own the variable (i.e: Qovery, Doppler)
     * @type {string}
     * @memberof VariableResponseAllOf
     */
    'owned_by'?: string;
}
/**
 * 
 * @export
 * @interface VariableResponseList
 */
export interface VariableResponseList {
    /**
     * 
     * @type {Array<VariableResponse>}
     * @memberof VariableResponseList
     */
    'results'?: Array<VariableResponse>;
}
/**
 * 
 * @export
 * @interface Version
 */
export interface Version {
    /**
     * 
     * @type {string}
     * @memberof Version
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface VersionResponseList
 */
export interface VersionResponseList {
    /**
     * 
     * @type {Array<Version>}
     * @memberof VersionResponseList
     */
    'results'?: Array<Version>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum WeekdayEnum {
    MONDAY = 'MONDAY',
    TUESDAY = 'TUESDAY',
    WEDNESDAY = 'WEDNESDAY',
    THURSDAY = 'THURSDAY',
    FRIDAY = 'FRIDAY',
    SATURDAY = 'SATURDAY',
    SUNDAY = 'SUNDAY'
}


/**
 * AccountInfoApi - axios parameter creator
 * @export
 */
export const AccountInfoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Account information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountInformation: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountInfoApi - functional programming interface
 * @export
 */
export const AccountInfoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountInfoApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Account information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountInformation(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountInformation(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountInfoApi - factory interface
 * @export
 */
export const AccountInfoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountInfoApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Account information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountInformation(options?: any): AxiosPromise<AccountInfo> {
            return localVarFp.getAccountInformation(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountInfoApi - object-oriented interface
 * @export
 * @class AccountInfoApi
 * @extends {BaseAPI}
 */
export class AccountInfoApi extends BaseAPI {
    /**
     * 
     * @summary Get Account information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountInfoApi
     */
    public getAccountInformation(options?: AxiosRequestConfig) {
        return AccountInfoApiFp(this.configuration).getAccountInformation(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ApplicationActionsApi - axios parameter creator
 * @export
 */
export const ApplicationActionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * You must provide a git commit id
         * @summary Deploy application
         * @param {string} applicationId Application ID
         * @param {DeployRequest} [deployRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployApplication: async (applicationId: string, deployRequest?: DeployRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('deployApplication', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/deploy`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deployRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reboot application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rebootApplication: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('rebootApplication', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/restart-service`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Redeploy application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeployApplication: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('redeployApplication', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/redeploy`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Deprecated** - Please use the \"Redeploy application\" endpoint now
         * @summary Deprecated - Restart application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartApplication: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('restartApplication', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/restart`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopApplication: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('stopApplication', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/stop`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationActionsApi - functional programming interface
 * @export
 */
export const ApplicationActionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationActionsApiAxiosParamCreator(configuration)
    return {
        /**
         * You must provide a git commit id
         * @summary Deploy application
         * @param {string} applicationId Application ID
         * @param {DeployRequest} [deployRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployApplication(applicationId: string, deployRequest?: DeployRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployApplication(applicationId, deployRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Reboot application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rebootApplication(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rebootApplication(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Redeploy application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async redeployApplication(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.redeployApplication(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **Deprecated** - Please use the \"Redeploy application\" endpoint now
         * @summary Deprecated - Restart application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restartApplication(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restartApplication(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Stop application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopApplication(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopApplication(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApplicationActionsApi - factory interface
 * @export
 */
export const ApplicationActionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationActionsApiFp(configuration)
    return {
        /**
         * You must provide a git commit id
         * @summary Deploy application
         * @param {string} applicationId Application ID
         * @param {DeployRequest} [deployRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployApplication(applicationId: string, deployRequest?: DeployRequest, options?: any): AxiosPromise<Status> {
            return localVarFp.deployApplication(applicationId, deployRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reboot application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rebootApplication(applicationId: string, options?: any): AxiosPromise<Status> {
            return localVarFp.rebootApplication(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Redeploy application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeployApplication(applicationId: string, options?: any): AxiosPromise<Status> {
            return localVarFp.redeployApplication(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * **Deprecated** - Please use the \"Redeploy application\" endpoint now
         * @summary Deprecated - Restart application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartApplication(applicationId: string, options?: any): AxiosPromise<Status> {
            return localVarFp.restartApplication(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Stop application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopApplication(applicationId: string, options?: any): AxiosPromise<Status> {
            return localVarFp.stopApplication(applicationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationActionsApi - object-oriented interface
 * @export
 * @class ApplicationActionsApi
 * @extends {BaseAPI}
 */
export class ApplicationActionsApi extends BaseAPI {
    /**
     * You must provide a git commit id
     * @summary Deploy application
     * @param {string} applicationId Application ID
     * @param {DeployRequest} [deployRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationActionsApi
     */
    public deployApplication(applicationId: string, deployRequest?: DeployRequest, options?: AxiosRequestConfig) {
        return ApplicationActionsApiFp(this.configuration).deployApplication(applicationId, deployRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reboot application
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationActionsApi
     */
    public rebootApplication(applicationId: string, options?: AxiosRequestConfig) {
        return ApplicationActionsApiFp(this.configuration).rebootApplication(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Redeploy application
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationActionsApi
     */
    public redeployApplication(applicationId: string, options?: AxiosRequestConfig) {
        return ApplicationActionsApiFp(this.configuration).redeployApplication(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Deprecated** - Please use the \"Redeploy application\" endpoint now
     * @summary Deprecated - Restart application
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationActionsApi
     */
    public restartApplication(applicationId: string, options?: AxiosRequestConfig) {
        return ApplicationActionsApiFp(this.configuration).restartApplication(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Stop application
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationActionsApi
     */
    public stopApplication(applicationId: string, options?: AxiosRequestConfig) {
        return ApplicationActionsApiFp(this.configuration).stopApplication(applicationId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ApplicationConfigurationApi - axios parameter creator
 * @export
 */
export const ApplicationConfigurationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Edit advanced settings by returning table of advanced settings.
         * @summary Edit advanced settings
         * @param {string} applicationId Application ID
         * @param {ApplicationAdvancedSettings} [applicationAdvancedSettings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editAdvancedSettings: async (applicationId: string, applicationAdvancedSettings?: ApplicationAdvancedSettings, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('editAdvancedSettings', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/advancedSettings`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(applicationAdvancedSettings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit the Network settings of the application.
         * @summary Edit Application Network
         * @param {string} applicationId Application ID
         * @param {ApplicationNetworkRequest} [applicationNetworkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editApplicationNetwork: async (applicationId: string, applicationNetworkRequest?: ApplicationNetworkRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('editApplicationNetwork', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/network`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(applicationNetworkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list and values of the advanced settings of the application.
         * @summary Get advanced settings
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdvancedSettings: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getAdvancedSettings', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/advancedSettings`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get status of the application network settings.
         * @summary Get Application Network information
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationNetwork: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getApplicationNetwork', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/network`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationConfigurationApi - functional programming interface
 * @export
 */
export const ApplicationConfigurationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationConfigurationApiAxiosParamCreator(configuration)
    return {
        /**
         * Edit advanced settings by returning table of advanced settings.
         * @summary Edit advanced settings
         * @param {string} applicationId Application ID
         * @param {ApplicationAdvancedSettings} [applicationAdvancedSettings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editAdvancedSettings(applicationId: string, applicationAdvancedSettings?: ApplicationAdvancedSettings, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationAdvancedSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editAdvancedSettings(applicationId, applicationAdvancedSettings, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Edit the Network settings of the application.
         * @summary Edit Application Network
         * @param {string} applicationId Application ID
         * @param {ApplicationNetworkRequest} [applicationNetworkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editApplicationNetwork(applicationId: string, applicationNetworkRequest?: ApplicationNetworkRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationNetwork>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editApplicationNetwork(applicationId, applicationNetworkRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get list and values of the advanced settings of the application.
         * @summary Get advanced settings
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAdvancedSettings(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationAdvancedSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAdvancedSettings(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get status of the application network settings.
         * @summary Get Application Network information
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationNetwork(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationNetwork>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationNetwork(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApplicationConfigurationApi - factory interface
 * @export
 */
export const ApplicationConfigurationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationConfigurationApiFp(configuration)
    return {
        /**
         * Edit advanced settings by returning table of advanced settings.
         * @summary Edit advanced settings
         * @param {string} applicationId Application ID
         * @param {ApplicationAdvancedSettings} [applicationAdvancedSettings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editAdvancedSettings(applicationId: string, applicationAdvancedSettings?: ApplicationAdvancedSettings, options?: any): AxiosPromise<ApplicationAdvancedSettings> {
            return localVarFp.editAdvancedSettings(applicationId, applicationAdvancedSettings, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit the Network settings of the application.
         * @summary Edit Application Network
         * @param {string} applicationId Application ID
         * @param {ApplicationNetworkRequest} [applicationNetworkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editApplicationNetwork(applicationId: string, applicationNetworkRequest?: ApplicationNetworkRequest, options?: any): AxiosPromise<ApplicationNetwork> {
            return localVarFp.editApplicationNetwork(applicationId, applicationNetworkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get list and values of the advanced settings of the application.
         * @summary Get advanced settings
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdvancedSettings(applicationId: string, options?: any): AxiosPromise<ApplicationAdvancedSettings> {
            return localVarFp.getAdvancedSettings(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get status of the application network settings.
         * @summary Get Application Network information
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationNetwork(applicationId: string, options?: any): AxiosPromise<ApplicationNetwork> {
            return localVarFp.getApplicationNetwork(applicationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationConfigurationApi - object-oriented interface
 * @export
 * @class ApplicationConfigurationApi
 * @extends {BaseAPI}
 */
export class ApplicationConfigurationApi extends BaseAPI {
    /**
     * Edit advanced settings by returning table of advanced settings.
     * @summary Edit advanced settings
     * @param {string} applicationId Application ID
     * @param {ApplicationAdvancedSettings} [applicationAdvancedSettings] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationConfigurationApi
     */
    public editAdvancedSettings(applicationId: string, applicationAdvancedSettings?: ApplicationAdvancedSettings, options?: AxiosRequestConfig) {
        return ApplicationConfigurationApiFp(this.configuration).editAdvancedSettings(applicationId, applicationAdvancedSettings, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit the Network settings of the application.
     * @summary Edit Application Network
     * @param {string} applicationId Application ID
     * @param {ApplicationNetworkRequest} [applicationNetworkRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationConfigurationApi
     */
    public editApplicationNetwork(applicationId: string, applicationNetworkRequest?: ApplicationNetworkRequest, options?: AxiosRequestConfig) {
        return ApplicationConfigurationApiFp(this.configuration).editApplicationNetwork(applicationId, applicationNetworkRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list and values of the advanced settings of the application.
     * @summary Get advanced settings
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationConfigurationApi
     */
    public getAdvancedSettings(applicationId: string, options?: AxiosRequestConfig) {
        return ApplicationConfigurationApiFp(this.configuration).getAdvancedSettings(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get status of the application network settings.
     * @summary Get Application Network information
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationConfigurationApi
     */
    public getApplicationNetwork(applicationId: string, options?: AxiosRequestConfig) {
        return ApplicationConfigurationApiFp(this.configuration).getApplicationNetwork(applicationId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ApplicationDeploymentHistoryApi - axios parameter creator
 * @export
 */
export const ApplicationDeploymentHistoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter. You can also filter by status (FAILED or SUCCESS), and git_commit_id
         * @summary List application deploys
         * @param {string} applicationId Application ID
         * @param {string} [startId] Starting point after which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationDeploymentHistory: async (applicationId: string, startId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('listApplicationDeploymentHistory', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/deploymentHistory`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (startId !== undefined) {
                localVarQueryParameter['startId'] = startId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationDeploymentHistoryApi - functional programming interface
 * @export
 */
export const ApplicationDeploymentHistoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationDeploymentHistoryApiAxiosParamCreator(configuration)
    return {
        /**
         * By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter. You can also filter by status (FAILED or SUCCESS), and git_commit_id
         * @summary List application deploys
         * @param {string} applicationId Application ID
         * @param {string} [startId] Starting point after which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplicationDeploymentHistory(applicationId: string, startId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentHistoryPaginatedResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplicationDeploymentHistory(applicationId, startId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApplicationDeploymentHistoryApi - factory interface
 * @export
 */
export const ApplicationDeploymentHistoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationDeploymentHistoryApiFp(configuration)
    return {
        /**
         * By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter. You can also filter by status (FAILED or SUCCESS), and git_commit_id
         * @summary List application deploys
         * @param {string} applicationId Application ID
         * @param {string} [startId] Starting point after which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationDeploymentHistory(applicationId: string, startId?: string, options?: any): AxiosPromise<DeploymentHistoryPaginatedResponseList> {
            return localVarFp.listApplicationDeploymentHistory(applicationId, startId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationDeploymentHistoryApi - object-oriented interface
 * @export
 * @class ApplicationDeploymentHistoryApi
 * @extends {BaseAPI}
 */
export class ApplicationDeploymentHistoryApi extends BaseAPI {
    /**
     * By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter. You can also filter by status (FAILED or SUCCESS), and git_commit_id
     * @summary List application deploys
     * @param {string} applicationId Application ID
     * @param {string} [startId] Starting point after which to return results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentHistoryApi
     */
    public listApplicationDeploymentHistory(applicationId: string, startId?: string, options?: AxiosRequestConfig) {
        return ApplicationDeploymentHistoryApiFp(this.configuration).listApplicationDeploymentHistory(applicationId, startId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ApplicationDeploymentRestrictionApi - axios parameter creator
 * @export
 */
export const ApplicationDeploymentRestrictionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an application deployment restriction
         * @summary Create an application deployment restriction
         * @param {string} applicationId Application ID
         * @param {ApplicationDeploymentRestrictionRequest} [applicationDeploymentRestrictionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationDeploymentRestriction: async (applicationId: string, applicationDeploymentRestrictionRequest?: ApplicationDeploymentRestrictionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('createApplicationDeploymentRestriction', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/deploymentRestriction`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(applicationDeploymentRestrictionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an application deployment restriction
         * @summary Delete an application deployment restriction
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationDeploymentRestriction: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('deleteApplicationDeploymentRestriction', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/deploymentRestriction/{deploymentRestrictionId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit an application deployment restriction
         * @summary Edit an application deployment restriction
         * @param {string} applicationId Application ID
         * @param {string} deploymentRestrictionId Deployment Restriction ID
         * @param {ApplicationDeploymentRestrictionRequest} [applicationDeploymentRestrictionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editApplicationDeploymentRestriction: async (applicationId: string, deploymentRestrictionId: string, applicationDeploymentRestrictionRequest?: ApplicationDeploymentRestrictionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('editApplicationDeploymentRestriction', 'applicationId', applicationId)
            // verify required parameter 'deploymentRestrictionId' is not null or undefined
            assertParamExists('editApplicationDeploymentRestriction', 'deploymentRestrictionId', deploymentRestrictionId)
            const localVarPath = `/application/{applicationId}/deploymentRestriction/{deploymentRestrictionId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"deploymentRestrictionId"}}`, encodeURIComponent(String(deploymentRestrictionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(applicationDeploymentRestrictionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get application deployment restrictions
         * @summary Get application deployment restrictions
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationDeploymentRestrictions: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getApplicationDeploymentRestrictions', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/deploymentRestriction`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationDeploymentRestrictionApi - functional programming interface
 * @export
 */
export const ApplicationDeploymentRestrictionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationDeploymentRestrictionApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an application deployment restriction
         * @summary Create an application deployment restriction
         * @param {string} applicationId Application ID
         * @param {ApplicationDeploymentRestrictionRequest} [applicationDeploymentRestrictionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplicationDeploymentRestriction(applicationId: string, applicationDeploymentRestrictionRequest?: ApplicationDeploymentRestrictionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationDeploymentRestriction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplicationDeploymentRestriction(applicationId, applicationDeploymentRestrictionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an application deployment restriction
         * @summary Delete an application deployment restriction
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApplicationDeploymentRestriction(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApplicationDeploymentRestriction(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Edit an application deployment restriction
         * @summary Edit an application deployment restriction
         * @param {string} applicationId Application ID
         * @param {string} deploymentRestrictionId Deployment Restriction ID
         * @param {ApplicationDeploymentRestrictionRequest} [applicationDeploymentRestrictionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editApplicationDeploymentRestriction(applicationId: string, deploymentRestrictionId: string, applicationDeploymentRestrictionRequest?: ApplicationDeploymentRestrictionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationDeploymentRestriction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editApplicationDeploymentRestriction(applicationId, deploymentRestrictionId, applicationDeploymentRestrictionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get application deployment restrictions
         * @summary Get application deployment restrictions
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationDeploymentRestrictions(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationDeploymentRestrictionResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationDeploymentRestrictions(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApplicationDeploymentRestrictionApi - factory interface
 * @export
 */
export const ApplicationDeploymentRestrictionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationDeploymentRestrictionApiFp(configuration)
    return {
        /**
         * Create an application deployment restriction
         * @summary Create an application deployment restriction
         * @param {string} applicationId Application ID
         * @param {ApplicationDeploymentRestrictionRequest} [applicationDeploymentRestrictionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationDeploymentRestriction(applicationId: string, applicationDeploymentRestrictionRequest?: ApplicationDeploymentRestrictionRequest, options?: any): AxiosPromise<ApplicationDeploymentRestriction> {
            return localVarFp.createApplicationDeploymentRestriction(applicationId, applicationDeploymentRestrictionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an application deployment restriction
         * @summary Delete an application deployment restriction
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationDeploymentRestriction(applicationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteApplicationDeploymentRestriction(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit an application deployment restriction
         * @summary Edit an application deployment restriction
         * @param {string} applicationId Application ID
         * @param {string} deploymentRestrictionId Deployment Restriction ID
         * @param {ApplicationDeploymentRestrictionRequest} [applicationDeploymentRestrictionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editApplicationDeploymentRestriction(applicationId: string, deploymentRestrictionId: string, applicationDeploymentRestrictionRequest?: ApplicationDeploymentRestrictionRequest, options?: any): AxiosPromise<ApplicationDeploymentRestriction> {
            return localVarFp.editApplicationDeploymentRestriction(applicationId, deploymentRestrictionId, applicationDeploymentRestrictionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get application deployment restrictions
         * @summary Get application deployment restrictions
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationDeploymentRestrictions(applicationId: string, options?: any): AxiosPromise<ApplicationDeploymentRestrictionResponseList> {
            return localVarFp.getApplicationDeploymentRestrictions(applicationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationDeploymentRestrictionApi - object-oriented interface
 * @export
 * @class ApplicationDeploymentRestrictionApi
 * @extends {BaseAPI}
 */
export class ApplicationDeploymentRestrictionApi extends BaseAPI {
    /**
     * Create an application deployment restriction
     * @summary Create an application deployment restriction
     * @param {string} applicationId Application ID
     * @param {ApplicationDeploymentRestrictionRequest} [applicationDeploymentRestrictionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentRestrictionApi
     */
    public createApplicationDeploymentRestriction(applicationId: string, applicationDeploymentRestrictionRequest?: ApplicationDeploymentRestrictionRequest, options?: AxiosRequestConfig) {
        return ApplicationDeploymentRestrictionApiFp(this.configuration).createApplicationDeploymentRestriction(applicationId, applicationDeploymentRestrictionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an application deployment restriction
     * @summary Delete an application deployment restriction
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentRestrictionApi
     */
    public deleteApplicationDeploymentRestriction(applicationId: string, options?: AxiosRequestConfig) {
        return ApplicationDeploymentRestrictionApiFp(this.configuration).deleteApplicationDeploymentRestriction(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit an application deployment restriction
     * @summary Edit an application deployment restriction
     * @param {string} applicationId Application ID
     * @param {string} deploymentRestrictionId Deployment Restriction ID
     * @param {ApplicationDeploymentRestrictionRequest} [applicationDeploymentRestrictionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentRestrictionApi
     */
    public editApplicationDeploymentRestriction(applicationId: string, deploymentRestrictionId: string, applicationDeploymentRestrictionRequest?: ApplicationDeploymentRestrictionRequest, options?: AxiosRequestConfig) {
        return ApplicationDeploymentRestrictionApiFp(this.configuration).editApplicationDeploymentRestriction(applicationId, deploymentRestrictionId, applicationDeploymentRestrictionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get application deployment restrictions
     * @summary Get application deployment restrictions
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentRestrictionApi
     */
    public getApplicationDeploymentRestrictions(applicationId: string, options?: AxiosRequestConfig) {
        return ApplicationDeploymentRestrictionApiFp(this.configuration).getApplicationDeploymentRestrictions(applicationId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ApplicationEnvironmentVariableApi - axios parameter creator
 * @export
 */
export const ApplicationEnvironmentVariableApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * - Add an environment variable to the application. 
         * @summary Add an environment variable to the application
         * @param {string} applicationId Application ID
         * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationEnvironmentVariable: async (applicationId: string, environmentVariableRequest?: EnvironmentVariableRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('createApplicationEnvironmentVariable', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/environmentVariable`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentVariableRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to add an alias at application level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at application level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - Only 1 alias level is allowed. You can\'t create an alias on an alias 
         * @summary Create an environment variable alias at the application level
         * @param {string} applicationId Application ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationEnvironmentVariableAlias: async (applicationId: string, environmentVariableId: string, key?: Key, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('createApplicationEnvironmentVariableAlias', 'applicationId', applicationId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('createApplicationEnvironmentVariableAlias', 'environmentVariableId', environmentVariableId)
            const localVarPath = `/application/{applicationId}/environmentVariable/{environmentVariableId}/alias`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(key, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to override at application level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at application level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
         * @summary Create an environment variable override at the application level
         * @param {string} applicationId Application ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationEnvironmentVariableOverride: async (applicationId: string, environmentVariableId: string, value?: Value, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('createApplicationEnvironmentVariableOverride', 'applicationId', applicationId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('createApplicationEnvironmentVariableOverride', 'environmentVariableId', environmentVariableId)
            const localVarPath = `/application/{applicationId}/environmentVariable/{environmentVariableId}/override`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(value, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - To delete an environment variable from an application you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete an environment variable from an application
         * @param {string} applicationId Application ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationEnvironmentVariable: async (applicationId: string, environmentVariableId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('deleteApplicationEnvironmentVariable', 'applicationId', applicationId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('deleteApplicationEnvironmentVariable', 'environmentVariableId', environmentVariableId)
            const localVarPath = `/application/{applicationId}/environmentVariable/{environmentVariableId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit an environment variable belonging to the application
         * @param {string} applicationId Application ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editApplicationEnvironmentVariable: async (applicationId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('editApplicationEnvironmentVariable', 'applicationId', applicationId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('editApplicationEnvironmentVariable', 'environmentVariableId', environmentVariableId)
            // verify required parameter 'environmentVariableEditRequest' is not null or undefined
            assertParamExists('editApplicationEnvironmentVariable', 'environmentVariableEditRequest', environmentVariableEditRequest)
            const localVarPath = `/application/{applicationId}/environmentVariable/{environmentVariableId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentVariableEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Import environment variables in a defined scope, with a defined visibility.
         * @summary Import variables
         * @param {string} applicationId Application ID
         * @param {VariableImportRequest} [variableImportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importEnvironmentVariable: async (applicationId: string, variableImportRequest?: VariableImportRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('importEnvironmentVariable', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/environmentVariable/import`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(variableImportRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List environment variables
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationEnvironmentVariable: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('listApplicationEnvironmentVariable', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/environmentVariable`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationEnvironmentVariableApi - functional programming interface
 * @export
 */
export const ApplicationEnvironmentVariableApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationEnvironmentVariableApiAxiosParamCreator(configuration)
    return {
        /**
         * - Add an environment variable to the application. 
         * @summary Add an environment variable to the application
         * @param {string} applicationId Application ID
         * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplicationEnvironmentVariable(applicationId: string, environmentVariableRequest?: EnvironmentVariableRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplicationEnvironmentVariable(applicationId, environmentVariableRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - Allows you to add an alias at application level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at application level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - Only 1 alias level is allowed. You can\'t create an alias on an alias 
         * @summary Create an environment variable alias at the application level
         * @param {string} applicationId Application ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplicationEnvironmentVariableAlias(applicationId: string, environmentVariableId: string, key?: Key, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplicationEnvironmentVariableAlias(applicationId, environmentVariableId, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - Allows you to override at application level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at application level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
         * @summary Create an environment variable override at the application level
         * @param {string} applicationId Application ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplicationEnvironmentVariableOverride(applicationId: string, environmentVariableId: string, value?: Value, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplicationEnvironmentVariableOverride(applicationId, environmentVariableId, value, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - To delete an environment variable from an application you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete an environment variable from an application
         * @param {string} applicationId Application ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApplicationEnvironmentVariable(applicationId: string, environmentVariableId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApplicationEnvironmentVariable(applicationId, environmentVariableId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit an environment variable belonging to the application
         * @param {string} applicationId Application ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editApplicationEnvironmentVariable(applicationId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editApplicationEnvironmentVariable(applicationId, environmentVariableId, environmentVariableEditRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Import environment variables in a defined scope, with a defined visibility.
         * @summary Import variables
         * @param {string} applicationId Application ID
         * @param {VariableImportRequest} [variableImportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importEnvironmentVariable(applicationId: string, variableImportRequest?: VariableImportRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariableImport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importEnvironmentVariable(applicationId, variableImportRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List environment variables
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplicationEnvironmentVariable(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariableResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplicationEnvironmentVariable(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApplicationEnvironmentVariableApi - factory interface
 * @export
 */
export const ApplicationEnvironmentVariableApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationEnvironmentVariableApiFp(configuration)
    return {
        /**
         * - Add an environment variable to the application. 
         * @summary Add an environment variable to the application
         * @param {string} applicationId Application ID
         * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationEnvironmentVariable(applicationId: string, environmentVariableRequest?: EnvironmentVariableRequest, options?: any): AxiosPromise<EnvironmentVariable> {
            return localVarFp.createApplicationEnvironmentVariable(applicationId, environmentVariableRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to add an alias at application level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at application level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - Only 1 alias level is allowed. You can\'t create an alias on an alias 
         * @summary Create an environment variable alias at the application level
         * @param {string} applicationId Application ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationEnvironmentVariableAlias(applicationId: string, environmentVariableId: string, key?: Key, options?: any): AxiosPromise<EnvironmentVariable> {
            return localVarFp.createApplicationEnvironmentVariableAlias(applicationId, environmentVariableId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to override at application level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at application level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
         * @summary Create an environment variable override at the application level
         * @param {string} applicationId Application ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationEnvironmentVariableOverride(applicationId: string, environmentVariableId: string, value?: Value, options?: any): AxiosPromise<EnvironmentVariable> {
            return localVarFp.createApplicationEnvironmentVariableOverride(applicationId, environmentVariableId, value, options).then((request) => request(axios, basePath));
        },
        /**
         * - To delete an environment variable from an application you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete an environment variable from an application
         * @param {string} applicationId Application ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationEnvironmentVariable(applicationId: string, environmentVariableId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteApplicationEnvironmentVariable(applicationId, environmentVariableId, options).then((request) => request(axios, basePath));
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit an environment variable belonging to the application
         * @param {string} applicationId Application ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editApplicationEnvironmentVariable(applicationId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options?: any): AxiosPromise<EnvironmentVariable> {
            return localVarFp.editApplicationEnvironmentVariable(applicationId, environmentVariableId, environmentVariableEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Import environment variables in a defined scope, with a defined visibility.
         * @summary Import variables
         * @param {string} applicationId Application ID
         * @param {VariableImportRequest} [variableImportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importEnvironmentVariable(applicationId: string, variableImportRequest?: VariableImportRequest, options?: any): AxiosPromise<VariableImport> {
            return localVarFp.importEnvironmentVariable(applicationId, variableImportRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List environment variables
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationEnvironmentVariable(applicationId: string, options?: any): AxiosPromise<EnvironmentVariableResponseList> {
            return localVarFp.listApplicationEnvironmentVariable(applicationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationEnvironmentVariableApi - object-oriented interface
 * @export
 * @class ApplicationEnvironmentVariableApi
 * @extends {BaseAPI}
 */
export class ApplicationEnvironmentVariableApi extends BaseAPI {
    /**
     * - Add an environment variable to the application. 
     * @summary Add an environment variable to the application
     * @param {string} applicationId Application ID
     * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationEnvironmentVariableApi
     */
    public createApplicationEnvironmentVariable(applicationId: string, environmentVariableRequest?: EnvironmentVariableRequest, options?: AxiosRequestConfig) {
        return ApplicationEnvironmentVariableApiFp(this.configuration).createApplicationEnvironmentVariable(applicationId, environmentVariableRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to add an alias at application level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at application level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - Only 1 alias level is allowed. You can\'t create an alias on an alias 
     * @summary Create an environment variable alias at the application level
     * @param {string} applicationId Application ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {Key} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationEnvironmentVariableApi
     */
    public createApplicationEnvironmentVariableAlias(applicationId: string, environmentVariableId: string, key?: Key, options?: AxiosRequestConfig) {
        return ApplicationEnvironmentVariableApiFp(this.configuration).createApplicationEnvironmentVariableAlias(applicationId, environmentVariableId, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to override at application level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at application level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
     * @summary Create an environment variable override at the application level
     * @param {string} applicationId Application ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {Value} [value] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationEnvironmentVariableApi
     */
    public createApplicationEnvironmentVariableOverride(applicationId: string, environmentVariableId: string, value?: Value, options?: AxiosRequestConfig) {
        return ApplicationEnvironmentVariableApiFp(this.configuration).createApplicationEnvironmentVariableOverride(applicationId, environmentVariableId, value, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - To delete an environment variable from an application you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
     * @summary Delete an environment variable from an application
     * @param {string} applicationId Application ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationEnvironmentVariableApi
     */
    public deleteApplicationEnvironmentVariable(applicationId: string, environmentVariableId: string, options?: AxiosRequestConfig) {
        return ApplicationEnvironmentVariableApiFp(this.configuration).deleteApplicationEnvironmentVariable(applicationId, environmentVariableId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
     * @summary Edit an environment variable belonging to the application
     * @param {string} applicationId Application ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationEnvironmentVariableApi
     */
    public editApplicationEnvironmentVariable(applicationId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options?: AxiosRequestConfig) {
        return ApplicationEnvironmentVariableApiFp(this.configuration).editApplicationEnvironmentVariable(applicationId, environmentVariableId, environmentVariableEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Import environment variables in a defined scope, with a defined visibility.
     * @summary Import variables
     * @param {string} applicationId Application ID
     * @param {VariableImportRequest} [variableImportRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationEnvironmentVariableApi
     */
    public importEnvironmentVariable(applicationId: string, variableImportRequest?: VariableImportRequest, options?: AxiosRequestConfig) {
        return ApplicationEnvironmentVariableApiFp(this.configuration).importEnvironmentVariable(applicationId, variableImportRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List environment variables
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationEnvironmentVariableApi
     */
    public listApplicationEnvironmentVariable(applicationId: string, options?: AxiosRequestConfig) {
        return ApplicationEnvironmentVariableApiFp(this.configuration).listApplicationEnvironmentVariable(applicationId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ApplicationEventApi - axios parameter creator
 * @export
 */
export const ApplicationEventApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter
         * @summary List application events
         * @param {string} applicationId Application ID
         * @param {string} [startId] Starting point after which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationEvent: async (applicationId: string, startId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('listApplicationEvent', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/event`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (startId !== undefined) {
                localVarQueryParameter['startId'] = startId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationEventApi - functional programming interface
 * @export
 */
export const ApplicationEventApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationEventApiAxiosParamCreator(configuration)
    return {
        /**
         * By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter
         * @summary List application events
         * @param {string} applicationId Application ID
         * @param {string} [startId] Starting point after which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplicationEvent(applicationId: string, startId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventPaginatedResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplicationEvent(applicationId, startId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApplicationEventApi - factory interface
 * @export
 */
export const ApplicationEventApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationEventApiFp(configuration)
    return {
        /**
         * By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter
         * @summary List application events
         * @param {string} applicationId Application ID
         * @param {string} [startId] Starting point after which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationEvent(applicationId: string, startId?: string, options?: any): AxiosPromise<EventPaginatedResponseList> {
            return localVarFp.listApplicationEvent(applicationId, startId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationEventApi - object-oriented interface
 * @export
 * @class ApplicationEventApi
 * @extends {BaseAPI}
 */
export class ApplicationEventApi extends BaseAPI {
    /**
     * By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter
     * @summary List application events
     * @param {string} applicationId Application ID
     * @param {string} [startId] Starting point after which to return results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationEventApi
     */
    public listApplicationEvent(applicationId: string, startId?: string, options?: AxiosRequestConfig) {
        return ApplicationEventApiFp(this.configuration).listApplicationEvent(applicationId, startId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ApplicationLogsApi - axios parameter creator
 * @export
 */
export const ApplicationLogsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This will list the last 1000 logs of the application
         * @summary List logs
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationLog: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('listApplicationLog', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/log`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationLogsApi - functional programming interface
 * @export
 */
export const ApplicationLogsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationLogsApiAxiosParamCreator(configuration)
    return {
        /**
         * This will list the last 1000 logs of the application
         * @summary List logs
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplicationLog(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplicationLog(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApplicationLogsApi - factory interface
 * @export
 */
export const ApplicationLogsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationLogsApiFp(configuration)
    return {
        /**
         * This will list the last 1000 logs of the application
         * @summary List logs
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationLog(applicationId: string, options?: any): AxiosPromise<LogResponseList> {
            return localVarFp.listApplicationLog(applicationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationLogsApi - object-oriented interface
 * @export
 * @class ApplicationLogsApi
 * @extends {BaseAPI}
 */
export class ApplicationLogsApi extends BaseAPI {
    /**
     * This will list the last 1000 logs of the application
     * @summary List logs
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationLogsApi
     */
    public listApplicationLog(applicationId: string, options?: AxiosRequestConfig) {
        return ApplicationLogsApiFp(this.configuration).listApplicationLog(applicationId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ApplicationMainCallsApi - axios parameter creator
 * @export
 */
export const ApplicationMainCallsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add application tag
         * @param {string} applicationId Application ID
         * @param {TagRequest} [tagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationTag: async (applicationId: string, tagRequest?: TagRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('createApplicationTag', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/tag`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To delete the application you must have the admin permission
         * @summary Delete application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplication: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('deleteApplication', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete application tag
         * @param {string} applicationId Application ID
         * @param {string} tagId Tag ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationTag: async (applicationId: string, tagId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('deleteApplicationTag', 'applicationId', applicationId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('deleteApplicationTag', 'tagId', tagId)
            const localVarPath = `/application/{applicationId}/tag/{tagId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - To edit the application you must have the admin permission. - For port edition, if you provide a port id, we will update the corresponding port. If you don\'t we will create a new one. If you remove a port from the payload, we will delete it. - For storage edition, if you provide a storage id, we will update the corresponding storage. If you don\'t we will create a new one. If you remove a storage from the payload, we will delete it. 
         * @summary Edit application
         * @param {string} applicationId Application ID
         * @param {ApplicationEditRequest} [applicationEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editApplication: async (applicationId: string, applicationEditRequest?: ApplicationEditRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('editApplication', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(applicationEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get application by ID
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplication: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getApplication', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get application status
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationStatus: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getApplicationStatus', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/status`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns list of the last 100 commits made on the repository linked to the application
         * @summary List last commits
         * @param {string} applicationId Application ID
         * @param {string} [startId] Starting point after which to return results
         * @param {string} [gitCommitId] Git Commit ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationCommit: async (applicationId: string, startId?: string, gitCommitId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('listApplicationCommit', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/commit`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (startId !== undefined) {
                localVarQueryParameter['startId'] = startId;
            }

            if (gitCommitId !== undefined) {
                localVarQueryParameter['gitCommitId'] = gitCommitId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List contributors
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationContributor: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('listApplicationContributor', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/contributor`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This will return all the custom domains and Qovery autogenerated domain for the given application
         * @summary List all URLs of the application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationLinks: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('listApplicationLinks', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/link`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List tags
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationTag: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('listApplicationTag', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/tag`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationMainCallsApi - functional programming interface
 * @export
 */
export const ApplicationMainCallsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationMainCallsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add application tag
         * @param {string} applicationId Application ID
         * @param {TagRequest} [tagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplicationTag(applicationId: string, tagRequest?: TagRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplicationTag(applicationId, tagRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * To delete the application you must have the admin permission
         * @summary Delete application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApplication(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApplication(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete application tag
         * @param {string} applicationId Application ID
         * @param {string} tagId Tag ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApplicationTag(applicationId: string, tagId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApplicationTag(applicationId, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - To edit the application you must have the admin permission. - For port edition, if you provide a port id, we will update the corresponding port. If you don\'t we will create a new one. If you remove a port from the payload, we will delete it. - For storage edition, if you provide a storage id, we will update the corresponding storage. If you don\'t we will create a new one. If you remove a storage from the payload, we will delete it. 
         * @summary Edit application
         * @param {string} applicationId Application ID
         * @param {ApplicationEditRequest} [applicationEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editApplication(applicationId: string, applicationEditRequest?: ApplicationEditRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Application>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editApplication(applicationId, applicationEditRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get application by ID
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplication(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Application>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplication(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get application status
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationStatus(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationStatus(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns list of the last 100 commits made on the repository linked to the application
         * @summary List last commits
         * @param {string} applicationId Application ID
         * @param {string} [startId] Starting point after which to return results
         * @param {string} [gitCommitId] Git Commit ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplicationCommit(applicationId: string, startId?: string, gitCommitId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommitResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplicationCommit(applicationId, startId, gitCommitId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List contributors
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplicationContributor(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplicationContributor(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This will return all the custom domains and Qovery autogenerated domain for the given application
         * @summary List all URLs of the application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplicationLinks(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplicationLinks(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List tags
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplicationTag(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplicationTag(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApplicationMainCallsApi - factory interface
 * @export
 */
export const ApplicationMainCallsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationMainCallsApiFp(configuration)
    return {
        /**
         * 
         * @summary Add application tag
         * @param {string} applicationId Application ID
         * @param {TagRequest} [tagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationTag(applicationId: string, tagRequest?: TagRequest, options?: any): AxiosPromise<TagResponseList> {
            return localVarFp.createApplicationTag(applicationId, tagRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * To delete the application you must have the admin permission
         * @summary Delete application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplication(applicationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteApplication(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete application tag
         * @param {string} applicationId Application ID
         * @param {string} tagId Tag ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationTag(applicationId: string, tagId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteApplicationTag(applicationId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * - To edit the application you must have the admin permission. - For port edition, if you provide a port id, we will update the corresponding port. If you don\'t we will create a new one. If you remove a port from the payload, we will delete it. - For storage edition, if you provide a storage id, we will update the corresponding storage. If you don\'t we will create a new one. If you remove a storage from the payload, we will delete it. 
         * @summary Edit application
         * @param {string} applicationId Application ID
         * @param {ApplicationEditRequest} [applicationEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editApplication(applicationId: string, applicationEditRequest?: ApplicationEditRequest, options?: any): AxiosPromise<Application> {
            return localVarFp.editApplication(applicationId, applicationEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get application by ID
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplication(applicationId: string, options?: any): AxiosPromise<Application> {
            return localVarFp.getApplication(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get application status
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationStatus(applicationId: string, options?: any): AxiosPromise<Status> {
            return localVarFp.getApplicationStatus(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns list of the last 100 commits made on the repository linked to the application
         * @summary List last commits
         * @param {string} applicationId Application ID
         * @param {string} [startId] Starting point after which to return results
         * @param {string} [gitCommitId] Git Commit ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationCommit(applicationId: string, startId?: string, gitCommitId?: string, options?: any): AxiosPromise<CommitResponseList> {
            return localVarFp.listApplicationCommit(applicationId, startId, gitCommitId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List contributors
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationContributor(applicationId: string, options?: any): AxiosPromise<UserResponseList> {
            return localVarFp.listApplicationContributor(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * This will return all the custom domains and Qovery autogenerated domain for the given application
         * @summary List all URLs of the application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationLinks(applicationId: string, options?: any): AxiosPromise<LinkResponseList> {
            return localVarFp.listApplicationLinks(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List tags
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationTag(applicationId: string, options?: any): AxiosPromise<TagResponseList> {
            return localVarFp.listApplicationTag(applicationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationMainCallsApi - object-oriented interface
 * @export
 * @class ApplicationMainCallsApi
 * @extends {BaseAPI}
 */
export class ApplicationMainCallsApi extends BaseAPI {
    /**
     * 
     * @summary Add application tag
     * @param {string} applicationId Application ID
     * @param {TagRequest} [tagRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationMainCallsApi
     */
    public createApplicationTag(applicationId: string, tagRequest?: TagRequest, options?: AxiosRequestConfig) {
        return ApplicationMainCallsApiFp(this.configuration).createApplicationTag(applicationId, tagRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To delete the application you must have the admin permission
     * @summary Delete application
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationMainCallsApi
     */
    public deleteApplication(applicationId: string, options?: AxiosRequestConfig) {
        return ApplicationMainCallsApiFp(this.configuration).deleteApplication(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete application tag
     * @param {string} applicationId Application ID
     * @param {string} tagId Tag ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationMainCallsApi
     */
    public deleteApplicationTag(applicationId: string, tagId: string, options?: AxiosRequestConfig) {
        return ApplicationMainCallsApiFp(this.configuration).deleteApplicationTag(applicationId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - To edit the application you must have the admin permission. - For port edition, if you provide a port id, we will update the corresponding port. If you don\'t we will create a new one. If you remove a port from the payload, we will delete it. - For storage edition, if you provide a storage id, we will update the corresponding storage. If you don\'t we will create a new one. If you remove a storage from the payload, we will delete it. 
     * @summary Edit application
     * @param {string} applicationId Application ID
     * @param {ApplicationEditRequest} [applicationEditRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationMainCallsApi
     */
    public editApplication(applicationId: string, applicationEditRequest?: ApplicationEditRequest, options?: AxiosRequestConfig) {
        return ApplicationMainCallsApiFp(this.configuration).editApplication(applicationId, applicationEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get application by ID
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationMainCallsApi
     */
    public getApplication(applicationId: string, options?: AxiosRequestConfig) {
        return ApplicationMainCallsApiFp(this.configuration).getApplication(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get application status
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationMainCallsApi
     */
    public getApplicationStatus(applicationId: string, options?: AxiosRequestConfig) {
        return ApplicationMainCallsApiFp(this.configuration).getApplicationStatus(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns list of the last 100 commits made on the repository linked to the application
     * @summary List last commits
     * @param {string} applicationId Application ID
     * @param {string} [startId] Starting point after which to return results
     * @param {string} [gitCommitId] Git Commit ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationMainCallsApi
     */
    public listApplicationCommit(applicationId: string, startId?: string, gitCommitId?: string, options?: AxiosRequestConfig) {
        return ApplicationMainCallsApiFp(this.configuration).listApplicationCommit(applicationId, startId, gitCommitId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List contributors
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationMainCallsApi
     */
    public listApplicationContributor(applicationId: string, options?: AxiosRequestConfig) {
        return ApplicationMainCallsApiFp(this.configuration).listApplicationContributor(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will return all the custom domains and Qovery autogenerated domain for the given application
     * @summary List all URLs of the application
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationMainCallsApi
     */
    public listApplicationLinks(applicationId: string, options?: AxiosRequestConfig) {
        return ApplicationMainCallsApiFp(this.configuration).listApplicationLinks(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List tags
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationMainCallsApi
     */
    public listApplicationTag(applicationId: string, options?: AxiosRequestConfig) {
        return ApplicationMainCallsApiFp(this.configuration).listApplicationTag(applicationId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ApplicationMetricsApi - axios parameter creator
 * @export
 */
export const ApplicationMetricsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List currently running instances of the application with their CPU and RAM metrics
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationCurrentInstance: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getApplicationCurrentInstance', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/instance`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns min, max, and running number of instances of the application
         * @summary Get current scaling of the application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationCurrentScale: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getApplicationCurrentScale', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/currentScale`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List current storage disk usage
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationCurrentStorageDisk: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getApplicationCurrentStorageDisk', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/currentStorage`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get CPU consumption metric over time for the application
         * @param {string} applicationId Application ID
         * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationMetricCpu: async (applicationId: string, lastSeconds: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getApplicationMetricCpu', 'applicationId', applicationId)
            // verify required parameter 'lastSeconds' is not null or undefined
            assertParamExists('getApplicationMetricCpu', 'lastSeconds', lastSeconds)
            const localVarPath = `/application/{applicationId}/metric/cpu`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (lastSeconds !== undefined) {
                localVarQueryParameter['lastSeconds'] = lastSeconds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The value returned corresponds to the 95th centile
         * @summary Get Health Check latency  metric over time for the application
         * @param {string} applicationId Application ID
         * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationMetricHealthCheck: async (applicationId: string, lastSeconds: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getApplicationMetricHealthCheck', 'applicationId', applicationId)
            // verify required parameter 'lastSeconds' is not null or undefined
            assertParamExists('getApplicationMetricHealthCheck', 'lastSeconds', lastSeconds)
            const localVarPath = `/application/{applicationId}/metric/healthCheck`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (lastSeconds !== undefined) {
                localVarQueryParameter['lastSeconds'] = lastSeconds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Memory consumption metric over time for the application
         * @param {string} applicationId Application ID
         * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationMetricMemory: async (applicationId: string, lastSeconds: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getApplicationMetricMemory', 'applicationId', applicationId)
            // verify required parameter 'lastSeconds' is not null or undefined
            assertParamExists('getApplicationMetricMemory', 'lastSeconds', lastSeconds)
            const localVarPath = `/application/{applicationId}/metric/memory`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (lastSeconds !== undefined) {
                localVarQueryParameter['lastSeconds'] = lastSeconds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Storage consumption metric over time for the application
         * @param {string} applicationId Application ID
         * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationMetricStorage: async (applicationId: string, lastSeconds: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getApplicationMetricStorage', 'applicationId', applicationId)
            // verify required parameter 'lastSeconds' is not null or undefined
            assertParamExists('getApplicationMetricStorage', 'lastSeconds', lastSeconds)
            const localVarPath = `/application/{applicationId}/metric/storage`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (lastSeconds !== undefined) {
                localVarQueryParameter['lastSeconds'] = lastSeconds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationMetricsApi - functional programming interface
 * @export
 */
export const ApplicationMetricsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationMetricsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List currently running instances of the application with their CPU and RAM metrics
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationCurrentInstance(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InstanceResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationCurrentInstance(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns min, max, and running number of instances of the application
         * @summary Get current scaling of the application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationCurrentScale(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationCurrentScale>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationCurrentScale(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List current storage disk usage
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationCurrentStorageDisk(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StorageDiskResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationCurrentStorageDisk(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get CPU consumption metric over time for the application
         * @param {string} applicationId Application ID
         * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationMetricCpu(applicationId: string, lastSeconds: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricCPUResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationMetricCpu(applicationId, lastSeconds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The value returned corresponds to the 95th centile
         * @summary Get Health Check latency  metric over time for the application
         * @param {string} applicationId Application ID
         * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationMetricHealthCheck(applicationId: string, lastSeconds: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricGenericResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationMetricHealthCheck(applicationId, lastSeconds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Memory consumption metric over time for the application
         * @param {string} applicationId Application ID
         * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationMetricMemory(applicationId: string, lastSeconds: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricMemoryResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationMetricMemory(applicationId, lastSeconds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Storage consumption metric over time for the application
         * @param {string} applicationId Application ID
         * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationMetricStorage(applicationId: string, lastSeconds: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricStorageResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationMetricStorage(applicationId, lastSeconds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApplicationMetricsApi - factory interface
 * @export
 */
export const ApplicationMetricsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationMetricsApiFp(configuration)
    return {
        /**
         * 
         * @summary List currently running instances of the application with their CPU and RAM metrics
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationCurrentInstance(applicationId: string, options?: any): AxiosPromise<InstanceResponseList> {
            return localVarFp.getApplicationCurrentInstance(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns min, max, and running number of instances of the application
         * @summary Get current scaling of the application
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationCurrentScale(applicationId: string, options?: any): AxiosPromise<ApplicationCurrentScale> {
            return localVarFp.getApplicationCurrentScale(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List current storage disk usage
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationCurrentStorageDisk(applicationId: string, options?: any): AxiosPromise<StorageDiskResponseList> {
            return localVarFp.getApplicationCurrentStorageDisk(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get CPU consumption metric over time for the application
         * @param {string} applicationId Application ID
         * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationMetricCpu(applicationId: string, lastSeconds: number, options?: any): AxiosPromise<MetricCPUResponseList> {
            return localVarFp.getApplicationMetricCpu(applicationId, lastSeconds, options).then((request) => request(axios, basePath));
        },
        /**
         * The value returned corresponds to the 95th centile
         * @summary Get Health Check latency  metric over time for the application
         * @param {string} applicationId Application ID
         * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationMetricHealthCheck(applicationId: string, lastSeconds: number, options?: any): AxiosPromise<MetricGenericResponseList> {
            return localVarFp.getApplicationMetricHealthCheck(applicationId, lastSeconds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Memory consumption metric over time for the application
         * @param {string} applicationId Application ID
         * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationMetricMemory(applicationId: string, lastSeconds: number, options?: any): AxiosPromise<MetricMemoryResponseList> {
            return localVarFp.getApplicationMetricMemory(applicationId, lastSeconds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Storage consumption metric over time for the application
         * @param {string} applicationId Application ID
         * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationMetricStorage(applicationId: string, lastSeconds: number, options?: any): AxiosPromise<MetricStorageResponseList> {
            return localVarFp.getApplicationMetricStorage(applicationId, lastSeconds, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationMetricsApi - object-oriented interface
 * @export
 * @class ApplicationMetricsApi
 * @extends {BaseAPI}
 */
export class ApplicationMetricsApi extends BaseAPI {
    /**
     * 
     * @summary List currently running instances of the application with their CPU and RAM metrics
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationMetricsApi
     */
    public getApplicationCurrentInstance(applicationId: string, options?: AxiosRequestConfig) {
        return ApplicationMetricsApiFp(this.configuration).getApplicationCurrentInstance(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns min, max, and running number of instances of the application
     * @summary Get current scaling of the application
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationMetricsApi
     */
    public getApplicationCurrentScale(applicationId: string, options?: AxiosRequestConfig) {
        return ApplicationMetricsApiFp(this.configuration).getApplicationCurrentScale(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List current storage disk usage
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationMetricsApi
     */
    public getApplicationCurrentStorageDisk(applicationId: string, options?: AxiosRequestConfig) {
        return ApplicationMetricsApiFp(this.configuration).getApplicationCurrentStorageDisk(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get CPU consumption metric over time for the application
     * @param {string} applicationId Application ID
     * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationMetricsApi
     */
    public getApplicationMetricCpu(applicationId: string, lastSeconds: number, options?: AxiosRequestConfig) {
        return ApplicationMetricsApiFp(this.configuration).getApplicationMetricCpu(applicationId, lastSeconds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The value returned corresponds to the 95th centile
     * @summary Get Health Check latency  metric over time for the application
     * @param {string} applicationId Application ID
     * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationMetricsApi
     */
    public getApplicationMetricHealthCheck(applicationId: string, lastSeconds: number, options?: AxiosRequestConfig) {
        return ApplicationMetricsApiFp(this.configuration).getApplicationMetricHealthCheck(applicationId, lastSeconds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Memory consumption metric over time for the application
     * @param {string} applicationId Application ID
     * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationMetricsApi
     */
    public getApplicationMetricMemory(applicationId: string, lastSeconds: number, options?: AxiosRequestConfig) {
        return ApplicationMetricsApiFp(this.configuration).getApplicationMetricMemory(applicationId, lastSeconds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Storage consumption metric over time for the application
     * @param {string} applicationId Application ID
     * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationMetricsApi
     */
    public getApplicationMetricStorage(applicationId: string, lastSeconds: number, options?: AxiosRequestConfig) {
        return ApplicationMetricsApiFp(this.configuration).getApplicationMetricStorage(applicationId, lastSeconds, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ApplicationSecretApi - axios parameter creator
 * @export
 */
export const ApplicationSecretApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * - Add a secret to the application. 
         * @summary Add a secret to the application
         * @param {string} applicationId Application ID
         * @param {SecretRequest} [secretRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationSecret: async (applicationId: string, secretRequest?: SecretRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('createApplicationSecret', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/secret`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(secretRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to add an alias at application level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at application level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - Only 1 alias level is allowed. You can\'t create an alias on an alias 
         * @summary Create a secret alias at the application level
         * @param {string} applicationId Application ID
         * @param {string} secretId Secret ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationSecretAlias: async (applicationId: string, secretId: string, key?: Key, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('createApplicationSecretAlias', 'applicationId', applicationId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('createApplicationSecretAlias', 'secretId', secretId)
            const localVarPath = `/application/{applicationId}/secret/{secretId}/alias`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(key, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to override at application level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at application level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
         * @summary Create a secret override at the application level
         * @param {string} applicationId Application ID
         * @param {string} secretId Secret ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationSecretOverride: async (applicationId: string, secretId: string, value?: Value, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('createApplicationSecretOverride', 'applicationId', applicationId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('createApplicationSecretOverride', 'secretId', secretId)
            const localVarPath = `/application/{applicationId}/secret/{secretId}/override`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(value, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete a secret from an application
         * @param {string} applicationId Application ID
         * @param {string} secretId Secret ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationSecret: async (applicationId: string, secretId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('deleteApplicationSecret', 'applicationId', applicationId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('deleteApplicationSecret', 'secretId', secretId)
            const localVarPath = `/application/{applicationId}/secret/{secretId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit a secret belonging to the application
         * @param {string} applicationId Application ID
         * @param {string} secretId Secret ID
         * @param {SecretEditRequest} secretEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editApplicationSecret: async (applicationId: string, secretId: string, secretEditRequest: SecretEditRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('editApplicationSecret', 'applicationId', applicationId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('editApplicationSecret', 'secretId', secretId)
            // verify required parameter 'secretEditRequest' is not null or undefined
            assertParamExists('editApplicationSecret', 'secretEditRequest', secretEditRequest)
            const localVarPath = `/application/{applicationId}/secret/{secretId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(secretEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Secrets are like environment variables, but they are secured and can\'t be revealed.
         * @summary List application secrets
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationSecrets: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('listApplicationSecrets', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/secret`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationSecretApi - functional programming interface
 * @export
 */
export const ApplicationSecretApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationSecretApiAxiosParamCreator(configuration)
    return {
        /**
         * - Add a secret to the application. 
         * @summary Add a secret to the application
         * @param {string} applicationId Application ID
         * @param {SecretRequest} [secretRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplicationSecret(applicationId: string, secretRequest?: SecretRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplicationSecret(applicationId, secretRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - Allows you to add an alias at application level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at application level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - Only 1 alias level is allowed. You can\'t create an alias on an alias 
         * @summary Create a secret alias at the application level
         * @param {string} applicationId Application ID
         * @param {string} secretId Secret ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplicationSecretAlias(applicationId: string, secretId: string, key?: Key, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplicationSecretAlias(applicationId, secretId, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - Allows you to override at application level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at application level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
         * @summary Create a secret override at the application level
         * @param {string} applicationId Application ID
         * @param {string} secretId Secret ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplicationSecretOverride(applicationId: string, secretId: string, value?: Value, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplicationSecretOverride(applicationId, secretId, value, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete a secret from an application
         * @param {string} applicationId Application ID
         * @param {string} secretId Secret ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApplicationSecret(applicationId: string, secretId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApplicationSecret(applicationId, secretId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit a secret belonging to the application
         * @param {string} applicationId Application ID
         * @param {string} secretId Secret ID
         * @param {SecretEditRequest} secretEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editApplicationSecret(applicationId: string, secretId: string, secretEditRequest: SecretEditRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editApplicationSecret(applicationId, secretId, secretEditRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Secrets are like environment variables, but they are secured and can\'t be revealed.
         * @summary List application secrets
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplicationSecrets(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecretResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplicationSecrets(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApplicationSecretApi - factory interface
 * @export
 */
export const ApplicationSecretApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationSecretApiFp(configuration)
    return {
        /**
         * - Add a secret to the application. 
         * @summary Add a secret to the application
         * @param {string} applicationId Application ID
         * @param {SecretRequest} [secretRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationSecret(applicationId: string, secretRequest?: SecretRequest, options?: any): AxiosPromise<Secret> {
            return localVarFp.createApplicationSecret(applicationId, secretRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to add an alias at application level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at application level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - Only 1 alias level is allowed. You can\'t create an alias on an alias 
         * @summary Create a secret alias at the application level
         * @param {string} applicationId Application ID
         * @param {string} secretId Secret ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationSecretAlias(applicationId: string, secretId: string, key?: Key, options?: any): AxiosPromise<Secret> {
            return localVarFp.createApplicationSecretAlias(applicationId, secretId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to override at application level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at application level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
         * @summary Create a secret override at the application level
         * @param {string} applicationId Application ID
         * @param {string} secretId Secret ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationSecretOverride(applicationId: string, secretId: string, value?: Value, options?: any): AxiosPromise<Secret> {
            return localVarFp.createApplicationSecretOverride(applicationId, secretId, value, options).then((request) => request(axios, basePath));
        },
        /**
         * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete a secret from an application
         * @param {string} applicationId Application ID
         * @param {string} secretId Secret ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationSecret(applicationId: string, secretId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteApplicationSecret(applicationId, secretId, options).then((request) => request(axios, basePath));
        },
        /**
         * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit a secret belonging to the application
         * @param {string} applicationId Application ID
         * @param {string} secretId Secret ID
         * @param {SecretEditRequest} secretEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editApplicationSecret(applicationId: string, secretId: string, secretEditRequest: SecretEditRequest, options?: any): AxiosPromise<Secret> {
            return localVarFp.editApplicationSecret(applicationId, secretId, secretEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Secrets are like environment variables, but they are secured and can\'t be revealed.
         * @summary List application secrets
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationSecrets(applicationId: string, options?: any): AxiosPromise<SecretResponseList> {
            return localVarFp.listApplicationSecrets(applicationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationSecretApi - object-oriented interface
 * @export
 * @class ApplicationSecretApi
 * @extends {BaseAPI}
 */
export class ApplicationSecretApi extends BaseAPI {
    /**
     * - Add a secret to the application. 
     * @summary Add a secret to the application
     * @param {string} applicationId Application ID
     * @param {SecretRequest} [secretRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationSecretApi
     */
    public createApplicationSecret(applicationId: string, secretRequest?: SecretRequest, options?: AxiosRequestConfig) {
        return ApplicationSecretApiFp(this.configuration).createApplicationSecret(applicationId, secretRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to add an alias at application level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at application level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - Only 1 alias level is allowed. You can\'t create an alias on an alias 
     * @summary Create a secret alias at the application level
     * @param {string} applicationId Application ID
     * @param {string} secretId Secret ID
     * @param {Key} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationSecretApi
     */
    public createApplicationSecretAlias(applicationId: string, secretId: string, key?: Key, options?: AxiosRequestConfig) {
        return ApplicationSecretApiFp(this.configuration).createApplicationSecretAlias(applicationId, secretId, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to override at application level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at application level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
     * @summary Create a secret override at the application level
     * @param {string} applicationId Application ID
     * @param {string} secretId Secret ID
     * @param {Value} [value] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationSecretApi
     */
    public createApplicationSecretOverride(applicationId: string, secretId: string, value?: Value, options?: AxiosRequestConfig) {
        return ApplicationSecretApiFp(this.configuration).createApplicationSecretOverride(applicationId, secretId, value, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well 
     * @summary Delete a secret from an application
     * @param {string} applicationId Application ID
     * @param {string} secretId Secret ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationSecretApi
     */
    public deleteApplicationSecret(applicationId: string, secretId: string, options?: AxiosRequestConfig) {
        return ApplicationSecretApiFp(this.configuration).deleteApplicationSecret(applicationId, secretId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
     * @summary Edit a secret belonging to the application
     * @param {string} applicationId Application ID
     * @param {string} secretId Secret ID
     * @param {SecretEditRequest} secretEditRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationSecretApi
     */
    public editApplicationSecret(applicationId: string, secretId: string, secretEditRequest: SecretEditRequest, options?: AxiosRequestConfig) {
        return ApplicationSecretApiFp(this.configuration).editApplicationSecret(applicationId, secretId, secretEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Secrets are like environment variables, but they are secured and can\'t be revealed.
     * @summary List application secrets
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationSecretApi
     */
    public listApplicationSecrets(applicationId: string, options?: AxiosRequestConfig) {
        return ApplicationSecretApiFp(this.configuration).listApplicationSecrets(applicationId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ApplicationsApi - axios parameter creator
 * @export
 */
export const ApplicationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This will create a new application with the same configuration on the targeted environment Id.
         * @summary Clone application
         * @param {string} applicationId Application ID
         * @param {CloneApplicationRequest} [cloneApplicationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneApplication: async (applicationId: string, cloneApplicationRequest?: CloneApplicationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('cloneApplication', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/clone`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloneApplicationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an application
         * @param {string} environmentId Environment ID
         * @param {ApplicationRequest} [applicationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplication: async (environmentId: string, applicationRequest?: ApplicationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('createApplication', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/application`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(applicationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List default application advanced settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultApplicationAdvancedSettings: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/defaultApplicationAdvancedSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns min, max, and running number of instances for each application
         * @summary List current scaling information for each application
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentApplicationCurrentScale: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('getEnvironmentApplicationCurrentScale', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/application/currentScale`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List current storage disk usage for each application
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentApplicationCurrentStorage: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('getEnvironmentApplicationCurrentStorage', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/application/currentStorage`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of applications with only their id and status.
         * @summary List all environment applications statuses
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentApplicationStatus: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('getEnvironmentApplicationStatus', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/application/status`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns list of languages supported by Buildpacks.
         * @summary List supported languages
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentApplicationSupportedLanguages: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('getEnvironmentApplicationSupportedLanguages', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/application/supportedLanguage`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List applications
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplication: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('listApplication', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/application`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationsApi - functional programming interface
 * @export
 */
export const ApplicationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationsApiAxiosParamCreator(configuration)
    return {
        /**
         * This will create a new application with the same configuration on the targeted environment Id.
         * @summary Clone application
         * @param {string} applicationId Application ID
         * @param {CloneApplicationRequest} [cloneApplicationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloneApplication(applicationId: string, cloneApplicationRequest?: CloneApplicationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Application>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cloneApplication(applicationId, cloneApplicationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create an application
         * @param {string} environmentId Environment ID
         * @param {ApplicationRequest} [applicationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplication(environmentId: string, applicationRequest?: ApplicationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Application>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplication(environmentId, applicationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List default application advanced settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDefaultApplicationAdvancedSettings(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationAdvancedSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDefaultApplicationAdvancedSettings(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns min, max, and running number of instances for each application
         * @summary List current scaling information for each application
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironmentApplicationCurrentScale(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentApplicationsCurrentScaleResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironmentApplicationCurrentScale(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List current storage disk usage for each application
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironmentApplicationCurrentStorage(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentApplicationsStorageResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironmentApplicationCurrentStorage(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of applications with only their id and status.
         * @summary List all environment applications statuses
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironmentApplicationStatus(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReferenceObjectStatusResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironmentApplicationStatus(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns list of languages supported by Buildpacks.
         * @summary List supported languages
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironmentApplicationSupportedLanguages(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentApplicationsSupportedLanguageList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironmentApplicationSupportedLanguages(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List applications
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplication(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplication(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApplicationsApi - factory interface
 * @export
 */
export const ApplicationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationsApiFp(configuration)
    return {
        /**
         * This will create a new application with the same configuration on the targeted environment Id.
         * @summary Clone application
         * @param {string} applicationId Application ID
         * @param {CloneApplicationRequest} [cloneApplicationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneApplication(applicationId: string, cloneApplicationRequest?: CloneApplicationRequest, options?: any): AxiosPromise<Application> {
            return localVarFp.cloneApplication(applicationId, cloneApplicationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create an application
         * @param {string} environmentId Environment ID
         * @param {ApplicationRequest} [applicationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplication(environmentId: string, applicationRequest?: ApplicationRequest, options?: any): AxiosPromise<Application> {
            return localVarFp.createApplication(environmentId, applicationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List default application advanced settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultApplicationAdvancedSettings(options?: any): AxiosPromise<ApplicationAdvancedSettings> {
            return localVarFp.getDefaultApplicationAdvancedSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns min, max, and running number of instances for each application
         * @summary List current scaling information for each application
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentApplicationCurrentScale(environmentId: string, options?: any): AxiosPromise<EnvironmentApplicationsCurrentScaleResponseList> {
            return localVarFp.getEnvironmentApplicationCurrentScale(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List current storage disk usage for each application
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentApplicationCurrentStorage(environmentId: string, options?: any): AxiosPromise<EnvironmentApplicationsStorageResponseList> {
            return localVarFp.getEnvironmentApplicationCurrentStorage(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of applications with only their id and status.
         * @summary List all environment applications statuses
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentApplicationStatus(environmentId: string, options?: any): AxiosPromise<ReferenceObjectStatusResponseList> {
            return localVarFp.getEnvironmentApplicationStatus(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns list of languages supported by Buildpacks.
         * @summary List supported languages
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentApplicationSupportedLanguages(environmentId: string, options?: any): AxiosPromise<EnvironmentApplicationsSupportedLanguageList> {
            return localVarFp.getEnvironmentApplicationSupportedLanguages(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List applications
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplication(environmentId: string, options?: any): AxiosPromise<ApplicationResponseList> {
            return localVarFp.listApplication(environmentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationsApi - object-oriented interface
 * @export
 * @class ApplicationsApi
 * @extends {BaseAPI}
 */
export class ApplicationsApi extends BaseAPI {
    /**
     * This will create a new application with the same configuration on the targeted environment Id.
     * @summary Clone application
     * @param {string} applicationId Application ID
     * @param {CloneApplicationRequest} [cloneApplicationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public cloneApplication(applicationId: string, cloneApplicationRequest?: CloneApplicationRequest, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).cloneApplication(applicationId, cloneApplicationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create an application
     * @param {string} environmentId Environment ID
     * @param {ApplicationRequest} [applicationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public createApplication(environmentId: string, applicationRequest?: ApplicationRequest, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).createApplication(environmentId, applicationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List default application advanced settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public getDefaultApplicationAdvancedSettings(options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).getDefaultApplicationAdvancedSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns min, max, and running number of instances for each application
     * @summary List current scaling information for each application
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public getEnvironmentApplicationCurrentScale(environmentId: string, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).getEnvironmentApplicationCurrentScale(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List current storage disk usage for each application
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public getEnvironmentApplicationCurrentStorage(environmentId: string, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).getEnvironmentApplicationCurrentStorage(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of applications with only their id and status.
     * @summary List all environment applications statuses
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public getEnvironmentApplicationStatus(environmentId: string, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).getEnvironmentApplicationStatus(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns list of languages supported by Buildpacks.
     * @summary List supported languages
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public getEnvironmentApplicationSupportedLanguages(environmentId: string, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).getEnvironmentApplicationSupportedLanguages(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List applications
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public listApplication(environmentId: string, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).listApplication(environmentId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BackupsApi - axios parameter creator
 * @export
 */
export const BackupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a backup to the Database 
         * @param {string} databaseId Database ID
         * @param {BackupRequest} [backupRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addBackupDatabase: async (databaseId: string, backupRequest?: BackupRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('addBackupDatabase', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}/backup`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(backupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter
         * @summary List database  backups
         * @param {string} databaseId Database ID
         * @param {string} [startId] Starting point after which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseBackup: async (databaseId: string, startId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('listDatabaseBackup', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}/backup`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (startId !== undefined) {
                localVarQueryParameter['startId'] = startId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove database  backup
         * @param {string} databaseId Database ID
         * @param {string} backupId Database Backup ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDatabaseBackup: async (databaseId: string, backupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('removeDatabaseBackup', 'databaseId', databaseId)
            // verify required parameter 'backupId' is not null or undefined
            assertParamExists('removeDatabaseBackup', 'backupId', backupId)
            const localVarPath = `/database/{databaseId}/backup/{backupId}`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)))
                .replace(`{${"backupId"}}`, encodeURIComponent(String(backupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BackupsApi - functional programming interface
 * @export
 */
export const BackupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BackupsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a backup to the Database 
         * @param {string} databaseId Database ID
         * @param {BackupRequest} [backupRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addBackupDatabase(databaseId: string, backupRequest?: BackupRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Backup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addBackupDatabase(databaseId, backupRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter
         * @summary List database  backups
         * @param {string} databaseId Database ID
         * @param {string} [startId] Starting point after which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDatabaseBackup(databaseId: string, startId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BackupPaginatedResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDatabaseBackup(databaseId, startId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove database  backup
         * @param {string} databaseId Database ID
         * @param {string} backupId Database Backup ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeDatabaseBackup(databaseId: string, backupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeDatabaseBackup(databaseId, backupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BackupsApi - factory interface
 * @export
 */
export const BackupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BackupsApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a backup to the Database 
         * @param {string} databaseId Database ID
         * @param {BackupRequest} [backupRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addBackupDatabase(databaseId: string, backupRequest?: BackupRequest, options?: any): AxiosPromise<Backup> {
            return localVarFp.addBackupDatabase(databaseId, backupRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter
         * @summary List database  backups
         * @param {string} databaseId Database ID
         * @param {string} [startId] Starting point after which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseBackup(databaseId: string, startId?: string, options?: any): AxiosPromise<BackupPaginatedResponseList> {
            return localVarFp.listDatabaseBackup(databaseId, startId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove database  backup
         * @param {string} databaseId Database ID
         * @param {string} backupId Database Backup ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDatabaseBackup(databaseId: string, backupId: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeDatabaseBackup(databaseId, backupId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BackupsApi - object-oriented interface
 * @export
 * @class BackupsApi
 * @extends {BaseAPI}
 */
export class BackupsApi extends BaseAPI {
    /**
     * 
     * @summary Add a backup to the Database 
     * @param {string} databaseId Database ID
     * @param {BackupRequest} [backupRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackupsApi
     */
    public addBackupDatabase(databaseId: string, backupRequest?: BackupRequest, options?: AxiosRequestConfig) {
        return BackupsApiFp(this.configuration).addBackupDatabase(databaseId, backupRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter
     * @summary List database  backups
     * @param {string} databaseId Database ID
     * @param {string} [startId] Starting point after which to return results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackupsApi
     */
    public listDatabaseBackup(databaseId: string, startId?: string, options?: AxiosRequestConfig) {
        return BackupsApiFp(this.configuration).listDatabaseBackup(databaseId, startId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove database  backup
     * @param {string} databaseId Database ID
     * @param {string} backupId Database Backup ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackupsApi
     */
    public removeDatabaseBackup(databaseId: string, backupId: string, options?: AxiosRequestConfig) {
        return BackupsApiFp(this.configuration).removeDatabaseBackup(databaseId, backupId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BillingApi - axios parameter creator
 * @export
 */
export const BillingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add credit card
         * @param {string} organizationId Organization ID
         * @param {CreditCardRequest} [creditCardRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCreditCard: async (organizationId: string, creditCardRequest?: CreditCardRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('addCreditCard', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/creditCard`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(creditCardRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add credit code
         * @param {string} organizationId Organization ID
         * @param {OrganizationCreditCodeRequest} [organizationCreditCodeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCreditCode: async (organizationId: string, organizationCreditCodeRequest?: OrganizationCreditCodeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('addCreditCode', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/creditCode`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationCreditCodeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Change organization plan
         * @param {string} organizationId Organization ID
         * @param {OrganizationChangePlanRequest} [organizationChangePlanRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePlan: async (organizationId: string, organizationChangePlanRequest?: OrganizationChangePlanRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('changePlan', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/changePlan`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationChangePlanRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete credit card
         * @param {string} organizationId Organization ID
         * @param {string} creditCardId Credit Card ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCreditCard: async (organizationId: string, creditCardId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteCreditCard', 'organizationId', organizationId)
            // verify required parameter 'creditCardId' is not null or undefined
            assertParamExists('deleteCreditCard', 'creditCardId', creditCardId)
            const localVarPath = `/organization/{organizationId}/creditCard/{creditCardId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"creditCardId"}}`, encodeURIComponent(String(creditCardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit Organization Billing Info
         * @param {string} organizationId Organization ID
         * @param {BillingInfoRequest} [billingInfoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editOrganizationBillingInfo: async (organizationId: string, billingInfoRequest?: BillingInfoRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('editOrganizationBillingInfo', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/billingInfo`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(billingInfoRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get your cluster cost range. We are unable to give a precise cost of your infrastructure at the moment. But Qovery guarantees that the cost of your cluster will not exceed the max range. 
         * @summary Get cluster current cost
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterCurrentCost: async (organizationId: string, clusterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getClusterCurrentCost', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('getClusterCurrentCost', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}/currentCost`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get organization billing info
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationBillingInfo: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationBillingInfo', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/billingInfo`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns a \"is_valid\" boolean field reflecting the billing status of the organization: - If true, the organization billing is valid - For Startup organization, it returns false if there is at least 1 invoice unpaid since 1 week - For Community organization, it returns false if there is no credit left 
         * @summary Get organization billing status
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationBillingStatus: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationBillingStatus', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/billingStatus`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get organization current cost
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationCurrentCost: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationCurrentCost', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/currentCost`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get organization invoice
         * @param {string} organizationId Organization ID
         * @param {string} invoiceId Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationInvoice: async (organizationId: string, invoiceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationInvoice', 'organizationId', organizationId)
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('getOrganizationInvoice', 'invoiceId', invoiceId)
            const localVarPath = `/organization/{organizationId}/invoice/{invoiceId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This will return URL of the invoice PDF
         * @summary Get invoice link
         * @param {string} organizationId Organization ID
         * @param {string} invoiceId Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationInvoicePDF: async (organizationId: string, invoiceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationInvoicePDF', 'organizationId', organizationId)
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('getOrganizationInvoicePDF', 'invoiceId', invoiceId)
            const localVarPath = `/organization/{organizationId}/invoice/{invoiceId}/download`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List organization credit cards
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationCreditCards: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listOrganizationCreditCards', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/creditCard`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List organization invoices
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationInvoice: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listOrganizationInvoice', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/invoice`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download all invoices
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationDownloadAllInvoices: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('organizationDownloadAllInvoices', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/downloadInvoices`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BillingApi - functional programming interface
 * @export
 */
export const BillingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BillingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add credit card
         * @param {string} organizationId Organization ID
         * @param {CreditCardRequest} [creditCardRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addCreditCard(organizationId: string, creditCardRequest?: CreditCardRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditCard>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addCreditCard(organizationId, creditCardRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add credit code
         * @param {string} organizationId Organization ID
         * @param {OrganizationCreditCodeRequest} [organizationCreditCodeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addCreditCode(organizationId: string, organizationCreditCodeRequest?: OrganizationCreditCodeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addCreditCode(organizationId, organizationCreditCodeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Change organization plan
         * @param {string} organizationId Organization ID
         * @param {OrganizationChangePlanRequest} [organizationChangePlanRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changePlan(organizationId: string, organizationChangePlanRequest?: OrganizationChangePlanRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changePlan(organizationId, organizationChangePlanRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete credit card
         * @param {string} organizationId Organization ID
         * @param {string} creditCardId Credit Card ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCreditCard(organizationId: string, creditCardId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCreditCard(organizationId, creditCardId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit Organization Billing Info
         * @param {string} organizationId Organization ID
         * @param {BillingInfoRequest} [billingInfoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editOrganizationBillingInfo(organizationId: string, billingInfoRequest?: BillingInfoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BillingInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editOrganizationBillingInfo(organizationId, billingInfoRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get your cluster cost range. We are unable to give a precise cost of your infrastructure at the moment. But Qovery guarantees that the cost of your cluster will not exceed the max range. 
         * @summary Get cluster current cost
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClusterCurrentCost(organizationId: string, clusterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CostRange>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClusterCurrentCost(organizationId, clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get organization billing info
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationBillingInfo(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BillingInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationBillingInfo(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns a \"is_valid\" boolean field reflecting the billing status of the organization: - If true, the organization billing is valid - For Startup organization, it returns false if there is at least 1 invoice unpaid since 1 week - For Community organization, it returns false if there is no credit left 
         * @summary Get organization billing status
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationBillingStatus(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BillingStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationBillingStatus(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get organization current cost
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationCurrentCost(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationCurrentCost>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationCurrentCost(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get organization invoice
         * @param {string} organizationId Organization ID
         * @param {string} invoiceId Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationInvoice(organizationId: string, invoiceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invoice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationInvoice(organizationId, invoiceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This will return URL of the invoice PDF
         * @summary Get invoice link
         * @param {string} organizationId Organization ID
         * @param {string} invoiceId Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationInvoicePDF(organizationId: string, invoiceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Link>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationInvoicePDF(organizationId, invoiceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List organization credit cards
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizationCreditCards(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditCardResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationCreditCards(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List organization invoices
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizationInvoice(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationInvoice(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Download all invoices
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationDownloadAllInvoices(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationDownloadAllInvoices(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BillingApi - factory interface
 * @export
 */
export const BillingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BillingApiFp(configuration)
    return {
        /**
         * 
         * @summary Add credit card
         * @param {string} organizationId Organization ID
         * @param {CreditCardRequest} [creditCardRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCreditCard(organizationId: string, creditCardRequest?: CreditCardRequest, options?: any): AxiosPromise<CreditCard> {
            return localVarFp.addCreditCard(organizationId, creditCardRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add credit code
         * @param {string} organizationId Organization ID
         * @param {OrganizationCreditCodeRequest} [organizationCreditCodeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCreditCode(organizationId: string, organizationCreditCodeRequest?: OrganizationCreditCodeRequest, options?: any): AxiosPromise<void> {
            return localVarFp.addCreditCode(organizationId, organizationCreditCodeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Change organization plan
         * @param {string} organizationId Organization ID
         * @param {OrganizationChangePlanRequest} [organizationChangePlanRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePlan(organizationId: string, organizationChangePlanRequest?: OrganizationChangePlanRequest, options?: any): AxiosPromise<Organization> {
            return localVarFp.changePlan(organizationId, organizationChangePlanRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete credit card
         * @param {string} organizationId Organization ID
         * @param {string} creditCardId Credit Card ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCreditCard(organizationId: string, creditCardId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCreditCard(organizationId, creditCardId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit Organization Billing Info
         * @param {string} organizationId Organization ID
         * @param {BillingInfoRequest} [billingInfoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editOrganizationBillingInfo(organizationId: string, billingInfoRequest?: BillingInfoRequest, options?: any): AxiosPromise<BillingInfo> {
            return localVarFp.editOrganizationBillingInfo(organizationId, billingInfoRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get your cluster cost range. We are unable to give a precise cost of your infrastructure at the moment. But Qovery guarantees that the cost of your cluster will not exceed the max range. 
         * @summary Get cluster current cost
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterCurrentCost(organizationId: string, clusterId: string, options?: any): AxiosPromise<CostRange> {
            return localVarFp.getClusterCurrentCost(organizationId, clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get organization billing info
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationBillingInfo(organizationId: string, options?: any): AxiosPromise<BillingInfo> {
            return localVarFp.getOrganizationBillingInfo(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a \"is_valid\" boolean field reflecting the billing status of the organization: - If true, the organization billing is valid - For Startup organization, it returns false if there is at least 1 invoice unpaid since 1 week - For Community organization, it returns false if there is no credit left 
         * @summary Get organization billing status
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationBillingStatus(organizationId: string, options?: any): AxiosPromise<BillingStatus> {
            return localVarFp.getOrganizationBillingStatus(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get organization current cost
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationCurrentCost(organizationId: string, options?: any): AxiosPromise<OrganizationCurrentCost> {
            return localVarFp.getOrganizationCurrentCost(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get organization invoice
         * @param {string} organizationId Organization ID
         * @param {string} invoiceId Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationInvoice(organizationId: string, invoiceId: string, options?: any): AxiosPromise<Invoice> {
            return localVarFp.getOrganizationInvoice(organizationId, invoiceId, options).then((request) => request(axios, basePath));
        },
        /**
         * This will return URL of the invoice PDF
         * @summary Get invoice link
         * @param {string} organizationId Organization ID
         * @param {string} invoiceId Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationInvoicePDF(organizationId: string, invoiceId: string, options?: any): AxiosPromise<Link> {
            return localVarFp.getOrganizationInvoicePDF(organizationId, invoiceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List organization credit cards
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationCreditCards(organizationId: string, options?: any): AxiosPromise<CreditCardResponseList> {
            return localVarFp.listOrganizationCreditCards(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List organization invoices
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationInvoice(organizationId: string, options?: any): AxiosPromise<InvoiceResponseList> {
            return localVarFp.listOrganizationInvoice(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download all invoices
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationDownloadAllInvoices(organizationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.organizationDownloadAllInvoices(organizationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BillingApi - object-oriented interface
 * @export
 * @class BillingApi
 * @extends {BaseAPI}
 */
export class BillingApi extends BaseAPI {
    /**
     * 
     * @summary Add credit card
     * @param {string} organizationId Organization ID
     * @param {CreditCardRequest} [creditCardRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public addCreditCard(organizationId: string, creditCardRequest?: CreditCardRequest, options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).addCreditCard(organizationId, creditCardRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add credit code
     * @param {string} organizationId Organization ID
     * @param {OrganizationCreditCodeRequest} [organizationCreditCodeRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public addCreditCode(organizationId: string, organizationCreditCodeRequest?: OrganizationCreditCodeRequest, options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).addCreditCode(organizationId, organizationCreditCodeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Change organization plan
     * @param {string} organizationId Organization ID
     * @param {OrganizationChangePlanRequest} [organizationChangePlanRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public changePlan(organizationId: string, organizationChangePlanRequest?: OrganizationChangePlanRequest, options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).changePlan(organizationId, organizationChangePlanRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete credit card
     * @param {string} organizationId Organization ID
     * @param {string} creditCardId Credit Card ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public deleteCreditCard(organizationId: string, creditCardId: string, options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).deleteCreditCard(organizationId, creditCardId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit Organization Billing Info
     * @param {string} organizationId Organization ID
     * @param {BillingInfoRequest} [billingInfoRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public editOrganizationBillingInfo(organizationId: string, billingInfoRequest?: BillingInfoRequest, options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).editOrganizationBillingInfo(organizationId, billingInfoRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get your cluster cost range. We are unable to give a precise cost of your infrastructure at the moment. But Qovery guarantees that the cost of your cluster will not exceed the max range. 
     * @summary Get cluster current cost
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getClusterCurrentCost(organizationId: string, clusterId: string, options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).getClusterCurrentCost(organizationId, clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get organization billing info
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getOrganizationBillingInfo(organizationId: string, options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).getOrganizationBillingInfo(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns a \"is_valid\" boolean field reflecting the billing status of the organization: - If true, the organization billing is valid - For Startup organization, it returns false if there is at least 1 invoice unpaid since 1 week - For Community organization, it returns false if there is no credit left 
     * @summary Get organization billing status
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getOrganizationBillingStatus(organizationId: string, options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).getOrganizationBillingStatus(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get organization current cost
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getOrganizationCurrentCost(organizationId: string, options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).getOrganizationCurrentCost(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get organization invoice
     * @param {string} organizationId Organization ID
     * @param {string} invoiceId Invoice ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getOrganizationInvoice(organizationId: string, invoiceId: string, options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).getOrganizationInvoice(organizationId, invoiceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will return URL of the invoice PDF
     * @summary Get invoice link
     * @param {string} organizationId Organization ID
     * @param {string} invoiceId Invoice ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getOrganizationInvoicePDF(organizationId: string, invoiceId: string, options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).getOrganizationInvoicePDF(organizationId, invoiceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List organization credit cards
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public listOrganizationCreditCards(organizationId: string, options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).listOrganizationCreditCards(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List organization invoices
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public listOrganizationInvoice(organizationId: string, options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).listOrganizationInvoice(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download all invoices
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public organizationDownloadAllInvoices(organizationId: string, options?: AxiosRequestConfig) {
        return BillingApiFp(this.configuration).organizationDownloadAllInvoices(organizationId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CloudProviderApi - axios parameter creator
 * @export
 */
export const CloudProviderApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List AWS EKS available instance types
         * @param {string} region region name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAWSEKSInstanceType: async (region: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'region' is not null or undefined
            assertParamExists('listAWSEKSInstanceType', 'region', region)
            const localVarPath = `/aws/eks/instanceType/{region}`
                .replace(`{${"region"}}`, encodeURIComponent(String(region)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List AWS EC2 available instance types
         * @param {string} region region name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAWSEc2InstanceType: async (region: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'region' is not null or undefined
            assertParamExists('listAWSEc2InstanceType', 'region', region)
            const localVarPath = `/aws/ec2/instanceType/{region}`
                .replace(`{${"region"}}`, encodeURIComponent(String(region)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List AWS features available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAWSFeatures: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/aws/clusterFeature`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List AWS available instance types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAWSInstanceType: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/aws/instanceType`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List AWS available managed database instance types
         * @param {string} region region name
         * @param {string} databaseType Database type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAWSManagedDatabaseInstanceType: async (region: string, databaseType: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'region' is not null or undefined
            assertParamExists('listAWSManagedDatabaseInstanceType', 'region', region)
            // verify required parameter 'databaseType' is not null or undefined
            assertParamExists('listAWSManagedDatabaseInstanceType', 'databaseType', databaseType)
            const localVarPath = `/aws/managedDatabase/instanceType/{region}/{databaseType}`
                .replace(`{${"region"}}`, encodeURIComponent(String(region)))
                .replace(`{${"databaseType"}}`, encodeURIComponent(String(databaseType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List AWS available managed database types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAWSManagedDatabaseType: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/aws/managedDatabase/type`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List AWS regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAWSRegions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/aws/region`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Cloud providers available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCloudProvider: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cloudProvider`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List DO features available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDOFeatures: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/digitalOcean/clusterFeature`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List DO available instance types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDOInstanceType: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/digitalOcean/instanceType`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Digital Ocean available managed database instance types
         * @param {string} region region name
         * @param {string} databaseType Database type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDOManagedDatabaseInstanceType: async (region: string, databaseType: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'region' is not null or undefined
            assertParamExists('listDOManagedDatabaseInstanceType', 'region', region)
            // verify required parameter 'databaseType' is not null or undefined
            assertParamExists('listDOManagedDatabaseInstanceType', 'databaseType', databaseType)
            const localVarPath = `/digitalOcean/managedDatabase/instanceType/{region}/{databaseType}`
                .replace(`{${"region"}}`, encodeURIComponent(String(region)))
                .replace(`{${"databaseType"}}`, encodeURIComponent(String(databaseType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Digital Ocean available managed database types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDOManagedDatabaseType: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/digitalOcean/managedDatabase/type`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List DO regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDORegions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/digitalOcean/region`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Scaleway available managed database instance types
         * @param {string} databaseType Database type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSCWManagedDatabaseInstanceType: async (databaseType: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseType' is not null or undefined
            assertParamExists('listSCWManagedDatabaseInstanceType', 'databaseType', databaseType)
            const localVarPath = `/scaleway/managedDatabase/instanceType/{zone}/{databaseType}`
                .replace(`{${"databaseType"}}`, encodeURIComponent(String(databaseType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Scaleway available managed database types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSCWManagedDatabaseType: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/scaleway/managedDatabase/type`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Scaleway features available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScalewayFeatures: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/scaleway/clusterFeature`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Scaleway available instance types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScalewayInstanceType: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/scaleway/instanceType`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Scaleway Kapsule available instance types
         * @param {string} zone zone name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScalewayKapsuleInstanceType: async (zone: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zone' is not null or undefined
            assertParamExists('listScalewayKapsuleInstanceType', 'zone', zone)
            const localVarPath = `/scaleway/instanceType/{zone}`
                .replace(`{${"zone"}}`, encodeURIComponent(String(zone)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Scaleway regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScalewayRegions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/scaleway/region`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CloudProviderApi - functional programming interface
 * @export
 */
export const CloudProviderApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CloudProviderApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List AWS EKS available instance types
         * @param {string} region region name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAWSEKSInstanceType(region: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterInstanceTypeResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAWSEKSInstanceType(region, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List AWS EC2 available instance types
         * @param {string} region region name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAWSEc2InstanceType(region: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterInstanceTypeResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAWSEc2InstanceType(region, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List AWS features available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAWSFeatures(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterFeatureResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAWSFeatures(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List AWS available instance types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAWSInstanceType(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterInstanceTypeResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAWSInstanceType(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List AWS available managed database instance types
         * @param {string} region region name
         * @param {string} databaseType Database type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAWSManagedDatabaseInstanceType(region: string, databaseType: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManagedDatabaseInstanceTypeResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAWSManagedDatabaseInstanceType(region, databaseType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List AWS available managed database types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAWSManagedDatabaseType(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManagedDatabaseTypeResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAWSManagedDatabaseType(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List AWS regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAWSRegions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterRegionResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAWSRegions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Cloud providers available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCloudProvider(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudProviderResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCloudProvider(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List DO features available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDOFeatures(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterFeatureResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDOFeatures(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List DO available instance types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDOInstanceType(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterInstanceTypeResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDOInstanceType(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Digital Ocean available managed database instance types
         * @param {string} region region name
         * @param {string} databaseType Database type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDOManagedDatabaseInstanceType(region: string, databaseType: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManagedDatabaseInstanceTypeResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDOManagedDatabaseInstanceType(region, databaseType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Digital Ocean available managed database types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDOManagedDatabaseType(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManagedDatabaseTypeResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDOManagedDatabaseType(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List DO regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDORegions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterRegionResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDORegions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Scaleway available managed database instance types
         * @param {string} databaseType Database type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSCWManagedDatabaseInstanceType(databaseType: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManagedDatabaseInstanceTypeResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSCWManagedDatabaseInstanceType(databaseType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Scaleway available managed database types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSCWManagedDatabaseType(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManagedDatabaseTypeResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSCWManagedDatabaseType(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Scaleway features available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listScalewayFeatures(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterFeatureResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listScalewayFeatures(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Scaleway available instance types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listScalewayInstanceType(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterInstanceTypeResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listScalewayInstanceType(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Scaleway Kapsule available instance types
         * @param {string} zone zone name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listScalewayKapsuleInstanceType(zone: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterInstanceTypeResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listScalewayKapsuleInstanceType(zone, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Scaleway regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listScalewayRegions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterRegionResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listScalewayRegions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CloudProviderApi - factory interface
 * @export
 */
export const CloudProviderApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CloudProviderApiFp(configuration)
    return {
        /**
         * 
         * @summary List AWS EKS available instance types
         * @param {string} region region name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAWSEKSInstanceType(region: string, options?: any): AxiosPromise<ClusterInstanceTypeResponseList> {
            return localVarFp.listAWSEKSInstanceType(region, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List AWS EC2 available instance types
         * @param {string} region region name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAWSEc2InstanceType(region: string, options?: any): AxiosPromise<ClusterInstanceTypeResponseList> {
            return localVarFp.listAWSEc2InstanceType(region, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List AWS features available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAWSFeatures(options?: any): AxiosPromise<ClusterFeatureResponseList> {
            return localVarFp.listAWSFeatures(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List AWS available instance types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAWSInstanceType(options?: any): AxiosPromise<ClusterInstanceTypeResponseList> {
            return localVarFp.listAWSInstanceType(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List AWS available managed database instance types
         * @param {string} region region name
         * @param {string} databaseType Database type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAWSManagedDatabaseInstanceType(region: string, databaseType: string, options?: any): AxiosPromise<ManagedDatabaseInstanceTypeResponseList> {
            return localVarFp.listAWSManagedDatabaseInstanceType(region, databaseType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List AWS available managed database types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAWSManagedDatabaseType(options?: any): AxiosPromise<ManagedDatabaseTypeResponseList> {
            return localVarFp.listAWSManagedDatabaseType(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List AWS regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAWSRegions(options?: any): AxiosPromise<ClusterRegionResponseList> {
            return localVarFp.listAWSRegions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Cloud providers available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCloudProvider(options?: any): AxiosPromise<CloudProviderResponseList> {
            return localVarFp.listCloudProvider(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List DO features available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDOFeatures(options?: any): AxiosPromise<ClusterFeatureResponseList> {
            return localVarFp.listDOFeatures(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List DO available instance types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDOInstanceType(options?: any): AxiosPromise<ClusterInstanceTypeResponseList> {
            return localVarFp.listDOInstanceType(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Digital Ocean available managed database instance types
         * @param {string} region region name
         * @param {string} databaseType Database type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDOManagedDatabaseInstanceType(region: string, databaseType: string, options?: any): AxiosPromise<ManagedDatabaseInstanceTypeResponseList> {
            return localVarFp.listDOManagedDatabaseInstanceType(region, databaseType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Digital Ocean available managed database types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDOManagedDatabaseType(options?: any): AxiosPromise<ManagedDatabaseTypeResponseList> {
            return localVarFp.listDOManagedDatabaseType(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List DO regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDORegions(options?: any): AxiosPromise<ClusterRegionResponseList> {
            return localVarFp.listDORegions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Scaleway available managed database instance types
         * @param {string} databaseType Database type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSCWManagedDatabaseInstanceType(databaseType: string, options?: any): AxiosPromise<ManagedDatabaseInstanceTypeResponseList> {
            return localVarFp.listSCWManagedDatabaseInstanceType(databaseType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Scaleway available managed database types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSCWManagedDatabaseType(options?: any): AxiosPromise<ManagedDatabaseTypeResponseList> {
            return localVarFp.listSCWManagedDatabaseType(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Scaleway features available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScalewayFeatures(options?: any): AxiosPromise<ClusterFeatureResponseList> {
            return localVarFp.listScalewayFeatures(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Scaleway available instance types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScalewayInstanceType(options?: any): AxiosPromise<ClusterInstanceTypeResponseList> {
            return localVarFp.listScalewayInstanceType(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Scaleway Kapsule available instance types
         * @param {string} zone zone name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScalewayKapsuleInstanceType(zone: string, options?: any): AxiosPromise<ClusterInstanceTypeResponseList> {
            return localVarFp.listScalewayKapsuleInstanceType(zone, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Scaleway regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScalewayRegions(options?: any): AxiosPromise<ClusterRegionResponseList> {
            return localVarFp.listScalewayRegions(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CloudProviderApi - object-oriented interface
 * @export
 * @class CloudProviderApi
 * @extends {BaseAPI}
 */
export class CloudProviderApi extends BaseAPI {
    /**
     * 
     * @summary List AWS EKS available instance types
     * @param {string} region region name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listAWSEKSInstanceType(region: string, options?: AxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listAWSEKSInstanceType(region, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List AWS EC2 available instance types
     * @param {string} region region name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listAWSEc2InstanceType(region: string, options?: AxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listAWSEc2InstanceType(region, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List AWS features available
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listAWSFeatures(options?: AxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listAWSFeatures(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List AWS available instance types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listAWSInstanceType(options?: AxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listAWSInstanceType(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List AWS available managed database instance types
     * @param {string} region region name
     * @param {string} databaseType Database type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listAWSManagedDatabaseInstanceType(region: string, databaseType: string, options?: AxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listAWSManagedDatabaseInstanceType(region, databaseType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List AWS available managed database types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listAWSManagedDatabaseType(options?: AxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listAWSManagedDatabaseType(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List AWS regions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listAWSRegions(options?: AxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listAWSRegions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Cloud providers available
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listCloudProvider(options?: AxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listCloudProvider(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List DO features available
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listDOFeatures(options?: AxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listDOFeatures(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List DO available instance types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listDOInstanceType(options?: AxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listDOInstanceType(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Digital Ocean available managed database instance types
     * @param {string} region region name
     * @param {string} databaseType Database type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listDOManagedDatabaseInstanceType(region: string, databaseType: string, options?: AxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listDOManagedDatabaseInstanceType(region, databaseType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Digital Ocean available managed database types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listDOManagedDatabaseType(options?: AxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listDOManagedDatabaseType(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List DO regions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listDORegions(options?: AxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listDORegions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Scaleway available managed database instance types
     * @param {string} databaseType Database type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listSCWManagedDatabaseInstanceType(databaseType: string, options?: AxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listSCWManagedDatabaseInstanceType(databaseType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Scaleway available managed database types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listSCWManagedDatabaseType(options?: AxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listSCWManagedDatabaseType(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Scaleway features available
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listScalewayFeatures(options?: AxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listScalewayFeatures(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Scaleway available instance types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listScalewayInstanceType(options?: AxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listScalewayInstanceType(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Scaleway Kapsule available instance types
     * @param {string} zone zone name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listScalewayKapsuleInstanceType(zone: string, options?: AxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listScalewayKapsuleInstanceType(zone, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Scaleway regions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderApi
     */
    public listScalewayRegions(options?: AxiosRequestConfig) {
        return CloudProviderApiFp(this.configuration).listScalewayRegions(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CloudProviderCredentialsApi - axios parameter creator
 * @export
 */
export const CloudProviderCredentialsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create AWS credentials set
         * @param {string} organizationId Organization ID
         * @param {AwsCredentialsRequest} [awsCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAWSCredentials: async (organizationId: string, awsCredentialsRequest?: AwsCredentialsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createAWSCredentials', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/aws/credentials`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(awsCredentialsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Digital Ocean credentials set
         * @param {string} organizationId Organization ID
         * @param {DoCredentialsRequest} [doCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDOCredentials: async (organizationId: string, doCredentialsRequest?: DoCredentialsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createDOCredentials', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/digitalOcean/credentials`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(doCredentialsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Scaleway credentials set
         * @param {string} organizationId Organization ID
         * @param {ScalewayCredentialsRequest} [scalewayCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScalewayCredentials: async (organizationId: string, scalewayCredentialsRequest?: ScalewayCredentialsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createScalewayCredentials', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/scaleway/credentials`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scalewayCredentialsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a set of AWS credentials
         * @param {string} credentialsId Credentials ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAWSCredentials: async (credentialsId: string, organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'credentialsId' is not null or undefined
            assertParamExists('deleteAWSCredentials', 'credentialsId', credentialsId)
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteAWSCredentials', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/aws/credentials/{credentialsId}`
                .replace(`{${"credentialsId"}}`, encodeURIComponent(String(credentialsId)))
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a set of Digital Ocean credentials
         * @param {string} credentialsId Credentials ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDOCredentials: async (credentialsId: string, organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'credentialsId' is not null or undefined
            assertParamExists('deleteDOCredentials', 'credentialsId', credentialsId)
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteDOCredentials', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/digitalOcean/credentials/{credentialsId}`
                .replace(`{${"credentialsId"}}`, encodeURIComponent(String(credentialsId)))
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a set of Scaleway credentials
         * @param {string} credentialsId Credentials ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScalewayCredentials: async (credentialsId: string, organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'credentialsId' is not null or undefined
            assertParamExists('deleteScalewayCredentials', 'credentialsId', credentialsId)
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteScalewayCredentials', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/scaleway/credentials/{credentialsId}`
                .replace(`{${"credentialsId"}}`, encodeURIComponent(String(credentialsId)))
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a set of AWS credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {AwsCredentialsRequest} [awsCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editAWSCredentials: async (organizationId: string, credentialsId: string, awsCredentialsRequest?: AwsCredentialsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('editAWSCredentials', 'organizationId', organizationId)
            // verify required parameter 'credentialsId' is not null or undefined
            assertParamExists('editAWSCredentials', 'credentialsId', credentialsId)
            const localVarPath = `/organization/{organizationId}/aws/credentials/{credentialsId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"credentialsId"}}`, encodeURIComponent(String(credentialsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(awsCredentialsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a set of Digital Ocean credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {DoCredentialsRequest} [doCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editDOCredentials: async (organizationId: string, credentialsId: string, doCredentialsRequest?: DoCredentialsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('editDOCredentials', 'organizationId', organizationId)
            // verify required parameter 'credentialsId' is not null or undefined
            assertParamExists('editDOCredentials', 'credentialsId', credentialsId)
            const localVarPath = `/organization/{organizationId}/digitalOcean/credentials/{credentialsId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"credentialsId"}}`, encodeURIComponent(String(credentialsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(doCredentialsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a set of Scaleway credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {ScalewayCredentialsRequest} [scalewayCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editScalewayCredentials: async (organizationId: string, credentialsId: string, scalewayCredentialsRequest?: ScalewayCredentialsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('editScalewayCredentials', 'organizationId', organizationId)
            // verify required parameter 'credentialsId' is not null or undefined
            assertParamExists('editScalewayCredentials', 'credentialsId', credentialsId)
            const localVarPath = `/organization/{organizationId}/scaleway/credentials/{credentialsId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"credentialsId"}}`, encodeURIComponent(String(credentialsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scalewayCredentialsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a set of AWS credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAWSCredentials: async (organizationId: string, credentialsId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getAWSCredentials', 'organizationId', organizationId)
            // verify required parameter 'credentialsId' is not null or undefined
            assertParamExists('getAWSCredentials', 'credentialsId', credentialsId)
            const localVarPath = `/organization/{organizationId}/aws/credentials/{credentialsId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"credentialsId"}}`, encodeURIComponent(String(credentialsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a set of Digital Ocean credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDOCredentials: async (organizationId: string, credentialsId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getDOCredentials', 'organizationId', organizationId)
            // verify required parameter 'credentialsId' is not null or undefined
            assertParamExists('getDOCredentials', 'credentialsId', credentialsId)
            const localVarPath = `/organization/{organizationId}/digitalOcean/credentials/{credentialsId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"credentialsId"}}`, encodeURIComponent(String(credentialsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a set of Scaleway credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScalewayCredentials: async (organizationId: string, credentialsId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getScalewayCredentials', 'organizationId', organizationId)
            // verify required parameter 'credentialsId' is not null or undefined
            assertParamExists('getScalewayCredentials', 'credentialsId', credentialsId)
            const localVarPath = `/organization/{organizationId}/scaleway/credentials/{credentialsId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"credentialsId"}}`, encodeURIComponent(String(credentialsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List AWS credentials
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAWSCredentials: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listAWSCredentials', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/aws/credentials`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List DO credentials
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDOCredentials: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listDOCredentials', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/digitalOcean/credentials`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Scaleway credentials
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScalewayCredentials: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listScalewayCredentials', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/scaleway/credentials`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CloudProviderCredentialsApi - functional programming interface
 * @export
 */
export const CloudProviderCredentialsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CloudProviderCredentialsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create AWS credentials set
         * @param {string} organizationId Organization ID
         * @param {AwsCredentialsRequest} [awsCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAWSCredentials(organizationId: string, awsCredentialsRequest?: AwsCredentialsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentials>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAWSCredentials(organizationId, awsCredentialsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create Digital Ocean credentials set
         * @param {string} organizationId Organization ID
         * @param {DoCredentialsRequest} [doCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDOCredentials(organizationId: string, doCredentialsRequest?: DoCredentialsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentials>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDOCredentials(organizationId, doCredentialsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create Scaleway credentials set
         * @param {string} organizationId Organization ID
         * @param {ScalewayCredentialsRequest} [scalewayCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createScalewayCredentials(organizationId: string, scalewayCredentialsRequest?: ScalewayCredentialsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentials>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createScalewayCredentials(organizationId, scalewayCredentialsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a set of AWS credentials
         * @param {string} credentialsId Credentials ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAWSCredentials(credentialsId: string, organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAWSCredentials(credentialsId, organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a set of Digital Ocean credentials
         * @param {string} credentialsId Credentials ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDOCredentials(credentialsId: string, organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDOCredentials(credentialsId, organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a set of Scaleway credentials
         * @param {string} credentialsId Credentials ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteScalewayCredentials(credentialsId: string, organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteScalewayCredentials(credentialsId, organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit a set of AWS credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {AwsCredentialsRequest} [awsCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editAWSCredentials(organizationId: string, credentialsId: string, awsCredentialsRequest?: AwsCredentialsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentials>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editAWSCredentials(organizationId, credentialsId, awsCredentialsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit a set of Digital Ocean credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {DoCredentialsRequest} [doCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editDOCredentials(organizationId: string, credentialsId: string, doCredentialsRequest?: DoCredentialsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentials>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editDOCredentials(organizationId, credentialsId, doCredentialsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit a set of Scaleway credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {ScalewayCredentialsRequest} [scalewayCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editScalewayCredentials(organizationId: string, credentialsId: string, scalewayCredentialsRequest?: ScalewayCredentialsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentials>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editScalewayCredentials(organizationId, credentialsId, scalewayCredentialsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a set of AWS credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAWSCredentials(organizationId: string, credentialsId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentials>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAWSCredentials(organizationId, credentialsId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a set of Digital Ocean credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDOCredentials(organizationId: string, credentialsId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentials>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDOCredentials(organizationId, credentialsId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a set of Scaleway credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScalewayCredentials(organizationId: string, credentialsId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentials>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScalewayCredentials(organizationId, credentialsId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List AWS credentials
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAWSCredentials(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentialsResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAWSCredentials(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List DO credentials
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDOCredentials(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentialsResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDOCredentials(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Scaleway credentials
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listScalewayCredentials(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentialsResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listScalewayCredentials(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CloudProviderCredentialsApi - factory interface
 * @export
 */
export const CloudProviderCredentialsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CloudProviderCredentialsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create AWS credentials set
         * @param {string} organizationId Organization ID
         * @param {AwsCredentialsRequest} [awsCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAWSCredentials(organizationId: string, awsCredentialsRequest?: AwsCredentialsRequest, options?: any): AxiosPromise<ClusterCredentials> {
            return localVarFp.createAWSCredentials(organizationId, awsCredentialsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Digital Ocean credentials set
         * @param {string} organizationId Organization ID
         * @param {DoCredentialsRequest} [doCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDOCredentials(organizationId: string, doCredentialsRequest?: DoCredentialsRequest, options?: any): AxiosPromise<ClusterCredentials> {
            return localVarFp.createDOCredentials(organizationId, doCredentialsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Scaleway credentials set
         * @param {string} organizationId Organization ID
         * @param {ScalewayCredentialsRequest} [scalewayCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScalewayCredentials(organizationId: string, scalewayCredentialsRequest?: ScalewayCredentialsRequest, options?: any): AxiosPromise<ClusterCredentials> {
            return localVarFp.createScalewayCredentials(organizationId, scalewayCredentialsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a set of AWS credentials
         * @param {string} credentialsId Credentials ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAWSCredentials(credentialsId: string, organizationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAWSCredentials(credentialsId, organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a set of Digital Ocean credentials
         * @param {string} credentialsId Credentials ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDOCredentials(credentialsId: string, organizationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDOCredentials(credentialsId, organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a set of Scaleway credentials
         * @param {string} credentialsId Credentials ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScalewayCredentials(credentialsId: string, organizationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteScalewayCredentials(credentialsId, organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a set of AWS credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {AwsCredentialsRequest} [awsCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editAWSCredentials(organizationId: string, credentialsId: string, awsCredentialsRequest?: AwsCredentialsRequest, options?: any): AxiosPromise<ClusterCredentials> {
            return localVarFp.editAWSCredentials(organizationId, credentialsId, awsCredentialsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a set of Digital Ocean credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {DoCredentialsRequest} [doCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editDOCredentials(organizationId: string, credentialsId: string, doCredentialsRequest?: DoCredentialsRequest, options?: any): AxiosPromise<ClusterCredentials> {
            return localVarFp.editDOCredentials(organizationId, credentialsId, doCredentialsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a set of Scaleway credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {ScalewayCredentialsRequest} [scalewayCredentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editScalewayCredentials(organizationId: string, credentialsId: string, scalewayCredentialsRequest?: ScalewayCredentialsRequest, options?: any): AxiosPromise<ClusterCredentials> {
            return localVarFp.editScalewayCredentials(organizationId, credentialsId, scalewayCredentialsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a set of AWS credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAWSCredentials(organizationId: string, credentialsId: string, options?: any): AxiosPromise<ClusterCredentials> {
            return localVarFp.getAWSCredentials(organizationId, credentialsId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a set of Digital Ocean credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDOCredentials(organizationId: string, credentialsId: string, options?: any): AxiosPromise<ClusterCredentials> {
            return localVarFp.getDOCredentials(organizationId, credentialsId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a set of Scaleway credentials
         * @param {string} organizationId Organization ID
         * @param {string} credentialsId Credentials ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScalewayCredentials(organizationId: string, credentialsId: string, options?: any): AxiosPromise<ClusterCredentials> {
            return localVarFp.getScalewayCredentials(organizationId, credentialsId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List AWS credentials
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAWSCredentials(organizationId: string, options?: any): AxiosPromise<ClusterCredentialsResponseList> {
            return localVarFp.listAWSCredentials(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List DO credentials
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDOCredentials(organizationId: string, options?: any): AxiosPromise<ClusterCredentialsResponseList> {
            return localVarFp.listDOCredentials(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Scaleway credentials
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScalewayCredentials(organizationId: string, options?: any): AxiosPromise<ClusterCredentialsResponseList> {
            return localVarFp.listScalewayCredentials(organizationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CloudProviderCredentialsApi - object-oriented interface
 * @export
 * @class CloudProviderCredentialsApi
 * @extends {BaseAPI}
 */
export class CloudProviderCredentialsApi extends BaseAPI {
    /**
     * 
     * @summary Create AWS credentials set
     * @param {string} organizationId Organization ID
     * @param {AwsCredentialsRequest} [awsCredentialsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public createAWSCredentials(organizationId: string, awsCredentialsRequest?: AwsCredentialsRequest, options?: AxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).createAWSCredentials(organizationId, awsCredentialsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Digital Ocean credentials set
     * @param {string} organizationId Organization ID
     * @param {DoCredentialsRequest} [doCredentialsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public createDOCredentials(organizationId: string, doCredentialsRequest?: DoCredentialsRequest, options?: AxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).createDOCredentials(organizationId, doCredentialsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Scaleway credentials set
     * @param {string} organizationId Organization ID
     * @param {ScalewayCredentialsRequest} [scalewayCredentialsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public createScalewayCredentials(organizationId: string, scalewayCredentialsRequest?: ScalewayCredentialsRequest, options?: AxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).createScalewayCredentials(organizationId, scalewayCredentialsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a set of AWS credentials
     * @param {string} credentialsId Credentials ID
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public deleteAWSCredentials(credentialsId: string, organizationId: string, options?: AxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).deleteAWSCredentials(credentialsId, organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a set of Digital Ocean credentials
     * @param {string} credentialsId Credentials ID
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public deleteDOCredentials(credentialsId: string, organizationId: string, options?: AxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).deleteDOCredentials(credentialsId, organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a set of Scaleway credentials
     * @param {string} credentialsId Credentials ID
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public deleteScalewayCredentials(credentialsId: string, organizationId: string, options?: AxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).deleteScalewayCredentials(credentialsId, organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a set of AWS credentials
     * @param {string} organizationId Organization ID
     * @param {string} credentialsId Credentials ID
     * @param {AwsCredentialsRequest} [awsCredentialsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public editAWSCredentials(organizationId: string, credentialsId: string, awsCredentialsRequest?: AwsCredentialsRequest, options?: AxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).editAWSCredentials(organizationId, credentialsId, awsCredentialsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a set of Digital Ocean credentials
     * @param {string} organizationId Organization ID
     * @param {string} credentialsId Credentials ID
     * @param {DoCredentialsRequest} [doCredentialsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public editDOCredentials(organizationId: string, credentialsId: string, doCredentialsRequest?: DoCredentialsRequest, options?: AxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).editDOCredentials(organizationId, credentialsId, doCredentialsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a set of Scaleway credentials
     * @param {string} organizationId Organization ID
     * @param {string} credentialsId Credentials ID
     * @param {ScalewayCredentialsRequest} [scalewayCredentialsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public editScalewayCredentials(organizationId: string, credentialsId: string, scalewayCredentialsRequest?: ScalewayCredentialsRequest, options?: AxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).editScalewayCredentials(organizationId, credentialsId, scalewayCredentialsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a set of AWS credentials
     * @param {string} organizationId Organization ID
     * @param {string} credentialsId Credentials ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public getAWSCredentials(organizationId: string, credentialsId: string, options?: AxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).getAWSCredentials(organizationId, credentialsId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a set of Digital Ocean credentials
     * @param {string} organizationId Organization ID
     * @param {string} credentialsId Credentials ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public getDOCredentials(organizationId: string, credentialsId: string, options?: AxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).getDOCredentials(organizationId, credentialsId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a set of Scaleway credentials
     * @param {string} organizationId Organization ID
     * @param {string} credentialsId Credentials ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public getScalewayCredentials(organizationId: string, credentialsId: string, options?: AxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).getScalewayCredentials(organizationId, credentialsId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List AWS credentials
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public listAWSCredentials(organizationId: string, options?: AxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).listAWSCredentials(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List DO credentials
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public listDOCredentials(organizationId: string, options?: AxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).listDOCredentials(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Scaleway credentials
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProviderCredentialsApi
     */
    public listScalewayCredentials(organizationId: string, options?: AxiosRequestConfig) {
        return CloudProviderCredentialsApiFp(this.configuration).listScalewayCredentials(organizationId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ClustersApi - axios parameter creator
 * @export
 */
export const ClustersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a cluster
         * @param {string} organizationId Organization ID
         * @param {ClusterRequest} [clusterRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCluster: async (organizationId: string, clusterRequest?: ClusterRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createCluster', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/cluster`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clusterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a cluster
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCluster: async (organizationId: string, clusterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteCluster', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('deleteCluster', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * allows to deploy a cluster
         * @summary Deploy a cluster
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployCluster: async (organizationId: string, clusterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deployCluster', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('deployCluster', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}/deploy`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a cluster
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {ClusterRequest} [clusterRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editCluster: async (organizationId: string, clusterId: string, clusterRequest?: ClusterRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('editCluster', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('editCluster', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clusterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit advanced settings by returning table of advanced settings.
         * @summary Edit advanced settings
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {ClusterAdvancedSettings} [clusterAdvancedSettings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editClusterAdvancedSettings: async (organizationId: string, clusterId: string, clusterAdvancedSettings?: ClusterAdvancedSettings, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('editClusterAdvancedSettings', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('editClusterAdvancedSettings', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}/advancedSettings`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clusterAdvancedSettings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit routing table by returning updated table.
         * @summary Edit routing table
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {ClusterRoutingTableRequest} [clusterRoutingTableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editRoutingTable: async (organizationId: string, clusterId: string, clusterRoutingTableRequest?: ClusterRoutingTableRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('editRoutingTable', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('editRoutingTable', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}/routingTable`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clusterRoutingTableRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list and values of the advanced settings of the cluster.
         * @summary Get advanced settings
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterAdvancedSettings: async (organizationId: string, clusterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getClusterAdvancedSettings', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('getClusterAdvancedSettings', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}/advancedSettings`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Know if a cluster is ready to be deployed or not
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterReadinessStatus: async (organizationId: string, clusterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getClusterReadinessStatus', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('getClusterReadinessStatus', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}/isReady`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get cluster status
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterStatus: async (organizationId: string, clusterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getClusterStatus', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('getClusterStatus', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}/status`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List default cluster advanced settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultClusterAdvancedSettings: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/defaultClusterAdvancedSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get cluster cloud provider info and credentials
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationCloudProviderInfo: async (organizationId: string, clusterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationCloudProviderInfo', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('getOrganizationCloudProviderInfo', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}/cloudProviderInfo`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of clusters with only their id and status.
         * @summary List all clusters statuses
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationClusterStatus: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationClusterStatus', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/cluster/status`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve network routing table where each line corresponds to a route between a destination and a target.
         * @summary Get routing table
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutingTable: async (organizationId: string, clusterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getRoutingTable', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('getRoutingTable', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}/routingTable`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List Cluster Logs
         * @summary List Cluster Logs
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listClusterLogs: async (organizationId: string, clusterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listClusterLogs', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('listClusterLogs', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}/logs`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List organization clusters
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationCluster: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listOrganizationCluster', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/cluster`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Specify cluster cloud provider info and credentials
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {ClusterCloudProviderInfoRequest} [clusterCloudProviderInfoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifyClusterCloudProviderInfo: async (organizationId: string, clusterId: string, clusterCloudProviderInfoRequest?: ClusterCloudProviderInfoRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('specifyClusterCloudProviderInfo', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('specifyClusterCloudProviderInfo', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}/cloudProviderInfo`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clusterCloudProviderInfoRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cluster stop has been requester.
         * @summary Stop cluster
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopCluster: async (organizationId: string, clusterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('stopCluster', 'organizationId', organizationId)
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('stopCluster', 'clusterId', clusterId)
            const localVarPath = `/organization/{organizationId}/cluster/{clusterId}/stop`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClustersApi - functional programming interface
 * @export
 */
export const ClustersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClustersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a cluster
         * @param {string} organizationId Organization ID
         * @param {ClusterRequest} [clusterRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCluster(organizationId: string, clusterRequest?: ClusterRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cluster>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCluster(organizationId, clusterRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a cluster
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCluster(organizationId: string, clusterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCluster(organizationId, clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * allows to deploy a cluster
         * @summary Deploy a cluster
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployCluster(organizationId: string, clusterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployCluster(organizationId, clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit a cluster
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {ClusterRequest} [clusterRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editCluster(organizationId: string, clusterId: string, clusterRequest?: ClusterRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cluster>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editCluster(organizationId, clusterId, clusterRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Edit advanced settings by returning table of advanced settings.
         * @summary Edit advanced settings
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {ClusterAdvancedSettings} [clusterAdvancedSettings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editClusterAdvancedSettings(organizationId: string, clusterId: string, clusterAdvancedSettings?: ClusterAdvancedSettings, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterAdvancedSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editClusterAdvancedSettings(organizationId, clusterId, clusterAdvancedSettings, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Edit routing table by returning updated table.
         * @summary Edit routing table
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {ClusterRoutingTableRequest} [clusterRoutingTableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editRoutingTable(organizationId: string, clusterId: string, clusterRoutingTableRequest?: ClusterRoutingTableRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterRoutingTable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editRoutingTable(organizationId, clusterId, clusterRoutingTableRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get list and values of the advanced settings of the cluster.
         * @summary Get advanced settings
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClusterAdvancedSettings(organizationId: string, clusterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterAdvancedSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClusterAdvancedSettings(organizationId, clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Know if a cluster is ready to be deployed or not
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClusterReadinessStatus(organizationId: string, clusterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterReadinessStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClusterReadinessStatus(organizationId, clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get cluster status
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClusterStatus(organizationId: string, clusterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterStatusGet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClusterStatus(organizationId, clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List default cluster advanced settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDefaultClusterAdvancedSettings(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterAdvancedSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDefaultClusterAdvancedSettings(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get cluster cloud provider info and credentials
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationCloudProviderInfo(organizationId: string, clusterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCloudProviderInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationCloudProviderInfo(organizationId, clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of clusters with only their id and status.
         * @summary List all clusters statuses
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationClusterStatus(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterStatusResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationClusterStatus(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve network routing table where each line corresponds to a route between a destination and a target.
         * @summary Get routing table
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoutingTable(organizationId: string, clusterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterRoutingTable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoutingTable(organizationId, clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List Cluster Logs
         * @summary List Cluster Logs
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listClusterLogs(organizationId: string, clusterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterLogsResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listClusterLogs(organizationId, clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List organization clusters
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizationCluster(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationCluster(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Specify cluster cloud provider info and credentials
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {ClusterCloudProviderInfoRequest} [clusterCloudProviderInfoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async specifyClusterCloudProviderInfo(organizationId: string, clusterId: string, clusterCloudProviderInfoRequest?: ClusterCloudProviderInfoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCloudProviderInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.specifyClusterCloudProviderInfo(organizationId, clusterId, clusterCloudProviderInfoRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Cluster stop has been requester.
         * @summary Stop cluster
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopCluster(organizationId: string, clusterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopCluster(organizationId, clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ClustersApi - factory interface
 * @export
 */
export const ClustersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClustersApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a cluster
         * @param {string} organizationId Organization ID
         * @param {ClusterRequest} [clusterRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCluster(organizationId: string, clusterRequest?: ClusterRequest, options?: any): AxiosPromise<Cluster> {
            return localVarFp.createCluster(organizationId, clusterRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a cluster
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCluster(organizationId: string, clusterId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCluster(organizationId, clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * allows to deploy a cluster
         * @summary Deploy a cluster
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployCluster(organizationId: string, clusterId: string, options?: any): AxiosPromise<ClusterStatus> {
            return localVarFp.deployCluster(organizationId, clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a cluster
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {ClusterRequest} [clusterRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editCluster(organizationId: string, clusterId: string, clusterRequest?: ClusterRequest, options?: any): AxiosPromise<Cluster> {
            return localVarFp.editCluster(organizationId, clusterId, clusterRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit advanced settings by returning table of advanced settings.
         * @summary Edit advanced settings
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {ClusterAdvancedSettings} [clusterAdvancedSettings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editClusterAdvancedSettings(organizationId: string, clusterId: string, clusterAdvancedSettings?: ClusterAdvancedSettings, options?: any): AxiosPromise<ClusterAdvancedSettings> {
            return localVarFp.editClusterAdvancedSettings(organizationId, clusterId, clusterAdvancedSettings, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit routing table by returning updated table.
         * @summary Edit routing table
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {ClusterRoutingTableRequest} [clusterRoutingTableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editRoutingTable(organizationId: string, clusterId: string, clusterRoutingTableRequest?: ClusterRoutingTableRequest, options?: any): AxiosPromise<ClusterRoutingTable> {
            return localVarFp.editRoutingTable(organizationId, clusterId, clusterRoutingTableRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get list and values of the advanced settings of the cluster.
         * @summary Get advanced settings
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterAdvancedSettings(organizationId: string, clusterId: string, options?: any): AxiosPromise<ClusterAdvancedSettings> {
            return localVarFp.getClusterAdvancedSettings(organizationId, clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Know if a cluster is ready to be deployed or not
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterReadinessStatus(organizationId: string, clusterId: string, options?: any): AxiosPromise<ClusterReadinessStatus> {
            return localVarFp.getClusterReadinessStatus(organizationId, clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get cluster status
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterStatus(organizationId: string, clusterId: string, options?: any): AxiosPromise<ClusterStatusGet> {
            return localVarFp.getClusterStatus(organizationId, clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List default cluster advanced settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultClusterAdvancedSettings(options?: any): AxiosPromise<ClusterAdvancedSettings> {
            return localVarFp.getDefaultClusterAdvancedSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get cluster cloud provider info and credentials
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationCloudProviderInfo(organizationId: string, clusterId: string, options?: any): AxiosPromise<ClusterCloudProviderInfo> {
            return localVarFp.getOrganizationCloudProviderInfo(organizationId, clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of clusters with only their id and status.
         * @summary List all clusters statuses
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationClusterStatus(organizationId: string, options?: any): AxiosPromise<ClusterStatusResponseList> {
            return localVarFp.getOrganizationClusterStatus(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve network routing table where each line corresponds to a route between a destination and a target.
         * @summary Get routing table
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutingTable(organizationId: string, clusterId: string, options?: any): AxiosPromise<ClusterRoutingTable> {
            return localVarFp.getRoutingTable(organizationId, clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * List Cluster Logs
         * @summary List Cluster Logs
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listClusterLogs(organizationId: string, clusterId: string, options?: any): AxiosPromise<ClusterLogsResponseList> {
            return localVarFp.listClusterLogs(organizationId, clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List organization clusters
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationCluster(organizationId: string, options?: any): AxiosPromise<ClusterResponseList> {
            return localVarFp.listOrganizationCluster(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Specify cluster cloud provider info and credentials
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {ClusterCloudProviderInfoRequest} [clusterCloudProviderInfoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifyClusterCloudProviderInfo(organizationId: string, clusterId: string, clusterCloudProviderInfoRequest?: ClusterCloudProviderInfoRequest, options?: any): AxiosPromise<ClusterCloudProviderInfo> {
            return localVarFp.specifyClusterCloudProviderInfo(organizationId, clusterId, clusterCloudProviderInfoRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Cluster stop has been requester.
         * @summary Stop cluster
         * @param {string} organizationId Organization ID
         * @param {string} clusterId Cluster ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopCluster(organizationId: string, clusterId: string, options?: any): AxiosPromise<ClusterStatus> {
            return localVarFp.stopCluster(organizationId, clusterId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClustersApi - object-oriented interface
 * @export
 * @class ClustersApi
 * @extends {BaseAPI}
 */
export class ClustersApi extends BaseAPI {
    /**
     * 
     * @summary Create a cluster
     * @param {string} organizationId Organization ID
     * @param {ClusterRequest} [clusterRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public createCluster(organizationId: string, clusterRequest?: ClusterRequest, options?: AxiosRequestConfig) {
        return ClustersApiFp(this.configuration).createCluster(organizationId, clusterRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a cluster
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public deleteCluster(organizationId: string, clusterId: string, options?: AxiosRequestConfig) {
        return ClustersApiFp(this.configuration).deleteCluster(organizationId, clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * allows to deploy a cluster
     * @summary Deploy a cluster
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public deployCluster(organizationId: string, clusterId: string, options?: AxiosRequestConfig) {
        return ClustersApiFp(this.configuration).deployCluster(organizationId, clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a cluster
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {ClusterRequest} [clusterRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public editCluster(organizationId: string, clusterId: string, clusterRequest?: ClusterRequest, options?: AxiosRequestConfig) {
        return ClustersApiFp(this.configuration).editCluster(organizationId, clusterId, clusterRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit advanced settings by returning table of advanced settings.
     * @summary Edit advanced settings
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {ClusterAdvancedSettings} [clusterAdvancedSettings] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public editClusterAdvancedSettings(organizationId: string, clusterId: string, clusterAdvancedSettings?: ClusterAdvancedSettings, options?: AxiosRequestConfig) {
        return ClustersApiFp(this.configuration).editClusterAdvancedSettings(organizationId, clusterId, clusterAdvancedSettings, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit routing table by returning updated table.
     * @summary Edit routing table
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {ClusterRoutingTableRequest} [clusterRoutingTableRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public editRoutingTable(organizationId: string, clusterId: string, clusterRoutingTableRequest?: ClusterRoutingTableRequest, options?: AxiosRequestConfig) {
        return ClustersApiFp(this.configuration).editRoutingTable(organizationId, clusterId, clusterRoutingTableRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list and values of the advanced settings of the cluster.
     * @summary Get advanced settings
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public getClusterAdvancedSettings(organizationId: string, clusterId: string, options?: AxiosRequestConfig) {
        return ClustersApiFp(this.configuration).getClusterAdvancedSettings(organizationId, clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Know if a cluster is ready to be deployed or not
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public getClusterReadinessStatus(organizationId: string, clusterId: string, options?: AxiosRequestConfig) {
        return ClustersApiFp(this.configuration).getClusterReadinessStatus(organizationId, clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get cluster status
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public getClusterStatus(organizationId: string, clusterId: string, options?: AxiosRequestConfig) {
        return ClustersApiFp(this.configuration).getClusterStatus(organizationId, clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List default cluster advanced settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public getDefaultClusterAdvancedSettings(options?: AxiosRequestConfig) {
        return ClustersApiFp(this.configuration).getDefaultClusterAdvancedSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get cluster cloud provider info and credentials
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public getOrganizationCloudProviderInfo(organizationId: string, clusterId: string, options?: AxiosRequestConfig) {
        return ClustersApiFp(this.configuration).getOrganizationCloudProviderInfo(organizationId, clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of clusters with only their id and status.
     * @summary List all clusters statuses
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public getOrganizationClusterStatus(organizationId: string, options?: AxiosRequestConfig) {
        return ClustersApiFp(this.configuration).getOrganizationClusterStatus(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve network routing table where each line corresponds to a route between a destination and a target.
     * @summary Get routing table
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public getRoutingTable(organizationId: string, clusterId: string, options?: AxiosRequestConfig) {
        return ClustersApiFp(this.configuration).getRoutingTable(organizationId, clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List Cluster Logs
     * @summary List Cluster Logs
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public listClusterLogs(organizationId: string, clusterId: string, options?: AxiosRequestConfig) {
        return ClustersApiFp(this.configuration).listClusterLogs(organizationId, clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List organization clusters
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public listOrganizationCluster(organizationId: string, options?: AxiosRequestConfig) {
        return ClustersApiFp(this.configuration).listOrganizationCluster(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Specify cluster cloud provider info and credentials
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {ClusterCloudProviderInfoRequest} [clusterCloudProviderInfoRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public specifyClusterCloudProviderInfo(organizationId: string, clusterId: string, clusterCloudProviderInfoRequest?: ClusterCloudProviderInfoRequest, options?: AxiosRequestConfig) {
        return ClustersApiFp(this.configuration).specifyClusterCloudProviderInfo(organizationId, clusterId, clusterCloudProviderInfoRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cluster stop has been requester.
     * @summary Stop cluster
     * @param {string} organizationId Organization ID
     * @param {string} clusterId Cluster ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public stopCluster(organizationId: string, clusterId: string, options?: AxiosRequestConfig) {
        return ClustersApiFp(this.configuration).stopCluster(organizationId, clusterId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ContainerActionsApi - axios parameter creator
 * @export
 */
export const ContainerActionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * You must provide a git commit id
         * @summary Deploy container
         * @param {string} containerId Container ID
         * @param {ContainerDeployRequest} [containerDeployRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployContainer: async (containerId: string, containerDeployRequest?: ContainerDeployRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('deployContainer', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/deploy`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(containerDeployRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reboot container
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rebootContainer: async (containerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('rebootContainer', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/restart-service`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Redeploy container
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeployContainer: async (containerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('redeployContainer', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/redeploy`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Deprecated** - Please use the \"Redeploy container\" endpoint now
         * @summary Deprecated - Restart container
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartContainer: async (containerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('restartContainer', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/restart`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop container
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopContainer: async (containerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('stopContainer', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/stop`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContainerActionsApi - functional programming interface
 * @export
 */
export const ContainerActionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContainerActionsApiAxiosParamCreator(configuration)
    return {
        /**
         * You must provide a git commit id
         * @summary Deploy container
         * @param {string} containerId Container ID
         * @param {ContainerDeployRequest} [containerDeployRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployContainer(containerId: string, containerDeployRequest?: ContainerDeployRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployContainer(containerId, containerDeployRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Reboot container
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rebootContainer(containerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rebootContainer(containerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Redeploy container
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async redeployContainer(containerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.redeployContainer(containerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **Deprecated** - Please use the \"Redeploy container\" endpoint now
         * @summary Deprecated - Restart container
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restartContainer(containerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restartContainer(containerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Stop container
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopContainer(containerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopContainer(containerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContainerActionsApi - factory interface
 * @export
 */
export const ContainerActionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContainerActionsApiFp(configuration)
    return {
        /**
         * You must provide a git commit id
         * @summary Deploy container
         * @param {string} containerId Container ID
         * @param {ContainerDeployRequest} [containerDeployRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployContainer(containerId: string, containerDeployRequest?: ContainerDeployRequest, options?: any): AxiosPromise<Status> {
            return localVarFp.deployContainer(containerId, containerDeployRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reboot container
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rebootContainer(containerId: string, options?: any): AxiosPromise<Status> {
            return localVarFp.rebootContainer(containerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Redeploy container
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeployContainer(containerId: string, options?: any): AxiosPromise<Status> {
            return localVarFp.redeployContainer(containerId, options).then((request) => request(axios, basePath));
        },
        /**
         * **Deprecated** - Please use the \"Redeploy container\" endpoint now
         * @summary Deprecated - Restart container
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartContainer(containerId: string, options?: any): AxiosPromise<Status> {
            return localVarFp.restartContainer(containerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Stop container
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopContainer(containerId: string, options?: any): AxiosPromise<Status> {
            return localVarFp.stopContainer(containerId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContainerActionsApi - object-oriented interface
 * @export
 * @class ContainerActionsApi
 * @extends {BaseAPI}
 */
export class ContainerActionsApi extends BaseAPI {
    /**
     * You must provide a git commit id
     * @summary Deploy container
     * @param {string} containerId Container ID
     * @param {ContainerDeployRequest} [containerDeployRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerActionsApi
     */
    public deployContainer(containerId: string, containerDeployRequest?: ContainerDeployRequest, options?: AxiosRequestConfig) {
        return ContainerActionsApiFp(this.configuration).deployContainer(containerId, containerDeployRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reboot container
     * @param {string} containerId Container ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerActionsApi
     */
    public rebootContainer(containerId: string, options?: AxiosRequestConfig) {
        return ContainerActionsApiFp(this.configuration).rebootContainer(containerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Redeploy container
     * @param {string} containerId Container ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerActionsApi
     */
    public redeployContainer(containerId: string, options?: AxiosRequestConfig) {
        return ContainerActionsApiFp(this.configuration).redeployContainer(containerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Deprecated** - Please use the \"Redeploy container\" endpoint now
     * @summary Deprecated - Restart container
     * @param {string} containerId Container ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerActionsApi
     */
    public restartContainer(containerId: string, options?: AxiosRequestConfig) {
        return ContainerActionsApiFp(this.configuration).restartContainer(containerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Stop container
     * @param {string} containerId Container ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerActionsApi
     */
    public stopContainer(containerId: string, options?: AxiosRequestConfig) {
        return ContainerActionsApiFp(this.configuration).stopContainer(containerId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ContainerConfigurationApi - axios parameter creator
 * @export
 */
export const ContainerConfigurationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Edit advanced settings by returning table of advanced settings.
         * @summary Edit advanced settings
         * @param {string} containerId Container ID
         * @param {ContainerAdvancedSettings} [containerAdvancedSettings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editContainerAdvancedSettings: async (containerId: string, containerAdvancedSettings?: ContainerAdvancedSettings, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('editContainerAdvancedSettings', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/advancedSettings`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(containerAdvancedSettings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit the Network settings of the container.
         * @summary Edit Container Network
         * @param {string} containerId Container ID
         * @param {ContainerNetworkRequest} [containerNetworkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editContainerNetwork: async (containerId: string, containerNetworkRequest?: ContainerNetworkRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('editContainerNetwork', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/network`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(containerNetworkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list and values of the advanced settings of the container.
         * @summary Get advanced settings
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainerAdvancedSettings: async (containerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('getContainerAdvancedSettings', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/advancedSettings`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get status of the container network settings.
         * @summary Get Container Network information
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainerNetwork: async (containerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('getContainerNetwork', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/network`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContainerConfigurationApi - functional programming interface
 * @export
 */
export const ContainerConfigurationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContainerConfigurationApiAxiosParamCreator(configuration)
    return {
        /**
         * Edit advanced settings by returning table of advanced settings.
         * @summary Edit advanced settings
         * @param {string} containerId Container ID
         * @param {ContainerAdvancedSettings} [containerAdvancedSettings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editContainerAdvancedSettings(containerId: string, containerAdvancedSettings?: ContainerAdvancedSettings, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerAdvancedSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editContainerAdvancedSettings(containerId, containerAdvancedSettings, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Edit the Network settings of the container.
         * @summary Edit Container Network
         * @param {string} containerId Container ID
         * @param {ContainerNetworkRequest} [containerNetworkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editContainerNetwork(containerId: string, containerNetworkRequest?: ContainerNetworkRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerNetwork>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editContainerNetwork(containerId, containerNetworkRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get list and values of the advanced settings of the container.
         * @summary Get advanced settings
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContainerAdvancedSettings(containerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerAdvancedSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContainerAdvancedSettings(containerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get status of the container network settings.
         * @summary Get Container Network information
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContainerNetwork(containerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerNetwork>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContainerNetwork(containerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContainerConfigurationApi - factory interface
 * @export
 */
export const ContainerConfigurationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContainerConfigurationApiFp(configuration)
    return {
        /**
         * Edit advanced settings by returning table of advanced settings.
         * @summary Edit advanced settings
         * @param {string} containerId Container ID
         * @param {ContainerAdvancedSettings} [containerAdvancedSettings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editContainerAdvancedSettings(containerId: string, containerAdvancedSettings?: ContainerAdvancedSettings, options?: any): AxiosPromise<ContainerAdvancedSettings> {
            return localVarFp.editContainerAdvancedSettings(containerId, containerAdvancedSettings, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit the Network settings of the container.
         * @summary Edit Container Network
         * @param {string} containerId Container ID
         * @param {ContainerNetworkRequest} [containerNetworkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editContainerNetwork(containerId: string, containerNetworkRequest?: ContainerNetworkRequest, options?: any): AxiosPromise<ContainerNetwork> {
            return localVarFp.editContainerNetwork(containerId, containerNetworkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get list and values of the advanced settings of the container.
         * @summary Get advanced settings
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainerAdvancedSettings(containerId: string, options?: any): AxiosPromise<ContainerAdvancedSettings> {
            return localVarFp.getContainerAdvancedSettings(containerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get status of the container network settings.
         * @summary Get Container Network information
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainerNetwork(containerId: string, options?: any): AxiosPromise<ContainerNetwork> {
            return localVarFp.getContainerNetwork(containerId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContainerConfigurationApi - object-oriented interface
 * @export
 * @class ContainerConfigurationApi
 * @extends {BaseAPI}
 */
export class ContainerConfigurationApi extends BaseAPI {
    /**
     * Edit advanced settings by returning table of advanced settings.
     * @summary Edit advanced settings
     * @param {string} containerId Container ID
     * @param {ContainerAdvancedSettings} [containerAdvancedSettings] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerConfigurationApi
     */
    public editContainerAdvancedSettings(containerId: string, containerAdvancedSettings?: ContainerAdvancedSettings, options?: AxiosRequestConfig) {
        return ContainerConfigurationApiFp(this.configuration).editContainerAdvancedSettings(containerId, containerAdvancedSettings, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit the Network settings of the container.
     * @summary Edit Container Network
     * @param {string} containerId Container ID
     * @param {ContainerNetworkRequest} [containerNetworkRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerConfigurationApi
     */
    public editContainerNetwork(containerId: string, containerNetworkRequest?: ContainerNetworkRequest, options?: AxiosRequestConfig) {
        return ContainerConfigurationApiFp(this.configuration).editContainerNetwork(containerId, containerNetworkRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list and values of the advanced settings of the container.
     * @summary Get advanced settings
     * @param {string} containerId Container ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerConfigurationApi
     */
    public getContainerAdvancedSettings(containerId: string, options?: AxiosRequestConfig) {
        return ContainerConfigurationApiFp(this.configuration).getContainerAdvancedSettings(containerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get status of the container network settings.
     * @summary Get Container Network information
     * @param {string} containerId Container ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerConfigurationApi
     */
    public getContainerNetwork(containerId: string, options?: AxiosRequestConfig) {
        return ContainerConfigurationApiFp(this.configuration).getContainerNetwork(containerId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ContainerCustomDomainApi - axios parameter creator
 * @export
 */
export const ContainerCustomDomainApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a custom domain to this container in order not to use qovery autogenerated domain
         * @summary Add custom domain to the container.
         * @param {string} containerId Container ID
         * @param {CustomDomainRequest} [customDomainRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainerCustomDomain: async (containerId: string, customDomainRequest?: CustomDomainRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('createContainerCustomDomain', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/customDomain`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customDomainRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To delete an CustomDomain you must have the project user permission
         * @summary Delete a Custom Domain
         * @param {string} containerId Container ID
         * @param {string} customDomainId Custom Domain ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContainerCustomDomain: async (containerId: string, customDomainId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('deleteContainerCustomDomain', 'containerId', containerId)
            // verify required parameter 'customDomainId' is not null or undefined
            assertParamExists('deleteContainerCustomDomain', 'customDomainId', customDomainId)
            const localVarPath = `/container/{containerId}/customDomain/{customDomainId}`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"customDomainId"}}`, encodeURIComponent(String(customDomainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To edit a Custom Domain  you must have the project user permission
         * @summary Edit a Custom Domain
         * @param {string} containerId Container ID
         * @param {string} customDomainId Custom Domain ID
         * @param {CustomDomainRequest} [customDomainRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editContainerCustomDomain: async (containerId: string, customDomainId: string, customDomainRequest?: CustomDomainRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('editContainerCustomDomain', 'containerId', containerId)
            // verify required parameter 'customDomainId' is not null or undefined
            assertParamExists('editContainerCustomDomain', 'customDomainId', customDomainId)
            const localVarPath = `/container/{containerId}/customDomain/{customDomainId}`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"customDomainId"}}`, encodeURIComponent(String(customDomainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customDomainRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Custom Domain status
         * @param {string} containerId Container ID
         * @param {string} customDomainId Custom Domain ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainerCustomDomainStatus: async (containerId: string, customDomainId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('getContainerCustomDomainStatus', 'containerId', containerId)
            // verify required parameter 'customDomainId' is not null or undefined
            assertParamExists('getContainerCustomDomainStatus', 'customDomainId', customDomainId)
            const localVarPath = `/container/{containerId}/customDomain/{customDomainId}/status`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"customDomainId"}}`, encodeURIComponent(String(customDomainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List container custom domains
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerCustomDomain: async (containerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('listContainerCustomDomain', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/customDomain`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContainerCustomDomainApi - functional programming interface
 * @export
 */
export const ContainerCustomDomainApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContainerCustomDomainApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a custom domain to this container in order not to use qovery autogenerated domain
         * @summary Add custom domain to the container.
         * @param {string} containerId Container ID
         * @param {CustomDomainRequest} [customDomainRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContainerCustomDomain(containerId: string, customDomainRequest?: CustomDomainRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomDomain>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContainerCustomDomain(containerId, customDomainRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * To delete an CustomDomain you must have the project user permission
         * @summary Delete a Custom Domain
         * @param {string} containerId Container ID
         * @param {string} customDomainId Custom Domain ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteContainerCustomDomain(containerId: string, customDomainId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteContainerCustomDomain(containerId, customDomainId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * To edit a Custom Domain  you must have the project user permission
         * @summary Edit a Custom Domain
         * @param {string} containerId Container ID
         * @param {string} customDomainId Custom Domain ID
         * @param {CustomDomainRequest} [customDomainRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editContainerCustomDomain(containerId: string, customDomainId: string, customDomainRequest?: CustomDomainRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomDomain>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editContainerCustomDomain(containerId, customDomainId, customDomainRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Custom Domain status
         * @param {string} containerId Container ID
         * @param {string} customDomainId Custom Domain ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContainerCustomDomainStatus(containerId: string, customDomainId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomDomain>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContainerCustomDomainStatus(containerId, customDomainId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List container custom domains
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContainerCustomDomain(containerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomDomainResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listContainerCustomDomain(containerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContainerCustomDomainApi - factory interface
 * @export
 */
export const ContainerCustomDomainApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContainerCustomDomainApiFp(configuration)
    return {
        /**
         * Add a custom domain to this container in order not to use qovery autogenerated domain
         * @summary Add custom domain to the container.
         * @param {string} containerId Container ID
         * @param {CustomDomainRequest} [customDomainRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainerCustomDomain(containerId: string, customDomainRequest?: CustomDomainRequest, options?: any): AxiosPromise<CustomDomain> {
            return localVarFp.createContainerCustomDomain(containerId, customDomainRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * To delete an CustomDomain you must have the project user permission
         * @summary Delete a Custom Domain
         * @param {string} containerId Container ID
         * @param {string} customDomainId Custom Domain ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContainerCustomDomain(containerId: string, customDomainId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteContainerCustomDomain(containerId, customDomainId, options).then((request) => request(axios, basePath));
        },
        /**
         * To edit a Custom Domain  you must have the project user permission
         * @summary Edit a Custom Domain
         * @param {string} containerId Container ID
         * @param {string} customDomainId Custom Domain ID
         * @param {CustomDomainRequest} [customDomainRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editContainerCustomDomain(containerId: string, customDomainId: string, customDomainRequest?: CustomDomainRequest, options?: any): AxiosPromise<CustomDomain> {
            return localVarFp.editContainerCustomDomain(containerId, customDomainId, customDomainRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Custom Domain status
         * @param {string} containerId Container ID
         * @param {string} customDomainId Custom Domain ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainerCustomDomainStatus(containerId: string, customDomainId: string, options?: any): AxiosPromise<CustomDomain> {
            return localVarFp.getContainerCustomDomainStatus(containerId, customDomainId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List container custom domains
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerCustomDomain(containerId: string, options?: any): AxiosPromise<CustomDomainResponseList> {
            return localVarFp.listContainerCustomDomain(containerId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContainerCustomDomainApi - object-oriented interface
 * @export
 * @class ContainerCustomDomainApi
 * @extends {BaseAPI}
 */
export class ContainerCustomDomainApi extends BaseAPI {
    /**
     * Add a custom domain to this container in order not to use qovery autogenerated domain
     * @summary Add custom domain to the container.
     * @param {string} containerId Container ID
     * @param {CustomDomainRequest} [customDomainRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerCustomDomainApi
     */
    public createContainerCustomDomain(containerId: string, customDomainRequest?: CustomDomainRequest, options?: AxiosRequestConfig) {
        return ContainerCustomDomainApiFp(this.configuration).createContainerCustomDomain(containerId, customDomainRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To delete an CustomDomain you must have the project user permission
     * @summary Delete a Custom Domain
     * @param {string} containerId Container ID
     * @param {string} customDomainId Custom Domain ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerCustomDomainApi
     */
    public deleteContainerCustomDomain(containerId: string, customDomainId: string, options?: AxiosRequestConfig) {
        return ContainerCustomDomainApiFp(this.configuration).deleteContainerCustomDomain(containerId, customDomainId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To edit a Custom Domain  you must have the project user permission
     * @summary Edit a Custom Domain
     * @param {string} containerId Container ID
     * @param {string} customDomainId Custom Domain ID
     * @param {CustomDomainRequest} [customDomainRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerCustomDomainApi
     */
    public editContainerCustomDomain(containerId: string, customDomainId: string, customDomainRequest?: CustomDomainRequest, options?: AxiosRequestConfig) {
        return ContainerCustomDomainApiFp(this.configuration).editContainerCustomDomain(containerId, customDomainId, customDomainRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Custom Domain status
     * @param {string} containerId Container ID
     * @param {string} customDomainId Custom Domain ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerCustomDomainApi
     */
    public getContainerCustomDomainStatus(containerId: string, customDomainId: string, options?: AxiosRequestConfig) {
        return ContainerCustomDomainApiFp(this.configuration).getContainerCustomDomainStatus(containerId, customDomainId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List container custom domains
     * @param {string} containerId Container ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerCustomDomainApi
     */
    public listContainerCustomDomain(containerId: string, options?: AxiosRequestConfig) {
        return ContainerCustomDomainApiFp(this.configuration).listContainerCustomDomain(containerId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ContainerDeploymentHistoryApi - axios parameter creator
 * @export
 */
export const ContainerDeploymentHistoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the 20 last container deployments
         * @summary List container deployments
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerDeploymentHistory: async (containerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('listContainerDeploymentHistory', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/deploymentHistory`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContainerDeploymentHistoryApi - functional programming interface
 * @export
 */
export const ContainerDeploymentHistoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContainerDeploymentHistoryApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the 20 last container deployments
         * @summary List container deployments
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContainerDeploymentHistory(containerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationData & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listContainerDeploymentHistory(containerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContainerDeploymentHistoryApi - factory interface
 * @export
 */
export const ContainerDeploymentHistoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContainerDeploymentHistoryApiFp(configuration)
    return {
        /**
         * Returns the 20 last container deployments
         * @summary List container deployments
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerDeploymentHistory(containerId: string, options?: any): AxiosPromise<PaginationData & object> {
            return localVarFp.listContainerDeploymentHistory(containerId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContainerDeploymentHistoryApi - object-oriented interface
 * @export
 * @class ContainerDeploymentHistoryApi
 * @extends {BaseAPI}
 */
export class ContainerDeploymentHistoryApi extends BaseAPI {
    /**
     * Returns the 20 last container deployments
     * @summary List container deployments
     * @param {string} containerId Container ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerDeploymentHistoryApi
     */
    public listContainerDeploymentHistory(containerId: string, options?: AxiosRequestConfig) {
        return ContainerDeploymentHistoryApiFp(this.configuration).listContainerDeploymentHistory(containerId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ContainerEnvironmentVariableApi - axios parameter creator
 * @export
 */
export const ContainerEnvironmentVariableApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * - Add an environment variable to the container. 
         * @summary Add an environment variable to the container
         * @param {string} containerId Container ID
         * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainerEnvironmentVariable: async (containerId: string, environmentVariableRequest?: EnvironmentVariableRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('createContainerEnvironmentVariable', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/environmentVariable`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentVariableRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to add an alias at container level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at container level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - Only 1 alias level is allowed. You can\'t create an alias on an alias 
         * @summary Create an environment variable alias at the container level
         * @param {string} containerId Container ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainerEnvironmentVariableAlias: async (containerId: string, environmentVariableId: string, key?: Key, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('createContainerEnvironmentVariableAlias', 'containerId', containerId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('createContainerEnvironmentVariableAlias', 'environmentVariableId', environmentVariableId)
            const localVarPath = `/container/{containerId}/environmentVariable/{environmentVariableId}/alias`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(key, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to override at container level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at container level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
         * @summary Create an environment variable override at the container level
         * @param {string} containerId Container ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainerEnvironmentVariableOverride: async (containerId: string, environmentVariableId: string, value?: Value, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('createContainerEnvironmentVariableOverride', 'containerId', containerId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('createContainerEnvironmentVariableOverride', 'environmentVariableId', environmentVariableId)
            const localVarPath = `/container/{containerId}/environmentVariable/{environmentVariableId}/override`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(value, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - To delete an environment variable from an container you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete an environment variable from a container
         * @param {string} containerId Container ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContainerEnvironmentVariable: async (containerId: string, environmentVariableId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('deleteContainerEnvironmentVariable', 'containerId', containerId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('deleteContainerEnvironmentVariable', 'environmentVariableId', environmentVariableId)
            const localVarPath = `/container/{containerId}/environmentVariable/{environmentVariableId}`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > CONTAINER) 
         * @summary Edit an environment variable belonging to the container
         * @param {string} containerId Container ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editContainerEnvironmentVariable: async (containerId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('editContainerEnvironmentVariable', 'containerId', containerId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('editContainerEnvironmentVariable', 'environmentVariableId', environmentVariableId)
            // verify required parameter 'environmentVariableEditRequest' is not null or undefined
            assertParamExists('editContainerEnvironmentVariable', 'environmentVariableEditRequest', environmentVariableEditRequest)
            const localVarPath = `/container/{containerId}/environmentVariable/{environmentVariableId}`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentVariableEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Import environment variables in a defined scope, with a defined visibility.
         * @summary Import variables
         * @param {string} containerId Container ID
         * @param {VariableImportRequest} [variableImportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importContainerEnvironmentVariable: async (containerId: string, variableImportRequest?: VariableImportRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('importContainerEnvironmentVariable', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/environmentVariable/import`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(variableImportRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List environment variables
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerEnvironmentVariable: async (containerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('listContainerEnvironmentVariable', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/environmentVariable`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContainerEnvironmentVariableApi - functional programming interface
 * @export
 */
export const ContainerEnvironmentVariableApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContainerEnvironmentVariableApiAxiosParamCreator(configuration)
    return {
        /**
         * - Add an environment variable to the container. 
         * @summary Add an environment variable to the container
         * @param {string} containerId Container ID
         * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContainerEnvironmentVariable(containerId: string, environmentVariableRequest?: EnvironmentVariableRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContainerEnvironmentVariable(containerId, environmentVariableRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - Allows you to add an alias at container level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at container level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - Only 1 alias level is allowed. You can\'t create an alias on an alias 
         * @summary Create an environment variable alias at the container level
         * @param {string} containerId Container ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContainerEnvironmentVariableAlias(containerId: string, environmentVariableId: string, key?: Key, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContainerEnvironmentVariableAlias(containerId, environmentVariableId, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - Allows you to override at container level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at container level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
         * @summary Create an environment variable override at the container level
         * @param {string} containerId Container ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContainerEnvironmentVariableOverride(containerId: string, environmentVariableId: string, value?: Value, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContainerEnvironmentVariableOverride(containerId, environmentVariableId, value, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - To delete an environment variable from an container you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete an environment variable from a container
         * @param {string} containerId Container ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteContainerEnvironmentVariable(containerId: string, environmentVariableId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteContainerEnvironmentVariable(containerId, environmentVariableId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > CONTAINER) 
         * @summary Edit an environment variable belonging to the container
         * @param {string} containerId Container ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editContainerEnvironmentVariable(containerId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editContainerEnvironmentVariable(containerId, environmentVariableId, environmentVariableEditRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Import environment variables in a defined scope, with a defined visibility.
         * @summary Import variables
         * @param {string} containerId Container ID
         * @param {VariableImportRequest} [variableImportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importContainerEnvironmentVariable(containerId: string, variableImportRequest?: VariableImportRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariableImport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importContainerEnvironmentVariable(containerId, variableImportRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List environment variables
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContainerEnvironmentVariable(containerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariableResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listContainerEnvironmentVariable(containerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContainerEnvironmentVariableApi - factory interface
 * @export
 */
export const ContainerEnvironmentVariableApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContainerEnvironmentVariableApiFp(configuration)
    return {
        /**
         * - Add an environment variable to the container. 
         * @summary Add an environment variable to the container
         * @param {string} containerId Container ID
         * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainerEnvironmentVariable(containerId: string, environmentVariableRequest?: EnvironmentVariableRequest, options?: any): AxiosPromise<EnvironmentVariable> {
            return localVarFp.createContainerEnvironmentVariable(containerId, environmentVariableRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to add an alias at container level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at container level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - Only 1 alias level is allowed. You can\'t create an alias on an alias 
         * @summary Create an environment variable alias at the container level
         * @param {string} containerId Container ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainerEnvironmentVariableAlias(containerId: string, environmentVariableId: string, key?: Key, options?: any): AxiosPromise<EnvironmentVariable> {
            return localVarFp.createContainerEnvironmentVariableAlias(containerId, environmentVariableId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to override at container level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at container level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
         * @summary Create an environment variable override at the container level
         * @param {string} containerId Container ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainerEnvironmentVariableOverride(containerId: string, environmentVariableId: string, value?: Value, options?: any): AxiosPromise<EnvironmentVariable> {
            return localVarFp.createContainerEnvironmentVariableOverride(containerId, environmentVariableId, value, options).then((request) => request(axios, basePath));
        },
        /**
         * - To delete an environment variable from an container you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete an environment variable from a container
         * @param {string} containerId Container ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContainerEnvironmentVariable(containerId: string, environmentVariableId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteContainerEnvironmentVariable(containerId, environmentVariableId, options).then((request) => request(axios, basePath));
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > CONTAINER) 
         * @summary Edit an environment variable belonging to the container
         * @param {string} containerId Container ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editContainerEnvironmentVariable(containerId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options?: any): AxiosPromise<EnvironmentVariable> {
            return localVarFp.editContainerEnvironmentVariable(containerId, environmentVariableId, environmentVariableEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Import environment variables in a defined scope, with a defined visibility.
         * @summary Import variables
         * @param {string} containerId Container ID
         * @param {VariableImportRequest} [variableImportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importContainerEnvironmentVariable(containerId: string, variableImportRequest?: VariableImportRequest, options?: any): AxiosPromise<VariableImport> {
            return localVarFp.importContainerEnvironmentVariable(containerId, variableImportRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List environment variables
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerEnvironmentVariable(containerId: string, options?: any): AxiosPromise<EnvironmentVariableResponseList> {
            return localVarFp.listContainerEnvironmentVariable(containerId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContainerEnvironmentVariableApi - object-oriented interface
 * @export
 * @class ContainerEnvironmentVariableApi
 * @extends {BaseAPI}
 */
export class ContainerEnvironmentVariableApi extends BaseAPI {
    /**
     * - Add an environment variable to the container. 
     * @summary Add an environment variable to the container
     * @param {string} containerId Container ID
     * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerEnvironmentVariableApi
     */
    public createContainerEnvironmentVariable(containerId: string, environmentVariableRequest?: EnvironmentVariableRequest, options?: AxiosRequestConfig) {
        return ContainerEnvironmentVariableApiFp(this.configuration).createContainerEnvironmentVariable(containerId, environmentVariableRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to add an alias at container level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at container level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - Only 1 alias level is allowed. You can\'t create an alias on an alias 
     * @summary Create an environment variable alias at the container level
     * @param {string} containerId Container ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {Key} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerEnvironmentVariableApi
     */
    public createContainerEnvironmentVariableAlias(containerId: string, environmentVariableId: string, key?: Key, options?: AxiosRequestConfig) {
        return ContainerEnvironmentVariableApiFp(this.configuration).createContainerEnvironmentVariableAlias(containerId, environmentVariableId, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to override at container level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at container level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
     * @summary Create an environment variable override at the container level
     * @param {string} containerId Container ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {Value} [value] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerEnvironmentVariableApi
     */
    public createContainerEnvironmentVariableOverride(containerId: string, environmentVariableId: string, value?: Value, options?: AxiosRequestConfig) {
        return ContainerEnvironmentVariableApiFp(this.configuration).createContainerEnvironmentVariableOverride(containerId, environmentVariableId, value, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - To delete an environment variable from an container you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
     * @summary Delete an environment variable from a container
     * @param {string} containerId Container ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerEnvironmentVariableApi
     */
    public deleteContainerEnvironmentVariable(containerId: string, environmentVariableId: string, options?: AxiosRequestConfig) {
        return ContainerEnvironmentVariableApiFp(this.configuration).deleteContainerEnvironmentVariable(containerId, environmentVariableId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > CONTAINER) 
     * @summary Edit an environment variable belonging to the container
     * @param {string} containerId Container ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerEnvironmentVariableApi
     */
    public editContainerEnvironmentVariable(containerId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options?: AxiosRequestConfig) {
        return ContainerEnvironmentVariableApiFp(this.configuration).editContainerEnvironmentVariable(containerId, environmentVariableId, environmentVariableEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Import environment variables in a defined scope, with a defined visibility.
     * @summary Import variables
     * @param {string} containerId Container ID
     * @param {VariableImportRequest} [variableImportRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerEnvironmentVariableApi
     */
    public importContainerEnvironmentVariable(containerId: string, variableImportRequest?: VariableImportRequest, options?: AxiosRequestConfig) {
        return ContainerEnvironmentVariableApiFp(this.configuration).importContainerEnvironmentVariable(containerId, variableImportRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List environment variables
     * @param {string} containerId Container ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerEnvironmentVariableApi
     */
    public listContainerEnvironmentVariable(containerId: string, options?: AxiosRequestConfig) {
        return ContainerEnvironmentVariableApiFp(this.configuration).listContainerEnvironmentVariable(containerId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ContainerLogsApi - axios parameter creator
 * @export
 */
export const ContainerLogsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This will list the last 1000 logs of the container
         * @summary List logs
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerLog: async (containerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('listContainerLog', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/log`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContainerLogsApi - functional programming interface
 * @export
 */
export const ContainerLogsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContainerLogsApiAxiosParamCreator(configuration)
    return {
        /**
         * This will list the last 1000 logs of the container
         * @summary List logs
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContainerLog(containerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listContainerLog(containerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContainerLogsApi - factory interface
 * @export
 */
export const ContainerLogsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContainerLogsApiFp(configuration)
    return {
        /**
         * This will list the last 1000 logs of the container
         * @summary List logs
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerLog(containerId: string, options?: any): AxiosPromise<LogResponseList> {
            return localVarFp.listContainerLog(containerId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContainerLogsApi - object-oriented interface
 * @export
 * @class ContainerLogsApi
 * @extends {BaseAPI}
 */
export class ContainerLogsApi extends BaseAPI {
    /**
     * This will list the last 1000 logs of the container
     * @summary List logs
     * @param {string} containerId Container ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerLogsApi
     */
    public listContainerLog(containerId: string, options?: AxiosRequestConfig) {
        return ContainerLogsApiFp(this.configuration).listContainerLog(containerId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ContainerMainCallsApi - axios parameter creator
 * @export
 */
export const ContainerMainCallsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * To delete the container you must have the admin permission
         * @summary Delete container
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContainer: async (containerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('deleteContainer', 'containerId', containerId)
            const localVarPath = `/container/{containerId}`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - To edit the container you must have the admin permission. - For port edition, if you provide a port id, we will update the corresponding port. If you don\'t we will create a new one. If you remove a port from the payload, we will delete it. - For storage edition, if you provide a storage id, we will update the corresponding storage. If you don\'t we will create a new one. If you remove a storage from the payload, we will delete it. 
         * @summary Edit container
         * @param {string} containerId Container ID
         * @param {ContainerRequest} [containerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editContainer: async (containerId: string, containerRequest?: ContainerRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('editContainer', 'containerId', containerId)
            const localVarPath = `/container/{containerId}`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(containerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get container by ID
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainer: async (containerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('getContainer', 'containerId', containerId)
            const localVarPath = `/container/{containerId}`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get container status
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainerStatus: async (containerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('getContainerStatus', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/status`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This will return all the custom domains and Qovery autogenerated domain for the given container
         * @summary List all URLs of the container
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerLinks: async (containerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('listContainerLinks', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/link`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContainerMainCallsApi - functional programming interface
 * @export
 */
export const ContainerMainCallsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContainerMainCallsApiAxiosParamCreator(configuration)
    return {
        /**
         * To delete the container you must have the admin permission
         * @summary Delete container
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteContainer(containerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteContainer(containerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - To edit the container you must have the admin permission. - For port edition, if you provide a port id, we will update the corresponding port. If you don\'t we will create a new one. If you remove a port from the payload, we will delete it. - For storage edition, if you provide a storage id, we will update the corresponding storage. If you don\'t we will create a new one. If you remove a storage from the payload, we will delete it. 
         * @summary Edit container
         * @param {string} containerId Container ID
         * @param {ContainerRequest} [containerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editContainer(containerId: string, containerRequest?: ContainerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editContainer(containerId, containerRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get container by ID
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContainer(containerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContainer(containerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get container status
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContainerStatus(containerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContainerStatus(containerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This will return all the custom domains and Qovery autogenerated domain for the given container
         * @summary List all URLs of the container
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContainerLinks(containerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listContainerLinks(containerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContainerMainCallsApi - factory interface
 * @export
 */
export const ContainerMainCallsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContainerMainCallsApiFp(configuration)
    return {
        /**
         * To delete the container you must have the admin permission
         * @summary Delete container
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContainer(containerId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteContainer(containerId, options).then((request) => request(axios, basePath));
        },
        /**
         * - To edit the container you must have the admin permission. - For port edition, if you provide a port id, we will update the corresponding port. If you don\'t we will create a new one. If you remove a port from the payload, we will delete it. - For storage edition, if you provide a storage id, we will update the corresponding storage. If you don\'t we will create a new one. If you remove a storage from the payload, we will delete it. 
         * @summary Edit container
         * @param {string} containerId Container ID
         * @param {ContainerRequest} [containerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editContainer(containerId: string, containerRequest?: ContainerRequest, options?: any): AxiosPromise<ContainerResponse> {
            return localVarFp.editContainer(containerId, containerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get container by ID
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainer(containerId: string, options?: any): AxiosPromise<ContainerResponse> {
            return localVarFp.getContainer(containerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get container status
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainerStatus(containerId: string, options?: any): AxiosPromise<Status> {
            return localVarFp.getContainerStatus(containerId, options).then((request) => request(axios, basePath));
        },
        /**
         * This will return all the custom domains and Qovery autogenerated domain for the given container
         * @summary List all URLs of the container
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerLinks(containerId: string, options?: any): AxiosPromise<LinkResponseList> {
            return localVarFp.listContainerLinks(containerId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContainerMainCallsApi - object-oriented interface
 * @export
 * @class ContainerMainCallsApi
 * @extends {BaseAPI}
 */
export class ContainerMainCallsApi extends BaseAPI {
    /**
     * To delete the container you must have the admin permission
     * @summary Delete container
     * @param {string} containerId Container ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerMainCallsApi
     */
    public deleteContainer(containerId: string, options?: AxiosRequestConfig) {
        return ContainerMainCallsApiFp(this.configuration).deleteContainer(containerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - To edit the container you must have the admin permission. - For port edition, if you provide a port id, we will update the corresponding port. If you don\'t we will create a new one. If you remove a port from the payload, we will delete it. - For storage edition, if you provide a storage id, we will update the corresponding storage. If you don\'t we will create a new one. If you remove a storage from the payload, we will delete it. 
     * @summary Edit container
     * @param {string} containerId Container ID
     * @param {ContainerRequest} [containerRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerMainCallsApi
     */
    public editContainer(containerId: string, containerRequest?: ContainerRequest, options?: AxiosRequestConfig) {
        return ContainerMainCallsApiFp(this.configuration).editContainer(containerId, containerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get container by ID
     * @param {string} containerId Container ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerMainCallsApi
     */
    public getContainer(containerId: string, options?: AxiosRequestConfig) {
        return ContainerMainCallsApiFp(this.configuration).getContainer(containerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get container status
     * @param {string} containerId Container ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerMainCallsApi
     */
    public getContainerStatus(containerId: string, options?: AxiosRequestConfig) {
        return ContainerMainCallsApiFp(this.configuration).getContainerStatus(containerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will return all the custom domains and Qovery autogenerated domain for the given container
     * @summary List all URLs of the container
     * @param {string} containerId Container ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerMainCallsApi
     */
    public listContainerLinks(containerId: string, options?: AxiosRequestConfig) {
        return ContainerMainCallsApiFp(this.configuration).listContainerLinks(containerId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ContainerMetricsApi - axios parameter creator
 * @export
 */
export const ContainerMetricsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List currently running instances of the container with their CPU and RAM metrics
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainerCurrentInstance: async (containerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('getContainerCurrentInstance', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/instance`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns min, max, and running number of instances of the application
         * @summary Get current scaling of the container
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainerCurrentScale: async (containerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('getContainerCurrentScale', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/currentScale`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List current storage disk usage
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainerCurrentStorageDisk: async (containerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('getContainerCurrentStorageDisk', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/currentStorage`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContainerMetricsApi - functional programming interface
 * @export
 */
export const ContainerMetricsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContainerMetricsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List currently running instances of the container with their CPU and RAM metrics
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContainerCurrentInstance(containerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InstanceResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContainerCurrentInstance(containerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns min, max, and running number of instances of the application
         * @summary Get current scaling of the container
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContainerCurrentScale(containerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerCurrentScale>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContainerCurrentScale(containerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List current storage disk usage
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContainerCurrentStorageDisk(containerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StorageDiskResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContainerCurrentStorageDisk(containerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContainerMetricsApi - factory interface
 * @export
 */
export const ContainerMetricsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContainerMetricsApiFp(configuration)
    return {
        /**
         * 
         * @summary List currently running instances of the container with their CPU and RAM metrics
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainerCurrentInstance(containerId: string, options?: any): AxiosPromise<InstanceResponseList> {
            return localVarFp.getContainerCurrentInstance(containerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns min, max, and running number of instances of the application
         * @summary Get current scaling of the container
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainerCurrentScale(containerId: string, options?: any): AxiosPromise<ContainerCurrentScale> {
            return localVarFp.getContainerCurrentScale(containerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List current storage disk usage
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainerCurrentStorageDisk(containerId: string, options?: any): AxiosPromise<StorageDiskResponseList> {
            return localVarFp.getContainerCurrentStorageDisk(containerId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContainerMetricsApi - object-oriented interface
 * @export
 * @class ContainerMetricsApi
 * @extends {BaseAPI}
 */
export class ContainerMetricsApi extends BaseAPI {
    /**
     * 
     * @summary List currently running instances of the container with their CPU and RAM metrics
     * @param {string} containerId Container ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerMetricsApi
     */
    public getContainerCurrentInstance(containerId: string, options?: AxiosRequestConfig) {
        return ContainerMetricsApiFp(this.configuration).getContainerCurrentInstance(containerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns min, max, and running number of instances of the application
     * @summary Get current scaling of the container
     * @param {string} containerId Container ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerMetricsApi
     */
    public getContainerCurrentScale(containerId: string, options?: AxiosRequestConfig) {
        return ContainerMetricsApiFp(this.configuration).getContainerCurrentScale(containerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List current storage disk usage
     * @param {string} containerId Container ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerMetricsApi
     */
    public getContainerCurrentStorageDisk(containerId: string, options?: AxiosRequestConfig) {
        return ContainerMetricsApiFp(this.configuration).getContainerCurrentStorageDisk(containerId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ContainerRegistriesApi - axios parameter creator
 * @export
 */
export const ContainerRegistriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a container registry
         * @param {string} organizationId Organization ID
         * @param {ContainerRegistryRequest} [containerRegistryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainerRegistry: async (organizationId: string, containerRegistryRequest?: ContainerRegistryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createContainerRegistry', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/containerRegistry`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(containerRegistryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a container registry
         * @param {string} organizationId Organization ID
         * @param {string} containerRegistryId Container Registry ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContainerRegistry: async (organizationId: string, containerRegistryId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteContainerRegistry', 'organizationId', organizationId)
            // verify required parameter 'containerRegistryId' is not null or undefined
            assertParamExists('deleteContainerRegistry', 'containerRegistryId', containerRegistryId)
            const localVarPath = `/organization/{organizationId}/containerRegistry/{containerRegistryId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"containerRegistryId"}}`, encodeURIComponent(String(containerRegistryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a container registry
         * @param {string} organizationId Organization ID
         * @param {string} containerRegistryId Container Registry ID
         * @param {ContainerRegistryRequest} [containerRegistryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editContainerRegistry: async (organizationId: string, containerRegistryId: string, containerRegistryRequest?: ContainerRegistryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('editContainerRegistry', 'organizationId', organizationId)
            // verify required parameter 'containerRegistryId' is not null or undefined
            assertParamExists('editContainerRegistry', 'containerRegistryId', containerRegistryId)
            const localVarPath = `/organization/{organizationId}/containerRegistry/{containerRegistryId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"containerRegistryId"}}`, encodeURIComponent(String(containerRegistryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(containerRegistryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a container registry
         * @param {string} organizationId Organization ID
         * @param {string} containerRegistryId Container Registry ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainerRegistry: async (organizationId: string, containerRegistryId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getContainerRegistry', 'organizationId', organizationId)
            // verify required parameter 'containerRegistryId' is not null or undefined
            assertParamExists('getContainerRegistry', 'containerRegistryId', containerRegistryId)
            const localVarPath = `/organization/{organizationId}/containerRegistry/{containerRegistryId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"containerRegistryId"}}`, encodeURIComponent(String(containerRegistryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List supported container registries by Qovery and get the mandatory authentification configuration.
         * @summary List supported container registries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAvailableContainerRegistry: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/availableContainerRegistry`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List organization container registries
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerRegistry: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listContainerRegistry', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/containerRegistry`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContainerRegistriesApi - functional programming interface
 * @export
 */
export const ContainerRegistriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContainerRegistriesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a container registry
         * @param {string} organizationId Organization ID
         * @param {ContainerRegistryRequest} [containerRegistryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContainerRegistry(organizationId: string, containerRegistryRequest?: ContainerRegistryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerRegistryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContainerRegistry(organizationId, containerRegistryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a container registry
         * @param {string} organizationId Organization ID
         * @param {string} containerRegistryId Container Registry ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteContainerRegistry(organizationId: string, containerRegistryId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteContainerRegistry(organizationId, containerRegistryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit a container registry
         * @param {string} organizationId Organization ID
         * @param {string} containerRegistryId Container Registry ID
         * @param {ContainerRegistryRequest} [containerRegistryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editContainerRegistry(organizationId: string, containerRegistryId: string, containerRegistryRequest?: ContainerRegistryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerRegistryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editContainerRegistry(organizationId, containerRegistryId, containerRegistryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a container registry
         * @param {string} organizationId Organization ID
         * @param {string} containerRegistryId Container Registry ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContainerRegistry(organizationId: string, containerRegistryId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerRegistryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContainerRegistry(organizationId, containerRegistryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List supported container registries by Qovery and get the mandatory authentification configuration.
         * @summary List supported container registries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAvailableContainerRegistry(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AvailableContainerRegistryResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAvailableContainerRegistry(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List organization container registries
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContainerRegistry(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerRegistryResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listContainerRegistry(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContainerRegistriesApi - factory interface
 * @export
 */
export const ContainerRegistriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContainerRegistriesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a container registry
         * @param {string} organizationId Organization ID
         * @param {ContainerRegistryRequest} [containerRegistryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainerRegistry(organizationId: string, containerRegistryRequest?: ContainerRegistryRequest, options?: any): AxiosPromise<ContainerRegistryResponse> {
            return localVarFp.createContainerRegistry(organizationId, containerRegistryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a container registry
         * @param {string} organizationId Organization ID
         * @param {string} containerRegistryId Container Registry ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContainerRegistry(organizationId: string, containerRegistryId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteContainerRegistry(organizationId, containerRegistryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a container registry
         * @param {string} organizationId Organization ID
         * @param {string} containerRegistryId Container Registry ID
         * @param {ContainerRegistryRequest} [containerRegistryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editContainerRegistry(organizationId: string, containerRegistryId: string, containerRegistryRequest?: ContainerRegistryRequest, options?: any): AxiosPromise<ContainerRegistryResponse> {
            return localVarFp.editContainerRegistry(organizationId, containerRegistryId, containerRegistryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a container registry
         * @param {string} organizationId Organization ID
         * @param {string} containerRegistryId Container Registry ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainerRegistry(organizationId: string, containerRegistryId: string, options?: any): AxiosPromise<ContainerRegistryResponse> {
            return localVarFp.getContainerRegistry(organizationId, containerRegistryId, options).then((request) => request(axios, basePath));
        },
        /**
         * List supported container registries by Qovery and get the mandatory authentification configuration.
         * @summary List supported container registries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAvailableContainerRegistry(options?: any): AxiosPromise<AvailableContainerRegistryResponseList> {
            return localVarFp.listAvailableContainerRegistry(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List organization container registries
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerRegistry(organizationId: string, options?: any): AxiosPromise<ContainerRegistryResponseList> {
            return localVarFp.listContainerRegistry(organizationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContainerRegistriesApi - object-oriented interface
 * @export
 * @class ContainerRegistriesApi
 * @extends {BaseAPI}
 */
export class ContainerRegistriesApi extends BaseAPI {
    /**
     * 
     * @summary Create a container registry
     * @param {string} organizationId Organization ID
     * @param {ContainerRegistryRequest} [containerRegistryRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerRegistriesApi
     */
    public createContainerRegistry(organizationId: string, containerRegistryRequest?: ContainerRegistryRequest, options?: AxiosRequestConfig) {
        return ContainerRegistriesApiFp(this.configuration).createContainerRegistry(organizationId, containerRegistryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a container registry
     * @param {string} organizationId Organization ID
     * @param {string} containerRegistryId Container Registry ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerRegistriesApi
     */
    public deleteContainerRegistry(organizationId: string, containerRegistryId: string, options?: AxiosRequestConfig) {
        return ContainerRegistriesApiFp(this.configuration).deleteContainerRegistry(organizationId, containerRegistryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a container registry
     * @param {string} organizationId Organization ID
     * @param {string} containerRegistryId Container Registry ID
     * @param {ContainerRegistryRequest} [containerRegistryRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerRegistriesApi
     */
    public editContainerRegistry(organizationId: string, containerRegistryId: string, containerRegistryRequest?: ContainerRegistryRequest, options?: AxiosRequestConfig) {
        return ContainerRegistriesApiFp(this.configuration).editContainerRegistry(organizationId, containerRegistryId, containerRegistryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a container registry
     * @param {string} organizationId Organization ID
     * @param {string} containerRegistryId Container Registry ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerRegistriesApi
     */
    public getContainerRegistry(organizationId: string, containerRegistryId: string, options?: AxiosRequestConfig) {
        return ContainerRegistriesApiFp(this.configuration).getContainerRegistry(organizationId, containerRegistryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List supported container registries by Qovery and get the mandatory authentification configuration.
     * @summary List supported container registries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerRegistriesApi
     */
    public listAvailableContainerRegistry(options?: AxiosRequestConfig) {
        return ContainerRegistriesApiFp(this.configuration).listAvailableContainerRegistry(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List organization container registries
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerRegistriesApi
     */
    public listContainerRegistry(organizationId: string, options?: AxiosRequestConfig) {
        return ContainerRegistriesApiFp(this.configuration).listContainerRegistry(organizationId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ContainerSecretApi - axios parameter creator
 * @export
 */
export const ContainerSecretApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * - Add a secret to the container. 
         * @summary Add a secret to the container
         * @param {string} containerId Container ID
         * @param {SecretRequest} [secretRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainerSecret: async (containerId: string, secretRequest?: SecretRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('createContainerSecret', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/secret`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(secretRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to add an alias at container level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at container level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - Only 1 alias level is allowed. You can\'t create an alias on an alias 
         * @summary Create a secret alias at the container level
         * @param {string} containerId Container ID
         * @param {string} secretId Secret ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainerSecretAlias: async (containerId: string, secretId: string, key?: Key, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('createContainerSecretAlias', 'containerId', containerId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('createContainerSecretAlias', 'secretId', secretId)
            const localVarPath = `/container/{containerId}/secret/{secretId}/alias`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(key, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to override at container level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at container level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
         * @summary Create a secret override at the container level
         * @param {string} containerId Container ID
         * @param {string} secretId Secret ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainerSecretOverride: async (containerId: string, secretId: string, value?: Value, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('createContainerSecretOverride', 'containerId', containerId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('createContainerSecretOverride', 'secretId', secretId)
            const localVarPath = `/container/{containerId}/secret/{secretId}/override`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(value, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete a secret from an container
         * @param {string} containerId Container ID
         * @param {string} secretId Secret ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContainerSecret: async (containerId: string, secretId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('deleteContainerSecret', 'containerId', containerId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('deleteContainerSecret', 'secretId', secretId)
            const localVarPath = `/container/{containerId}/secret/{secretId}`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > CONTAINER) 
         * @summary Edit a secret belonging to the container
         * @param {string} containerId Container ID
         * @param {string} secretId Secret ID
         * @param {SecretEditRequest} secretEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editContainerSecret: async (containerId: string, secretId: string, secretEditRequest: SecretEditRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('editContainerSecret', 'containerId', containerId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('editContainerSecret', 'secretId', secretId)
            // verify required parameter 'secretEditRequest' is not null or undefined
            assertParamExists('editContainerSecret', 'secretEditRequest', secretEditRequest)
            const localVarPath = `/container/{containerId}/secret/{secretId}`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(secretEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Secrets are like environment variables, but they are secured and can\'t be revealed.
         * @summary List container secrets
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerSecrets: async (containerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('listContainerSecrets', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/secret`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContainerSecretApi - functional programming interface
 * @export
 */
export const ContainerSecretApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContainerSecretApiAxiosParamCreator(configuration)
    return {
        /**
         * - Add a secret to the container. 
         * @summary Add a secret to the container
         * @param {string} containerId Container ID
         * @param {SecretRequest} [secretRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContainerSecret(containerId: string, secretRequest?: SecretRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContainerSecret(containerId, secretRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - Allows you to add an alias at container level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at container level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - Only 1 alias level is allowed. You can\'t create an alias on an alias 
         * @summary Create a secret alias at the container level
         * @param {string} containerId Container ID
         * @param {string} secretId Secret ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContainerSecretAlias(containerId: string, secretId: string, key?: Key, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContainerSecretAlias(containerId, secretId, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - Allows you to override at container level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at container level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
         * @summary Create a secret override at the container level
         * @param {string} containerId Container ID
         * @param {string} secretId Secret ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContainerSecretOverride(containerId: string, secretId: string, value?: Value, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContainerSecretOverride(containerId, secretId, value, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete a secret from an container
         * @param {string} containerId Container ID
         * @param {string} secretId Secret ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteContainerSecret(containerId: string, secretId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteContainerSecret(containerId, secretId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > CONTAINER) 
         * @summary Edit a secret belonging to the container
         * @param {string} containerId Container ID
         * @param {string} secretId Secret ID
         * @param {SecretEditRequest} secretEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editContainerSecret(containerId: string, secretId: string, secretEditRequest: SecretEditRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editContainerSecret(containerId, secretId, secretEditRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Secrets are like environment variables, but they are secured and can\'t be revealed.
         * @summary List container secrets
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContainerSecrets(containerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecretResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listContainerSecrets(containerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContainerSecretApi - factory interface
 * @export
 */
export const ContainerSecretApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContainerSecretApiFp(configuration)
    return {
        /**
         * - Add a secret to the container. 
         * @summary Add a secret to the container
         * @param {string} containerId Container ID
         * @param {SecretRequest} [secretRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainerSecret(containerId: string, secretRequest?: SecretRequest, options?: any): AxiosPromise<Secret> {
            return localVarFp.createContainerSecret(containerId, secretRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to add an alias at container level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at container level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - Only 1 alias level is allowed. You can\'t create an alias on an alias 
         * @summary Create a secret alias at the container level
         * @param {string} containerId Container ID
         * @param {string} secretId Secret ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainerSecretAlias(containerId: string, secretId: string, key?: Key, options?: any): AxiosPromise<Secret> {
            return localVarFp.createContainerSecretAlias(containerId, secretId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to override at container level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at container level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
         * @summary Create a secret override at the container level
         * @param {string} containerId Container ID
         * @param {string} secretId Secret ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainerSecretOverride(containerId: string, secretId: string, value?: Value, options?: any): AxiosPromise<Secret> {
            return localVarFp.createContainerSecretOverride(containerId, secretId, value, options).then((request) => request(axios, basePath));
        },
        /**
         * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete a secret from an container
         * @param {string} containerId Container ID
         * @param {string} secretId Secret ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContainerSecret(containerId: string, secretId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteContainerSecret(containerId, secretId, options).then((request) => request(axios, basePath));
        },
        /**
         * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > CONTAINER) 
         * @summary Edit a secret belonging to the container
         * @param {string} containerId Container ID
         * @param {string} secretId Secret ID
         * @param {SecretEditRequest} secretEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editContainerSecret(containerId: string, secretId: string, secretEditRequest: SecretEditRequest, options?: any): AxiosPromise<Secret> {
            return localVarFp.editContainerSecret(containerId, secretId, secretEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Secrets are like environment variables, but they are secured and can\'t be revealed.
         * @summary List container secrets
         * @param {string} containerId Container ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerSecrets(containerId: string, options?: any): AxiosPromise<SecretResponseList> {
            return localVarFp.listContainerSecrets(containerId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContainerSecretApi - object-oriented interface
 * @export
 * @class ContainerSecretApi
 * @extends {BaseAPI}
 */
export class ContainerSecretApi extends BaseAPI {
    /**
     * - Add a secret to the container. 
     * @summary Add a secret to the container
     * @param {string} containerId Container ID
     * @param {SecretRequest} [secretRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerSecretApi
     */
    public createContainerSecret(containerId: string, secretRequest?: SecretRequest, options?: AxiosRequestConfig) {
        return ContainerSecretApiFp(this.configuration).createContainerSecret(containerId, secretRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to add an alias at container level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at container level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - Only 1 alias level is allowed. You can\'t create an alias on an alias 
     * @summary Create a secret alias at the container level
     * @param {string} containerId Container ID
     * @param {string} secretId Secret ID
     * @param {Key} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerSecretApi
     */
    public createContainerSecretAlias(containerId: string, secretId: string, key?: Key, options?: AxiosRequestConfig) {
        return ContainerSecretApiFp(this.configuration).createContainerSecretAlias(containerId, secretId, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to override at container level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at container level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
     * @summary Create a secret override at the container level
     * @param {string} containerId Container ID
     * @param {string} secretId Secret ID
     * @param {Value} [value] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerSecretApi
     */
    public createContainerSecretOverride(containerId: string, secretId: string, value?: Value, options?: AxiosRequestConfig) {
        return ContainerSecretApiFp(this.configuration).createContainerSecretOverride(containerId, secretId, value, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well 
     * @summary Delete a secret from an container
     * @param {string} containerId Container ID
     * @param {string} secretId Secret ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerSecretApi
     */
    public deleteContainerSecret(containerId: string, secretId: string, options?: AxiosRequestConfig) {
        return ContainerSecretApiFp(this.configuration).deleteContainerSecret(containerId, secretId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > CONTAINER) 
     * @summary Edit a secret belonging to the container
     * @param {string} containerId Container ID
     * @param {string} secretId Secret ID
     * @param {SecretEditRequest} secretEditRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerSecretApi
     */
    public editContainerSecret(containerId: string, secretId: string, secretEditRequest: SecretEditRequest, options?: AxiosRequestConfig) {
        return ContainerSecretApiFp(this.configuration).editContainerSecret(containerId, secretId, secretEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Secrets are like environment variables, but they are secured and can\'t be revealed.
     * @summary List container secrets
     * @param {string} containerId Container ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerSecretApi
     */
    public listContainerSecrets(containerId: string, options?: AxiosRequestConfig) {
        return ContainerSecretApiFp(this.configuration).listContainerSecrets(containerId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ContainersApi - axios parameter creator
 * @export
 */
export const ContainersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Triggers a new container deploy in each environment matching the following conditions - environment should have the auto-deploy enabled - the container should have the same image name and a different tag 
         * @summary Auto deploy containers
         * @param {string} organizationId Organization ID
         * @param {OrganizationContainerAutoDeployRequest} [organizationContainerAutoDeployRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoDeployContainerEnvironments: async (organizationId: string, organizationContainerAutoDeployRequest?: OrganizationContainerAutoDeployRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('autoDeployContainerEnvironments', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/container/deploy`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationContainerAutoDeployRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This will create a new container with the same configuration on the targeted environment Id.
         * @summary Clone container
         * @param {string} containerId Container ID
         * @param {CloneContainerRequest} [cloneContainerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneContainer: async (containerId: string, cloneContainerRequest?: CloneContainerRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('cloneContainer', 'containerId', containerId)
            const localVarPath = `/container/{containerId}/clone`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloneContainerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a container
         * @param {string} environmentId Environment ID
         * @param {ContainerRequest} [containerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainer: async (environmentId: string, containerRequest?: ContainerRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('createContainer', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/container`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(containerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of containers with only their id and status.
         * @summary List all container registry container statuses
         * @param {string} organizationId Organization ID
         * @param {string} containerRegistryId Container Registry ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainerRegistryContainerStatus: async (organizationId: string, containerRegistryId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getContainerRegistryContainerStatus', 'organizationId', organizationId)
            // verify required parameter 'containerRegistryId' is not null or undefined
            assertParamExists('getContainerRegistryContainerStatus', 'containerRegistryId', containerRegistryId)
            const localVarPath = `/organization/{organizationId}/containerRegistry/{containerRegistryId}/container/status`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"containerRegistryId"}}`, encodeURIComponent(String(containerRegistryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List default container advanced settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultContainerAdvancedSettings: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/defaultContainerAdvancedSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns min, max, and running number of instances for each container
         * @summary List current scaling information for each container
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentContainerCurrentScale: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('getEnvironmentContainerCurrentScale', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/container/currentScale`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List current storage disk usage for each containers
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentContainerCurrentStorage: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('getEnvironmentContainerCurrentStorage', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/container/currentStorage`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of containers with only their id and status.
         * @summary List all environment container statuses
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentContainerStatus: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('getEnvironmentContainerStatus', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/container/status`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List containers
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainer: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('listContainer', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/container`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Triggers a new container preview for each environment matching the following conditions - preview environment feature should be enabled for the container - the container should have the same image name and a different tag 
         * @summary Preview container environments
         * @param {string} organizationId Organization ID
         * @param {OrganizationContainerPreviewRequest} [organizationContainerPreviewRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewContainerEnvironments: async (organizationId: string, organizationContainerPreviewRequest?: OrganizationContainerPreviewRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('previewContainerEnvironments', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/container/preview`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationContainerPreviewRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContainersApi - functional programming interface
 * @export
 */
export const ContainersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContainersApiAxiosParamCreator(configuration)
    return {
        /**
         * Triggers a new container deploy in each environment matching the following conditions - environment should have the auto-deploy enabled - the container should have the same image name and a different tag 
         * @summary Auto deploy containers
         * @param {string} organizationId Organization ID
         * @param {OrganizationContainerAutoDeployRequest} [organizationContainerAutoDeployRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autoDeployContainerEnvironments(organizationId: string, organizationContainerAutoDeployRequest?: OrganizationContainerAutoDeployRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autoDeployContainerEnvironments(organizationId, organizationContainerAutoDeployRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This will create a new container with the same configuration on the targeted environment Id.
         * @summary Clone container
         * @param {string} containerId Container ID
         * @param {CloneContainerRequest} [cloneContainerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloneContainer(containerId: string, cloneContainerRequest?: CloneContainerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cloneContainer(containerId, cloneContainerRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a container
         * @param {string} environmentId Environment ID
         * @param {ContainerRequest} [containerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContainer(environmentId: string, containerRequest?: ContainerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContainer(environmentId, containerRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of containers with only their id and status.
         * @summary List all container registry container statuses
         * @param {string} organizationId Organization ID
         * @param {string} containerRegistryId Container Registry ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContainerRegistryContainerStatus(organizationId: string, containerRegistryId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReferenceObjectStatusResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContainerRegistryContainerStatus(organizationId, containerRegistryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List default container advanced settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDefaultContainerAdvancedSettings(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerAdvancedSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDefaultContainerAdvancedSettings(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns min, max, and running number of instances for each container
         * @summary List current scaling information for each container
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironmentContainerCurrentScale(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentContainersCurrentScaleResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironmentContainerCurrentScale(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List current storage disk usage for each containers
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironmentContainerCurrentStorage(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentContainersStorageResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironmentContainerCurrentStorage(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of containers with only their id and status.
         * @summary List all environment container statuses
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironmentContainerStatus(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReferenceObjectStatusResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironmentContainerStatus(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List containers
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContainer(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listContainer(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Triggers a new container preview for each environment matching the following conditions - preview environment feature should be enabled for the container - the container should have the same image name and a different tag 
         * @summary Preview container environments
         * @param {string} organizationId Organization ID
         * @param {OrganizationContainerPreviewRequest} [organizationContainerPreviewRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async previewContainerEnvironments(organizationId: string, organizationContainerPreviewRequest?: OrganizationContainerPreviewRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.previewContainerEnvironments(organizationId, organizationContainerPreviewRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContainersApi - factory interface
 * @export
 */
export const ContainersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContainersApiFp(configuration)
    return {
        /**
         * Triggers a new container deploy in each environment matching the following conditions - environment should have the auto-deploy enabled - the container should have the same image name and a different tag 
         * @summary Auto deploy containers
         * @param {string} organizationId Organization ID
         * @param {OrganizationContainerAutoDeployRequest} [organizationContainerAutoDeployRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoDeployContainerEnvironments(organizationId: string, organizationContainerAutoDeployRequest?: OrganizationContainerAutoDeployRequest, options?: any): AxiosPromise<Status> {
            return localVarFp.autoDeployContainerEnvironments(organizationId, organizationContainerAutoDeployRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This will create a new container with the same configuration on the targeted environment Id.
         * @summary Clone container
         * @param {string} containerId Container ID
         * @param {CloneContainerRequest} [cloneContainerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneContainer(containerId: string, cloneContainerRequest?: CloneContainerRequest, options?: any): AxiosPromise<ContainerResponse> {
            return localVarFp.cloneContainer(containerId, cloneContainerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a container
         * @param {string} environmentId Environment ID
         * @param {ContainerRequest} [containerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainer(environmentId: string, containerRequest?: ContainerRequest, options?: any): AxiosPromise<ContainerResponse> {
            return localVarFp.createContainer(environmentId, containerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of containers with only their id and status.
         * @summary List all container registry container statuses
         * @param {string} organizationId Organization ID
         * @param {string} containerRegistryId Container Registry ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContainerRegistryContainerStatus(organizationId: string, containerRegistryId: string, options?: any): AxiosPromise<ReferenceObjectStatusResponseList> {
            return localVarFp.getContainerRegistryContainerStatus(organizationId, containerRegistryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List default container advanced settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultContainerAdvancedSettings(options?: any): AxiosPromise<ContainerAdvancedSettings> {
            return localVarFp.getDefaultContainerAdvancedSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns min, max, and running number of instances for each container
         * @summary List current scaling information for each container
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentContainerCurrentScale(environmentId: string, options?: any): AxiosPromise<EnvironmentContainersCurrentScaleResponseList> {
            return localVarFp.getEnvironmentContainerCurrentScale(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List current storage disk usage for each containers
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentContainerCurrentStorage(environmentId: string, options?: any): AxiosPromise<EnvironmentContainersStorageResponseList> {
            return localVarFp.getEnvironmentContainerCurrentStorage(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of containers with only their id and status.
         * @summary List all environment container statuses
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentContainerStatus(environmentId: string, options?: any): AxiosPromise<ReferenceObjectStatusResponseList> {
            return localVarFp.getEnvironmentContainerStatus(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List containers
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainer(environmentId: string, options?: any): AxiosPromise<ContainerResponseList> {
            return localVarFp.listContainer(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Triggers a new container preview for each environment matching the following conditions - preview environment feature should be enabled for the container - the container should have the same image name and a different tag 
         * @summary Preview container environments
         * @param {string} organizationId Organization ID
         * @param {OrganizationContainerPreviewRequest} [organizationContainerPreviewRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewContainerEnvironments(organizationId: string, organizationContainerPreviewRequest?: OrganizationContainerPreviewRequest, options?: any): AxiosPromise<Status> {
            return localVarFp.previewContainerEnvironments(organizationId, organizationContainerPreviewRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContainersApi - object-oriented interface
 * @export
 * @class ContainersApi
 * @extends {BaseAPI}
 */
export class ContainersApi extends BaseAPI {
    /**
     * Triggers a new container deploy in each environment matching the following conditions - environment should have the auto-deploy enabled - the container should have the same image name and a different tag 
     * @summary Auto deploy containers
     * @param {string} organizationId Organization ID
     * @param {OrganizationContainerAutoDeployRequest} [organizationContainerAutoDeployRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public autoDeployContainerEnvironments(organizationId: string, organizationContainerAutoDeployRequest?: OrganizationContainerAutoDeployRequest, options?: AxiosRequestConfig) {
        return ContainersApiFp(this.configuration).autoDeployContainerEnvironments(organizationId, organizationContainerAutoDeployRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will create a new container with the same configuration on the targeted environment Id.
     * @summary Clone container
     * @param {string} containerId Container ID
     * @param {CloneContainerRequest} [cloneContainerRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public cloneContainer(containerId: string, cloneContainerRequest?: CloneContainerRequest, options?: AxiosRequestConfig) {
        return ContainersApiFp(this.configuration).cloneContainer(containerId, cloneContainerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a container
     * @param {string} environmentId Environment ID
     * @param {ContainerRequest} [containerRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public createContainer(environmentId: string, containerRequest?: ContainerRequest, options?: AxiosRequestConfig) {
        return ContainersApiFp(this.configuration).createContainer(environmentId, containerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of containers with only their id and status.
     * @summary List all container registry container statuses
     * @param {string} organizationId Organization ID
     * @param {string} containerRegistryId Container Registry ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public getContainerRegistryContainerStatus(organizationId: string, containerRegistryId: string, options?: AxiosRequestConfig) {
        return ContainersApiFp(this.configuration).getContainerRegistryContainerStatus(organizationId, containerRegistryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List default container advanced settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public getDefaultContainerAdvancedSettings(options?: AxiosRequestConfig) {
        return ContainersApiFp(this.configuration).getDefaultContainerAdvancedSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns min, max, and running number of instances for each container
     * @summary List current scaling information for each container
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public getEnvironmentContainerCurrentScale(environmentId: string, options?: AxiosRequestConfig) {
        return ContainersApiFp(this.configuration).getEnvironmentContainerCurrentScale(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List current storage disk usage for each containers
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public getEnvironmentContainerCurrentStorage(environmentId: string, options?: AxiosRequestConfig) {
        return ContainersApiFp(this.configuration).getEnvironmentContainerCurrentStorage(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of containers with only their id and status.
     * @summary List all environment container statuses
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public getEnvironmentContainerStatus(environmentId: string, options?: AxiosRequestConfig) {
        return ContainersApiFp(this.configuration).getEnvironmentContainerStatus(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List containers
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public listContainer(environmentId: string, options?: AxiosRequestConfig) {
        return ContainersApiFp(this.configuration).listContainer(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Triggers a new container preview for each environment matching the following conditions - preview environment feature should be enabled for the container - the container should have the same image name and a different tag 
     * @summary Preview container environments
     * @param {string} organizationId Organization ID
     * @param {OrganizationContainerPreviewRequest} [organizationContainerPreviewRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public previewContainerEnvironments(organizationId: string, organizationContainerPreviewRequest?: OrganizationContainerPreviewRequest, options?: AxiosRequestConfig) {
        return ContainersApiFp(this.configuration).previewContainerEnvironments(organizationId, organizationContainerPreviewRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CustomDomainApi - axios parameter creator
 * @export
 */
export const CustomDomainApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a custom domain to this application in order not to use qovery autogenerated domain
         * @summary Add custom domain to the application.
         * @param {string} applicationId Application ID
         * @param {CustomDomainRequest} [customDomainRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationCustomDomain: async (applicationId: string, customDomainRequest?: CustomDomainRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('createApplicationCustomDomain', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/customDomain`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customDomainRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To delete an CustomDomain you must have the project user permission
         * @summary Delete a Custom Domain
         * @param {string} applicationId Application ID
         * @param {string} customDomainId Custom Domain ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomDomain: async (applicationId: string, customDomainId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('deleteCustomDomain', 'applicationId', applicationId)
            // verify required parameter 'customDomainId' is not null or undefined
            assertParamExists('deleteCustomDomain', 'customDomainId', customDomainId)
            const localVarPath = `/application/{applicationId}/customDomain/{customDomainId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"customDomainId"}}`, encodeURIComponent(String(customDomainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To edit a Custom Domain  you must have the project user permission
         * @summary Edit a Custom Domain
         * @param {string} applicationId Application ID
         * @param {string} customDomainId Custom Domain ID
         * @param {CustomDomainRequest} [customDomainRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editCustomDomain: async (applicationId: string, customDomainId: string, customDomainRequest?: CustomDomainRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('editCustomDomain', 'applicationId', applicationId)
            // verify required parameter 'customDomainId' is not null or undefined
            assertParamExists('editCustomDomain', 'customDomainId', customDomainId)
            const localVarPath = `/application/{applicationId}/customDomain/{customDomainId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"customDomainId"}}`, encodeURIComponent(String(customDomainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customDomainRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Custom Domain status
         * @param {string} applicationId Application ID
         * @param {string} customDomainId Custom Domain ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomDomainStatus: async (applicationId: string, customDomainId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getCustomDomainStatus', 'applicationId', applicationId)
            // verify required parameter 'customDomainId' is not null or undefined
            assertParamExists('getCustomDomainStatus', 'customDomainId', customDomainId)
            const localVarPath = `/application/{applicationId}/customDomain/{customDomainId}/status`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"customDomainId"}}`, encodeURIComponent(String(customDomainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List application custom domains
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationCustomDomain: async (applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('listApplicationCustomDomain', 'applicationId', applicationId)
            const localVarPath = `/application/{applicationId}/customDomain`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomDomainApi - functional programming interface
 * @export
 */
export const CustomDomainApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomDomainApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a custom domain to this application in order not to use qovery autogenerated domain
         * @summary Add custom domain to the application.
         * @param {string} applicationId Application ID
         * @param {CustomDomainRequest} [customDomainRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplicationCustomDomain(applicationId: string, customDomainRequest?: CustomDomainRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomDomain>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplicationCustomDomain(applicationId, customDomainRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * To delete an CustomDomain you must have the project user permission
         * @summary Delete a Custom Domain
         * @param {string} applicationId Application ID
         * @param {string} customDomainId Custom Domain ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCustomDomain(applicationId: string, customDomainId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCustomDomain(applicationId, customDomainId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * To edit a Custom Domain  you must have the project user permission
         * @summary Edit a Custom Domain
         * @param {string} applicationId Application ID
         * @param {string} customDomainId Custom Domain ID
         * @param {CustomDomainRequest} [customDomainRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editCustomDomain(applicationId: string, customDomainId: string, customDomainRequest?: CustomDomainRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomDomain>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editCustomDomain(applicationId, customDomainId, customDomainRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Custom Domain status
         * @param {string} applicationId Application ID
         * @param {string} customDomainId Custom Domain ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomDomainStatus(applicationId: string, customDomainId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomDomain>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomDomainStatus(applicationId, customDomainId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List application custom domains
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplicationCustomDomain(applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomDomainResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplicationCustomDomain(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CustomDomainApi - factory interface
 * @export
 */
export const CustomDomainApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomDomainApiFp(configuration)
    return {
        /**
         * Add a custom domain to this application in order not to use qovery autogenerated domain
         * @summary Add custom domain to the application.
         * @param {string} applicationId Application ID
         * @param {CustomDomainRequest} [customDomainRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationCustomDomain(applicationId: string, customDomainRequest?: CustomDomainRequest, options?: any): AxiosPromise<CustomDomain> {
            return localVarFp.createApplicationCustomDomain(applicationId, customDomainRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * To delete an CustomDomain you must have the project user permission
         * @summary Delete a Custom Domain
         * @param {string} applicationId Application ID
         * @param {string} customDomainId Custom Domain ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomDomain(applicationId: string, customDomainId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCustomDomain(applicationId, customDomainId, options).then((request) => request(axios, basePath));
        },
        /**
         * To edit a Custom Domain  you must have the project user permission
         * @summary Edit a Custom Domain
         * @param {string} applicationId Application ID
         * @param {string} customDomainId Custom Domain ID
         * @param {CustomDomainRequest} [customDomainRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editCustomDomain(applicationId: string, customDomainId: string, customDomainRequest?: CustomDomainRequest, options?: any): AxiosPromise<CustomDomain> {
            return localVarFp.editCustomDomain(applicationId, customDomainId, customDomainRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Custom Domain status
         * @param {string} applicationId Application ID
         * @param {string} customDomainId Custom Domain ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomDomainStatus(applicationId: string, customDomainId: string, options?: any): AxiosPromise<CustomDomain> {
            return localVarFp.getCustomDomainStatus(applicationId, customDomainId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List application custom domains
         * @param {string} applicationId Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationCustomDomain(applicationId: string, options?: any): AxiosPromise<CustomDomainResponseList> {
            return localVarFp.listApplicationCustomDomain(applicationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CustomDomainApi - object-oriented interface
 * @export
 * @class CustomDomainApi
 * @extends {BaseAPI}
 */
export class CustomDomainApi extends BaseAPI {
    /**
     * Add a custom domain to this application in order not to use qovery autogenerated domain
     * @summary Add custom domain to the application.
     * @param {string} applicationId Application ID
     * @param {CustomDomainRequest} [customDomainRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomDomainApi
     */
    public createApplicationCustomDomain(applicationId: string, customDomainRequest?: CustomDomainRequest, options?: AxiosRequestConfig) {
        return CustomDomainApiFp(this.configuration).createApplicationCustomDomain(applicationId, customDomainRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To delete an CustomDomain you must have the project user permission
     * @summary Delete a Custom Domain
     * @param {string} applicationId Application ID
     * @param {string} customDomainId Custom Domain ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomDomainApi
     */
    public deleteCustomDomain(applicationId: string, customDomainId: string, options?: AxiosRequestConfig) {
        return CustomDomainApiFp(this.configuration).deleteCustomDomain(applicationId, customDomainId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To edit a Custom Domain  you must have the project user permission
     * @summary Edit a Custom Domain
     * @param {string} applicationId Application ID
     * @param {string} customDomainId Custom Domain ID
     * @param {CustomDomainRequest} [customDomainRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomDomainApi
     */
    public editCustomDomain(applicationId: string, customDomainId: string, customDomainRequest?: CustomDomainRequest, options?: AxiosRequestConfig) {
        return CustomDomainApiFp(this.configuration).editCustomDomain(applicationId, customDomainId, customDomainRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Custom Domain status
     * @param {string} applicationId Application ID
     * @param {string} customDomainId Custom Domain ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomDomainApi
     */
    public getCustomDomainStatus(applicationId: string, customDomainId: string, options?: AxiosRequestConfig) {
        return CustomDomainApiFp(this.configuration).getCustomDomainStatus(applicationId, customDomainId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List application custom domains
     * @param {string} applicationId Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomDomainApi
     */
    public listApplicationCustomDomain(applicationId: string, options?: AxiosRequestConfig) {
        return CustomDomainApiFp(this.configuration).listApplicationCustomDomain(applicationId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DatabaseActionsApi - axios parameter creator
 * @export
 */
export const DatabaseActionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deploy database 
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployDatabase: async (databaseId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('deployDatabase', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}/deploy`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retart database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rebootDatabase: async (databaseId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('rebootDatabase', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}/restart-service`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Redeploy database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeployDatabase: async (databaseId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('redeployDatabase', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}/redeploy`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Deprecated** - Please use the \"Redeploy database\" endpoint now
         * @summary Deprecated - Restart database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartDatabase: async (databaseId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('restartDatabase', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}/restart`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopDatabase: async (databaseId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('stopDatabase', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}/stop`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatabaseActionsApi - functional programming interface
 * @export
 */
export const DatabaseActionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DatabaseActionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Deploy database 
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployDatabase(databaseId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployDatabase(databaseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retart database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rebootDatabase(databaseId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rebootDatabase(databaseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Redeploy database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async redeployDatabase(databaseId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.redeployDatabase(databaseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **Deprecated** - Please use the \"Redeploy database\" endpoint now
         * @summary Deprecated - Restart database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restartDatabase(databaseId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restartDatabase(databaseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Stop database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopDatabase(databaseId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopDatabase(databaseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DatabaseActionsApi - factory interface
 * @export
 */
export const DatabaseActionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DatabaseActionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Deploy database 
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployDatabase(databaseId: string, options?: any): AxiosPromise<Status> {
            return localVarFp.deployDatabase(databaseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retart database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rebootDatabase(databaseId: string, options?: any): AxiosPromise<Status> {
            return localVarFp.rebootDatabase(databaseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Redeploy database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeployDatabase(databaseId: string, options?: any): AxiosPromise<Status> {
            return localVarFp.redeployDatabase(databaseId, options).then((request) => request(axios, basePath));
        },
        /**
         * **Deprecated** - Please use the \"Redeploy database\" endpoint now
         * @summary Deprecated - Restart database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartDatabase(databaseId: string, options?: any): AxiosPromise<Status> {
            return localVarFp.restartDatabase(databaseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Stop database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopDatabase(databaseId: string, options?: any): AxiosPromise<Status> {
            return localVarFp.stopDatabase(databaseId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DatabaseActionsApi - object-oriented interface
 * @export
 * @class DatabaseActionsApi
 * @extends {BaseAPI}
 */
export class DatabaseActionsApi extends BaseAPI {
    /**
     * 
     * @summary Deploy database 
     * @param {string} databaseId Database ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseActionsApi
     */
    public deployDatabase(databaseId: string, options?: AxiosRequestConfig) {
        return DatabaseActionsApiFp(this.configuration).deployDatabase(databaseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retart database
     * @param {string} databaseId Database ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseActionsApi
     */
    public rebootDatabase(databaseId: string, options?: AxiosRequestConfig) {
        return DatabaseActionsApiFp(this.configuration).rebootDatabase(databaseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Redeploy database
     * @param {string} databaseId Database ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseActionsApi
     */
    public redeployDatabase(databaseId: string, options?: AxiosRequestConfig) {
        return DatabaseActionsApiFp(this.configuration).redeployDatabase(databaseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Deprecated** - Please use the \"Redeploy database\" endpoint now
     * @summary Deprecated - Restart database
     * @param {string} databaseId Database ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseActionsApi
     */
    public restartDatabase(databaseId: string, options?: AxiosRequestConfig) {
        return DatabaseActionsApiFp(this.configuration).restartDatabase(databaseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Stop database
     * @param {string} databaseId Database ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseActionsApi
     */
    public stopDatabase(databaseId: string, options?: AxiosRequestConfig) {
        return DatabaseActionsApiFp(this.configuration).stopDatabase(databaseId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DatabaseApplicationApi - axios parameter creator
 * @export
 */
export const DatabaseApplicationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List applications using the database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseApplication: async (databaseId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('listDatabaseApplication', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}/application`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove an application from this database 
         * @param {string} databaseId Database ID
         * @param {string} targetApplicationId Target application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeApplicationFromDatabase: async (databaseId: string, targetApplicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('removeApplicationFromDatabase', 'databaseId', databaseId)
            // verify required parameter 'targetApplicationId' is not null or undefined
            assertParamExists('removeApplicationFromDatabase', 'targetApplicationId', targetApplicationId)
            const localVarPath = `/database/{databaseId}/application/{targetApplicationId}`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)))
                .replace(`{${"targetApplicationId"}}`, encodeURIComponent(String(targetApplicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatabaseApplicationApi - functional programming interface
 * @export
 */
export const DatabaseApplicationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DatabaseApplicationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List applications using the database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDatabaseApplication(databaseId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDatabaseApplication(databaseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove an application from this database 
         * @param {string} databaseId Database ID
         * @param {string} targetApplicationId Target application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeApplicationFromDatabase(databaseId: string, targetApplicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeApplicationFromDatabase(databaseId, targetApplicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DatabaseApplicationApi - factory interface
 * @export
 */
export const DatabaseApplicationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DatabaseApplicationApiFp(configuration)
    return {
        /**
         * 
         * @summary List applications using the database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseApplication(databaseId: string, options?: any): AxiosPromise<ApplicationResponseList> {
            return localVarFp.listDatabaseApplication(databaseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove an application from this database 
         * @param {string} databaseId Database ID
         * @param {string} targetApplicationId Target application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeApplicationFromDatabase(databaseId: string, targetApplicationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeApplicationFromDatabase(databaseId, targetApplicationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DatabaseApplicationApi - object-oriented interface
 * @export
 * @class DatabaseApplicationApi
 * @extends {BaseAPI}
 */
export class DatabaseApplicationApi extends BaseAPI {
    /**
     * 
     * @summary List applications using the database
     * @param {string} databaseId Database ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseApplicationApi
     */
    public listDatabaseApplication(databaseId: string, options?: AxiosRequestConfig) {
        return DatabaseApplicationApiFp(this.configuration).listDatabaseApplication(databaseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove an application from this database 
     * @param {string} databaseId Database ID
     * @param {string} targetApplicationId Target application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseApplicationApi
     */
    public removeApplicationFromDatabase(databaseId: string, targetApplicationId: string, options?: AxiosRequestConfig) {
        return DatabaseApplicationApiFp(this.configuration).removeApplicationFromDatabase(databaseId, targetApplicationId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DatabaseDeploymentHistoryApi - axios parameter creator
 * @export
 */
export const DatabaseDeploymentHistoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * By default it returns the 20 last results. The response is paginated.
         * @summary List database deploys
         * @param {string} databaseId Database ID
         * @param {string} [startId] Starting point after which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseDeploymentHistory: async (databaseId: string, startId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('listDatabaseDeploymentHistory', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}/deploymentHistory`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (startId !== undefined) {
                localVarQueryParameter['startId'] = startId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatabaseDeploymentHistoryApi - functional programming interface
 * @export
 */
export const DatabaseDeploymentHistoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DatabaseDeploymentHistoryApiAxiosParamCreator(configuration)
    return {
        /**
         * By default it returns the 20 last results. The response is paginated.
         * @summary List database deploys
         * @param {string} databaseId Database ID
         * @param {string} [startId] Starting point after which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDatabaseDeploymentHistory(databaseId: string, startId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationData & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDatabaseDeploymentHistory(databaseId, startId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DatabaseDeploymentHistoryApi - factory interface
 * @export
 */
export const DatabaseDeploymentHistoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DatabaseDeploymentHistoryApiFp(configuration)
    return {
        /**
         * By default it returns the 20 last results. The response is paginated.
         * @summary List database deploys
         * @param {string} databaseId Database ID
         * @param {string} [startId] Starting point after which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseDeploymentHistory(databaseId: string, startId?: string, options?: any): AxiosPromise<PaginationData & object> {
            return localVarFp.listDatabaseDeploymentHistory(databaseId, startId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DatabaseDeploymentHistoryApi - object-oriented interface
 * @export
 * @class DatabaseDeploymentHistoryApi
 * @extends {BaseAPI}
 */
export class DatabaseDeploymentHistoryApi extends BaseAPI {
    /**
     * By default it returns the 20 last results. The response is paginated.
     * @summary List database deploys
     * @param {string} databaseId Database ID
     * @param {string} [startId] Starting point after which to return results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseDeploymentHistoryApi
     */
    public listDatabaseDeploymentHistory(databaseId: string, startId?: string, options?: AxiosRequestConfig) {
        return DatabaseDeploymentHistoryApiFp(this.configuration).listDatabaseDeploymentHistory(databaseId, startId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DatabaseEventApi - axios parameter creator
 * @export
 */
export const DatabaseEventApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter
         * @summary List database  events
         * @param {string} databaseId Database ID
         * @param {string} [startId] Starting point after which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseEvent: async (databaseId: string, startId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('listDatabaseEvent', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}/event`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (startId !== undefined) {
                localVarQueryParameter['startId'] = startId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatabaseEventApi - functional programming interface
 * @export
 */
export const DatabaseEventApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DatabaseEventApiAxiosParamCreator(configuration)
    return {
        /**
         * By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter
         * @summary List database  events
         * @param {string} databaseId Database ID
         * @param {string} [startId] Starting point after which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDatabaseEvent(databaseId: string, startId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventPaginatedResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDatabaseEvent(databaseId, startId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DatabaseEventApi - factory interface
 * @export
 */
export const DatabaseEventApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DatabaseEventApiFp(configuration)
    return {
        /**
         * By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter
         * @summary List database  events
         * @param {string} databaseId Database ID
         * @param {string} [startId] Starting point after which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseEvent(databaseId: string, startId?: string, options?: any): AxiosPromise<EventPaginatedResponseList> {
            return localVarFp.listDatabaseEvent(databaseId, startId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DatabaseEventApi - object-oriented interface
 * @export
 * @class DatabaseEventApi
 * @extends {BaseAPI}
 */
export class DatabaseEventApi extends BaseAPI {
    /**
     * By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter
     * @summary List database  events
     * @param {string} databaseId Database ID
     * @param {string} [startId] Starting point after which to return results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseEventApi
     */
    public listDatabaseEvent(databaseId: string, startId?: string, options?: AxiosRequestConfig) {
        return DatabaseEventApiFp(this.configuration).listDatabaseEvent(databaseId, startId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DatabaseMainCallsApi - axios parameter creator
 * @export
 */
export const DatabaseMainCallsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * To delete a database you must have the admin permission
         * @summary Delete a database 
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDatabase: async (databaseId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('deleteDatabase', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To edit a database  you must have the admin permission
         * @summary Edit a database 
         * @param {string} databaseId Database ID
         * @param {DatabaseEditRequest} [databaseEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editDatabase: async (databaseId: string, databaseEditRequest?: DatabaseEditRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('editDatabase', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(databaseEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit database  master credentials
         * @param {string} databaseId Database ID
         * @param {CredentialsRequest} [credentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editDatabaseCredentials: async (databaseId: string, credentialsRequest?: CredentialsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('editDatabaseCredentials', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}/masterCredentials`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(credentialsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get database by ID
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabase: async (databaseId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('getDatabase', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get master credentials of the database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseMasterCredentials: async (databaseId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('getDatabaseMasterCredentials', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}/masterCredentials`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get database status
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseStatus: async (databaseId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('getDatabaseStatus', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}/status`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List eligible versions for the database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseVersion: async (databaseId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('listDatabaseVersion', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}/version`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatabaseMainCallsApi - functional programming interface
 * @export
 */
export const DatabaseMainCallsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DatabaseMainCallsApiAxiosParamCreator(configuration)
    return {
        /**
         * To delete a database you must have the admin permission
         * @summary Delete a database 
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDatabase(databaseId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDatabase(databaseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * To edit a database  you must have the admin permission
         * @summary Edit a database 
         * @param {string} databaseId Database ID
         * @param {DatabaseEditRequest} [databaseEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editDatabase(databaseId: string, databaseEditRequest?: DatabaseEditRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Database>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editDatabase(databaseId, databaseEditRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit database  master credentials
         * @param {string} databaseId Database ID
         * @param {CredentialsRequest} [credentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editDatabaseCredentials(databaseId: string, credentialsRequest?: CredentialsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Credentials>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editDatabaseCredentials(databaseId, credentialsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get database by ID
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDatabase(databaseId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Database>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDatabase(databaseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get master credentials of the database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDatabaseMasterCredentials(databaseId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Credentials>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDatabaseMasterCredentials(databaseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get database status
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDatabaseStatus(databaseId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDatabaseStatus(databaseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List eligible versions for the database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDatabaseVersion(databaseId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VersionResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDatabaseVersion(databaseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DatabaseMainCallsApi - factory interface
 * @export
 */
export const DatabaseMainCallsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DatabaseMainCallsApiFp(configuration)
    return {
        /**
         * To delete a database you must have the admin permission
         * @summary Delete a database 
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDatabase(databaseId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDatabase(databaseId, options).then((request) => request(axios, basePath));
        },
        /**
         * To edit a database  you must have the admin permission
         * @summary Edit a database 
         * @param {string} databaseId Database ID
         * @param {DatabaseEditRequest} [databaseEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editDatabase(databaseId: string, databaseEditRequest?: DatabaseEditRequest, options?: any): AxiosPromise<Database> {
            return localVarFp.editDatabase(databaseId, databaseEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit database  master credentials
         * @param {string} databaseId Database ID
         * @param {CredentialsRequest} [credentialsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editDatabaseCredentials(databaseId: string, credentialsRequest?: CredentialsRequest, options?: any): AxiosPromise<Credentials> {
            return localVarFp.editDatabaseCredentials(databaseId, credentialsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get database by ID
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabase(databaseId: string, options?: any): AxiosPromise<Database> {
            return localVarFp.getDatabase(databaseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get master credentials of the database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseMasterCredentials(databaseId: string, options?: any): AxiosPromise<Credentials> {
            return localVarFp.getDatabaseMasterCredentials(databaseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get database status
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseStatus(databaseId: string, options?: any): AxiosPromise<Status> {
            return localVarFp.getDatabaseStatus(databaseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List eligible versions for the database
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabaseVersion(databaseId: string, options?: any): AxiosPromise<VersionResponseList> {
            return localVarFp.listDatabaseVersion(databaseId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DatabaseMainCallsApi - object-oriented interface
 * @export
 * @class DatabaseMainCallsApi
 * @extends {BaseAPI}
 */
export class DatabaseMainCallsApi extends BaseAPI {
    /**
     * To delete a database you must have the admin permission
     * @summary Delete a database 
     * @param {string} databaseId Database ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseMainCallsApi
     */
    public deleteDatabase(databaseId: string, options?: AxiosRequestConfig) {
        return DatabaseMainCallsApiFp(this.configuration).deleteDatabase(databaseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To edit a database  you must have the admin permission
     * @summary Edit a database 
     * @param {string} databaseId Database ID
     * @param {DatabaseEditRequest} [databaseEditRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseMainCallsApi
     */
    public editDatabase(databaseId: string, databaseEditRequest?: DatabaseEditRequest, options?: AxiosRequestConfig) {
        return DatabaseMainCallsApiFp(this.configuration).editDatabase(databaseId, databaseEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit database  master credentials
     * @param {string} databaseId Database ID
     * @param {CredentialsRequest} [credentialsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseMainCallsApi
     */
    public editDatabaseCredentials(databaseId: string, credentialsRequest?: CredentialsRequest, options?: AxiosRequestConfig) {
        return DatabaseMainCallsApiFp(this.configuration).editDatabaseCredentials(databaseId, credentialsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get database by ID
     * @param {string} databaseId Database ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseMainCallsApi
     */
    public getDatabase(databaseId: string, options?: AxiosRequestConfig) {
        return DatabaseMainCallsApiFp(this.configuration).getDatabase(databaseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get master credentials of the database
     * @param {string} databaseId Database ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseMainCallsApi
     */
    public getDatabaseMasterCredentials(databaseId: string, options?: AxiosRequestConfig) {
        return DatabaseMainCallsApiFp(this.configuration).getDatabaseMasterCredentials(databaseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get database status
     * @param {string} databaseId Database ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseMainCallsApi
     */
    public getDatabaseStatus(databaseId: string, options?: AxiosRequestConfig) {
        return DatabaseMainCallsApiFp(this.configuration).getDatabaseStatus(databaseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List eligible versions for the database
     * @param {string} databaseId Database ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseMainCallsApi
     */
    public listDatabaseVersion(databaseId: string, options?: AxiosRequestConfig) {
        return DatabaseMainCallsApiFp(this.configuration).listDatabaseVersion(databaseId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DatabaseMetricsApi - axios parameter creator
 * @export
 */
export const DatabaseMetricsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get current metric consumption of the database 
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseCurrentMetric: async (databaseId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('getDatabaseCurrentMetric', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}/currentMetric`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get CPU consumption metric over time for the database
         * @param {string} databaseId Database ID
         * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseMetricCpu: async (databaseId: string, lastSeconds: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('getDatabaseMetricCpu', 'databaseId', databaseId)
            // verify required parameter 'lastSeconds' is not null or undefined
            assertParamExists('getDatabaseMetricCpu', 'lastSeconds', lastSeconds)
            const localVarPath = `/database/{databaseId}/metric/cpu`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (lastSeconds !== undefined) {
                localVarQueryParameter['lastSeconds'] = lastSeconds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The value returned corresponds to the 95th centile
         * @summary Get Health Check latency  metric over time for the database
         * @param {string} databaseId Database ID
         * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseMetricHealthCheck: async (databaseId: string, lastSeconds: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('getDatabaseMetricHealthCheck', 'databaseId', databaseId)
            // verify required parameter 'lastSeconds' is not null or undefined
            assertParamExists('getDatabaseMetricHealthCheck', 'lastSeconds', lastSeconds)
            const localVarPath = `/database/{databaseId}/metric/healthCheck`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (lastSeconds !== undefined) {
                localVarQueryParameter['lastSeconds'] = lastSeconds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Memory consumption metric over time for the database
         * @param {string} databaseId Database ID
         * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseMetricMemory: async (databaseId: string, lastSeconds: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('getDatabaseMetricMemory', 'databaseId', databaseId)
            // verify required parameter 'lastSeconds' is not null or undefined
            assertParamExists('getDatabaseMetricMemory', 'lastSeconds', lastSeconds)
            const localVarPath = `/database/{databaseId}/metric/memory`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (lastSeconds !== undefined) {
                localVarQueryParameter['lastSeconds'] = lastSeconds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Storage consumption metric over time for the database
         * @param {string} databaseId Database ID
         * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseMetricStorage: async (databaseId: string, lastSeconds: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('getDatabaseMetricStorage', 'databaseId', databaseId)
            // verify required parameter 'lastSeconds' is not null or undefined
            assertParamExists('getDatabaseMetricStorage', 'lastSeconds', lastSeconds)
            const localVarPath = `/database/{databaseId}/metric/storage`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (lastSeconds !== undefined) {
                localVarQueryParameter['lastSeconds'] = lastSeconds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatabaseMetricsApi - functional programming interface
 * @export
 */
export const DatabaseMetricsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DatabaseMetricsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get current metric consumption of the database 
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDatabaseCurrentMetric(databaseId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatabaseCurrentMetric>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDatabaseCurrentMetric(databaseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get CPU consumption metric over time for the database
         * @param {string} databaseId Database ID
         * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDatabaseMetricCpu(databaseId: string, lastSeconds: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricCPUDatapointResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDatabaseMetricCpu(databaseId, lastSeconds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The value returned corresponds to the 95th centile
         * @summary Get Health Check latency  metric over time for the database
         * @param {string} databaseId Database ID
         * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDatabaseMetricHealthCheck(databaseId: string, lastSeconds: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricGenericResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDatabaseMetricHealthCheck(databaseId, lastSeconds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Memory consumption metric over time for the database
         * @param {string} databaseId Database ID
         * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDatabaseMetricMemory(databaseId: string, lastSeconds: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricMemoryDatapointResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDatabaseMetricMemory(databaseId, lastSeconds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Storage consumption metric over time for the database
         * @param {string} databaseId Database ID
         * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDatabaseMetricStorage(databaseId: string, lastSeconds: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricStorageDatapointResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDatabaseMetricStorage(databaseId, lastSeconds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DatabaseMetricsApi - factory interface
 * @export
 */
export const DatabaseMetricsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DatabaseMetricsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get current metric consumption of the database 
         * @param {string} databaseId Database ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseCurrentMetric(databaseId: string, options?: any): AxiosPromise<DatabaseCurrentMetric> {
            return localVarFp.getDatabaseCurrentMetric(databaseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get CPU consumption metric over time for the database
         * @param {string} databaseId Database ID
         * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseMetricCpu(databaseId: string, lastSeconds: number, options?: any): AxiosPromise<MetricCPUDatapointResponseList> {
            return localVarFp.getDatabaseMetricCpu(databaseId, lastSeconds, options).then((request) => request(axios, basePath));
        },
        /**
         * The value returned corresponds to the 95th centile
         * @summary Get Health Check latency  metric over time for the database
         * @param {string} databaseId Database ID
         * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseMetricHealthCheck(databaseId: string, lastSeconds: number, options?: any): AxiosPromise<MetricGenericResponseList> {
            return localVarFp.getDatabaseMetricHealthCheck(databaseId, lastSeconds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Memory consumption metric over time for the database
         * @param {string} databaseId Database ID
         * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseMetricMemory(databaseId: string, lastSeconds: number, options?: any): AxiosPromise<MetricMemoryDatapointResponseList> {
            return localVarFp.getDatabaseMetricMemory(databaseId, lastSeconds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Storage consumption metric over time for the database
         * @param {string} databaseId Database ID
         * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseMetricStorage(databaseId: string, lastSeconds: number, options?: any): AxiosPromise<MetricStorageDatapointResponseList> {
            return localVarFp.getDatabaseMetricStorage(databaseId, lastSeconds, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DatabaseMetricsApi - object-oriented interface
 * @export
 * @class DatabaseMetricsApi
 * @extends {BaseAPI}
 */
export class DatabaseMetricsApi extends BaseAPI {
    /**
     * 
     * @summary Get current metric consumption of the database 
     * @param {string} databaseId Database ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseMetricsApi
     */
    public getDatabaseCurrentMetric(databaseId: string, options?: AxiosRequestConfig) {
        return DatabaseMetricsApiFp(this.configuration).getDatabaseCurrentMetric(databaseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get CPU consumption metric over time for the database
     * @param {string} databaseId Database ID
     * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseMetricsApi
     */
    public getDatabaseMetricCpu(databaseId: string, lastSeconds: number, options?: AxiosRequestConfig) {
        return DatabaseMetricsApiFp(this.configuration).getDatabaseMetricCpu(databaseId, lastSeconds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The value returned corresponds to the 95th centile
     * @summary Get Health Check latency  metric over time for the database
     * @param {string} databaseId Database ID
     * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseMetricsApi
     */
    public getDatabaseMetricHealthCheck(databaseId: string, lastSeconds: number, options?: AxiosRequestConfig) {
        return DatabaseMetricsApiFp(this.configuration).getDatabaseMetricHealthCheck(databaseId, lastSeconds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Memory consumption metric over time for the database
     * @param {string} databaseId Database ID
     * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseMetricsApi
     */
    public getDatabaseMetricMemory(databaseId: string, lastSeconds: number, options?: AxiosRequestConfig) {
        return DatabaseMetricsApiFp(this.configuration).getDatabaseMetricMemory(databaseId, lastSeconds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Storage consumption metric over time for the database
     * @param {string} databaseId Database ID
     * @param {number} lastSeconds Up to how many seconds in the past to ask analytics results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseMetricsApi
     */
    public getDatabaseMetricStorage(databaseId: string, lastSeconds: number, options?: AxiosRequestConfig) {
        return DatabaseMetricsApiFp(this.configuration).getDatabaseMetricStorage(databaseId, lastSeconds, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DatabasesApi - axios parameter creator
 * @export
 */
export const DatabasesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This will create a new database with the same configuration on the targeted environment Id.
         * @summary Clone database
         * @param {string} databaseId Database ID
         * @param {CloneDatabaseRequest} [cloneDatabaseRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneDatabase: async (databaseId: string, cloneDatabaseRequest?: CloneDatabaseRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('cloneDatabase', 'databaseId', databaseId)
            const localVarPath = `/database/{databaseId}/clone`
                .replace(`{${"databaseId"}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloneDatabaseRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a database
         * @param {string} environmentId Environment ID
         * @param {DatabaseRequest} [databaseRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatabase: async (environmentId: string, databaseRequest?: DatabaseRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('createDatabase', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/database`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(databaseRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of databases with only their id and status.
         * @summary List all environment databases statuses
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentDatabaseStatus: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('getEnvironmentDatabaseStatus', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/database/status`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List environment databases
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabase: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('listDatabase', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/database`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List eligible database types, versions and modes for the environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentDatabaseConfig: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('listEnvironmentDatabaseConfig', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/databaseConfiguration`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List current metric consumption for each database
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentDatabaseCurrentMetric: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('listEnvironmentDatabaseCurrentMetric', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/database/currentMetric`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatabasesApi - functional programming interface
 * @export
 */
export const DatabasesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DatabasesApiAxiosParamCreator(configuration)
    return {
        /**
         * This will create a new database with the same configuration on the targeted environment Id.
         * @summary Clone database
         * @param {string} databaseId Database ID
         * @param {CloneDatabaseRequest} [cloneDatabaseRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloneDatabase(databaseId: string, cloneDatabaseRequest?: CloneDatabaseRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Database>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cloneDatabase(databaseId, cloneDatabaseRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a database
         * @param {string} environmentId Environment ID
         * @param {DatabaseRequest} [databaseRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDatabase(environmentId: string, databaseRequest?: DatabaseRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Database>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDatabase(environmentId, databaseRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of databases with only their id and status.
         * @summary List all environment databases statuses
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironmentDatabaseStatus(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReferenceObjectStatusResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironmentDatabaseStatus(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List environment databases
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDatabase(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatabaseResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDatabase(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List eligible database types, versions and modes for the environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEnvironmentDatabaseConfig(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatabaseConfigurationResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEnvironmentDatabaseConfig(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List current metric consumption for each database
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEnvironmentDatabaseCurrentMetric(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentDatabasesCurrentMetricResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEnvironmentDatabaseCurrentMetric(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DatabasesApi - factory interface
 * @export
 */
export const DatabasesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DatabasesApiFp(configuration)
    return {
        /**
         * This will create a new database with the same configuration on the targeted environment Id.
         * @summary Clone database
         * @param {string} databaseId Database ID
         * @param {CloneDatabaseRequest} [cloneDatabaseRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneDatabase(databaseId: string, cloneDatabaseRequest?: CloneDatabaseRequest, options?: any): AxiosPromise<Database> {
            return localVarFp.cloneDatabase(databaseId, cloneDatabaseRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a database
         * @param {string} environmentId Environment ID
         * @param {DatabaseRequest} [databaseRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatabase(environmentId: string, databaseRequest?: DatabaseRequest, options?: any): AxiosPromise<Database> {
            return localVarFp.createDatabase(environmentId, databaseRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of databases with only their id and status.
         * @summary List all environment databases statuses
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentDatabaseStatus(environmentId: string, options?: any): AxiosPromise<ReferenceObjectStatusResponseList> {
            return localVarFp.getEnvironmentDatabaseStatus(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List environment databases
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabase(environmentId: string, options?: any): AxiosPromise<DatabaseResponseList> {
            return localVarFp.listDatabase(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List eligible database types, versions and modes for the environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentDatabaseConfig(environmentId: string, options?: any): AxiosPromise<DatabaseConfigurationResponseList> {
            return localVarFp.listEnvironmentDatabaseConfig(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List current metric consumption for each database
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentDatabaseCurrentMetric(environmentId: string, options?: any): AxiosPromise<EnvironmentDatabasesCurrentMetricResponseList> {
            return localVarFp.listEnvironmentDatabaseCurrentMetric(environmentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DatabasesApi - object-oriented interface
 * @export
 * @class DatabasesApi
 * @extends {BaseAPI}
 */
export class DatabasesApi extends BaseAPI {
    /**
     * This will create a new database with the same configuration on the targeted environment Id.
     * @summary Clone database
     * @param {string} databaseId Database ID
     * @param {CloneDatabaseRequest} [cloneDatabaseRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabasesApi
     */
    public cloneDatabase(databaseId: string, cloneDatabaseRequest?: CloneDatabaseRequest, options?: AxiosRequestConfig) {
        return DatabasesApiFp(this.configuration).cloneDatabase(databaseId, cloneDatabaseRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a database
     * @param {string} environmentId Environment ID
     * @param {DatabaseRequest} [databaseRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabasesApi
     */
    public createDatabase(environmentId: string, databaseRequest?: DatabaseRequest, options?: AxiosRequestConfig) {
        return DatabasesApiFp(this.configuration).createDatabase(environmentId, databaseRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of databases with only their id and status.
     * @summary List all environment databases statuses
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabasesApi
     */
    public getEnvironmentDatabaseStatus(environmentId: string, options?: AxiosRequestConfig) {
        return DatabasesApiFp(this.configuration).getEnvironmentDatabaseStatus(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List environment databases
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabasesApi
     */
    public listDatabase(environmentId: string, options?: AxiosRequestConfig) {
        return DatabasesApiFp(this.configuration).listDatabase(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List eligible database types, versions and modes for the environment
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabasesApi
     */
    public listEnvironmentDatabaseConfig(environmentId: string, options?: AxiosRequestConfig) {
        return DatabasesApiFp(this.configuration).listEnvironmentDatabaseConfig(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List current metric consumption for each database
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabasesApi
     */
    public listEnvironmentDatabaseCurrentMetric(environmentId: string, options?: AxiosRequestConfig) {
        return DatabasesApiFp(this.configuration).listEnvironmentDatabaseCurrentMetric(environmentId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DeploymentStageMainCallsApi - axios parameter creator
 * @export
 */
export const DeploymentStageMainCallsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Attach service to deployment stage
         * @param {string} deploymentStageId Deployment Stage ID
         * @param {string} serviceId Service ID of an application/job/container/database
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachServiceToDeploymentStage: async (deploymentStageId: string, serviceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deploymentStageId' is not null or undefined
            assertParamExists('attachServiceToDeploymentStage', 'deploymentStageId', deploymentStageId)
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('attachServiceToDeploymentStage', 'serviceId', serviceId)
            const localVarPath = `/deploymentStage/{deploymentStageId}/service/{serviceId}`
                .replace(`{${"deploymentStageId"}}`, encodeURIComponent(String(deploymentStageId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create environment deployment stage
         * @param {string} environmentId Environment ID
         * @param {DeploymentStageRequest} [deploymentStageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironmentDeploymentStage: async (environmentId: string, deploymentStageRequest?: DeploymentStageRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('createEnvironmentDeploymentStage', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/deploymentStage`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deploymentStageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete deployment stage
         * @param {string} deploymentStageId Deployment Stage ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeploymentStage: async (deploymentStageId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deploymentStageId' is not null or undefined
            assertParamExists('deleteDeploymentStage', 'deploymentStageId', deploymentStageId)
            const localVarPath = `/deploymentStage/{deploymentStageId}`
                .replace(`{${"deploymentStageId"}}`, encodeURIComponent(String(deploymentStageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit deployment stage
         * @param {string} deploymentStageId Deployment Stage ID
         * @param {DeploymentStageRequest} [deploymentStageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editDeploymentStage: async (deploymentStageId: string, deploymentStageRequest?: DeploymentStageRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deploymentStageId' is not null or undefined
            assertParamExists('editDeploymentStage', 'deploymentStageId', deploymentStageId)
            const localVarPath = `/deploymentStage/{deploymentStageId}`
                .replace(`{${"deploymentStageId"}}`, encodeURIComponent(String(deploymentStageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deploymentStageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Deployment Stage
         * @param {string} deploymentStageId Deployment Stage ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeploymentStage: async (deploymentStageId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deploymentStageId' is not null or undefined
            assertParamExists('getDeploymentStage', 'deploymentStageId', deploymentStageId)
            const localVarPath = `/deploymentStage/{deploymentStageId}`
                .replace(`{${"deploymentStageId"}}`, encodeURIComponent(String(deploymentStageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Service Deployment Stage
         * @param {string} serviceId Service ID of an application/job/container/database
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeploymentStage: async (serviceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('getServiceDeploymentStage', 'serviceId', serviceId)
            const localVarPath = `/service/{serviceId}/deploymentStage`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List environment deployment stage
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentDeploymentStage: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('listEnvironmentDeploymentStage', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/deploymentStage`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Move deployment stage after requested stage
         * @param {string} deploymentStageId Deployment Stage ID
         * @param {string} stageId Deployment Stage ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveAfterDeploymentStage: async (deploymentStageId: string, stageId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deploymentStageId' is not null or undefined
            assertParamExists('moveAfterDeploymentStage', 'deploymentStageId', deploymentStageId)
            // verify required parameter 'stageId' is not null or undefined
            assertParamExists('moveAfterDeploymentStage', 'stageId', stageId)
            const localVarPath = `/deploymentStage/{deploymentStageId}/moveAfter/{stageId}`
                .replace(`{${"deploymentStageId"}}`, encodeURIComponent(String(deploymentStageId)))
                .replace(`{${"stageId"}}`, encodeURIComponent(String(stageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Move deployment stage before requested stage
         * @param {string} deploymentStageId Deployment Stage ID
         * @param {string} stageId Deployment Stage ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveBeforeDeploymentStage: async (deploymentStageId: string, stageId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deploymentStageId' is not null or undefined
            assertParamExists('moveBeforeDeploymentStage', 'deploymentStageId', deploymentStageId)
            // verify required parameter 'stageId' is not null or undefined
            assertParamExists('moveBeforeDeploymentStage', 'stageId', stageId)
            const localVarPath = `/deploymentStage/{deploymentStageId}/moveBefore/{stageId}`
                .replace(`{${"deploymentStageId"}}`, encodeURIComponent(String(deploymentStageId)))
                .replace(`{${"stageId"}}`, encodeURIComponent(String(stageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeploymentStageMainCallsApi - functional programming interface
 * @export
 */
export const DeploymentStageMainCallsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeploymentStageMainCallsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Attach service to deployment stage
         * @param {string} deploymentStageId Deployment Stage ID
         * @param {string} serviceId Service ID of an application/job/container/database
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async attachServiceToDeploymentStage(deploymentStageId: string, serviceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentStageResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.attachServiceToDeploymentStage(deploymentStageId, serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create environment deployment stage
         * @param {string} environmentId Environment ID
         * @param {DeploymentStageRequest} [deploymentStageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEnvironmentDeploymentStage(environmentId: string, deploymentStageRequest?: DeploymentStageRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentStageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEnvironmentDeploymentStage(environmentId, deploymentStageRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete deployment stage
         * @param {string} deploymentStageId Deployment Stage ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDeploymentStage(deploymentStageId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDeploymentStage(deploymentStageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit deployment stage
         * @param {string} deploymentStageId Deployment Stage ID
         * @param {DeploymentStageRequest} [deploymentStageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editDeploymentStage(deploymentStageId: string, deploymentStageRequest?: DeploymentStageRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentStageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editDeploymentStage(deploymentStageId, deploymentStageRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Deployment Stage
         * @param {string} deploymentStageId Deployment Stage ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeploymentStage(deploymentStageId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentStageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeploymentStage(deploymentStageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Service Deployment Stage
         * @param {string} serviceId Service ID of an application/job/container/database
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceDeploymentStage(serviceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentStageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceDeploymentStage(serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List environment deployment stage
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEnvironmentDeploymentStage(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentStageResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEnvironmentDeploymentStage(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Move deployment stage after requested stage
         * @param {string} deploymentStageId Deployment Stage ID
         * @param {string} stageId Deployment Stage ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moveAfterDeploymentStage(deploymentStageId: string, stageId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentStageResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moveAfterDeploymentStage(deploymentStageId, stageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Move deployment stage before requested stage
         * @param {string} deploymentStageId Deployment Stage ID
         * @param {string} stageId Deployment Stage ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moveBeforeDeploymentStage(deploymentStageId: string, stageId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentStageResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moveBeforeDeploymentStage(deploymentStageId, stageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DeploymentStageMainCallsApi - factory interface
 * @export
 */
export const DeploymentStageMainCallsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeploymentStageMainCallsApiFp(configuration)
    return {
        /**
         * 
         * @summary Attach service to deployment stage
         * @param {string} deploymentStageId Deployment Stage ID
         * @param {string} serviceId Service ID of an application/job/container/database
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachServiceToDeploymentStage(deploymentStageId: string, serviceId: string, options?: any): AxiosPromise<DeploymentStageResponseList> {
            return localVarFp.attachServiceToDeploymentStage(deploymentStageId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create environment deployment stage
         * @param {string} environmentId Environment ID
         * @param {DeploymentStageRequest} [deploymentStageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironmentDeploymentStage(environmentId: string, deploymentStageRequest?: DeploymentStageRequest, options?: any): AxiosPromise<DeploymentStageResponse> {
            return localVarFp.createEnvironmentDeploymentStage(environmentId, deploymentStageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete deployment stage
         * @param {string} deploymentStageId Deployment Stage ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeploymentStage(deploymentStageId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDeploymentStage(deploymentStageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit deployment stage
         * @param {string} deploymentStageId Deployment Stage ID
         * @param {DeploymentStageRequest} [deploymentStageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editDeploymentStage(deploymentStageId: string, deploymentStageRequest?: DeploymentStageRequest, options?: any): AxiosPromise<DeploymentStageResponse> {
            return localVarFp.editDeploymentStage(deploymentStageId, deploymentStageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Deployment Stage
         * @param {string} deploymentStageId Deployment Stage ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeploymentStage(deploymentStageId: string, options?: any): AxiosPromise<DeploymentStageResponse> {
            return localVarFp.getDeploymentStage(deploymentStageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Service Deployment Stage
         * @param {string} serviceId Service ID of an application/job/container/database
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeploymentStage(serviceId: string, options?: any): AxiosPromise<DeploymentStageResponse> {
            return localVarFp.getServiceDeploymentStage(serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List environment deployment stage
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentDeploymentStage(environmentId: string, options?: any): AxiosPromise<DeploymentStageResponseList> {
            return localVarFp.listEnvironmentDeploymentStage(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Move deployment stage after requested stage
         * @param {string} deploymentStageId Deployment Stage ID
         * @param {string} stageId Deployment Stage ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveAfterDeploymentStage(deploymentStageId: string, stageId: string, options?: any): AxiosPromise<DeploymentStageResponseList> {
            return localVarFp.moveAfterDeploymentStage(deploymentStageId, stageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Move deployment stage before requested stage
         * @param {string} deploymentStageId Deployment Stage ID
         * @param {string} stageId Deployment Stage ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveBeforeDeploymentStage(deploymentStageId: string, stageId: string, options?: any): AxiosPromise<DeploymentStageResponseList> {
            return localVarFp.moveBeforeDeploymentStage(deploymentStageId, stageId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeploymentStageMainCallsApi - object-oriented interface
 * @export
 * @class DeploymentStageMainCallsApi
 * @extends {BaseAPI}
 */
export class DeploymentStageMainCallsApi extends BaseAPI {
    /**
     * 
     * @summary Attach service to deployment stage
     * @param {string} deploymentStageId Deployment Stage ID
     * @param {string} serviceId Service ID of an application/job/container/database
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentStageMainCallsApi
     */
    public attachServiceToDeploymentStage(deploymentStageId: string, serviceId: string, options?: AxiosRequestConfig) {
        return DeploymentStageMainCallsApiFp(this.configuration).attachServiceToDeploymentStage(deploymentStageId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create environment deployment stage
     * @param {string} environmentId Environment ID
     * @param {DeploymentStageRequest} [deploymentStageRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentStageMainCallsApi
     */
    public createEnvironmentDeploymentStage(environmentId: string, deploymentStageRequest?: DeploymentStageRequest, options?: AxiosRequestConfig) {
        return DeploymentStageMainCallsApiFp(this.configuration).createEnvironmentDeploymentStage(environmentId, deploymentStageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete deployment stage
     * @param {string} deploymentStageId Deployment Stage ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentStageMainCallsApi
     */
    public deleteDeploymentStage(deploymentStageId: string, options?: AxiosRequestConfig) {
        return DeploymentStageMainCallsApiFp(this.configuration).deleteDeploymentStage(deploymentStageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit deployment stage
     * @param {string} deploymentStageId Deployment Stage ID
     * @param {DeploymentStageRequest} [deploymentStageRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentStageMainCallsApi
     */
    public editDeploymentStage(deploymentStageId: string, deploymentStageRequest?: DeploymentStageRequest, options?: AxiosRequestConfig) {
        return DeploymentStageMainCallsApiFp(this.configuration).editDeploymentStage(deploymentStageId, deploymentStageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Deployment Stage
     * @param {string} deploymentStageId Deployment Stage ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentStageMainCallsApi
     */
    public getDeploymentStage(deploymentStageId: string, options?: AxiosRequestConfig) {
        return DeploymentStageMainCallsApiFp(this.configuration).getDeploymentStage(deploymentStageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Service Deployment Stage
     * @param {string} serviceId Service ID of an application/job/container/database
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentStageMainCallsApi
     */
    public getServiceDeploymentStage(serviceId: string, options?: AxiosRequestConfig) {
        return DeploymentStageMainCallsApiFp(this.configuration).getServiceDeploymentStage(serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List environment deployment stage
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentStageMainCallsApi
     */
    public listEnvironmentDeploymentStage(environmentId: string, options?: AxiosRequestConfig) {
        return DeploymentStageMainCallsApiFp(this.configuration).listEnvironmentDeploymentStage(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Move deployment stage after requested stage
     * @param {string} deploymentStageId Deployment Stage ID
     * @param {string} stageId Deployment Stage ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentStageMainCallsApi
     */
    public moveAfterDeploymentStage(deploymentStageId: string, stageId: string, options?: AxiosRequestConfig) {
        return DeploymentStageMainCallsApiFp(this.configuration).moveAfterDeploymentStage(deploymentStageId, stageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Move deployment stage before requested stage
     * @param {string} deploymentStageId Deployment Stage ID
     * @param {string} stageId Deployment Stage ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentStageMainCallsApi
     */
    public moveBeforeDeploymentStage(deploymentStageId: string, stageId: string, options?: AxiosRequestConfig) {
        return DeploymentStageMainCallsApiFp(this.configuration).moveBeforeDeploymentStage(deploymentStageId, stageId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EnvironmentApi - axios parameter creator
 * @export
 */
export const EnvironmentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Start a deployment of the environment. Any of the services within the chosen environment based on the following rule: a service is deployed only if a new version is specified in the payload for that application/container or if there was a change in its configuration that needs to be applied (vCPU,RAM etc..)
         * @summary Deploy applications
         * @param {string} environmentId Environment ID
         * @param {DeployAllRequest} [deployAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployAllApplications: async (environmentId: string, deployAllRequest?: DeployAllRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('deployAllApplications', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/application/deploy`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deployAllRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentApi - functional programming interface
 * @export
 */
export const EnvironmentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnvironmentApiAxiosParamCreator(configuration)
    return {
        /**
         * Start a deployment of the environment. Any of the services within the chosen environment based on the following rule: a service is deployed only if a new version is specified in the payload for that application/container or if there was a change in its configuration that needs to be applied (vCPU,RAM etc..)
         * @summary Deploy applications
         * @param {string} environmentId Environment ID
         * @param {DeployAllRequest} [deployAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployAllApplications(environmentId: string, deployAllRequest?: DeployAllRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployAllApplications(environmentId, deployAllRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EnvironmentApi - factory interface
 * @export
 */
export const EnvironmentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnvironmentApiFp(configuration)
    return {
        /**
         * Start a deployment of the environment. Any of the services within the chosen environment based on the following rule: a service is deployed only if a new version is specified in the payload for that application/container or if there was a change in its configuration that needs to be applied (vCPU,RAM etc..)
         * @summary Deploy applications
         * @param {string} environmentId Environment ID
         * @param {DeployAllRequest} [deployAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployAllApplications(environmentId: string, deployAllRequest?: DeployAllRequest, options?: any): AxiosPromise<Status> {
            return localVarFp.deployAllApplications(environmentId, deployAllRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnvironmentApi - object-oriented interface
 * @export
 * @class EnvironmentApi
 * @extends {BaseAPI}
 */
export class EnvironmentApi extends BaseAPI {
    /**
     * Start a deployment of the environment. Any of the services within the chosen environment based on the following rule: a service is deployed only if a new version is specified in the payload for that application/container or if there was a change in its configuration that needs to be applied (vCPU,RAM etc..)
     * @summary Deploy applications
     * @param {string} environmentId Environment ID
     * @param {DeployAllRequest} [deployAllRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public deployAllApplications(environmentId: string, deployAllRequest?: DeployAllRequest, options?: AxiosRequestConfig) {
        return EnvironmentApiFp(this.configuration).deployAllApplications(environmentId, deployAllRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EnvironmentActionsApi - axios parameter creator
 * @export
 */
export const EnvironmentActionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancel the current deployment of your environment.
         * @summary Cancel environment deployment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelEnvironmentDeployment: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('cancelEnvironmentDeployment', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/cancelDeployment`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You must provide a name. This will create a new environment, with the same configuration, and same applications and databases. Database data is not cloned.
         * @summary Clone environment
         * @param {string} environmentId Environment ID
         * @param {CloneRequest} [cloneRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneEnvironment: async (environmentId: string, cloneRequest?: CloneRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('cloneEnvironment', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/clone`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloneRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update and deploy the selected services
         * @summary Deploy services
         * @param {string} environmentId Environment ID
         * @param {DeployAllRequest} [deployAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployAllServices: async (environmentId: string, deployAllRequest?: DeployAllRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('deployAllServices', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/service/deploy`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deployAllRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This will deploy all the services of this environment to their latest version.
         * @summary Deploy environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployEnvironment: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('deployEnvironment', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/deploy`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update and reboot the selected services
         * @summary Reboot services
         * @param {string} environmentId Environment ID
         * @param {RebootServicesRequest} [rebootServicesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rebootServices: async (environmentId: string, rebootServicesRequest?: RebootServicesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('rebootServices', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/service/restart-service`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rebootServicesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Redeploy environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeployEnvironment: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('redeployEnvironment', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/redeploy`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Deprecated** - Please use the \"Redeploy environment\" endpoint now
         * @summary Deprecated - Restart environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartEnvironment: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('restartEnvironment', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/restart`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopEnvironment: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('stopEnvironment', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/stop`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentActionsApi - functional programming interface
 * @export
 */
export const EnvironmentActionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnvironmentActionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Cancel the current deployment of your environment.
         * @summary Cancel environment deployment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelEnvironmentDeployment(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelEnvironmentDeployment(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * You must provide a name. This will create a new environment, with the same configuration, and same applications and databases. Database data is not cloned.
         * @summary Clone environment
         * @param {string} environmentId Environment ID
         * @param {CloneRequest} [cloneRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloneEnvironment(environmentId: string, cloneRequest?: CloneRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Environment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cloneEnvironment(environmentId, cloneRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update and deploy the selected services
         * @summary Deploy services
         * @param {string} environmentId Environment ID
         * @param {DeployAllRequest} [deployAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployAllServices(environmentId: string, deployAllRequest?: DeployAllRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployAllServices(environmentId, deployAllRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This will deploy all the services of this environment to their latest version.
         * @summary Deploy environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployEnvironment(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployEnvironment(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update and reboot the selected services
         * @summary Reboot services
         * @param {string} environmentId Environment ID
         * @param {RebootServicesRequest} [rebootServicesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rebootServices(environmentId: string, rebootServicesRequest?: RebootServicesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rebootServices(environmentId, rebootServicesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Redeploy environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async redeployEnvironment(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.redeployEnvironment(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **Deprecated** - Please use the \"Redeploy environment\" endpoint now
         * @summary Deprecated - Restart environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restartEnvironment(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restartEnvironment(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Stop environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopEnvironment(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopEnvironment(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EnvironmentActionsApi - factory interface
 * @export
 */
export const EnvironmentActionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnvironmentActionsApiFp(configuration)
    return {
        /**
         * Cancel the current deployment of your environment.
         * @summary Cancel environment deployment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelEnvironmentDeployment(environmentId: string, options?: any): AxiosPromise<EnvironmentStatus> {
            return localVarFp.cancelEnvironmentDeployment(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * You must provide a name. This will create a new environment, with the same configuration, and same applications and databases. Database data is not cloned.
         * @summary Clone environment
         * @param {string} environmentId Environment ID
         * @param {CloneRequest} [cloneRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneEnvironment(environmentId: string, cloneRequest?: CloneRequest, options?: any): AxiosPromise<Environment> {
            return localVarFp.cloneEnvironment(environmentId, cloneRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update and deploy the selected services
         * @summary Deploy services
         * @param {string} environmentId Environment ID
         * @param {DeployAllRequest} [deployAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployAllServices(environmentId: string, deployAllRequest?: DeployAllRequest, options?: any): AxiosPromise<Status> {
            return localVarFp.deployAllServices(environmentId, deployAllRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This will deploy all the services of this environment to their latest version.
         * @summary Deploy environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployEnvironment(environmentId: string, options?: any): AxiosPromise<Status> {
            return localVarFp.deployEnvironment(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update and reboot the selected services
         * @summary Reboot services
         * @param {string} environmentId Environment ID
         * @param {RebootServicesRequest} [rebootServicesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rebootServices(environmentId: string, rebootServicesRequest?: RebootServicesRequest, options?: any): AxiosPromise<Status> {
            return localVarFp.rebootServices(environmentId, rebootServicesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Redeploy environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeployEnvironment(environmentId: string, options?: any): AxiosPromise<EnvironmentStatus> {
            return localVarFp.redeployEnvironment(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * **Deprecated** - Please use the \"Redeploy environment\" endpoint now
         * @summary Deprecated - Restart environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartEnvironment(environmentId: string, options?: any): AxiosPromise<EnvironmentStatus> {
            return localVarFp.restartEnvironment(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Stop environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopEnvironment(environmentId: string, options?: any): AxiosPromise<EnvironmentStatus> {
            return localVarFp.stopEnvironment(environmentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnvironmentActionsApi - object-oriented interface
 * @export
 * @class EnvironmentActionsApi
 * @extends {BaseAPI}
 */
export class EnvironmentActionsApi extends BaseAPI {
    /**
     * Cancel the current deployment of your environment.
     * @summary Cancel environment deployment
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentActionsApi
     */
    public cancelEnvironmentDeployment(environmentId: string, options?: AxiosRequestConfig) {
        return EnvironmentActionsApiFp(this.configuration).cancelEnvironmentDeployment(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You must provide a name. This will create a new environment, with the same configuration, and same applications and databases. Database data is not cloned.
     * @summary Clone environment
     * @param {string} environmentId Environment ID
     * @param {CloneRequest} [cloneRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentActionsApi
     */
    public cloneEnvironment(environmentId: string, cloneRequest?: CloneRequest, options?: AxiosRequestConfig) {
        return EnvironmentActionsApiFp(this.configuration).cloneEnvironment(environmentId, cloneRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update and deploy the selected services
     * @summary Deploy services
     * @param {string} environmentId Environment ID
     * @param {DeployAllRequest} [deployAllRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentActionsApi
     */
    public deployAllServices(environmentId: string, deployAllRequest?: DeployAllRequest, options?: AxiosRequestConfig) {
        return EnvironmentActionsApiFp(this.configuration).deployAllServices(environmentId, deployAllRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will deploy all the services of this environment to their latest version.
     * @summary Deploy environment
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentActionsApi
     */
    public deployEnvironment(environmentId: string, options?: AxiosRequestConfig) {
        return EnvironmentActionsApiFp(this.configuration).deployEnvironment(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update and reboot the selected services
     * @summary Reboot services
     * @param {string} environmentId Environment ID
     * @param {RebootServicesRequest} [rebootServicesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentActionsApi
     */
    public rebootServices(environmentId: string, rebootServicesRequest?: RebootServicesRequest, options?: AxiosRequestConfig) {
        return EnvironmentActionsApiFp(this.configuration).rebootServices(environmentId, rebootServicesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Redeploy environment
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentActionsApi
     */
    public redeployEnvironment(environmentId: string, options?: AxiosRequestConfig) {
        return EnvironmentActionsApiFp(this.configuration).redeployEnvironment(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Deprecated** - Please use the \"Redeploy environment\" endpoint now
     * @summary Deprecated - Restart environment
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentActionsApi
     */
    public restartEnvironment(environmentId: string, options?: AxiosRequestConfig) {
        return EnvironmentActionsApiFp(this.configuration).restartEnvironment(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Stop environment
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentActionsApi
     */
    public stopEnvironment(environmentId: string, options?: AxiosRequestConfig) {
        return EnvironmentActionsApiFp(this.configuration).stopEnvironment(environmentId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EnvironmentDeploymentHistoryApi - axios parameter creator
 * @export
 */
export const EnvironmentDeploymentHistoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List previous and current environment deployments with the status deployment and the related services. By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter
         * @summary List environment deployments
         * @param {string} environmentId Environment ID
         * @param {string} [startId] Starting point after which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentDeploymentHistory: async (environmentId: string, startId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('listEnvironmentDeploymentHistory', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/deploymentHistory`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (startId !== undefined) {
                localVarQueryParameter['startId'] = startId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentDeploymentHistoryApi - functional programming interface
 * @export
 */
export const EnvironmentDeploymentHistoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnvironmentDeploymentHistoryApiAxiosParamCreator(configuration)
    return {
        /**
         * List previous and current environment deployments with the status deployment and the related services. By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter
         * @summary List environment deployments
         * @param {string} environmentId Environment ID
         * @param {string} [startId] Starting point after which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEnvironmentDeploymentHistory(environmentId: string, startId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentHistoryEnvironmentPaginatedResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEnvironmentDeploymentHistory(environmentId, startId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EnvironmentDeploymentHistoryApi - factory interface
 * @export
 */
export const EnvironmentDeploymentHistoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnvironmentDeploymentHistoryApiFp(configuration)
    return {
        /**
         * List previous and current environment deployments with the status deployment and the related services. By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter
         * @summary List environment deployments
         * @param {string} environmentId Environment ID
         * @param {string} [startId] Starting point after which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentDeploymentHistory(environmentId: string, startId?: string, options?: any): AxiosPromise<DeploymentHistoryEnvironmentPaginatedResponseList> {
            return localVarFp.listEnvironmentDeploymentHistory(environmentId, startId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnvironmentDeploymentHistoryApi - object-oriented interface
 * @export
 * @class EnvironmentDeploymentHistoryApi
 * @extends {BaseAPI}
 */
export class EnvironmentDeploymentHistoryApi extends BaseAPI {
    /**
     * List previous and current environment deployments with the status deployment and the related services. By default it returns the 20 last results. The response is paginated. In order to request the next page, you can use the startId query parameter
     * @summary List environment deployments
     * @param {string} environmentId Environment ID
     * @param {string} [startId] Starting point after which to return results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentDeploymentHistoryApi
     */
    public listEnvironmentDeploymentHistory(environmentId: string, startId?: string, options?: AxiosRequestConfig) {
        return EnvironmentDeploymentHistoryApiFp(this.configuration).listEnvironmentDeploymentHistory(environmentId, startId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EnvironmentDeploymentRuleApi - axios parameter creator
 * @export
 */
export const EnvironmentDeploymentRuleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Edit an environment deployment rule
         * @param {string} environmentId Environment ID
         * @param {string} deploymentRuleId Deployment Rule ID
         * @param {EnvironmentDeploymentRuleEditRequest} [environmentDeploymentRuleEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editEnvironmentDeploymentRule: async (environmentId: string, deploymentRuleId: string, environmentDeploymentRuleEditRequest?: EnvironmentDeploymentRuleEditRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('editEnvironmentDeploymentRule', 'environmentId', environmentId)
            // verify required parameter 'deploymentRuleId' is not null or undefined
            assertParamExists('editEnvironmentDeploymentRule', 'deploymentRuleId', deploymentRuleId)
            const localVarPath = `/environment/{environmentId}/deploymentRule/{deploymentRuleId}`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)))
                .replace(`{${"deploymentRuleId"}}`, encodeURIComponent(String(deploymentRuleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentDeploymentRuleEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get environment deployment rule
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentDeploymentRule: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('getEnvironmentDeploymentRule', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/deploymentRule`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentDeploymentRuleApi - functional programming interface
 * @export
 */
export const EnvironmentDeploymentRuleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnvironmentDeploymentRuleApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Edit an environment deployment rule
         * @param {string} environmentId Environment ID
         * @param {string} deploymentRuleId Deployment Rule ID
         * @param {EnvironmentDeploymentRuleEditRequest} [environmentDeploymentRuleEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editEnvironmentDeploymentRule(environmentId: string, deploymentRuleId: string, environmentDeploymentRuleEditRequest?: EnvironmentDeploymentRuleEditRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentDeploymentRule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editEnvironmentDeploymentRule(environmentId, deploymentRuleId, environmentDeploymentRuleEditRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get environment deployment rule
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironmentDeploymentRule(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentDeploymentRule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironmentDeploymentRule(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EnvironmentDeploymentRuleApi - factory interface
 * @export
 */
export const EnvironmentDeploymentRuleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnvironmentDeploymentRuleApiFp(configuration)
    return {
        /**
         * 
         * @summary Edit an environment deployment rule
         * @param {string} environmentId Environment ID
         * @param {string} deploymentRuleId Deployment Rule ID
         * @param {EnvironmentDeploymentRuleEditRequest} [environmentDeploymentRuleEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editEnvironmentDeploymentRule(environmentId: string, deploymentRuleId: string, environmentDeploymentRuleEditRequest?: EnvironmentDeploymentRuleEditRequest, options?: any): AxiosPromise<EnvironmentDeploymentRule> {
            return localVarFp.editEnvironmentDeploymentRule(environmentId, deploymentRuleId, environmentDeploymentRuleEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get environment deployment rule
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentDeploymentRule(environmentId: string, options?: any): AxiosPromise<EnvironmentDeploymentRule> {
            return localVarFp.getEnvironmentDeploymentRule(environmentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnvironmentDeploymentRuleApi - object-oriented interface
 * @export
 * @class EnvironmentDeploymentRuleApi
 * @extends {BaseAPI}
 */
export class EnvironmentDeploymentRuleApi extends BaseAPI {
    /**
     * 
     * @summary Edit an environment deployment rule
     * @param {string} environmentId Environment ID
     * @param {string} deploymentRuleId Deployment Rule ID
     * @param {EnvironmentDeploymentRuleEditRequest} [environmentDeploymentRuleEditRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentDeploymentRuleApi
     */
    public editEnvironmentDeploymentRule(environmentId: string, deploymentRuleId: string, environmentDeploymentRuleEditRequest?: EnvironmentDeploymentRuleEditRequest, options?: AxiosRequestConfig) {
        return EnvironmentDeploymentRuleApiFp(this.configuration).editEnvironmentDeploymentRule(environmentId, deploymentRuleId, environmentDeploymentRuleEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get environment deployment rule
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentDeploymentRuleApi
     */
    public getEnvironmentDeploymentRule(environmentId: string, options?: AxiosRequestConfig) {
        return EnvironmentDeploymentRuleApiFp(this.configuration).getEnvironmentDeploymentRule(environmentId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EnvironmentExportApi - axios parameter creator
 * @export
 */
export const EnvironmentExportApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Export full environment and its resources into Terraform manifests
         * @param {string} environmentId Environment ID
         * @param {boolean} [exportSecrets] export Secrets from configuration and include them into Terraform export
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportEnvironmentConfigurationIntoTerraform: async (environmentId: string, exportSecrets?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('exportEnvironmentConfigurationIntoTerraform', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/terraformExport`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (exportSecrets !== undefined) {
                localVarQueryParameter['exportSecrets'] = exportSecrets;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentExportApi - functional programming interface
 * @export
 */
export const EnvironmentExportApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnvironmentExportApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Export full environment and its resources into Terraform manifests
         * @param {string} environmentId Environment ID
         * @param {boolean} [exportSecrets] export Secrets from configuration and include them into Terraform export
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportEnvironmentConfigurationIntoTerraform(environmentId: string, exportSecrets?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportEnvironmentConfigurationIntoTerraform(environmentId, exportSecrets, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EnvironmentExportApi - factory interface
 * @export
 */
export const EnvironmentExportApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnvironmentExportApiFp(configuration)
    return {
        /**
         * 
         * @summary Export full environment and its resources into Terraform manifests
         * @param {string} environmentId Environment ID
         * @param {boolean} [exportSecrets] export Secrets from configuration and include them into Terraform export
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportEnvironmentConfigurationIntoTerraform(environmentId: string, exportSecrets?: boolean, options?: any): AxiosPromise<any> {
            return localVarFp.exportEnvironmentConfigurationIntoTerraform(environmentId, exportSecrets, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnvironmentExportApi - object-oriented interface
 * @export
 * @class EnvironmentExportApi
 * @extends {BaseAPI}
 */
export class EnvironmentExportApi extends BaseAPI {
    /**
     * 
     * @summary Export full environment and its resources into Terraform manifests
     * @param {string} environmentId Environment ID
     * @param {boolean} [exportSecrets] export Secrets from configuration and include them into Terraform export
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentExportApi
     */
    public exportEnvironmentConfigurationIntoTerraform(environmentId: string, exportSecrets?: boolean, options?: AxiosRequestConfig) {
        return EnvironmentExportApiFp(this.configuration).exportEnvironmentConfigurationIntoTerraform(environmentId, exportSecrets, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EnvironmentLogsApi - axios parameter creator
 * @export
 */
export const EnvironmentLogsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This returns the last 1000 environment deployment logs.
         * @summary List environment deployment logs
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentLog: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('listEnvironmentLog', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/log`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This returns the last 1000 environment deployment logs v2
         * @summary List environment deployment logs v2
         * @param {string} environmentId Environment ID
         * @param {string} [version] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentLogs: async (environmentId: string, version?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('listEnvironmentLogs', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/logs`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentLogsApi - functional programming interface
 * @export
 */
export const EnvironmentLogsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnvironmentLogsApiAxiosParamCreator(configuration)
    return {
        /**
         * This returns the last 1000 environment deployment logs.
         * @summary List environment deployment logs
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEnvironmentLog(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentLogResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEnvironmentLog(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This returns the last 1000 environment deployment logs v2
         * @summary List environment deployment logs v2
         * @param {string} environmentId Environment ID
         * @param {string} [version] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEnvironmentLogs(environmentId: string, version?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EnvironmentLogs>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEnvironmentLogs(environmentId, version, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EnvironmentLogsApi - factory interface
 * @export
 */
export const EnvironmentLogsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnvironmentLogsApiFp(configuration)
    return {
        /**
         * This returns the last 1000 environment deployment logs.
         * @summary List environment deployment logs
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentLog(environmentId: string, options?: any): AxiosPromise<EnvironmentLogResponseList> {
            return localVarFp.listEnvironmentLog(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * This returns the last 1000 environment deployment logs v2
         * @summary List environment deployment logs v2
         * @param {string} environmentId Environment ID
         * @param {string} [version] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentLogs(environmentId: string, version?: string, options?: any): AxiosPromise<Array<EnvironmentLogs>> {
            return localVarFp.listEnvironmentLogs(environmentId, version, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnvironmentLogsApi - object-oriented interface
 * @export
 * @class EnvironmentLogsApi
 * @extends {BaseAPI}
 */
export class EnvironmentLogsApi extends BaseAPI {
    /**
     * This returns the last 1000 environment deployment logs.
     * @summary List environment deployment logs
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentLogsApi
     */
    public listEnvironmentLog(environmentId: string, options?: AxiosRequestConfig) {
        return EnvironmentLogsApiFp(this.configuration).listEnvironmentLog(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This returns the last 1000 environment deployment logs v2
     * @summary List environment deployment logs v2
     * @param {string} environmentId Environment ID
     * @param {string} [version] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentLogsApi
     */
    public listEnvironmentLogs(environmentId: string, version?: string, options?: AxiosRequestConfig) {
        return EnvironmentLogsApiFp(this.configuration).listEnvironmentLogs(environmentId, version, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EnvironmentMainCallsApi - axios parameter creator
 * @export
 */
export const EnvironmentMainCallsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * To delete an environment you must have the admin permission
         * @summary Delete an environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEnvironment: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('deleteEnvironment', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To edit an environment you must have the admin permission
         * @summary Edit an environment
         * @param {string} environmentId Environment ID
         * @param {EnvironmentEditRequest} [environmentEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editEnvironment: async (environmentId: string, environmentEditRequest?: EnvironmentEditRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('editEnvironment', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get environment by ID
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironment: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('getEnvironment', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get environment status
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentStatus: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('getEnvironmentStatus', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/status`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get environment statuses with services status
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentStatuses: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('getEnvironmentStatuses', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/statuses`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get environment statuses with stages
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentStatusesWithStages: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('getEnvironmentStatusesWithStages', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/statusesWithStages`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentMainCallsApi - functional programming interface
 * @export
 */
export const EnvironmentMainCallsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnvironmentMainCallsApiAxiosParamCreator(configuration)
    return {
        /**
         * To delete an environment you must have the admin permission
         * @summary Delete an environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEnvironment(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEnvironment(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * To edit an environment you must have the admin permission
         * @summary Edit an environment
         * @param {string} environmentId Environment ID
         * @param {EnvironmentEditRequest} [environmentEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editEnvironment(environmentId: string, environmentEditRequest?: EnvironmentEditRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Environment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editEnvironment(environmentId, environmentEditRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get environment by ID
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironment(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Environment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironment(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get environment status
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironmentStatus(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironmentStatus(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get environment statuses with services status
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironmentStatuses(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironmentStatuses(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get environment statuses with stages
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironmentStatusesWithStages(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironmentStatusesWithStages(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EnvironmentMainCallsApi - factory interface
 * @export
 */
export const EnvironmentMainCallsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnvironmentMainCallsApiFp(configuration)
    return {
        /**
         * To delete an environment you must have the admin permission
         * @summary Delete an environment
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEnvironment(environmentId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteEnvironment(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * To edit an environment you must have the admin permission
         * @summary Edit an environment
         * @param {string} environmentId Environment ID
         * @param {EnvironmentEditRequest} [environmentEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editEnvironment(environmentId: string, environmentEditRequest?: EnvironmentEditRequest, options?: any): AxiosPromise<Environment> {
            return localVarFp.editEnvironment(environmentId, environmentEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get environment by ID
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironment(environmentId: string, options?: any): AxiosPromise<Environment> {
            return localVarFp.getEnvironment(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get environment status
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentStatus(environmentId: string, options?: any): AxiosPromise<EnvironmentStatus> {
            return localVarFp.getEnvironmentStatus(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get environment statuses with services status
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentStatuses(environmentId: string, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.getEnvironmentStatuses(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get environment statuses with stages
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentStatusesWithStages(environmentId: string, options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.getEnvironmentStatusesWithStages(environmentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnvironmentMainCallsApi - object-oriented interface
 * @export
 * @class EnvironmentMainCallsApi
 * @extends {BaseAPI}
 */
export class EnvironmentMainCallsApi extends BaseAPI {
    /**
     * To delete an environment you must have the admin permission
     * @summary Delete an environment
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentMainCallsApi
     */
    public deleteEnvironment(environmentId: string, options?: AxiosRequestConfig) {
        return EnvironmentMainCallsApiFp(this.configuration).deleteEnvironment(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To edit an environment you must have the admin permission
     * @summary Edit an environment
     * @param {string} environmentId Environment ID
     * @param {EnvironmentEditRequest} [environmentEditRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentMainCallsApi
     */
    public editEnvironment(environmentId: string, environmentEditRequest?: EnvironmentEditRequest, options?: AxiosRequestConfig) {
        return EnvironmentMainCallsApiFp(this.configuration).editEnvironment(environmentId, environmentEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get environment by ID
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentMainCallsApi
     */
    public getEnvironment(environmentId: string, options?: AxiosRequestConfig) {
        return EnvironmentMainCallsApiFp(this.configuration).getEnvironment(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get environment status
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentMainCallsApi
     */
    public getEnvironmentStatus(environmentId: string, options?: AxiosRequestConfig) {
        return EnvironmentMainCallsApiFp(this.configuration).getEnvironmentStatus(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get environment statuses with services status
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentMainCallsApi
     */
    public getEnvironmentStatuses(environmentId: string, options?: AxiosRequestConfig) {
        return EnvironmentMainCallsApiFp(this.configuration).getEnvironmentStatuses(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get environment statuses with stages
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentMainCallsApi
     */
    public getEnvironmentStatusesWithStages(environmentId: string, options?: AxiosRequestConfig) {
        return EnvironmentMainCallsApiFp(this.configuration).getEnvironmentStatusesWithStages(environmentId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EnvironmentSecretApi - axios parameter creator
 * @export
 */
export const EnvironmentSecretApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * - Add a secret to the environment.   - If the secret key already exists, then it will be replaced by the new one.   - If the secret value points toward an existing secret key, it will be considered as an alias. 
         * @summary Add a secret to the environment
         * @param {string} environmentId Environment ID
         * @param {SecretRequest} [secretRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironmentSecret: async (environmentId: string, secretRequest?: SecretRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('createEnvironmentSecret', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/secret`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(secretRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to add an alias at environment level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at environment level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - Only 1 alias level is allowed. You can\'t create an alias on an alias 
         * @summary Create a secret alias at the environment level
         * @param {string} environmentId Environment ID
         * @param {string} secretId Secret ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironmentSecretAlias: async (environmentId: string, secretId: string, key?: Key, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('createEnvironmentSecretAlias', 'environmentId', environmentId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('createEnvironmentSecretAlias', 'secretId', secretId)
            const localVarPath = `/environment/{environmentId}/secret/{secretId}/alias`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(key, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to override at environment level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at environment level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
         * @summary Create a secret override at the environment level
         * @param {string} environmentId Environment ID
         * @param {string} secretId Secret ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironmentSecretOverride: async (environmentId: string, secretId: string, value?: Value, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('createEnvironmentSecretOverride', 'environmentId', environmentId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('createEnvironmentSecretOverride', 'secretId', secretId)
            const localVarPath = `/environment/{environmentId}/secret/{secretId}/override`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(value, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well  operationId: deleteEnvironmentSecret 
         * @summary Delete a secret from the environment
         * @param {string} environmentId Environment ID
         * @param {string} secretId Secret ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEnvironmentSecret: async (environmentId: string, secretId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('deleteEnvironmentSecret', 'environmentId', environmentId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('deleteEnvironmentSecret', 'secretId', secretId)
            const localVarPath = `/environment/{environmentId}/secret/{secretId}`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit a secret belonging to the environment
         * @param {string} environmentId Environment ID
         * @param {string} secretId Secret ID
         * @param {SecretEditRequest} secretEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editEnvironmentSecret: async (environmentId: string, secretId: string, secretEditRequest: SecretEditRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('editEnvironmentSecret', 'environmentId', environmentId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('editEnvironmentSecret', 'secretId', secretId)
            // verify required parameter 'secretEditRequest' is not null or undefined
            assertParamExists('editEnvironmentSecret', 'secretEditRequest', secretEditRequest)
            const localVarPath = `/environment/{environmentId}/secret/{secretId}`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(secretEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List environment secrets
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentSecrets: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('listEnvironmentSecrets', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/secret`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentSecretApi - functional programming interface
 * @export
 */
export const EnvironmentSecretApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnvironmentSecretApiAxiosParamCreator(configuration)
    return {
        /**
         * - Add a secret to the environment.   - If the secret key already exists, then it will be replaced by the new one.   - If the secret value points toward an existing secret key, it will be considered as an alias. 
         * @summary Add a secret to the environment
         * @param {string} environmentId Environment ID
         * @param {SecretRequest} [secretRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEnvironmentSecret(environmentId: string, secretRequest?: SecretRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEnvironmentSecret(environmentId, secretRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - Allows you to add an alias at environment level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at environment level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - Only 1 alias level is allowed. You can\'t create an alias on an alias 
         * @summary Create a secret alias at the environment level
         * @param {string} environmentId Environment ID
         * @param {string} secretId Secret ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEnvironmentSecretAlias(environmentId: string, secretId: string, key?: Key, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEnvironmentSecretAlias(environmentId, secretId, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - Allows you to override at environment level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at environment level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
         * @summary Create a secret override at the environment level
         * @param {string} environmentId Environment ID
         * @param {string} secretId Secret ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEnvironmentSecretOverride(environmentId: string, secretId: string, value?: Value, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEnvironmentSecretOverride(environmentId, secretId, value, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well  operationId: deleteEnvironmentSecret 
         * @summary Delete a secret from the environment
         * @param {string} environmentId Environment ID
         * @param {string} secretId Secret ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEnvironmentSecret(environmentId: string, secretId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEnvironmentSecret(environmentId, secretId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit a secret belonging to the environment
         * @param {string} environmentId Environment ID
         * @param {string} secretId Secret ID
         * @param {SecretEditRequest} secretEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editEnvironmentSecret(environmentId: string, secretId: string, secretEditRequest: SecretEditRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editEnvironmentSecret(environmentId, secretId, secretEditRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List environment secrets
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEnvironmentSecrets(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecretResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEnvironmentSecrets(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EnvironmentSecretApi - factory interface
 * @export
 */
export const EnvironmentSecretApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnvironmentSecretApiFp(configuration)
    return {
        /**
         * - Add a secret to the environment.   - If the secret key already exists, then it will be replaced by the new one.   - If the secret value points toward an existing secret key, it will be considered as an alias. 
         * @summary Add a secret to the environment
         * @param {string} environmentId Environment ID
         * @param {SecretRequest} [secretRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironmentSecret(environmentId: string, secretRequest?: SecretRequest, options?: any): AxiosPromise<Secret> {
            return localVarFp.createEnvironmentSecret(environmentId, secretRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to add an alias at environment level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at environment level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - Only 1 alias level is allowed. You can\'t create an alias on an alias 
         * @summary Create a secret alias at the environment level
         * @param {string} environmentId Environment ID
         * @param {string} secretId Secret ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironmentSecretAlias(environmentId: string, secretId: string, key?: Key, options?: any): AxiosPromise<Secret> {
            return localVarFp.createEnvironmentSecretAlias(environmentId, secretId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to override at environment level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at environment level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
         * @summary Create a secret override at the environment level
         * @param {string} environmentId Environment ID
         * @param {string} secretId Secret ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironmentSecretOverride(environmentId: string, secretId: string, value?: Value, options?: any): AxiosPromise<Secret> {
            return localVarFp.createEnvironmentSecretOverride(environmentId, secretId, value, options).then((request) => request(axios, basePath));
        },
        /**
         * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well  operationId: deleteEnvironmentSecret 
         * @summary Delete a secret from the environment
         * @param {string} environmentId Environment ID
         * @param {string} secretId Secret ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEnvironmentSecret(environmentId: string, secretId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteEnvironmentSecret(environmentId, secretId, options).then((request) => request(axios, basePath));
        },
        /**
         * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit a secret belonging to the environment
         * @param {string} environmentId Environment ID
         * @param {string} secretId Secret ID
         * @param {SecretEditRequest} secretEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editEnvironmentSecret(environmentId: string, secretId: string, secretEditRequest: SecretEditRequest, options?: any): AxiosPromise<Secret> {
            return localVarFp.editEnvironmentSecret(environmentId, secretId, secretEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List environment secrets
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentSecrets(environmentId: string, options?: any): AxiosPromise<SecretResponseList> {
            return localVarFp.listEnvironmentSecrets(environmentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnvironmentSecretApi - object-oriented interface
 * @export
 * @class EnvironmentSecretApi
 * @extends {BaseAPI}
 */
export class EnvironmentSecretApi extends BaseAPI {
    /**
     * - Add a secret to the environment.   - If the secret key already exists, then it will be replaced by the new one.   - If the secret value points toward an existing secret key, it will be considered as an alias. 
     * @summary Add a secret to the environment
     * @param {string} environmentId Environment ID
     * @param {SecretRequest} [secretRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentSecretApi
     */
    public createEnvironmentSecret(environmentId: string, secretRequest?: SecretRequest, options?: AxiosRequestConfig) {
        return EnvironmentSecretApiFp(this.configuration).createEnvironmentSecret(environmentId, secretRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to add an alias at environment level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at environment level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - Only 1 alias level is allowed. You can\'t create an alias on an alias 
     * @summary Create a secret alias at the environment level
     * @param {string} environmentId Environment ID
     * @param {string} secretId Secret ID
     * @param {Key} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentSecretApi
     */
    public createEnvironmentSecretAlias(environmentId: string, secretId: string, key?: Key, options?: AxiosRequestConfig) {
        return EnvironmentSecretApiFp(this.configuration).createEnvironmentSecretAlias(environmentId, secretId, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to override at environment level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at environment level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
     * @summary Create a secret override at the environment level
     * @param {string} environmentId Environment ID
     * @param {string} secretId Secret ID
     * @param {Value} [value] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentSecretApi
     */
    public createEnvironmentSecretOverride(environmentId: string, secretId: string, value?: Value, options?: AxiosRequestConfig) {
        return EnvironmentSecretApiFp(this.configuration).createEnvironmentSecretOverride(environmentId, secretId, value, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well  operationId: deleteEnvironmentSecret 
     * @summary Delete a secret from the environment
     * @param {string} environmentId Environment ID
     * @param {string} secretId Secret ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentSecretApi
     */
    public deleteEnvironmentSecret(environmentId: string, secretId: string, options?: AxiosRequestConfig) {
        return EnvironmentSecretApiFp(this.configuration).deleteEnvironmentSecret(environmentId, secretId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
     * @summary Edit a secret belonging to the environment
     * @param {string} environmentId Environment ID
     * @param {string} secretId Secret ID
     * @param {SecretEditRequest} secretEditRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentSecretApi
     */
    public editEnvironmentSecret(environmentId: string, secretId: string, secretEditRequest: SecretEditRequest, options?: AxiosRequestConfig) {
        return EnvironmentSecretApiFp(this.configuration).editEnvironmentSecret(environmentId, secretId, secretEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List environment secrets
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentSecretApi
     */
    public listEnvironmentSecrets(environmentId: string, options?: AxiosRequestConfig) {
        return EnvironmentSecretApiFp(this.configuration).listEnvironmentSecrets(environmentId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EnvironmentVariableApi - axios parameter creator
 * @export
 */
export const EnvironmentVariableApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * - Add an environment variable to the environment.   - If the environment variable key already exists, then it will be replaced by the new one.   - If the environment variable value points toward an existing environment variable key, it will be considered as an alias. 
         * @summary Add an environment variable to the environment
         * @param {string} environmentId Environment ID
         * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironmentEnvironmentVariable: async (environmentId: string, environmentVariableRequest?: EnvironmentVariableRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('createEnvironmentEnvironmentVariable', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/environmentVariable`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentVariableRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to add an alias at environment level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at environment level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - Only 1 alias level is allowed. You can\'t create an alias on an alias 
         * @summary Create an environment variable alias at the environment level
         * @param {string} environmentId Environment ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironmentEnvironmentVariableAlias: async (environmentId: string, environmentVariableId: string, key?: Key, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('createEnvironmentEnvironmentVariableAlias', 'environmentId', environmentId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('createEnvironmentEnvironmentVariableAlias', 'environmentVariableId', environmentVariableId)
            const localVarPath = `/environment/{environmentId}/environmentVariable/{environmentVariableId}/alias`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(key, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to override at environment level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at environment level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
         * @summary Create an environment variable override at the environment level
         * @param {string} environmentId Environment ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironmentEnvironmentVariableOverride: async (environmentId: string, environmentVariableId: string, value?: Value, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('createEnvironmentEnvironmentVariableOverride', 'environmentId', environmentId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('createEnvironmentEnvironmentVariableOverride', 'environmentVariableId', environmentVariableId)
            const localVarPath = `/environment/{environmentId}/environmentVariable/{environmentVariableId}/override`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(value, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - To delete an environment variable you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete an environment variable from an environment
         * @param {string} environmentId Environment ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEnvironmentEnvironmentVariable: async (environmentId: string, environmentVariableId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('deleteEnvironmentEnvironmentVariable', 'environmentId', environmentId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('deleteEnvironmentEnvironmentVariable', 'environmentVariableId', environmentVariableId)
            const localVarPath = `/environment/{environmentId}/environmentVariable/{environmentVariableId}`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit an environment variable belonging to the environment
         * @param {string} environmentId Environment ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editEnvironmentEnvironmentVariable: async (environmentId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('editEnvironmentEnvironmentVariable', 'environmentId', environmentId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('editEnvironmentEnvironmentVariable', 'environmentVariableId', environmentVariableId)
            // verify required parameter 'environmentVariableEditRequest' is not null or undefined
            assertParamExists('editEnvironmentEnvironmentVariable', 'environmentVariableEditRequest', environmentVariableEditRequest)
            const localVarPath = `/environment/{environmentId}/environmentVariable/{environmentVariableId}`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentVariableEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List environment variables
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentEnvironmentVariable: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('listEnvironmentEnvironmentVariable', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/environmentVariable`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentVariableApi - functional programming interface
 * @export
 */
export const EnvironmentVariableApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnvironmentVariableApiAxiosParamCreator(configuration)
    return {
        /**
         * - Add an environment variable to the environment.   - If the environment variable key already exists, then it will be replaced by the new one.   - If the environment variable value points toward an existing environment variable key, it will be considered as an alias. 
         * @summary Add an environment variable to the environment
         * @param {string} environmentId Environment ID
         * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEnvironmentEnvironmentVariable(environmentId: string, environmentVariableRequest?: EnvironmentVariableRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEnvironmentEnvironmentVariable(environmentId, environmentVariableRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - Allows you to add an alias at environment level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at environment level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - Only 1 alias level is allowed. You can\'t create an alias on an alias 
         * @summary Create an environment variable alias at the environment level
         * @param {string} environmentId Environment ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEnvironmentEnvironmentVariableAlias(environmentId: string, environmentVariableId: string, key?: Key, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEnvironmentEnvironmentVariableAlias(environmentId, environmentVariableId, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - Allows you to override at environment level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at environment level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
         * @summary Create an environment variable override at the environment level
         * @param {string} environmentId Environment ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEnvironmentEnvironmentVariableOverride(environmentId: string, environmentVariableId: string, value?: Value, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEnvironmentEnvironmentVariableOverride(environmentId, environmentVariableId, value, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - To delete an environment variable you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete an environment variable from an environment
         * @param {string} environmentId Environment ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEnvironmentEnvironmentVariable(environmentId: string, environmentVariableId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEnvironmentEnvironmentVariable(environmentId, environmentVariableId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit an environment variable belonging to the environment
         * @param {string} environmentId Environment ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editEnvironmentEnvironmentVariable(environmentId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editEnvironmentEnvironmentVariable(environmentId, environmentVariableId, environmentVariableEditRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List environment variables
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEnvironmentEnvironmentVariable(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariableResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEnvironmentEnvironmentVariable(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EnvironmentVariableApi - factory interface
 * @export
 */
export const EnvironmentVariableApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnvironmentVariableApiFp(configuration)
    return {
        /**
         * - Add an environment variable to the environment.   - If the environment variable key already exists, then it will be replaced by the new one.   - If the environment variable value points toward an existing environment variable key, it will be considered as an alias. 
         * @summary Add an environment variable to the environment
         * @param {string} environmentId Environment ID
         * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironmentEnvironmentVariable(environmentId: string, environmentVariableRequest?: EnvironmentVariableRequest, options?: any): AxiosPromise<EnvironmentVariable> {
            return localVarFp.createEnvironmentEnvironmentVariable(environmentId, environmentVariableRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to add an alias at environment level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at environment level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - Only 1 alias level is allowed. You can\'t create an alias on an alias 
         * @summary Create an environment variable alias at the environment level
         * @param {string} environmentId Environment ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironmentEnvironmentVariableAlias(environmentId: string, environmentVariableId: string, key?: Key, options?: any): AxiosPromise<EnvironmentVariable> {
            return localVarFp.createEnvironmentEnvironmentVariableAlias(environmentId, environmentVariableId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to override at environment level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at environment level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
         * @summary Create an environment variable override at the environment level
         * @param {string} environmentId Environment ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironmentEnvironmentVariableOverride(environmentId: string, environmentVariableId: string, value?: Value, options?: any): AxiosPromise<EnvironmentVariable> {
            return localVarFp.createEnvironmentEnvironmentVariableOverride(environmentId, environmentVariableId, value, options).then((request) => request(axios, basePath));
        },
        /**
         * - To delete an environment variable you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete an environment variable from an environment
         * @param {string} environmentId Environment ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEnvironmentEnvironmentVariable(environmentId: string, environmentVariableId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteEnvironmentEnvironmentVariable(environmentId, environmentVariableId, options).then((request) => request(axios, basePath));
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit an environment variable belonging to the environment
         * @param {string} environmentId Environment ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editEnvironmentEnvironmentVariable(environmentId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options?: any): AxiosPromise<EnvironmentVariable> {
            return localVarFp.editEnvironmentEnvironmentVariable(environmentId, environmentVariableId, environmentVariableEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List environment variables
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentEnvironmentVariable(environmentId: string, options?: any): AxiosPromise<EnvironmentVariableResponseList> {
            return localVarFp.listEnvironmentEnvironmentVariable(environmentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnvironmentVariableApi - object-oriented interface
 * @export
 * @class EnvironmentVariableApi
 * @extends {BaseAPI}
 */
export class EnvironmentVariableApi extends BaseAPI {
    /**
     * - Add an environment variable to the environment.   - If the environment variable key already exists, then it will be replaced by the new one.   - If the environment variable value points toward an existing environment variable key, it will be considered as an alias. 
     * @summary Add an environment variable to the environment
     * @param {string} environmentId Environment ID
     * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentVariableApi
     */
    public createEnvironmentEnvironmentVariable(environmentId: string, environmentVariableRequest?: EnvironmentVariableRequest, options?: AxiosRequestConfig) {
        return EnvironmentVariableApiFp(this.configuration).createEnvironmentEnvironmentVariable(environmentId, environmentVariableRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to add an alias at environment level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at environment level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - Only 1 alias level is allowed. You can\'t create an alias on an alias 
     * @summary Create an environment variable alias at the environment level
     * @param {string} environmentId Environment ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {Key} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentVariableApi
     */
    public createEnvironmentEnvironmentVariableAlias(environmentId: string, environmentVariableId: string, key?: Key, options?: AxiosRequestConfig) {
        return EnvironmentVariableApiFp(this.configuration).createEnvironmentEnvironmentVariableAlias(environmentId, environmentVariableId, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to override at environment level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at environment level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
     * @summary Create an environment variable override at the environment level
     * @param {string} environmentId Environment ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {Value} [value] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentVariableApi
     */
    public createEnvironmentEnvironmentVariableOverride(environmentId: string, environmentVariableId: string, value?: Value, options?: AxiosRequestConfig) {
        return EnvironmentVariableApiFp(this.configuration).createEnvironmentEnvironmentVariableOverride(environmentId, environmentVariableId, value, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - To delete an environment variable you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
     * @summary Delete an environment variable from an environment
     * @param {string} environmentId Environment ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentVariableApi
     */
    public deleteEnvironmentEnvironmentVariable(environmentId: string, environmentVariableId: string, options?: AxiosRequestConfig) {
        return EnvironmentVariableApiFp(this.configuration).deleteEnvironmentEnvironmentVariable(environmentId, environmentVariableId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
     * @summary Edit an environment variable belonging to the environment
     * @param {string} environmentId Environment ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentVariableApi
     */
    public editEnvironmentEnvironmentVariable(environmentId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options?: AxiosRequestConfig) {
        return EnvironmentVariableApiFp(this.configuration).editEnvironmentEnvironmentVariable(environmentId, environmentVariableId, environmentVariableEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List environment variables
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentVariableApi
     */
    public listEnvironmentEnvironmentVariable(environmentId: string, options?: AxiosRequestConfig) {
        return EnvironmentVariableApiFp(this.configuration).listEnvironmentEnvironmentVariable(environmentId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EnvironmentsApi - axios parameter creator
 * @export
 */
export const EnvironmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create an environment
         * @param {string} projectId Project ID
         * @param {CreateEnvironmentRequest} [createEnvironmentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironment: async (projectId: string, createEnvironmentRequest?: CreateEnvironmentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createEnvironment', 'projectId', projectId)
            const localVarPath = `/project/{projectId}/environment`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createEnvironmentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of environment ids, and for each its total numberof services
         * @summary List total number of services for each environment of the project
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectEnvironmentServiceNumber: async (projectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getProjectEnvironmentServiceNumber', 'projectId', projectId)
            const localVarPath = `/project/{projectId}/environment/stats`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of environments with only their id and status.
         * @summary List environments statuses
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectEnvironmentsStatus: async (projectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getProjectEnvironmentsStatus', 'projectId', projectId)
            const localVarPath = `/project/{projectId}/environment/status`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List environments
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironment: async (projectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('listEnvironment', 'projectId', projectId)
            const localVarPath = `/project/{projectId}/environment`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentsApi - functional programming interface
 * @export
 */
export const EnvironmentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnvironmentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create an environment
         * @param {string} projectId Project ID
         * @param {CreateEnvironmentRequest} [createEnvironmentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEnvironment(projectId: string, createEnvironmentRequest?: CreateEnvironmentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Environment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEnvironment(projectId, createEnvironmentRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of environment ids, and for each its total numberof services
         * @summary List total number of services for each environment of the project
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjectEnvironmentServiceNumber(projectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentStatsResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectEnvironmentServiceNumber(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of environments with only their id and status.
         * @summary List environments statuses
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjectEnvironmentsStatus(projectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentStatusList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectEnvironmentsStatus(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List environments
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEnvironment(projectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEnvironment(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EnvironmentsApi - factory interface
 * @export
 */
export const EnvironmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnvironmentsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create an environment
         * @param {string} projectId Project ID
         * @param {CreateEnvironmentRequest} [createEnvironmentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironment(projectId: string, createEnvironmentRequest?: CreateEnvironmentRequest, options?: any): AxiosPromise<Environment> {
            return localVarFp.createEnvironment(projectId, createEnvironmentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of environment ids, and for each its total numberof services
         * @summary List total number of services for each environment of the project
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectEnvironmentServiceNumber(projectId: string, options?: any): AxiosPromise<EnvironmentStatsResponseList> {
            return localVarFp.getProjectEnvironmentServiceNumber(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of environments with only their id and status.
         * @summary List environments statuses
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectEnvironmentsStatus(projectId: string, options?: any): AxiosPromise<EnvironmentStatusList> {
            return localVarFp.getProjectEnvironmentsStatus(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List environments
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironment(projectId: string, options?: any): AxiosPromise<EnvironmentResponseList> {
            return localVarFp.listEnvironment(projectId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnvironmentsApi - object-oriented interface
 * @export
 * @class EnvironmentsApi
 * @extends {BaseAPI}
 */
export class EnvironmentsApi extends BaseAPI {
    /**
     * 
     * @summary Create an environment
     * @param {string} projectId Project ID
     * @param {CreateEnvironmentRequest} [createEnvironmentRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public createEnvironment(projectId: string, createEnvironmentRequest?: CreateEnvironmentRequest, options?: AxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).createEnvironment(projectId, createEnvironmentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of environment ids, and for each its total numberof services
     * @summary List total number of services for each environment of the project
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public getProjectEnvironmentServiceNumber(projectId: string, options?: AxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).getProjectEnvironmentServiceNumber(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of environments with only their id and status.
     * @summary List environments statuses
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public getProjectEnvironmentsStatus(projectId: string, options?: AxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).getProjectEnvironmentsStatus(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List environments
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public listEnvironment(projectId: string, options?: AxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).listEnvironment(projectId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GitRepositoriesApi - axios parameter creator
 * @export
 */
export const GitRepositoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get bitbucket repositories of the connected user
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getBitbucketRepositories: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/bitbucket/repository`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get bitbucket branches of the specified repository
         * @param {string} [name] The name of the repository where to retrieve the branches
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getBitbucketRepositoryBranches: async (name?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/bitbucket/repository/branch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get git provider accounts
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getGitProviderAccount: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/gitAuthProvider`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get github repositories of the connected user
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getGithubRepositories: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/github/repository`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get github branches of the specified repository
         * @param {string} [name] The name of the repository where to retrieve the branches
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getGithubRepositoryBranches: async (name?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/github/repository/branch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get gitlab repositories of the connected user
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getGitlabRepositories: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/gitlab/repository`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get gitlab branches of the specified repository
         * @param {string} [name] The name of the repository to retrieve the branches
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getGitlabRepositoryBranches: async (name?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/gitlab/repository/branch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GitRepositoriesApi - functional programming interface
 * @export
 */
export const GitRepositoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GitRepositoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get bitbucket repositories of the connected user
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getBitbucketRepositories(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitRepositoryResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBitbucketRepositories(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get bitbucket branches of the specified repository
         * @param {string} [name] The name of the repository where to retrieve the branches
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getBitbucketRepositoryBranches(name?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitRepositoryBranchResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBitbucketRepositoryBranches(name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get git provider accounts
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getGitProviderAccount(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitAuthProviderResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGitProviderAccount(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get github repositories of the connected user
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getGithubRepositories(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitRepositoryResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGithubRepositories(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get github branches of the specified repository
         * @param {string} [name] The name of the repository where to retrieve the branches
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getGithubRepositoryBranches(name?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitRepositoryBranchResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGithubRepositoryBranches(name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get gitlab repositories of the connected user
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getGitlabRepositories(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitRepositoryResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGitlabRepositories(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get gitlab branches of the specified repository
         * @param {string} [name] The name of the repository to retrieve the branches
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getGitlabRepositoryBranches(name?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitRepositoryBranchResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGitlabRepositoryBranches(name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GitRepositoriesApi - factory interface
 * @export
 */
export const GitRepositoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GitRepositoriesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get bitbucket repositories of the connected user
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getBitbucketRepositories(options?: any): AxiosPromise<GitRepositoryResponseList> {
            return localVarFp.getBitbucketRepositories(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get bitbucket branches of the specified repository
         * @param {string} [name] The name of the repository where to retrieve the branches
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getBitbucketRepositoryBranches(name?: string, options?: any): AxiosPromise<GitRepositoryBranchResponseList> {
            return localVarFp.getBitbucketRepositoryBranches(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get git provider accounts
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getGitProviderAccount(options?: any): AxiosPromise<GitAuthProviderResponseList> {
            return localVarFp.getGitProviderAccount(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get github repositories of the connected user
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getGithubRepositories(options?: any): AxiosPromise<GitRepositoryResponseList> {
            return localVarFp.getGithubRepositories(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get github branches of the specified repository
         * @param {string} [name] The name of the repository where to retrieve the branches
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getGithubRepositoryBranches(name?: string, options?: any): AxiosPromise<GitRepositoryBranchResponseList> {
            return localVarFp.getGithubRepositoryBranches(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get gitlab repositories of the connected user
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getGitlabRepositories(options?: any): AxiosPromise<GitRepositoryResponseList> {
            return localVarFp.getGitlabRepositories(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get gitlab branches of the specified repository
         * @param {string} [name] The name of the repository to retrieve the branches
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getGitlabRepositoryBranches(name?: string, options?: any): AxiosPromise<GitRepositoryBranchResponseList> {
            return localVarFp.getGitlabRepositoryBranches(name, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GitRepositoriesApi - object-oriented interface
 * @export
 * @class GitRepositoriesApi
 * @extends {BaseAPI}
 */
export class GitRepositoriesApi extends BaseAPI {
    /**
     * 
     * @summary Get bitbucket repositories of the connected user
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof GitRepositoriesApi
     */
    public getBitbucketRepositories(options?: AxiosRequestConfig) {
        return GitRepositoriesApiFp(this.configuration).getBitbucketRepositories(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get bitbucket branches of the specified repository
     * @param {string} [name] The name of the repository where to retrieve the branches
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof GitRepositoriesApi
     */
    public getBitbucketRepositoryBranches(name?: string, options?: AxiosRequestConfig) {
        return GitRepositoriesApiFp(this.configuration).getBitbucketRepositoryBranches(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get git provider accounts
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof GitRepositoriesApi
     */
    public getGitProviderAccount(options?: AxiosRequestConfig) {
        return GitRepositoriesApiFp(this.configuration).getGitProviderAccount(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get github repositories of the connected user
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof GitRepositoriesApi
     */
    public getGithubRepositories(options?: AxiosRequestConfig) {
        return GitRepositoriesApiFp(this.configuration).getGithubRepositories(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get github branches of the specified repository
     * @param {string} [name] The name of the repository where to retrieve the branches
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof GitRepositoriesApi
     */
    public getGithubRepositoryBranches(name?: string, options?: AxiosRequestConfig) {
        return GitRepositoriesApiFp(this.configuration).getGithubRepositoryBranches(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get gitlab repositories of the connected user
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof GitRepositoriesApi
     */
    public getGitlabRepositories(options?: AxiosRequestConfig) {
        return GitRepositoriesApiFp(this.configuration).getGitlabRepositories(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get gitlab branches of the specified repository
     * @param {string} [name] The name of the repository to retrieve the branches
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof GitRepositoriesApi
     */
    public getGitlabRepositoryBranches(name?: string, options?: AxiosRequestConfig) {
        return GitRepositoriesApiFp(this.configuration).getGitlabRepositoryBranches(name, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GithubAppApi - axios parameter creator
 * @export
 */
export const GithubAppApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Connect a github account to an organization
         * @param {string} organizationId Organization ID
         * @param {OrganizationGithubAppConnectRequest} [organizationGithubAppConnectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationGithubAppConnect: async (organizationId: string, organizationGithubAppConnectRequest?: OrganizationGithubAppConnectRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('organizationGithubAppConnect', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/github/connect`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationGithubAppConnectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Disconnect a github account from an organization
         * @param {string} organizationId Organization ID
         * @param {boolean} [force] Indicates if the github app should be disconnected despite github applications linked to organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationGithubAppDisconnect: async (organizationId: string, force?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('organizationGithubAppDisconnect', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/github/disconnect`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GithubAppApi - functional programming interface
 * @export
 */
export const GithubAppApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GithubAppApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Connect a github account to an organization
         * @param {string} organizationId Organization ID
         * @param {OrganizationGithubAppConnectRequest} [organizationGithubAppConnectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationGithubAppConnect(organizationId: string, organizationGithubAppConnectRequest?: OrganizationGithubAppConnectRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationGithubAppConnect(organizationId, organizationGithubAppConnectRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Disconnect a github account from an organization
         * @param {string} organizationId Organization ID
         * @param {boolean} [force] Indicates if the github app should be disconnected despite github applications linked to organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationGithubAppDisconnect(organizationId: string, force?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationGithubAppDisconnect(organizationId, force, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GithubAppApi - factory interface
 * @export
 */
export const GithubAppApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GithubAppApiFp(configuration)
    return {
        /**
         * 
         * @summary Connect a github account to an organization
         * @param {string} organizationId Organization ID
         * @param {OrganizationGithubAppConnectRequest} [organizationGithubAppConnectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationGithubAppConnect(organizationId: string, organizationGithubAppConnectRequest?: OrganizationGithubAppConnectRequest, options?: any): AxiosPromise<void> {
            return localVarFp.organizationGithubAppConnect(organizationId, organizationGithubAppConnectRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Disconnect a github account from an organization
         * @param {string} organizationId Organization ID
         * @param {boolean} [force] Indicates if the github app should be disconnected despite github applications linked to organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationGithubAppDisconnect(organizationId: string, force?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.organizationGithubAppDisconnect(organizationId, force, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GithubAppApi - object-oriented interface
 * @export
 * @class GithubAppApi
 * @extends {BaseAPI}
 */
export class GithubAppApi extends BaseAPI {
    /**
     * 
     * @summary Connect a github account to an organization
     * @param {string} organizationId Organization ID
     * @param {OrganizationGithubAppConnectRequest} [organizationGithubAppConnectRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GithubAppApi
     */
    public organizationGithubAppConnect(organizationId: string, organizationGithubAppConnectRequest?: OrganizationGithubAppConnectRequest, options?: AxiosRequestConfig) {
        return GithubAppApiFp(this.configuration).organizationGithubAppConnect(organizationId, organizationGithubAppConnectRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Disconnect a github account from an organization
     * @param {string} organizationId Organization ID
     * @param {boolean} [force] Indicates if the github app should be disconnected despite github applications linked to organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GithubAppApi
     */
    public organizationGithubAppDisconnect(organizationId: string, force?: boolean, options?: AxiosRequestConfig) {
        return GithubAppApiFp(this.configuration).organizationGithubAppDisconnect(organizationId, force, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * JobActionsApi - axios parameter creator
 * @export
 */
export const JobActionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * You must provide a git commit id or an image tag depending on the source location of your code (git vs image repository).
         * @summary Deploy job
         * @param {string} jobId Job ID
         * @param {JobForceEvent} [forceEvent] When filled, it indicates the target event to be deployed.   If the concerned job hasn\&#39;t the target event provided, the job won\&#39;t be deployed. 
         * @param {JobDeployRequest} [jobDeployRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployJob: async (jobId: string, forceEvent?: JobForceEvent, jobDeployRequest?: JobDeployRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('deployJob', 'jobId', jobId)
            const localVarPath = `/job/{jobId}/deploy`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (forceEvent !== undefined) {
                localVarQueryParameter['forceEvent'] = forceEvent;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jobDeployRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Redeploy job
         * @param {string} jobId Job ID
         * @param {JobForceEvent} [forceEvent] When filled, it indicates the target event to be deployed.   If the concerned job hasn\&#39;t the target event provided, the job won\&#39;t be deployed. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeployJob: async (jobId: string, forceEvent?: JobForceEvent, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('redeployJob', 'jobId', jobId)
            const localVarPath = `/job/{jobId}/redeploy`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (forceEvent !== undefined) {
                localVarQueryParameter['forceEvent'] = forceEvent;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Deprecated** - Please use the \"Redeploy job\" endpoint now
         * @summary Deprecated - Restart job
         * @param {string} jobId Job ID
         * @param {JobForceEvent} [forceEvent] When filled, it indicates the target event to be deployed.   If the concerned job hasn\&#39;t the target event provided, the job won\&#39;t be deployed. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartJob: async (jobId: string, forceEvent?: JobForceEvent, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('restartJob', 'jobId', jobId)
            const localVarPath = `/job/{jobId}/restart`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (forceEvent !== undefined) {
                localVarQueryParameter['forceEvent'] = forceEvent;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop job
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopJob: async (jobId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('stopJob', 'jobId', jobId)
            const localVarPath = `/job/{jobId}/stop`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobActionsApi - functional programming interface
 * @export
 */
export const JobActionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JobActionsApiAxiosParamCreator(configuration)
    return {
        /**
         * You must provide a git commit id or an image tag depending on the source location of your code (git vs image repository).
         * @summary Deploy job
         * @param {string} jobId Job ID
         * @param {JobForceEvent} [forceEvent] When filled, it indicates the target event to be deployed.   If the concerned job hasn\&#39;t the target event provided, the job won\&#39;t be deployed. 
         * @param {JobDeployRequest} [jobDeployRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployJob(jobId: string, forceEvent?: JobForceEvent, jobDeployRequest?: JobDeployRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployJob(jobId, forceEvent, jobDeployRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Redeploy job
         * @param {string} jobId Job ID
         * @param {JobForceEvent} [forceEvent] When filled, it indicates the target event to be deployed.   If the concerned job hasn\&#39;t the target event provided, the job won\&#39;t be deployed. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async redeployJob(jobId: string, forceEvent?: JobForceEvent, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.redeployJob(jobId, forceEvent, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **Deprecated** - Please use the \"Redeploy job\" endpoint now
         * @summary Deprecated - Restart job
         * @param {string} jobId Job ID
         * @param {JobForceEvent} [forceEvent] When filled, it indicates the target event to be deployed.   If the concerned job hasn\&#39;t the target event provided, the job won\&#39;t be deployed. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restartJob(jobId: string, forceEvent?: JobForceEvent, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restartJob(jobId, forceEvent, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Stop job
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopJob(jobId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopJob(jobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * JobActionsApi - factory interface
 * @export
 */
export const JobActionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JobActionsApiFp(configuration)
    return {
        /**
         * You must provide a git commit id or an image tag depending on the source location of your code (git vs image repository).
         * @summary Deploy job
         * @param {string} jobId Job ID
         * @param {JobForceEvent} [forceEvent] When filled, it indicates the target event to be deployed.   If the concerned job hasn\&#39;t the target event provided, the job won\&#39;t be deployed. 
         * @param {JobDeployRequest} [jobDeployRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployJob(jobId: string, forceEvent?: JobForceEvent, jobDeployRequest?: JobDeployRequest, options?: any): AxiosPromise<Status> {
            return localVarFp.deployJob(jobId, forceEvent, jobDeployRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Redeploy job
         * @param {string} jobId Job ID
         * @param {JobForceEvent} [forceEvent] When filled, it indicates the target event to be deployed.   If the concerned job hasn\&#39;t the target event provided, the job won\&#39;t be deployed. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeployJob(jobId: string, forceEvent?: JobForceEvent, options?: any): AxiosPromise<Status> {
            return localVarFp.redeployJob(jobId, forceEvent, options).then((request) => request(axios, basePath));
        },
        /**
         * **Deprecated** - Please use the \"Redeploy job\" endpoint now
         * @summary Deprecated - Restart job
         * @param {string} jobId Job ID
         * @param {JobForceEvent} [forceEvent] When filled, it indicates the target event to be deployed.   If the concerned job hasn\&#39;t the target event provided, the job won\&#39;t be deployed. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartJob(jobId: string, forceEvent?: JobForceEvent, options?: any): AxiosPromise<Status> {
            return localVarFp.restartJob(jobId, forceEvent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Stop job
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopJob(jobId: string, options?: any): AxiosPromise<Status> {
            return localVarFp.stopJob(jobId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JobActionsApi - object-oriented interface
 * @export
 * @class JobActionsApi
 * @extends {BaseAPI}
 */
export class JobActionsApi extends BaseAPI {
    /**
     * You must provide a git commit id or an image tag depending on the source location of your code (git vs image repository).
     * @summary Deploy job
     * @param {string} jobId Job ID
     * @param {JobForceEvent} [forceEvent] When filled, it indicates the target event to be deployed.   If the concerned job hasn\&#39;t the target event provided, the job won\&#39;t be deployed. 
     * @param {JobDeployRequest} [jobDeployRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobActionsApi
     */
    public deployJob(jobId: string, forceEvent?: JobForceEvent, jobDeployRequest?: JobDeployRequest, options?: AxiosRequestConfig) {
        return JobActionsApiFp(this.configuration).deployJob(jobId, forceEvent, jobDeployRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Redeploy job
     * @param {string} jobId Job ID
     * @param {JobForceEvent} [forceEvent] When filled, it indicates the target event to be deployed.   If the concerned job hasn\&#39;t the target event provided, the job won\&#39;t be deployed. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobActionsApi
     */
    public redeployJob(jobId: string, forceEvent?: JobForceEvent, options?: AxiosRequestConfig) {
        return JobActionsApiFp(this.configuration).redeployJob(jobId, forceEvent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Deprecated** - Please use the \"Redeploy job\" endpoint now
     * @summary Deprecated - Restart job
     * @param {string} jobId Job ID
     * @param {JobForceEvent} [forceEvent] When filled, it indicates the target event to be deployed.   If the concerned job hasn\&#39;t the target event provided, the job won\&#39;t be deployed. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobActionsApi
     */
    public restartJob(jobId: string, forceEvent?: JobForceEvent, options?: AxiosRequestConfig) {
        return JobActionsApiFp(this.configuration).restartJob(jobId, forceEvent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Stop job
     * @param {string} jobId Job ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobActionsApi
     */
    public stopJob(jobId: string, options?: AxiosRequestConfig) {
        return JobActionsApiFp(this.configuration).stopJob(jobId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * JobConfigurationApi - axios parameter creator
 * @export
 */
export const JobConfigurationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Edit advanced settings by returning table of advanced settings.
         * @summary Edit advanced settings
         * @param {string} jobId Job ID
         * @param {JobAdvancedSettings} [jobAdvancedSettings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editJobAdvancedSettings: async (jobId: string, jobAdvancedSettings?: JobAdvancedSettings, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('editJobAdvancedSettings', 'jobId', jobId)
            const localVarPath = `/job/{jobId}/advancedSettings`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jobAdvancedSettings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list and values of the advanced settings of the job.
         * @summary Get advanced settings
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobAdvancedSettings: async (jobId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getJobAdvancedSettings', 'jobId', jobId)
            const localVarPath = `/job/{jobId}/advancedSettings`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobConfigurationApi - functional programming interface
 * @export
 */
export const JobConfigurationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JobConfigurationApiAxiosParamCreator(configuration)
    return {
        /**
         * Edit advanced settings by returning table of advanced settings.
         * @summary Edit advanced settings
         * @param {string} jobId Job ID
         * @param {JobAdvancedSettings} [jobAdvancedSettings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editJobAdvancedSettings(jobId: string, jobAdvancedSettings?: JobAdvancedSettings, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobAdvancedSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editJobAdvancedSettings(jobId, jobAdvancedSettings, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get list and values of the advanced settings of the job.
         * @summary Get advanced settings
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobAdvancedSettings(jobId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobAdvancedSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobAdvancedSettings(jobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * JobConfigurationApi - factory interface
 * @export
 */
export const JobConfigurationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JobConfigurationApiFp(configuration)
    return {
        /**
         * Edit advanced settings by returning table of advanced settings.
         * @summary Edit advanced settings
         * @param {string} jobId Job ID
         * @param {JobAdvancedSettings} [jobAdvancedSettings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editJobAdvancedSettings(jobId: string, jobAdvancedSettings?: JobAdvancedSettings, options?: any): AxiosPromise<JobAdvancedSettings> {
            return localVarFp.editJobAdvancedSettings(jobId, jobAdvancedSettings, options).then((request) => request(axios, basePath));
        },
        /**
         * Get list and values of the advanced settings of the job.
         * @summary Get advanced settings
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobAdvancedSettings(jobId: string, options?: any): AxiosPromise<JobAdvancedSettings> {
            return localVarFp.getJobAdvancedSettings(jobId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JobConfigurationApi - object-oriented interface
 * @export
 * @class JobConfigurationApi
 * @extends {BaseAPI}
 */
export class JobConfigurationApi extends BaseAPI {
    /**
     * Edit advanced settings by returning table of advanced settings.
     * @summary Edit advanced settings
     * @param {string} jobId Job ID
     * @param {JobAdvancedSettings} [jobAdvancedSettings] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobConfigurationApi
     */
    public editJobAdvancedSettings(jobId: string, jobAdvancedSettings?: JobAdvancedSettings, options?: AxiosRequestConfig) {
        return JobConfigurationApiFp(this.configuration).editJobAdvancedSettings(jobId, jobAdvancedSettings, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list and values of the advanced settings of the job.
     * @summary Get advanced settings
     * @param {string} jobId Job ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobConfigurationApi
     */
    public getJobAdvancedSettings(jobId: string, options?: AxiosRequestConfig) {
        return JobConfigurationApiFp(this.configuration).getJobAdvancedSettings(jobId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * JobDeploymentHistoryApi - axios parameter creator
 * @export
 */
export const JobDeploymentHistoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the 20 last job deployments
         * @summary List job deployments
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobDeploymentHistory: async (jobId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('listJobDeploymentHistory', 'jobId', jobId)
            const localVarPath = `/job/{jobId}/deploymentHistory`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobDeploymentHistoryApi - functional programming interface
 * @export
 */
export const JobDeploymentHistoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JobDeploymentHistoryApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the 20 last job deployments
         * @summary List job deployments
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listJobDeploymentHistory(jobId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationData & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listJobDeploymentHistory(jobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * JobDeploymentHistoryApi - factory interface
 * @export
 */
export const JobDeploymentHistoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JobDeploymentHistoryApiFp(configuration)
    return {
        /**
         * Returns the 20 last job deployments
         * @summary List job deployments
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobDeploymentHistory(jobId: string, options?: any): AxiosPromise<PaginationData & object> {
            return localVarFp.listJobDeploymentHistory(jobId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JobDeploymentHistoryApi - object-oriented interface
 * @export
 * @class JobDeploymentHistoryApi
 * @extends {BaseAPI}
 */
export class JobDeploymentHistoryApi extends BaseAPI {
    /**
     * Returns the 20 last job deployments
     * @summary List job deployments
     * @param {string} jobId Job ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobDeploymentHistoryApi
     */
    public listJobDeploymentHistory(jobId: string, options?: AxiosRequestConfig) {
        return JobDeploymentHistoryApiFp(this.configuration).listJobDeploymentHistory(jobId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * JobEnvironmentVariableApi - axios parameter creator
 * @export
 */
export const JobEnvironmentVariableApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * - Add an environment variable to the job. 
         * @summary Add an environment variable to the job
         * @param {string} jobId Job ID
         * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJobEnvironmentVariable: async (jobId: string, environmentVariableRequest?: EnvironmentVariableRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('createJobEnvironmentVariable', 'jobId', jobId)
            const localVarPath = `/job/{jobId}/environmentVariable`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentVariableRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to add an alias at job level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at job level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - Only 1 alias level is allowed. You can\'t create an alias on an alias 
         * @summary Create an environment variable alias at the job level
         * @param {string} jobId Job ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJobEnvironmentVariableAlias: async (jobId: string, environmentVariableId: string, key?: Key, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('createJobEnvironmentVariableAlias', 'jobId', jobId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('createJobEnvironmentVariableAlias', 'environmentVariableId', environmentVariableId)
            const localVarPath = `/job/{jobId}/environmentVariable/{environmentVariableId}/alias`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(key, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to override at job level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at job level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
         * @summary Create an environment variable override at the job level
         * @param {string} jobId Job ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJobEnvironmentVariableOverride: async (jobId: string, environmentVariableId: string, value?: Value, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('createJobEnvironmentVariableOverride', 'jobId', jobId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('createJobEnvironmentVariableOverride', 'environmentVariableId', environmentVariableId)
            const localVarPath = `/job/{jobId}/environmentVariable/{environmentVariableId}/override`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(value, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - To delete an environment variable from an job you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete an environment variable from a job
         * @param {string} jobId Job ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJobEnvironmentVariable: async (jobId: string, environmentVariableId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('deleteJobEnvironmentVariable', 'jobId', jobId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('deleteJobEnvironmentVariable', 'environmentVariableId', environmentVariableId)
            const localVarPath = `/job/{jobId}/environmentVariable/{environmentVariableId}`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > CONTAINER) 
         * @summary Edit an environment variable belonging to the job
         * @param {string} jobId Job ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editJobEnvironmentVariable: async (jobId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('editJobEnvironmentVariable', 'jobId', jobId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('editJobEnvironmentVariable', 'environmentVariableId', environmentVariableId)
            // verify required parameter 'environmentVariableEditRequest' is not null or undefined
            assertParamExists('editJobEnvironmentVariable', 'environmentVariableEditRequest', environmentVariableEditRequest)
            const localVarPath = `/job/{jobId}/environmentVariable/{environmentVariableId}`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentVariableEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Import environment variables in a defined scope, with a defined visibility.
         * @summary Import variables
         * @param {string} jobId Job ID
         * @param {VariableImportRequest} [variableImportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importJobEnvironmentVariable: async (jobId: string, variableImportRequest?: VariableImportRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('importJobEnvironmentVariable', 'jobId', jobId)
            const localVarPath = `/job/{jobId}/environmentVariable/import`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(variableImportRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List environment variables
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobEnvironmentVariable: async (jobId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('listJobEnvironmentVariable', 'jobId', jobId)
            const localVarPath = `/job/{jobId}/environmentVariable`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobEnvironmentVariableApi - functional programming interface
 * @export
 */
export const JobEnvironmentVariableApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JobEnvironmentVariableApiAxiosParamCreator(configuration)
    return {
        /**
         * - Add an environment variable to the job. 
         * @summary Add an environment variable to the job
         * @param {string} jobId Job ID
         * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createJobEnvironmentVariable(jobId: string, environmentVariableRequest?: EnvironmentVariableRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createJobEnvironmentVariable(jobId, environmentVariableRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - Allows you to add an alias at job level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at job level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - Only 1 alias level is allowed. You can\'t create an alias on an alias 
         * @summary Create an environment variable alias at the job level
         * @param {string} jobId Job ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createJobEnvironmentVariableAlias(jobId: string, environmentVariableId: string, key?: Key, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createJobEnvironmentVariableAlias(jobId, environmentVariableId, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - Allows you to override at job level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at job level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
         * @summary Create an environment variable override at the job level
         * @param {string} jobId Job ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createJobEnvironmentVariableOverride(jobId: string, environmentVariableId: string, value?: Value, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createJobEnvironmentVariableOverride(jobId, environmentVariableId, value, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - To delete an environment variable from an job you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete an environment variable from a job
         * @param {string} jobId Job ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteJobEnvironmentVariable(jobId: string, environmentVariableId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteJobEnvironmentVariable(jobId, environmentVariableId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > CONTAINER) 
         * @summary Edit an environment variable belonging to the job
         * @param {string} jobId Job ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editJobEnvironmentVariable(jobId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editJobEnvironmentVariable(jobId, environmentVariableId, environmentVariableEditRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Import environment variables in a defined scope, with a defined visibility.
         * @summary Import variables
         * @param {string} jobId Job ID
         * @param {VariableImportRequest} [variableImportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importJobEnvironmentVariable(jobId: string, variableImportRequest?: VariableImportRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariableImport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importJobEnvironmentVariable(jobId, variableImportRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List environment variables
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listJobEnvironmentVariable(jobId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariableResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listJobEnvironmentVariable(jobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * JobEnvironmentVariableApi - factory interface
 * @export
 */
export const JobEnvironmentVariableApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JobEnvironmentVariableApiFp(configuration)
    return {
        /**
         * - Add an environment variable to the job. 
         * @summary Add an environment variable to the job
         * @param {string} jobId Job ID
         * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJobEnvironmentVariable(jobId: string, environmentVariableRequest?: EnvironmentVariableRequest, options?: any): AxiosPromise<EnvironmentVariable> {
            return localVarFp.createJobEnvironmentVariable(jobId, environmentVariableRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to add an alias at job level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at job level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - Only 1 alias level is allowed. You can\'t create an alias on an alias 
         * @summary Create an environment variable alias at the job level
         * @param {string} jobId Job ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJobEnvironmentVariableAlias(jobId: string, environmentVariableId: string, key?: Key, options?: any): AxiosPromise<EnvironmentVariable> {
            return localVarFp.createJobEnvironmentVariableAlias(jobId, environmentVariableId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to override at job level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at job level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
         * @summary Create an environment variable override at the job level
         * @param {string} jobId Job ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJobEnvironmentVariableOverride(jobId: string, environmentVariableId: string, value?: Value, options?: any): AxiosPromise<EnvironmentVariable> {
            return localVarFp.createJobEnvironmentVariableOverride(jobId, environmentVariableId, value, options).then((request) => request(axios, basePath));
        },
        /**
         * - To delete an environment variable from an job you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete an environment variable from a job
         * @param {string} jobId Job ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJobEnvironmentVariable(jobId: string, environmentVariableId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteJobEnvironmentVariable(jobId, environmentVariableId, options).then((request) => request(axios, basePath));
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > CONTAINER) 
         * @summary Edit an environment variable belonging to the job
         * @param {string} jobId Job ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editJobEnvironmentVariable(jobId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options?: any): AxiosPromise<EnvironmentVariable> {
            return localVarFp.editJobEnvironmentVariable(jobId, environmentVariableId, environmentVariableEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Import environment variables in a defined scope, with a defined visibility.
         * @summary Import variables
         * @param {string} jobId Job ID
         * @param {VariableImportRequest} [variableImportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importJobEnvironmentVariable(jobId: string, variableImportRequest?: VariableImportRequest, options?: any): AxiosPromise<VariableImport> {
            return localVarFp.importJobEnvironmentVariable(jobId, variableImportRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List environment variables
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobEnvironmentVariable(jobId: string, options?: any): AxiosPromise<EnvironmentVariableResponseList> {
            return localVarFp.listJobEnvironmentVariable(jobId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JobEnvironmentVariableApi - object-oriented interface
 * @export
 * @class JobEnvironmentVariableApi
 * @extends {BaseAPI}
 */
export class JobEnvironmentVariableApi extends BaseAPI {
    /**
     * - Add an environment variable to the job. 
     * @summary Add an environment variable to the job
     * @param {string} jobId Job ID
     * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobEnvironmentVariableApi
     */
    public createJobEnvironmentVariable(jobId: string, environmentVariableRequest?: EnvironmentVariableRequest, options?: AxiosRequestConfig) {
        return JobEnvironmentVariableApiFp(this.configuration).createJobEnvironmentVariable(jobId, environmentVariableRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to add an alias at job level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at job level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - Only 1 alias level is allowed. You can\'t create an alias on an alias 
     * @summary Create an environment variable alias at the job level
     * @param {string} jobId Job ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {Key} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobEnvironmentVariableApi
     */
    public createJobEnvironmentVariableAlias(jobId: string, environmentVariableId: string, key?: Key, options?: AxiosRequestConfig) {
        return JobEnvironmentVariableApiFp(this.configuration).createJobEnvironmentVariableAlias(jobId, environmentVariableId, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to override at job level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at job level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
     * @summary Create an environment variable override at the job level
     * @param {string} jobId Job ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {Value} [value] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobEnvironmentVariableApi
     */
    public createJobEnvironmentVariableOverride(jobId: string, environmentVariableId: string, value?: Value, options?: AxiosRequestConfig) {
        return JobEnvironmentVariableApiFp(this.configuration).createJobEnvironmentVariableOverride(jobId, environmentVariableId, value, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - To delete an environment variable from an job you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
     * @summary Delete an environment variable from a job
     * @param {string} jobId Job ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobEnvironmentVariableApi
     */
    public deleteJobEnvironmentVariable(jobId: string, environmentVariableId: string, options?: AxiosRequestConfig) {
        return JobEnvironmentVariableApiFp(this.configuration).deleteJobEnvironmentVariable(jobId, environmentVariableId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > CONTAINER) 
     * @summary Edit an environment variable belonging to the job
     * @param {string} jobId Job ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobEnvironmentVariableApi
     */
    public editJobEnvironmentVariable(jobId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options?: AxiosRequestConfig) {
        return JobEnvironmentVariableApiFp(this.configuration).editJobEnvironmentVariable(jobId, environmentVariableId, environmentVariableEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Import environment variables in a defined scope, with a defined visibility.
     * @summary Import variables
     * @param {string} jobId Job ID
     * @param {VariableImportRequest} [variableImportRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobEnvironmentVariableApi
     */
    public importJobEnvironmentVariable(jobId: string, variableImportRequest?: VariableImportRequest, options?: AxiosRequestConfig) {
        return JobEnvironmentVariableApiFp(this.configuration).importJobEnvironmentVariable(jobId, variableImportRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List environment variables
     * @param {string} jobId Job ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobEnvironmentVariableApi
     */
    public listJobEnvironmentVariable(jobId: string, options?: AxiosRequestConfig) {
        return JobEnvironmentVariableApiFp(this.configuration).listJobEnvironmentVariable(jobId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * JobMainCallsApi - axios parameter creator
 * @export
 */
export const JobMainCallsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * To delete the job you must have the admin permission
         * @summary Delete job
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJob: async (jobId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('deleteJob', 'jobId', jobId)
            const localVarPath = `/job/{jobId}`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - To edit the job you must have the admin permission. 
         * @summary Edit job
         * @param {string} jobId Job ID
         * @param {JobRequest} [jobRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editJob: async (jobId: string, jobRequest?: JobRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('editJob', 'jobId', jobId)
            const localVarPath = `/job/{jobId}`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jobRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get job by ID
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJob: async (jobId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getJob', 'jobId', jobId)
            const localVarPath = `/job/{jobId}`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get job status
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobStatus: async (jobId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getJobStatus', 'jobId', jobId)
            const localVarPath = `/job/{jobId}/status`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns list of the last 100 commits made on the repository linked to the job
         * @summary List last job commits
         * @param {string} jobId Job ID
         * @param {string} [startId] Starting point after which to return results
         * @param {string} [gitCommitId] Git Commit ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobCommit: async (jobId: string, startId?: string, gitCommitId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('listJobCommit', 'jobId', jobId)
            const localVarPath = `/job/{jobId}/commit`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (startId !== undefined) {
                localVarQueryParameter['startId'] = startId;
            }

            if (gitCommitId !== undefined) {
                localVarQueryParameter['gitCommitId'] = gitCommitId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobMainCallsApi - functional programming interface
 * @export
 */
export const JobMainCallsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JobMainCallsApiAxiosParamCreator(configuration)
    return {
        /**
         * To delete the job you must have the admin permission
         * @summary Delete job
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteJob(jobId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteJob(jobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - To edit the job you must have the admin permission. 
         * @summary Edit job
         * @param {string} jobId Job ID
         * @param {JobRequest} [jobRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editJob(jobId: string, jobRequest?: JobRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editJob(jobId, jobRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get job by ID
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJob(jobId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJob(jobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get job status
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobStatus(jobId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobStatus(jobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns list of the last 100 commits made on the repository linked to the job
         * @summary List last job commits
         * @param {string} jobId Job ID
         * @param {string} [startId] Starting point after which to return results
         * @param {string} [gitCommitId] Git Commit ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listJobCommit(jobId: string, startId?: string, gitCommitId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommitResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listJobCommit(jobId, startId, gitCommitId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * JobMainCallsApi - factory interface
 * @export
 */
export const JobMainCallsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JobMainCallsApiFp(configuration)
    return {
        /**
         * To delete the job you must have the admin permission
         * @summary Delete job
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJob(jobId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteJob(jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * - To edit the job you must have the admin permission. 
         * @summary Edit job
         * @param {string} jobId Job ID
         * @param {JobRequest} [jobRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editJob(jobId: string, jobRequest?: JobRequest, options?: any): AxiosPromise<JobResponse> {
            return localVarFp.editJob(jobId, jobRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get job by ID
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJob(jobId: string, options?: any): AxiosPromise<JobResponse> {
            return localVarFp.getJob(jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get job status
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobStatus(jobId: string, options?: any): AxiosPromise<Status> {
            return localVarFp.getJobStatus(jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns list of the last 100 commits made on the repository linked to the job
         * @summary List last job commits
         * @param {string} jobId Job ID
         * @param {string} [startId] Starting point after which to return results
         * @param {string} [gitCommitId] Git Commit ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobCommit(jobId: string, startId?: string, gitCommitId?: string, options?: any): AxiosPromise<CommitResponseList> {
            return localVarFp.listJobCommit(jobId, startId, gitCommitId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JobMainCallsApi - object-oriented interface
 * @export
 * @class JobMainCallsApi
 * @extends {BaseAPI}
 */
export class JobMainCallsApi extends BaseAPI {
    /**
     * To delete the job you must have the admin permission
     * @summary Delete job
     * @param {string} jobId Job ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobMainCallsApi
     */
    public deleteJob(jobId: string, options?: AxiosRequestConfig) {
        return JobMainCallsApiFp(this.configuration).deleteJob(jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - To edit the job you must have the admin permission. 
     * @summary Edit job
     * @param {string} jobId Job ID
     * @param {JobRequest} [jobRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobMainCallsApi
     */
    public editJob(jobId: string, jobRequest?: JobRequest, options?: AxiosRequestConfig) {
        return JobMainCallsApiFp(this.configuration).editJob(jobId, jobRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get job by ID
     * @param {string} jobId Job ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobMainCallsApi
     */
    public getJob(jobId: string, options?: AxiosRequestConfig) {
        return JobMainCallsApiFp(this.configuration).getJob(jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get job status
     * @param {string} jobId Job ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobMainCallsApi
     */
    public getJobStatus(jobId: string, options?: AxiosRequestConfig) {
        return JobMainCallsApiFp(this.configuration).getJobStatus(jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns list of the last 100 commits made on the repository linked to the job
     * @summary List last job commits
     * @param {string} jobId Job ID
     * @param {string} [startId] Starting point after which to return results
     * @param {string} [gitCommitId] Git Commit ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobMainCallsApi
     */
    public listJobCommit(jobId: string, startId?: string, gitCommitId?: string, options?: AxiosRequestConfig) {
        return JobMainCallsApiFp(this.configuration).listJobCommit(jobId, startId, gitCommitId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * JobMetricsApi - axios parameter creator
 * @export
 */
export const JobMetricsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List currently running instances of the job with their CPU and RAM metrics
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobCurrentInstance: async (jobId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getJobCurrentInstance', 'jobId', jobId)
            const localVarPath = `/job/{jobId}/instance`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobMetricsApi - functional programming interface
 * @export
 */
export const JobMetricsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JobMetricsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List currently running instances of the job with their CPU and RAM metrics
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobCurrentInstance(jobId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InstanceResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobCurrentInstance(jobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * JobMetricsApi - factory interface
 * @export
 */
export const JobMetricsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JobMetricsApiFp(configuration)
    return {
        /**
         * 
         * @summary List currently running instances of the job with their CPU and RAM metrics
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobCurrentInstance(jobId: string, options?: any): AxiosPromise<InstanceResponseList> {
            return localVarFp.getJobCurrentInstance(jobId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JobMetricsApi - object-oriented interface
 * @export
 * @class JobMetricsApi
 * @extends {BaseAPI}
 */
export class JobMetricsApi extends BaseAPI {
    /**
     * 
     * @summary List currently running instances of the job with their CPU and RAM metrics
     * @param {string} jobId Job ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobMetricsApi
     */
    public getJobCurrentInstance(jobId: string, options?: AxiosRequestConfig) {
        return JobMetricsApiFp(this.configuration).getJobCurrentInstance(jobId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * JobSecretApi - axios parameter creator
 * @export
 */
export const JobSecretApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * - Add a secret to the job. 
         * @summary Add a secret to the job
         * @param {string} jobId Job ID
         * @param {SecretRequest} [secretRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJobSecret: async (jobId: string, secretRequest?: SecretRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('createJobSecret', 'jobId', jobId)
            const localVarPath = `/job/{jobId}/secret`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(secretRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to add an alias at job level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at job level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - Only 1 alias level is allowed. You can\'t create an alias on an alias 
         * @summary Create a secret alias at the job level
         * @param {string} jobId Job ID
         * @param {string} secretId Secret ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJobSecretAlias: async (jobId: string, secretId: string, key?: Key, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('createJobSecretAlias', 'jobId', jobId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('createJobSecretAlias', 'secretId', secretId)
            const localVarPath = `/job/{jobId}/secret/{secretId}/alias`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(key, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to override at job level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at job level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
         * @summary Create a secret override at the job level
         * @param {string} jobId Job ID
         * @param {string} secretId Secret ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJobSecretOverride: async (jobId: string, secretId: string, value?: Value, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('createJobSecretOverride', 'jobId', jobId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('createJobSecretOverride', 'secretId', secretId)
            const localVarPath = `/job/{jobId}/secret/{secretId}/override`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(value, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete a secret from an job
         * @param {string} jobId Job ID
         * @param {string} secretId Secret ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJobSecret: async (jobId: string, secretId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('deleteJobSecret', 'jobId', jobId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('deleteJobSecret', 'secretId', secretId)
            const localVarPath = `/job/{jobId}/secret/{secretId}`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > CONTAINER) 
         * @summary Edit a secret belonging to the job
         * @param {string} jobId Job ID
         * @param {string} secretId Secret ID
         * @param {SecretEditRequest} secretEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editJobSecret: async (jobId: string, secretId: string, secretEditRequest: SecretEditRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('editJobSecret', 'jobId', jobId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('editJobSecret', 'secretId', secretId)
            // verify required parameter 'secretEditRequest' is not null or undefined
            assertParamExists('editJobSecret', 'secretEditRequest', secretEditRequest)
            const localVarPath = `/job/{jobId}/secret/{secretId}`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(secretEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Secrets are like environment variables, but they are secured and can\'t be revealed.
         * @summary List job secrets
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobSecrets: async (jobId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('listJobSecrets', 'jobId', jobId)
            const localVarPath = `/job/{jobId}/secret`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobSecretApi - functional programming interface
 * @export
 */
export const JobSecretApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JobSecretApiAxiosParamCreator(configuration)
    return {
        /**
         * - Add a secret to the job. 
         * @summary Add a secret to the job
         * @param {string} jobId Job ID
         * @param {SecretRequest} [secretRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createJobSecret(jobId: string, secretRequest?: SecretRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createJobSecret(jobId, secretRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - Allows you to add an alias at job level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at job level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - Only 1 alias level is allowed. You can\'t create an alias on an alias 
         * @summary Create a secret alias at the job level
         * @param {string} jobId Job ID
         * @param {string} secretId Secret ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createJobSecretAlias(jobId: string, secretId: string, key?: Key, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createJobSecretAlias(jobId, secretId, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - Allows you to override at job level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at job level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
         * @summary Create a secret override at the job level
         * @param {string} jobId Job ID
         * @param {string} secretId Secret ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createJobSecretOverride(jobId: string, secretId: string, value?: Value, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createJobSecretOverride(jobId, secretId, value, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete a secret from an job
         * @param {string} jobId Job ID
         * @param {string} secretId Secret ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteJobSecret(jobId: string, secretId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteJobSecret(jobId, secretId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > CONTAINER) 
         * @summary Edit a secret belonging to the job
         * @param {string} jobId Job ID
         * @param {string} secretId Secret ID
         * @param {SecretEditRequest} secretEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editJobSecret(jobId: string, secretId: string, secretEditRequest: SecretEditRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editJobSecret(jobId, secretId, secretEditRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Secrets are like environment variables, but they are secured and can\'t be revealed.
         * @summary List job secrets
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listJobSecrets(jobId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecretResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listJobSecrets(jobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * JobSecretApi - factory interface
 * @export
 */
export const JobSecretApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JobSecretApiFp(configuration)
    return {
        /**
         * - Add a secret to the job. 
         * @summary Add a secret to the job
         * @param {string} jobId Job ID
         * @param {SecretRequest} [secretRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJobSecret(jobId: string, secretRequest?: SecretRequest, options?: any): AxiosPromise<Secret> {
            return localVarFp.createJobSecret(jobId, secretRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to add an alias at job level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at job level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - Only 1 alias level is allowed. You can\'t create an alias on an alias 
         * @summary Create a secret alias at the job level
         * @param {string} jobId Job ID
         * @param {string} secretId Secret ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJobSecretAlias(jobId: string, secretId: string, key?: Key, options?: any): AxiosPromise<Secret> {
            return localVarFp.createJobSecretAlias(jobId, secretId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to override at job level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at job level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
         * @summary Create a secret override at the job level
         * @param {string} jobId Job ID
         * @param {string} secretId Secret ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJobSecretOverride(jobId: string, secretId: string, value?: Value, options?: any): AxiosPromise<Secret> {
            return localVarFp.createJobSecretOverride(jobId, secretId, value, options).then((request) => request(axios, basePath));
        },
        /**
         * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete a secret from an job
         * @param {string} jobId Job ID
         * @param {string} secretId Secret ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJobSecret(jobId: string, secretId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteJobSecret(jobId, secretId, options).then((request) => request(axios, basePath));
        },
        /**
         * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > CONTAINER) 
         * @summary Edit a secret belonging to the job
         * @param {string} jobId Job ID
         * @param {string} secretId Secret ID
         * @param {SecretEditRequest} secretEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editJobSecret(jobId: string, secretId: string, secretEditRequest: SecretEditRequest, options?: any): AxiosPromise<Secret> {
            return localVarFp.editJobSecret(jobId, secretId, secretEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Secrets are like environment variables, but they are secured and can\'t be revealed.
         * @summary List job secrets
         * @param {string} jobId Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobSecrets(jobId: string, options?: any): AxiosPromise<SecretResponseList> {
            return localVarFp.listJobSecrets(jobId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JobSecretApi - object-oriented interface
 * @export
 * @class JobSecretApi
 * @extends {BaseAPI}
 */
export class JobSecretApi extends BaseAPI {
    /**
     * - Add a secret to the job. 
     * @summary Add a secret to the job
     * @param {string} jobId Job ID
     * @param {SecretRequest} [secretRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobSecretApi
     */
    public createJobSecret(jobId: string, secretRequest?: SecretRequest, options?: AxiosRequestConfig) {
        return JobSecretApiFp(this.configuration).createJobSecret(jobId, secretRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to add an alias at job level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at job level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - Only 1 alias level is allowed. You can\'t create an alias on an alias 
     * @summary Create a secret alias at the job level
     * @param {string} jobId Job ID
     * @param {string} secretId Secret ID
     * @param {Key} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobSecretApi
     */
    public createJobSecretAlias(jobId: string, secretId: string, key?: Key, options?: AxiosRequestConfig) {
        return JobSecretApiFp(this.configuration).createJobSecretAlias(jobId, secretId, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to override at job level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at job level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
     * @summary Create a secret override at the job level
     * @param {string} jobId Job ID
     * @param {string} secretId Secret ID
     * @param {Value} [value] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobSecretApi
     */
    public createJobSecretOverride(jobId: string, secretId: string, value?: Value, options?: AxiosRequestConfig) {
        return JobSecretApiFp(this.configuration).createJobSecretOverride(jobId, secretId, value, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well 
     * @summary Delete a secret from an job
     * @param {string} jobId Job ID
     * @param {string} secretId Secret ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobSecretApi
     */
    public deleteJobSecret(jobId: string, secretId: string, options?: AxiosRequestConfig) {
        return JobSecretApiFp(this.configuration).deleteJobSecret(jobId, secretId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > CONTAINER) 
     * @summary Edit a secret belonging to the job
     * @param {string} jobId Job ID
     * @param {string} secretId Secret ID
     * @param {SecretEditRequest} secretEditRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobSecretApi
     */
    public editJobSecret(jobId: string, secretId: string, secretEditRequest: SecretEditRequest, options?: AxiosRequestConfig) {
        return JobSecretApiFp(this.configuration).editJobSecret(jobId, secretId, secretEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Secrets are like environment variables, but they are secured and can\'t be revealed.
     * @summary List job secrets
     * @param {string} jobId Job ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobSecretApi
     */
    public listJobSecrets(jobId: string, options?: AxiosRequestConfig) {
        return JobSecretApiFp(this.configuration).listJobSecrets(jobId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * JobsApi - axios parameter creator
 * @export
 */
export const JobsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This will create a new job with the same configuration on the targeted environment Id.
         * @summary Clone job
         * @param {string} jobId Job ID
         * @param {CloneJobRequest} [cloneJobRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneJob: async (jobId: string, cloneJobRequest?: CloneJobRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('cloneJob', 'jobId', jobId)
            const localVarPath = `/job/{jobId}/clone`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloneJobRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a job
         * @param {string} environmentId Environment ID
         * @param {JobRequest} [jobRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJob: async (environmentId: string, jobRequest?: JobRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('createJob', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/job`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jobRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List default job advanced settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultJobAdvancedSettings: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/defaultJobAdvancedSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of jobs with only their id and status.
         * @summary List all environment job statuses
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentJobStatus: async (environmentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('getEnvironmentJobStatus', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/job/status`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List jobs
         * @param {string} environmentId Environment ID
         * @param {boolean} [toUpdate] return (or not) results that must be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobs: async (environmentId: string, toUpdate?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('listJobs', 'environmentId', environmentId)
            const localVarPath = `/environment/{environmentId}/job`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (toUpdate !== undefined) {
                localVarQueryParameter['toUpdate'] = toUpdate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobsApi - functional programming interface
 * @export
 */
export const JobsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JobsApiAxiosParamCreator(configuration)
    return {
        /**
         * This will create a new job with the same configuration on the targeted environment Id.
         * @summary Clone job
         * @param {string} jobId Job ID
         * @param {CloneJobRequest} [cloneJobRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloneJob(jobId: string, cloneJobRequest?: CloneJobRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cloneJob(jobId, cloneJobRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a job
         * @param {string} environmentId Environment ID
         * @param {JobRequest} [jobRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createJob(environmentId: string, jobRequest?: JobRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createJob(environmentId, jobRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List default job advanced settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDefaultJobAdvancedSettings(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobAdvancedSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDefaultJobAdvancedSettings(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of jobs with only their id and status.
         * @summary List all environment job statuses
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironmentJobStatus(environmentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReferenceObjectStatusResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironmentJobStatus(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List jobs
         * @param {string} environmentId Environment ID
         * @param {boolean} [toUpdate] return (or not) results that must be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listJobs(environmentId: string, toUpdate?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listJobs(environmentId, toUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * JobsApi - factory interface
 * @export
 */
export const JobsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JobsApiFp(configuration)
    return {
        /**
         * This will create a new job with the same configuration on the targeted environment Id.
         * @summary Clone job
         * @param {string} jobId Job ID
         * @param {CloneJobRequest} [cloneJobRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneJob(jobId: string, cloneJobRequest?: CloneJobRequest, options?: any): AxiosPromise<JobResponse> {
            return localVarFp.cloneJob(jobId, cloneJobRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a job
         * @param {string} environmentId Environment ID
         * @param {JobRequest} [jobRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJob(environmentId: string, jobRequest?: JobRequest, options?: any): AxiosPromise<JobResponse> {
            return localVarFp.createJob(environmentId, jobRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List default job advanced settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultJobAdvancedSettings(options?: any): AxiosPromise<JobAdvancedSettings> {
            return localVarFp.getDefaultJobAdvancedSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of jobs with only their id and status.
         * @summary List all environment job statuses
         * @param {string} environmentId Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentJobStatus(environmentId: string, options?: any): AxiosPromise<ReferenceObjectStatusResponseList> {
            return localVarFp.getEnvironmentJobStatus(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List jobs
         * @param {string} environmentId Environment ID
         * @param {boolean} [toUpdate] return (or not) results that must be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobs(environmentId: string, toUpdate?: boolean, options?: any): AxiosPromise<JobResponseList> {
            return localVarFp.listJobs(environmentId, toUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JobsApi - object-oriented interface
 * @export
 * @class JobsApi
 * @extends {BaseAPI}
 */
export class JobsApi extends BaseAPI {
    /**
     * This will create a new job with the same configuration on the targeted environment Id.
     * @summary Clone job
     * @param {string} jobId Job ID
     * @param {CloneJobRequest} [cloneJobRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public cloneJob(jobId: string, cloneJobRequest?: CloneJobRequest, options?: AxiosRequestConfig) {
        return JobsApiFp(this.configuration).cloneJob(jobId, cloneJobRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a job
     * @param {string} environmentId Environment ID
     * @param {JobRequest} [jobRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public createJob(environmentId: string, jobRequest?: JobRequest, options?: AxiosRequestConfig) {
        return JobsApiFp(this.configuration).createJob(environmentId, jobRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List default job advanced settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public getDefaultJobAdvancedSettings(options?: AxiosRequestConfig) {
        return JobsApiFp(this.configuration).getDefaultJobAdvancedSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of jobs with only their id and status.
     * @summary List all environment job statuses
     * @param {string} environmentId Environment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public getEnvironmentJobStatus(environmentId: string, options?: AxiosRequestConfig) {
        return JobsApiFp(this.configuration).getEnvironmentJobStatus(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List jobs
     * @param {string} environmentId Environment ID
     * @param {boolean} [toUpdate] return (or not) results that must be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public listJobs(environmentId: string, toUpdate?: boolean, options?: AxiosRequestConfig) {
        return JobsApiFp(this.configuration).listJobs(environmentId, toUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MembersApi - axios parameter creator
 * @export
 */
export const MembersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove an invited member
         * @param {string} organizationId Organization ID
         * @param {string} inviteId Invite ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInviteMember: async (organizationId: string, inviteId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteInviteMember', 'organizationId', organizationId)
            // verify required parameter 'inviteId' is not null or undefined
            assertParamExists('deleteInviteMember', 'inviteId', inviteId)
            const localVarPath = `/organization/{organizationId}/inviteMember/{inviteId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"inviteId"}}`, encodeURIComponent(String(inviteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a member
         * @param {string} organizationId Organization ID
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMember: async (organizationId: string, inlineObject?: InlineObject, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteMember', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/member`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit an organization member role
         * @summary Edit an organization member role
         * @param {string} organizationId Organization ID
         * @param {MemberRoleUpdateRequest} [memberRoleUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editOrganizationMemberRole: async (organizationId: string, memberRoleUpdateRequest?: MemberRoleUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('editOrganizationMemberRole', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/member`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(memberRoleUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get member invitation
         * @param {string} organizationId Organization ID
         * @param {string} inviteId Invite ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMemberInvitation: async (organizationId: string, inviteId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getMemberInvitation', 'organizationId', organizationId)
            // verify required parameter 'inviteId' is not null or undefined
            assertParamExists('getMemberInvitation', 'inviteId', inviteId)
            const localVarPath = `/organization/{organizationId}/inviteMember/{inviteId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"inviteId"}}`, encodeURIComponent(String(inviteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get invited members
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationInvitedMembers: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationInvitedMembers', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/inviteMember`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get organization members
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationMembers: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationMembers', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/member`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Accept Invite in the organization
         * @param {string} organizationId Organization ID
         * @param {string} inviteId Invite ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAcceptInviteMember: async (organizationId: string, inviteId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('postAcceptInviteMember', 'organizationId', organizationId)
            // verify required parameter 'inviteId' is not null or undefined
            assertParamExists('postAcceptInviteMember', 'inviteId', inviteId)
            const localVarPath = `/organization/{organizationId}/inviteMember/{inviteId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"inviteId"}}`, encodeURIComponent(String(inviteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invite someone in the organization
         * @param {string} organizationId Organization ID
         * @param {InviteMemberRequest} [inviteMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postInviteMember: async (organizationId: string, inviteMemberRequest?: InviteMemberRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('postInviteMember', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/inviteMember`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inviteMemberRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Transfer organization ownership to another user
         * @param {string} organizationId Organization ID
         * @param {TransferOwnershipRequest} [transferOwnershipRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrganizationTransferOwnership: async (organizationId: string, transferOwnershipRequest?: TransferOwnershipRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('postOrganizationTransferOwnership', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/transferOwnership`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transferOwnershipRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MembersApi - functional programming interface
 * @export
 */
export const MembersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MembersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove an invited member
         * @param {string} organizationId Organization ID
         * @param {string} inviteId Invite ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteInviteMember(organizationId: string, inviteId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteInviteMember(organizationId, inviteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove a member
         * @param {string} organizationId Organization ID
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMember(organizationId: string, inlineObject?: InlineObject, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMember(organizationId, inlineObject, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Edit an organization member role
         * @summary Edit an organization member role
         * @param {string} organizationId Organization ID
         * @param {MemberRoleUpdateRequest} [memberRoleUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editOrganizationMemberRole(organizationId: string, memberRoleUpdateRequest?: MemberRoleUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editOrganizationMemberRole(organizationId, memberRoleUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get member invitation
         * @param {string} organizationId Organization ID
         * @param {string} inviteId Invite ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMemberInvitation(organizationId: string, inviteId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InviteMember>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMemberInvitation(organizationId, inviteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get invited members
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationInvitedMembers(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InviteMemberResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationInvitedMembers(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get organization members
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationMembers(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemberResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationMembers(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Accept Invite in the organization
         * @param {string} organizationId Organization ID
         * @param {string} inviteId Invite ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAcceptInviteMember(organizationId: string, inviteId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InviteMember>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postAcceptInviteMember(organizationId, inviteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Invite someone in the organization
         * @param {string} organizationId Organization ID
         * @param {InviteMemberRequest} [inviteMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postInviteMember(organizationId: string, inviteMemberRequest?: InviteMemberRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InviteMember>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postInviteMember(organizationId, inviteMemberRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Transfer organization ownership to another user
         * @param {string} organizationId Organization ID
         * @param {TransferOwnershipRequest} [transferOwnershipRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postOrganizationTransferOwnership(organizationId: string, transferOwnershipRequest?: TransferOwnershipRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postOrganizationTransferOwnership(organizationId, transferOwnershipRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MembersApi - factory interface
 * @export
 */
export const MembersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MembersApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove an invited member
         * @param {string} organizationId Organization ID
         * @param {string} inviteId Invite ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInviteMember(organizationId: string, inviteId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteInviteMember(organizationId, inviteId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a member
         * @param {string} organizationId Organization ID
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMember(organizationId: string, inlineObject?: InlineObject, options?: any): AxiosPromise<void> {
            return localVarFp.deleteMember(organizationId, inlineObject, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit an organization member role
         * @summary Edit an organization member role
         * @param {string} organizationId Organization ID
         * @param {MemberRoleUpdateRequest} [memberRoleUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editOrganizationMemberRole(organizationId: string, memberRoleUpdateRequest?: MemberRoleUpdateRequest, options?: any): AxiosPromise<void> {
            return localVarFp.editOrganizationMemberRole(organizationId, memberRoleUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get member invitation
         * @param {string} organizationId Organization ID
         * @param {string} inviteId Invite ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMemberInvitation(organizationId: string, inviteId: string, options?: any): AxiosPromise<InviteMember> {
            return localVarFp.getMemberInvitation(organizationId, inviteId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get invited members
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationInvitedMembers(organizationId: string, options?: any): AxiosPromise<InviteMemberResponseList> {
            return localVarFp.getOrganizationInvitedMembers(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get organization members
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationMembers(organizationId: string, options?: any): AxiosPromise<MemberResponseList> {
            return localVarFp.getOrganizationMembers(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Accept Invite in the organization
         * @param {string} organizationId Organization ID
         * @param {string} inviteId Invite ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAcceptInviteMember(organizationId: string, inviteId: string, options?: any): AxiosPromise<InviteMember> {
            return localVarFp.postAcceptInviteMember(organizationId, inviteId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invite someone in the organization
         * @param {string} organizationId Organization ID
         * @param {InviteMemberRequest} [inviteMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postInviteMember(organizationId: string, inviteMemberRequest?: InviteMemberRequest, options?: any): AxiosPromise<InviteMember> {
            return localVarFp.postInviteMember(organizationId, inviteMemberRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Transfer organization ownership to another user
         * @param {string} organizationId Organization ID
         * @param {TransferOwnershipRequest} [transferOwnershipRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrganizationTransferOwnership(organizationId: string, transferOwnershipRequest?: TransferOwnershipRequest, options?: any): AxiosPromise<void> {
            return localVarFp.postOrganizationTransferOwnership(organizationId, transferOwnershipRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MembersApi - object-oriented interface
 * @export
 * @class MembersApi
 * @extends {BaseAPI}
 */
export class MembersApi extends BaseAPI {
    /**
     * 
     * @summary Remove an invited member
     * @param {string} organizationId Organization ID
     * @param {string} inviteId Invite ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public deleteInviteMember(organizationId: string, inviteId: string, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).deleteInviteMember(organizationId, inviteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a member
     * @param {string} organizationId Organization ID
     * @param {InlineObject} [inlineObject] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public deleteMember(organizationId: string, inlineObject?: InlineObject, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).deleteMember(organizationId, inlineObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit an organization member role
     * @summary Edit an organization member role
     * @param {string} organizationId Organization ID
     * @param {MemberRoleUpdateRequest} [memberRoleUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public editOrganizationMemberRole(organizationId: string, memberRoleUpdateRequest?: MemberRoleUpdateRequest, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).editOrganizationMemberRole(organizationId, memberRoleUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get member invitation
     * @param {string} organizationId Organization ID
     * @param {string} inviteId Invite ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public getMemberInvitation(organizationId: string, inviteId: string, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).getMemberInvitation(organizationId, inviteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get invited members
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public getOrganizationInvitedMembers(organizationId: string, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).getOrganizationInvitedMembers(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get organization members
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public getOrganizationMembers(organizationId: string, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).getOrganizationMembers(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Accept Invite in the organization
     * @param {string} organizationId Organization ID
     * @param {string} inviteId Invite ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public postAcceptInviteMember(organizationId: string, inviteId: string, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).postAcceptInviteMember(organizationId, inviteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invite someone in the organization
     * @param {string} organizationId Organization ID
     * @param {InviteMemberRequest} [inviteMemberRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public postInviteMember(organizationId: string, inviteMemberRequest?: InviteMemberRequest, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).postInviteMember(organizationId, inviteMemberRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Transfer organization ownership to another user
     * @param {string} organizationId Organization ID
     * @param {TransferOwnershipRequest} [transferOwnershipRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public postOrganizationTransferOwnership(organizationId: string, transferOwnershipRequest?: TransferOwnershipRequest, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).postOrganizationTransferOwnership(organizationId, transferOwnershipRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrganizationAccountGitRepositoriesApi - axios parameter creator
 * @export
 */
export const OrganizationAccountGitRepositoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get bitbucket repositories of the connected user
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationBitbucketRepositories: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationBitbucketRepositories', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/account/bitbucket/repository`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get bitbucket branches of the specified repository
         * @param {string} organizationId Organization ID
         * @param {string} [name] The name of the repository where to retrieve the branches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationBitbucketRepositoryBranches: async (organizationId: string, name?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationBitbucketRepositoryBranches', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/account/bitbucket/repository/branch`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get git provider accounts
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationGitProviderAccount: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationGitProviderAccount', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/account/gitAuthProvider`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get github repositories of the connected user
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationGithubRepositories: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationGithubRepositories', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/account/github/repository`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get github branches of the specified repository
         * @param {string} organizationId Organization ID
         * @param {string} [name] The name of the repository where to retrieve the branches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationGithubRepositoryBranches: async (organizationId: string, name?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationGithubRepositoryBranches', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/account/github/repository/branch`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get gitlab repositories of the connected user
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationGitlabRepositories: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationGitlabRepositories', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/account/gitlab/repository`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get gitlab branches of the specified repository
         * @param {string} organizationId Organization ID
         * @param {string} [name] The name of the repository to retrieve the branches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationGitlabRepositoryBranches: async (organizationId: string, name?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationGitlabRepositoryBranches', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/account/gitlab/repository/branch`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationAccountGitRepositoriesApi - functional programming interface
 * @export
 */
export const OrganizationAccountGitRepositoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationAccountGitRepositoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get bitbucket repositories of the connected user
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationBitbucketRepositories(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitRepositoryResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationBitbucketRepositories(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get bitbucket branches of the specified repository
         * @param {string} organizationId Organization ID
         * @param {string} [name] The name of the repository where to retrieve the branches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationBitbucketRepositoryBranches(organizationId: string, name?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitRepositoryBranchResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationBitbucketRepositoryBranches(organizationId, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get git provider accounts
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationGitProviderAccount(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitAuthProviderResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationGitProviderAccount(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get github repositories of the connected user
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationGithubRepositories(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitRepositoryResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationGithubRepositories(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get github branches of the specified repository
         * @param {string} organizationId Organization ID
         * @param {string} [name] The name of the repository where to retrieve the branches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationGithubRepositoryBranches(organizationId: string, name?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitRepositoryBranchResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationGithubRepositoryBranches(organizationId, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get gitlab repositories of the connected user
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationGitlabRepositories(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitRepositoryResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationGitlabRepositories(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get gitlab branches of the specified repository
         * @param {string} organizationId Organization ID
         * @param {string} [name] The name of the repository to retrieve the branches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationGitlabRepositoryBranches(organizationId: string, name?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitRepositoryBranchResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationGitlabRepositoryBranches(organizationId, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrganizationAccountGitRepositoriesApi - factory interface
 * @export
 */
export const OrganizationAccountGitRepositoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationAccountGitRepositoriesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get bitbucket repositories of the connected user
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationBitbucketRepositories(organizationId: string, options?: any): AxiosPromise<GitRepositoryResponseList> {
            return localVarFp.getOrganizationBitbucketRepositories(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get bitbucket branches of the specified repository
         * @param {string} organizationId Organization ID
         * @param {string} [name] The name of the repository where to retrieve the branches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationBitbucketRepositoryBranches(organizationId: string, name?: string, options?: any): AxiosPromise<GitRepositoryBranchResponseList> {
            return localVarFp.getOrganizationBitbucketRepositoryBranches(organizationId, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get git provider accounts
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationGitProviderAccount(organizationId: string, options?: any): AxiosPromise<GitAuthProviderResponseList> {
            return localVarFp.getOrganizationGitProviderAccount(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get github repositories of the connected user
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationGithubRepositories(organizationId: string, options?: any): AxiosPromise<GitRepositoryResponseList> {
            return localVarFp.getOrganizationGithubRepositories(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get github branches of the specified repository
         * @param {string} organizationId Organization ID
         * @param {string} [name] The name of the repository where to retrieve the branches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationGithubRepositoryBranches(organizationId: string, name?: string, options?: any): AxiosPromise<GitRepositoryBranchResponseList> {
            return localVarFp.getOrganizationGithubRepositoryBranches(organizationId, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get gitlab repositories of the connected user
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationGitlabRepositories(organizationId: string, options?: any): AxiosPromise<GitRepositoryResponseList> {
            return localVarFp.getOrganizationGitlabRepositories(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get gitlab branches of the specified repository
         * @param {string} organizationId Organization ID
         * @param {string} [name] The name of the repository to retrieve the branches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationGitlabRepositoryBranches(organizationId: string, name?: string, options?: any): AxiosPromise<GitRepositoryBranchResponseList> {
            return localVarFp.getOrganizationGitlabRepositoryBranches(organizationId, name, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationAccountGitRepositoriesApi - object-oriented interface
 * @export
 * @class OrganizationAccountGitRepositoriesApi
 * @extends {BaseAPI}
 */
export class OrganizationAccountGitRepositoriesApi extends BaseAPI {
    /**
     * 
     * @summary Get bitbucket repositories of the connected user
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationAccountGitRepositoriesApi
     */
    public getOrganizationBitbucketRepositories(organizationId: string, options?: AxiosRequestConfig) {
        return OrganizationAccountGitRepositoriesApiFp(this.configuration).getOrganizationBitbucketRepositories(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get bitbucket branches of the specified repository
     * @param {string} organizationId Organization ID
     * @param {string} [name] The name of the repository where to retrieve the branches
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationAccountGitRepositoriesApi
     */
    public getOrganizationBitbucketRepositoryBranches(organizationId: string, name?: string, options?: AxiosRequestConfig) {
        return OrganizationAccountGitRepositoriesApiFp(this.configuration).getOrganizationBitbucketRepositoryBranches(organizationId, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get git provider accounts
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationAccountGitRepositoriesApi
     */
    public getOrganizationGitProviderAccount(organizationId: string, options?: AxiosRequestConfig) {
        return OrganizationAccountGitRepositoriesApiFp(this.configuration).getOrganizationGitProviderAccount(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get github repositories of the connected user
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationAccountGitRepositoriesApi
     */
    public getOrganizationGithubRepositories(organizationId: string, options?: AxiosRequestConfig) {
        return OrganizationAccountGitRepositoriesApiFp(this.configuration).getOrganizationGithubRepositories(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get github branches of the specified repository
     * @param {string} organizationId Organization ID
     * @param {string} [name] The name of the repository where to retrieve the branches
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationAccountGitRepositoriesApi
     */
    public getOrganizationGithubRepositoryBranches(organizationId: string, name?: string, options?: AxiosRequestConfig) {
        return OrganizationAccountGitRepositoriesApiFp(this.configuration).getOrganizationGithubRepositoryBranches(organizationId, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get gitlab repositories of the connected user
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationAccountGitRepositoriesApi
     */
    public getOrganizationGitlabRepositories(organizationId: string, options?: AxiosRequestConfig) {
        return OrganizationAccountGitRepositoriesApiFp(this.configuration).getOrganizationGitlabRepositories(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get gitlab branches of the specified repository
     * @param {string} organizationId Organization ID
     * @param {string} [name] The name of the repository to retrieve the branches
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationAccountGitRepositoriesApi
     */
    public getOrganizationGitlabRepositoryBranches(organizationId: string, name?: string, options?: AxiosRequestConfig) {
        return OrganizationAccountGitRepositoriesApiFp(this.configuration).getOrganizationGitlabRepositoryBranches(organizationId, name, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrganizationApiTokenApi - axios parameter creator
 * @export
 */
export const OrganizationApiTokenApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an organization api token. You can use the generated token to interact in a programmatic way with our API.
         * @summary Create an organization api token
         * @param {string} organizationId Organization ID
         * @param {OrganizationApiTokenCreateRequest} [organizationApiTokenCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationApiToken: async (organizationId: string, organizationApiTokenCreateRequest?: OrganizationApiTokenCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createOrganizationApiToken', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/apiToken`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationApiTokenCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete organization api token
         * @summary Delete organization api token
         * @param {string} organizationId Organization ID
         * @param {string} apiTokenId Organization Api Token ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationApiToken: async (organizationId: string, apiTokenId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteOrganizationApiToken', 'organizationId', organizationId)
            // verify required parameter 'apiTokenId' is not null or undefined
            assertParamExists('deleteOrganizationApiToken', 'apiTokenId', apiTokenId)
            const localVarPath = `/organization/{organizationId}/apiToken/{apiTokenId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"apiTokenId"}}`, encodeURIComponent(String(apiTokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List organization api tokens
         * @summary List organization api tokens
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationApiTokens: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listOrganizationApiTokens', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/apiToken`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationApiTokenApi - functional programming interface
 * @export
 */
export const OrganizationApiTokenApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationApiTokenApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an organization api token. You can use the generated token to interact in a programmatic way with our API.
         * @summary Create an organization api token
         * @param {string} organizationId Organization ID
         * @param {OrganizationApiTokenCreateRequest} [organizationApiTokenCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrganizationApiToken(organizationId: string, organizationApiTokenCreateRequest?: OrganizationApiTokenCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationApiTokenCreate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrganizationApiToken(organizationId, organizationApiTokenCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete organization api token
         * @summary Delete organization api token
         * @param {string} organizationId Organization ID
         * @param {string} apiTokenId Organization Api Token ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrganizationApiToken(organizationId: string, apiTokenId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrganizationApiToken(organizationId, apiTokenId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List organization api tokens
         * @summary List organization api tokens
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizationApiTokens(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationApiTokenResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationApiTokens(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrganizationApiTokenApi - factory interface
 * @export
 */
export const OrganizationApiTokenApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationApiTokenApiFp(configuration)
    return {
        /**
         * Create an organization api token. You can use the generated token to interact in a programmatic way with our API.
         * @summary Create an organization api token
         * @param {string} organizationId Organization ID
         * @param {OrganizationApiTokenCreateRequest} [organizationApiTokenCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationApiToken(organizationId: string, organizationApiTokenCreateRequest?: OrganizationApiTokenCreateRequest, options?: any): AxiosPromise<OrganizationApiTokenCreate> {
            return localVarFp.createOrganizationApiToken(organizationId, organizationApiTokenCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete organization api token
         * @summary Delete organization api token
         * @param {string} organizationId Organization ID
         * @param {string} apiTokenId Organization Api Token ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationApiToken(organizationId: string, apiTokenId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteOrganizationApiToken(organizationId, apiTokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * List organization api tokens
         * @summary List organization api tokens
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationApiTokens(organizationId: string, options?: any): AxiosPromise<OrganizationApiTokenResponseList> {
            return localVarFp.listOrganizationApiTokens(organizationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationApiTokenApi - object-oriented interface
 * @export
 * @class OrganizationApiTokenApi
 * @extends {BaseAPI}
 */
export class OrganizationApiTokenApi extends BaseAPI {
    /**
     * Create an organization api token. You can use the generated token to interact in a programmatic way with our API.
     * @summary Create an organization api token
     * @param {string} organizationId Organization ID
     * @param {OrganizationApiTokenCreateRequest} [organizationApiTokenCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiTokenApi
     */
    public createOrganizationApiToken(organizationId: string, organizationApiTokenCreateRequest?: OrganizationApiTokenCreateRequest, options?: AxiosRequestConfig) {
        return OrganizationApiTokenApiFp(this.configuration).createOrganizationApiToken(organizationId, organizationApiTokenCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete organization api token
     * @summary Delete organization api token
     * @param {string} organizationId Organization ID
     * @param {string} apiTokenId Organization Api Token ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiTokenApi
     */
    public deleteOrganizationApiToken(organizationId: string, apiTokenId: string, options?: AxiosRequestConfig) {
        return OrganizationApiTokenApiFp(this.configuration).deleteOrganizationApiToken(organizationId, apiTokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List organization api tokens
     * @summary List organization api tokens
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiTokenApi
     */
    public listOrganizationApiTokens(organizationId: string, options?: AxiosRequestConfig) {
        return OrganizationApiTokenApiFp(this.configuration).listOrganizationApiTokens(organizationId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrganizationCustomRoleApi - axios parameter creator
 * @export
 */
export const OrganizationCustomRoleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an organization custom role
         * @summary Create an organization custom role
         * @param {string} organizationId Organization ID
         * @param {OrganizationCustomRoleCreateRequest} [organizationCustomRoleCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationCustomRole: async (organizationId: string, organizationCustomRoleCreateRequest?: OrganizationCustomRoleCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createOrganizationCustomRole', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/customRole`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationCustomRoleCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete organization custom role
         * @summary Delete organization custom role
         * @param {string} organizationId Organization ID
         * @param {string} customRoleId Custom Role ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationCustomRole: async (organizationId: string, customRoleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteOrganizationCustomRole', 'organizationId', organizationId)
            // verify required parameter 'customRoleId' is not null or undefined
            assertParamExists('deleteOrganizationCustomRole', 'customRoleId', customRoleId)
            const localVarPath = `/organization/{organizationId}/customRole/{customRoleId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"customRoleId"}}`, encodeURIComponent(String(customRoleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit an organization custom role
         * @summary Edit an organization custom role
         * @param {string} organizationId Organization ID
         * @param {string} customRoleId Custom Role ID
         * @param {OrganizationCustomRoleUpdateRequest} [organizationCustomRoleUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editOrganizationCustomRole: async (organizationId: string, customRoleId: string, organizationCustomRoleUpdateRequest?: OrganizationCustomRoleUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('editOrganizationCustomRole', 'organizationId', organizationId)
            // verify required parameter 'customRoleId' is not null or undefined
            assertParamExists('editOrganizationCustomRole', 'customRoleId', customRoleId)
            const localVarPath = `/organization/{organizationId}/customRole/{customRoleId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"customRoleId"}}`, encodeURIComponent(String(customRoleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationCustomRoleUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an organization custom role 
         * @summary Get an organization custom role 
         * @param {string} organizationId Organization ID
         * @param {string} customRoleId Custom Role ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationCustomRole: async (organizationId: string, customRoleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationCustomRole', 'organizationId', organizationId)
            // verify required parameter 'customRoleId' is not null or undefined
            assertParamExists('getOrganizationCustomRole', 'customRoleId', customRoleId)
            const localVarPath = `/organization/{organizationId}/customRole/{customRoleId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"customRoleId"}}`, encodeURIComponent(String(customRoleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List organization custom roles
         * @summary List organization custom roles
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationCustomRoles: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listOrganizationCustomRoles', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/customRole`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationCustomRoleApi - functional programming interface
 * @export
 */
export const OrganizationCustomRoleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationCustomRoleApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an organization custom role
         * @summary Create an organization custom role
         * @param {string} organizationId Organization ID
         * @param {OrganizationCustomRoleCreateRequest} [organizationCustomRoleCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrganizationCustomRole(organizationId: string, organizationCustomRoleCreateRequest?: OrganizationCustomRoleCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationCustomRole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrganizationCustomRole(organizationId, organizationCustomRoleCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete organization custom role
         * @summary Delete organization custom role
         * @param {string} organizationId Organization ID
         * @param {string} customRoleId Custom Role ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrganizationCustomRole(organizationId: string, customRoleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrganizationCustomRole(organizationId, customRoleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Edit an organization custom role
         * @summary Edit an organization custom role
         * @param {string} organizationId Organization ID
         * @param {string} customRoleId Custom Role ID
         * @param {OrganizationCustomRoleUpdateRequest} [organizationCustomRoleUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editOrganizationCustomRole(organizationId: string, customRoleId: string, organizationCustomRoleUpdateRequest?: OrganizationCustomRoleUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationCustomRole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editOrganizationCustomRole(organizationId, customRoleId, organizationCustomRoleUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get an organization custom role 
         * @summary Get an organization custom role 
         * @param {string} organizationId Organization ID
         * @param {string} customRoleId Custom Role ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationCustomRole(organizationId: string, customRoleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationCustomRole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationCustomRole(organizationId, customRoleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List organization custom roles
         * @summary List organization custom roles
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizationCustomRoles(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationCustomRoleList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationCustomRoles(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrganizationCustomRoleApi - factory interface
 * @export
 */
export const OrganizationCustomRoleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationCustomRoleApiFp(configuration)
    return {
        /**
         * Create an organization custom role
         * @summary Create an organization custom role
         * @param {string} organizationId Organization ID
         * @param {OrganizationCustomRoleCreateRequest} [organizationCustomRoleCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationCustomRole(organizationId: string, organizationCustomRoleCreateRequest?: OrganizationCustomRoleCreateRequest, options?: any): AxiosPromise<OrganizationCustomRole> {
            return localVarFp.createOrganizationCustomRole(organizationId, organizationCustomRoleCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete organization custom role
         * @summary Delete organization custom role
         * @param {string} organizationId Organization ID
         * @param {string} customRoleId Custom Role ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationCustomRole(organizationId: string, customRoleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteOrganizationCustomRole(organizationId, customRoleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit an organization custom role
         * @summary Edit an organization custom role
         * @param {string} organizationId Organization ID
         * @param {string} customRoleId Custom Role ID
         * @param {OrganizationCustomRoleUpdateRequest} [organizationCustomRoleUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editOrganizationCustomRole(organizationId: string, customRoleId: string, organizationCustomRoleUpdateRequest?: OrganizationCustomRoleUpdateRequest, options?: any): AxiosPromise<OrganizationCustomRole> {
            return localVarFp.editOrganizationCustomRole(organizationId, customRoleId, organizationCustomRoleUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an organization custom role 
         * @summary Get an organization custom role 
         * @param {string} organizationId Organization ID
         * @param {string} customRoleId Custom Role ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationCustomRole(organizationId: string, customRoleId: string, options?: any): AxiosPromise<OrganizationCustomRole> {
            return localVarFp.getOrganizationCustomRole(organizationId, customRoleId, options).then((request) => request(axios, basePath));
        },
        /**
         * List organization custom roles
         * @summary List organization custom roles
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationCustomRoles(organizationId: string, options?: any): AxiosPromise<OrganizationCustomRoleList> {
            return localVarFp.listOrganizationCustomRoles(organizationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationCustomRoleApi - object-oriented interface
 * @export
 * @class OrganizationCustomRoleApi
 * @extends {BaseAPI}
 */
export class OrganizationCustomRoleApi extends BaseAPI {
    /**
     * Create an organization custom role
     * @summary Create an organization custom role
     * @param {string} organizationId Organization ID
     * @param {OrganizationCustomRoleCreateRequest} [organizationCustomRoleCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationCustomRoleApi
     */
    public createOrganizationCustomRole(organizationId: string, organizationCustomRoleCreateRequest?: OrganizationCustomRoleCreateRequest, options?: AxiosRequestConfig) {
        return OrganizationCustomRoleApiFp(this.configuration).createOrganizationCustomRole(organizationId, organizationCustomRoleCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete organization custom role
     * @summary Delete organization custom role
     * @param {string} organizationId Organization ID
     * @param {string} customRoleId Custom Role ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationCustomRoleApi
     */
    public deleteOrganizationCustomRole(organizationId: string, customRoleId: string, options?: AxiosRequestConfig) {
        return OrganizationCustomRoleApiFp(this.configuration).deleteOrganizationCustomRole(organizationId, customRoleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit an organization custom role
     * @summary Edit an organization custom role
     * @param {string} organizationId Organization ID
     * @param {string} customRoleId Custom Role ID
     * @param {OrganizationCustomRoleUpdateRequest} [organizationCustomRoleUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationCustomRoleApi
     */
    public editOrganizationCustomRole(organizationId: string, customRoleId: string, organizationCustomRoleUpdateRequest?: OrganizationCustomRoleUpdateRequest, options?: AxiosRequestConfig) {
        return OrganizationCustomRoleApiFp(this.configuration).editOrganizationCustomRole(organizationId, customRoleId, organizationCustomRoleUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an organization custom role 
     * @summary Get an organization custom role 
     * @param {string} organizationId Organization ID
     * @param {string} customRoleId Custom Role ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationCustomRoleApi
     */
    public getOrganizationCustomRole(organizationId: string, customRoleId: string, options?: AxiosRequestConfig) {
        return OrganizationCustomRoleApiFp(this.configuration).getOrganizationCustomRole(organizationId, customRoleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List organization custom roles
     * @summary List organization custom roles
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationCustomRoleApi
     */
    public listOrganizationCustomRoles(organizationId: string, options?: AxiosRequestConfig) {
        return OrganizationCustomRoleApiFp(this.configuration).listOrganizationCustomRoles(organizationId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrganizationEventApi - axios parameter creator
 * @export
 */
export const OrganizationEventApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get available event targets to filter events
         * @summary Get available event targets to filter events
         * @param {string} organizationId Organization ID
         * @param {string} [fromTimestamp] Display targets available since this timestamp.   A range of date can be specified by using &#x60;from-timestamp&#x60; with &#x60;to-timestamp&#x60; The format is a timestamp with nano precision 
         * @param {string} [toTimestamp] Display targets triggered before this timestamp.   A range of date can be specified by using &#x60;to-timestamp&#x60; with &#x60;from-timestamp&#x60; The format is a timestamp with nano precision 
         * @param {OrganizationEventType} [eventType] 
         * @param {OrganizationEventTargetType} [targetType] 
         * @param {string} [triggeredBy] Information about the owner of the event (user name / apitoken / automatic action)
         * @param {OrganizationEventOrigin} [origin] 
         * @param {string} [projectId] Mandatory when requesting an environment or a service
         * @param {string} [environmentId] Mandatory when requesting a service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationEventTargets: async (organizationId: string, fromTimestamp?: string, toTimestamp?: string, eventType?: OrganizationEventType, targetType?: OrganizationEventTargetType, triggeredBy?: string, origin?: OrganizationEventOrigin, projectId?: string, environmentId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationEventTargets', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/targets`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fromTimestamp !== undefined) {
                localVarQueryParameter['fromTimestamp'] = fromTimestamp;
            }

            if (toTimestamp !== undefined) {
                localVarQueryParameter['toTimestamp'] = toTimestamp;
            }

            if (eventType !== undefined) {
                localVarQueryParameter['eventType'] = eventType;
            }

            if (targetType !== undefined) {
                localVarQueryParameter['targetType'] = targetType;
            }

            if (triggeredBy !== undefined) {
                localVarQueryParameter['triggeredBy'] = triggeredBy;
            }

            if (origin !== undefined) {
                localVarQueryParameter['origin'] = origin;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }

            if (environmentId !== undefined) {
                localVarQueryParameter['environmentId'] = environmentId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all events inside the organization
         * @summary Get all events inside the organization
         * @param {string} organizationId Organization ID
         * @param {number} [pageSize] The number of events to display in the current page
         * @param {string} [fromTimestamp] Display events triggered since this timestamp.   A range of date can be specified by using &#x60;from-timestamp&#x60; with &#x60;to-timestamp&#x60; The format is a timestamp with nano precision 
         * @param {string} [toTimestamp] Display events triggered before this timestamp.   A range of date can be specified by using &#x60;to-timestamp&#x60; with &#x60;from-timestamp&#x60; The format is a timestamp with nano precision 
         * @param {string} [continueToken] Token used to fetch the next page results The format is a timestamp with nano precision 
         * @param {string} [stepBackToken] Token used to fetch the previous page results The format is a timestamp with nano precision 
         * @param {OrganizationEventType} [eventType] 
         * @param {OrganizationEventTargetType} [targetType] 
         * @param {string} [targetId] The target resource id to search.   Must be specified with the corresponding &#x60;target_type&#x60; 
         * @param {OrganizationEventSubTargetType} [subTargetType] 
         * @param {string} [triggeredBy] Information about the owner of the event (user name / apitoken / automatic action)
         * @param {OrganizationEventOrigin} [origin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationEvents: async (organizationId: string, pageSize?: number, fromTimestamp?: string, toTimestamp?: string, continueToken?: string, stepBackToken?: string, eventType?: OrganizationEventType, targetType?: OrganizationEventTargetType, targetId?: string, subTargetType?: OrganizationEventSubTargetType, triggeredBy?: string, origin?: OrganizationEventOrigin, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationEvents', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/events`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (fromTimestamp !== undefined) {
                localVarQueryParameter['fromTimestamp'] = fromTimestamp;
            }

            if (toTimestamp !== undefined) {
                localVarQueryParameter['toTimestamp'] = toTimestamp;
            }

            if (continueToken !== undefined) {
                localVarQueryParameter['continueToken'] = continueToken;
            }

            if (stepBackToken !== undefined) {
                localVarQueryParameter['stepBackToken'] = stepBackToken;
            }

            if (eventType !== undefined) {
                localVarQueryParameter['eventType'] = eventType;
            }

            if (targetType !== undefined) {
                localVarQueryParameter['targetType'] = targetType;
            }

            if (targetId !== undefined) {
                localVarQueryParameter['targetId'] = targetId;
            }

            if (subTargetType !== undefined) {
                localVarQueryParameter['subTargetType'] = subTargetType;
            }

            if (triggeredBy !== undefined) {
                localVarQueryParameter['triggeredBy'] = triggeredBy;
            }

            if (origin !== undefined) {
                localVarQueryParameter['origin'] = origin;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationEventApi - functional programming interface
 * @export
 */
export const OrganizationEventApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationEventApiAxiosParamCreator(configuration)
    return {
        /**
         * Get available event targets to filter events
         * @summary Get available event targets to filter events
         * @param {string} organizationId Organization ID
         * @param {string} [fromTimestamp] Display targets available since this timestamp.   A range of date can be specified by using &#x60;from-timestamp&#x60; with &#x60;to-timestamp&#x60; The format is a timestamp with nano precision 
         * @param {string} [toTimestamp] Display targets triggered before this timestamp.   A range of date can be specified by using &#x60;to-timestamp&#x60; with &#x60;from-timestamp&#x60; The format is a timestamp with nano precision 
         * @param {OrganizationEventType} [eventType] 
         * @param {OrganizationEventTargetType} [targetType] 
         * @param {string} [triggeredBy] Information about the owner of the event (user name / apitoken / automatic action)
         * @param {OrganizationEventOrigin} [origin] 
         * @param {string} [projectId] Mandatory when requesting an environment or a service
         * @param {string} [environmentId] Mandatory when requesting a service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationEventTargets(organizationId: string, fromTimestamp?: string, toTimestamp?: string, eventType?: OrganizationEventType, targetType?: OrganizationEventTargetType, triggeredBy?: string, origin?: OrganizationEventOrigin, projectId?: string, environmentId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationEventTargetResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationEventTargets(organizationId, fromTimestamp, toTimestamp, eventType, targetType, triggeredBy, origin, projectId, environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all events inside the organization
         * @summary Get all events inside the organization
         * @param {string} organizationId Organization ID
         * @param {number} [pageSize] The number of events to display in the current page
         * @param {string} [fromTimestamp] Display events triggered since this timestamp.   A range of date can be specified by using &#x60;from-timestamp&#x60; with &#x60;to-timestamp&#x60; The format is a timestamp with nano precision 
         * @param {string} [toTimestamp] Display events triggered before this timestamp.   A range of date can be specified by using &#x60;to-timestamp&#x60; with &#x60;from-timestamp&#x60; The format is a timestamp with nano precision 
         * @param {string} [continueToken] Token used to fetch the next page results The format is a timestamp with nano precision 
         * @param {string} [stepBackToken] Token used to fetch the previous page results The format is a timestamp with nano precision 
         * @param {OrganizationEventType} [eventType] 
         * @param {OrganizationEventTargetType} [targetType] 
         * @param {string} [targetId] The target resource id to search.   Must be specified with the corresponding &#x60;target_type&#x60; 
         * @param {OrganizationEventSubTargetType} [subTargetType] 
         * @param {string} [triggeredBy] Information about the owner of the event (user name / apitoken / automatic action)
         * @param {OrganizationEventOrigin} [origin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationEvents(organizationId: string, pageSize?: number, fromTimestamp?: string, toTimestamp?: string, continueToken?: string, stepBackToken?: string, eventType?: OrganizationEventType, targetType?: OrganizationEventTargetType, targetId?: string, subTargetType?: OrganizationEventSubTargetType, triggeredBy?: string, origin?: OrganizationEventOrigin, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationEventResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationEvents(organizationId, pageSize, fromTimestamp, toTimestamp, continueToken, stepBackToken, eventType, targetType, targetId, subTargetType, triggeredBy, origin, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrganizationEventApi - factory interface
 * @export
 */
export const OrganizationEventApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationEventApiFp(configuration)
    return {
        /**
         * Get available event targets to filter events
         * @summary Get available event targets to filter events
         * @param {string} organizationId Organization ID
         * @param {string} [fromTimestamp] Display targets available since this timestamp.   A range of date can be specified by using &#x60;from-timestamp&#x60; with &#x60;to-timestamp&#x60; The format is a timestamp with nano precision 
         * @param {string} [toTimestamp] Display targets triggered before this timestamp.   A range of date can be specified by using &#x60;to-timestamp&#x60; with &#x60;from-timestamp&#x60; The format is a timestamp with nano precision 
         * @param {OrganizationEventType} [eventType] 
         * @param {OrganizationEventTargetType} [targetType] 
         * @param {string} [triggeredBy] Information about the owner of the event (user name / apitoken / automatic action)
         * @param {OrganizationEventOrigin} [origin] 
         * @param {string} [projectId] Mandatory when requesting an environment or a service
         * @param {string} [environmentId] Mandatory when requesting a service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationEventTargets(organizationId: string, fromTimestamp?: string, toTimestamp?: string, eventType?: OrganizationEventType, targetType?: OrganizationEventTargetType, triggeredBy?: string, origin?: OrganizationEventOrigin, projectId?: string, environmentId?: string, options?: any): AxiosPromise<OrganizationEventTargetResponseList> {
            return localVarFp.getOrganizationEventTargets(organizationId, fromTimestamp, toTimestamp, eventType, targetType, triggeredBy, origin, projectId, environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all events inside the organization
         * @summary Get all events inside the organization
         * @param {string} organizationId Organization ID
         * @param {number} [pageSize] The number of events to display in the current page
         * @param {string} [fromTimestamp] Display events triggered since this timestamp.   A range of date can be specified by using &#x60;from-timestamp&#x60; with &#x60;to-timestamp&#x60; The format is a timestamp with nano precision 
         * @param {string} [toTimestamp] Display events triggered before this timestamp.   A range of date can be specified by using &#x60;to-timestamp&#x60; with &#x60;from-timestamp&#x60; The format is a timestamp with nano precision 
         * @param {string} [continueToken] Token used to fetch the next page results The format is a timestamp with nano precision 
         * @param {string} [stepBackToken] Token used to fetch the previous page results The format is a timestamp with nano precision 
         * @param {OrganizationEventType} [eventType] 
         * @param {OrganizationEventTargetType} [targetType] 
         * @param {string} [targetId] The target resource id to search.   Must be specified with the corresponding &#x60;target_type&#x60; 
         * @param {OrganizationEventSubTargetType} [subTargetType] 
         * @param {string} [triggeredBy] Information about the owner of the event (user name / apitoken / automatic action)
         * @param {OrganizationEventOrigin} [origin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationEvents(organizationId: string, pageSize?: number, fromTimestamp?: string, toTimestamp?: string, continueToken?: string, stepBackToken?: string, eventType?: OrganizationEventType, targetType?: OrganizationEventTargetType, targetId?: string, subTargetType?: OrganizationEventSubTargetType, triggeredBy?: string, origin?: OrganizationEventOrigin, options?: any): AxiosPromise<OrganizationEventResponseList> {
            return localVarFp.getOrganizationEvents(organizationId, pageSize, fromTimestamp, toTimestamp, continueToken, stepBackToken, eventType, targetType, targetId, subTargetType, triggeredBy, origin, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationEventApi - object-oriented interface
 * @export
 * @class OrganizationEventApi
 * @extends {BaseAPI}
 */
export class OrganizationEventApi extends BaseAPI {
    /**
     * Get available event targets to filter events
     * @summary Get available event targets to filter events
     * @param {string} organizationId Organization ID
     * @param {string} [fromTimestamp] Display targets available since this timestamp.   A range of date can be specified by using &#x60;from-timestamp&#x60; with &#x60;to-timestamp&#x60; The format is a timestamp with nano precision 
     * @param {string} [toTimestamp] Display targets triggered before this timestamp.   A range of date can be specified by using &#x60;to-timestamp&#x60; with &#x60;from-timestamp&#x60; The format is a timestamp with nano precision 
     * @param {OrganizationEventType} [eventType] 
     * @param {OrganizationEventTargetType} [targetType] 
     * @param {string} [triggeredBy] Information about the owner of the event (user name / apitoken / automatic action)
     * @param {OrganizationEventOrigin} [origin] 
     * @param {string} [projectId] Mandatory when requesting an environment or a service
     * @param {string} [environmentId] Mandatory when requesting a service
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationEventApi
     */
    public getOrganizationEventTargets(organizationId: string, fromTimestamp?: string, toTimestamp?: string, eventType?: OrganizationEventType, targetType?: OrganizationEventTargetType, triggeredBy?: string, origin?: OrganizationEventOrigin, projectId?: string, environmentId?: string, options?: AxiosRequestConfig) {
        return OrganizationEventApiFp(this.configuration).getOrganizationEventTargets(organizationId, fromTimestamp, toTimestamp, eventType, targetType, triggeredBy, origin, projectId, environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all events inside the organization
     * @summary Get all events inside the organization
     * @param {string} organizationId Organization ID
     * @param {number} [pageSize] The number of events to display in the current page
     * @param {string} [fromTimestamp] Display events triggered since this timestamp.   A range of date can be specified by using &#x60;from-timestamp&#x60; with &#x60;to-timestamp&#x60; The format is a timestamp with nano precision 
     * @param {string} [toTimestamp] Display events triggered before this timestamp.   A range of date can be specified by using &#x60;to-timestamp&#x60; with &#x60;from-timestamp&#x60; The format is a timestamp with nano precision 
     * @param {string} [continueToken] Token used to fetch the next page results The format is a timestamp with nano precision 
     * @param {string} [stepBackToken] Token used to fetch the previous page results The format is a timestamp with nano precision 
     * @param {OrganizationEventType} [eventType] 
     * @param {OrganizationEventTargetType} [targetType] 
     * @param {string} [targetId] The target resource id to search.   Must be specified with the corresponding &#x60;target_type&#x60; 
     * @param {OrganizationEventSubTargetType} [subTargetType] 
     * @param {string} [triggeredBy] Information about the owner of the event (user name / apitoken / automatic action)
     * @param {OrganizationEventOrigin} [origin] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationEventApi
     */
    public getOrganizationEvents(organizationId: string, pageSize?: number, fromTimestamp?: string, toTimestamp?: string, continueToken?: string, stepBackToken?: string, eventType?: OrganizationEventType, targetType?: OrganizationEventTargetType, targetId?: string, subTargetType?: OrganizationEventSubTargetType, triggeredBy?: string, origin?: OrganizationEventOrigin, options?: AxiosRequestConfig) {
        return OrganizationEventApiFp(this.configuration).getOrganizationEvents(organizationId, pageSize, fromTimestamp, toTimestamp, continueToken, stepBackToken, eventType, targetType, targetId, subTargetType, triggeredBy, origin, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrganizationMainCallsApi - axios parameter creator
 * @export
 */
export const OrganizationMainCallsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create an organization
         * @param {OrganizationRequest} [organizationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganization: async (organizationRequest?: OrganizationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/organization`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To delete an organization you must have the admin permission
         * @summary Delete an organization
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganization: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteOrganization', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To edit an organization you must have the admin permission
         * @summary Edit an organization
         * @param {string} organizationId Organization ID
         * @param {OrganizationEditRequest} [organizationEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editOrganization: async (organizationId: string, organizationEditRequest?: OrganizationEditRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('editOrganization', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get organization by ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganization', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List user organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganization: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/organization`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List organization available roles
         * @summary List organization available roles
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationAvailableRoles: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listOrganizationAvailableRoles', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/availableRole`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationMainCallsApi - functional programming interface
 * @export
 */
export const OrganizationMainCallsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationMainCallsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create an organization
         * @param {OrganizationRequest} [organizationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrganization(organizationRequest?: OrganizationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrganization(organizationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * To delete an organization you must have the admin permission
         * @summary Delete an organization
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrganization(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrganization(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * To edit an organization you must have the admin permission
         * @summary Edit an organization
         * @param {string} organizationId Organization ID
         * @param {OrganizationEditRequest} [organizationEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editOrganization(organizationId: string, organizationEditRequest?: OrganizationEditRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editOrganization(organizationId, organizationEditRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get organization by ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganization(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganization(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List user organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganization(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganization(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List organization available roles
         * @summary List organization available roles
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizationAvailableRoles(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationAvailableRoleList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationAvailableRoles(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrganizationMainCallsApi - factory interface
 * @export
 */
export const OrganizationMainCallsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationMainCallsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create an organization
         * @param {OrganizationRequest} [organizationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganization(organizationRequest?: OrganizationRequest, options?: any): AxiosPromise<Organization> {
            return localVarFp.createOrganization(organizationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * To delete an organization you must have the admin permission
         * @summary Delete an organization
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganization(organizationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteOrganization(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * To edit an organization you must have the admin permission
         * @summary Edit an organization
         * @param {string} organizationId Organization ID
         * @param {OrganizationEditRequest} [organizationEditRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editOrganization(organizationId: string, organizationEditRequest?: OrganizationEditRequest, options?: any): AxiosPromise<Organization> {
            return localVarFp.editOrganization(organizationId, organizationEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get organization by ID
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization(organizationId: string, options?: any): AxiosPromise<Organization> {
            return localVarFp.getOrganization(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List user organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganization(options?: any): AxiosPromise<OrganizationResponseList> {
            return localVarFp.listOrganization(options).then((request) => request(axios, basePath));
        },
        /**
         * List organization available roles
         * @summary List organization available roles
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationAvailableRoles(organizationId: string, options?: any): AxiosPromise<OrganizationAvailableRoleList> {
            return localVarFp.listOrganizationAvailableRoles(organizationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationMainCallsApi - object-oriented interface
 * @export
 * @class OrganizationMainCallsApi
 * @extends {BaseAPI}
 */
export class OrganizationMainCallsApi extends BaseAPI {
    /**
     * 
     * @summary Create an organization
     * @param {OrganizationRequest} [organizationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationMainCallsApi
     */
    public createOrganization(organizationRequest?: OrganizationRequest, options?: AxiosRequestConfig) {
        return OrganizationMainCallsApiFp(this.configuration).createOrganization(organizationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To delete an organization you must have the admin permission
     * @summary Delete an organization
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationMainCallsApi
     */
    public deleteOrganization(organizationId: string, options?: AxiosRequestConfig) {
        return OrganizationMainCallsApiFp(this.configuration).deleteOrganization(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To edit an organization you must have the admin permission
     * @summary Edit an organization
     * @param {string} organizationId Organization ID
     * @param {OrganizationEditRequest} [organizationEditRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationMainCallsApi
     */
    public editOrganization(organizationId: string, organizationEditRequest?: OrganizationEditRequest, options?: AxiosRequestConfig) {
        return OrganizationMainCallsApiFp(this.configuration).editOrganization(organizationId, organizationEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get organization by ID
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationMainCallsApi
     */
    public getOrganization(organizationId: string, options?: AxiosRequestConfig) {
        return OrganizationMainCallsApiFp(this.configuration).getOrganization(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List user organizations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationMainCallsApi
     */
    public listOrganization(options?: AxiosRequestConfig) {
        return OrganizationMainCallsApiFp(this.configuration).listOrganization(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List organization available roles
     * @summary List organization available roles
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationMainCallsApi
     */
    public listOrganizationAvailableRoles(organizationId: string, options?: AxiosRequestConfig) {
        return OrganizationMainCallsApiFp(this.configuration).listOrganizationAvailableRoles(organizationId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrganizationWebhookApi - axios parameter creator
 * @export
 */
export const OrganizationWebhookApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an organization webhook.
         * @summary Create an organization webhook
         * @param {string} organizationId Organization ID
         * @param {OrganizationWebhookCreateRequest} [organizationWebhookCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationWebhook: async (organizationId: string, organizationWebhookCreateRequest?: OrganizationWebhookCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createOrganizationWebhook', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/webhook`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationWebhookCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete organization webhook
         * @summary Delete organization webhook
         * @param {string} organizationId Organization ID
         * @param {string} webhookId Webhook ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationWebhook: async (organizationId: string, webhookId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteOrganizationWebhook', 'organizationId', organizationId)
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('deleteOrganizationWebhook', 'webhookId', webhookId)
            const localVarPath = `/organization/{organizationId}/webhook/{webhookId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit an organization webhook
         * @summary Edit an organization webhook
         * @param {string} organizationId Organization ID
         * @param {string} webhookId Webhook ID
         * @param {OrganizationWebhookCreateRequest} [organizationWebhookCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editOrganizationWebhook: async (organizationId: string, webhookId: string, organizationWebhookCreateRequest?: OrganizationWebhookCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('editOrganizationWebhook', 'organizationId', organizationId)
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('editOrganizationWebhook', 'webhookId', webhookId)
            const localVarPath = `/organization/{organizationId}/webhook/{webhookId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationWebhookCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an Organization webhook
         * @summary Get an Organization webhook
         * @param {string} organizationId Organization ID
         * @param {string} webhookId Webhook ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationWebhook: async (organizationId: string, webhookId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationWebhook', 'organizationId', organizationId)
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('getOrganizationWebhook', 'webhookId', webhookId)
            const localVarPath = `/organization/{organizationId}/webhook/{webhookId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List organization webhooks
         * @summary List organization webhooks
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationWebHooks: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listOrganizationWebHooks', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/webhook`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationWebhookApi - functional programming interface
 * @export
 */
export const OrganizationWebhookApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationWebhookApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an organization webhook.
         * @summary Create an organization webhook
         * @param {string} organizationId Organization ID
         * @param {OrganizationWebhookCreateRequest} [organizationWebhookCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrganizationWebhook(organizationId: string, organizationWebhookCreateRequest?: OrganizationWebhookCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationWebhookCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrganizationWebhook(organizationId, organizationWebhookCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete organization webhook
         * @summary Delete organization webhook
         * @param {string} organizationId Organization ID
         * @param {string} webhookId Webhook ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrganizationWebhook(organizationId: string, webhookId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrganizationWebhook(organizationId, webhookId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Edit an organization webhook
         * @summary Edit an organization webhook
         * @param {string} organizationId Organization ID
         * @param {string} webhookId Webhook ID
         * @param {OrganizationWebhookCreateRequest} [organizationWebhookCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editOrganizationWebhook(organizationId: string, webhookId: string, organizationWebhookCreateRequest?: OrganizationWebhookCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationWebhookCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editOrganizationWebhook(organizationId, webhookId, organizationWebhookCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get an Organization webhook
         * @summary Get an Organization webhook
         * @param {string} organizationId Organization ID
         * @param {string} webhookId Webhook ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationWebhook(organizationId: string, webhookId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationWebhookResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationWebhook(organizationId, webhookId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List organization webhooks
         * @summary List organization webhooks
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizationWebHooks(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationWebhookResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationWebHooks(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrganizationWebhookApi - factory interface
 * @export
 */
export const OrganizationWebhookApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationWebhookApiFp(configuration)
    return {
        /**
         * Create an organization webhook.
         * @summary Create an organization webhook
         * @param {string} organizationId Organization ID
         * @param {OrganizationWebhookCreateRequest} [organizationWebhookCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationWebhook(organizationId: string, organizationWebhookCreateRequest?: OrganizationWebhookCreateRequest, options?: any): AxiosPromise<OrganizationWebhookCreateResponse> {
            return localVarFp.createOrganizationWebhook(organizationId, organizationWebhookCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete organization webhook
         * @summary Delete organization webhook
         * @param {string} organizationId Organization ID
         * @param {string} webhookId Webhook ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationWebhook(organizationId: string, webhookId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteOrganizationWebhook(organizationId, webhookId, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit an organization webhook
         * @summary Edit an organization webhook
         * @param {string} organizationId Organization ID
         * @param {string} webhookId Webhook ID
         * @param {OrganizationWebhookCreateRequest} [organizationWebhookCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editOrganizationWebhook(organizationId: string, webhookId: string, organizationWebhookCreateRequest?: OrganizationWebhookCreateRequest, options?: any): AxiosPromise<OrganizationWebhookCreateResponse> {
            return localVarFp.editOrganizationWebhook(organizationId, webhookId, organizationWebhookCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an Organization webhook
         * @summary Get an Organization webhook
         * @param {string} organizationId Organization ID
         * @param {string} webhookId Webhook ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationWebhook(organizationId: string, webhookId: string, options?: any): AxiosPromise<OrganizationWebhookResponse> {
            return localVarFp.getOrganizationWebhook(organizationId, webhookId, options).then((request) => request(axios, basePath));
        },
        /**
         * List organization webhooks
         * @summary List organization webhooks
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationWebHooks(organizationId: string, options?: any): AxiosPromise<OrganizationWebhookResponseList> {
            return localVarFp.listOrganizationWebHooks(organizationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationWebhookApi - object-oriented interface
 * @export
 * @class OrganizationWebhookApi
 * @extends {BaseAPI}
 */
export class OrganizationWebhookApi extends BaseAPI {
    /**
     * Create an organization webhook.
     * @summary Create an organization webhook
     * @param {string} organizationId Organization ID
     * @param {OrganizationWebhookCreateRequest} [organizationWebhookCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationWebhookApi
     */
    public createOrganizationWebhook(organizationId: string, organizationWebhookCreateRequest?: OrganizationWebhookCreateRequest, options?: AxiosRequestConfig) {
        return OrganizationWebhookApiFp(this.configuration).createOrganizationWebhook(organizationId, organizationWebhookCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete organization webhook
     * @summary Delete organization webhook
     * @param {string} organizationId Organization ID
     * @param {string} webhookId Webhook ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationWebhookApi
     */
    public deleteOrganizationWebhook(organizationId: string, webhookId: string, options?: AxiosRequestConfig) {
        return OrganizationWebhookApiFp(this.configuration).deleteOrganizationWebhook(organizationId, webhookId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit an organization webhook
     * @summary Edit an organization webhook
     * @param {string} organizationId Organization ID
     * @param {string} webhookId Webhook ID
     * @param {OrganizationWebhookCreateRequest} [organizationWebhookCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationWebhookApi
     */
    public editOrganizationWebhook(organizationId: string, webhookId: string, organizationWebhookCreateRequest?: OrganizationWebhookCreateRequest, options?: AxiosRequestConfig) {
        return OrganizationWebhookApiFp(this.configuration).editOrganizationWebhook(organizationId, webhookId, organizationWebhookCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an Organization webhook
     * @summary Get an Organization webhook
     * @param {string} organizationId Organization ID
     * @param {string} webhookId Webhook ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationWebhookApi
     */
    public getOrganizationWebhook(organizationId: string, webhookId: string, options?: AxiosRequestConfig) {
        return OrganizationWebhookApiFp(this.configuration).getOrganizationWebhook(organizationId, webhookId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List organization webhooks
     * @summary List organization webhooks
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationWebhookApi
     */
    public listOrganizationWebHooks(organizationId: string, options?: AxiosRequestConfig) {
        return OrganizationWebhookApiFp(this.configuration).listOrganizationWebHooks(organizationId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProjectDeploymentRuleApi - axios parameter creator
 * @export
 */
export const ProjectDeploymentRuleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a deployment rule
         * @summary Create a deployment rule
         * @param {string} projectId Project ID
         * @param {ProjectDeploymentRuleRequest} [projectDeploymentRuleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeploymentRule: async (projectId: string, projectDeploymentRuleRequest?: ProjectDeploymentRuleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createDeploymentRule', 'projectId', projectId)
            const localVarPath = `/project/{projectId}/deploymentRule`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectDeploymentRuleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a project deployment rule
         * @summary Delete a project deployment rule
         * @param {string} projectId Project ID
         * @param {string} deploymentRuleId Deployment Rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectDeploymentRule: async (projectId: string, deploymentRuleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteProjectDeploymentRule', 'projectId', projectId)
            // verify required parameter 'deploymentRuleId' is not null or undefined
            assertParamExists('deleteProjectDeploymentRule', 'deploymentRuleId', deploymentRuleId)
            const localVarPath = `/project/{projectId}/deploymentRule/{deploymentRuleId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"deploymentRuleId"}}`, encodeURIComponent(String(deploymentRuleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit a project deployment rule
         * @summary Edit a project deployment rule
         * @param {string} projectId Project ID
         * @param {string} deploymentRuleId Deployment Rule ID
         * @param {ProjectDeploymentRuleRequest} [projectDeploymentRuleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editProjectDeployemtnRule: async (projectId: string, deploymentRuleId: string, projectDeploymentRuleRequest?: ProjectDeploymentRuleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('editProjectDeployemtnRule', 'projectId', projectId)
            // verify required parameter 'deploymentRuleId' is not null or undefined
            assertParamExists('editProjectDeployemtnRule', 'deploymentRuleId', deploymentRuleId)
            const localVarPath = `/project/{projectId}/deploymentRule/{deploymentRuleId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"deploymentRuleId"}}`, encodeURIComponent(String(deploymentRuleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectDeploymentRuleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a project deployment rule
         * @summary Get a project deployment rule
         * @param {string} projectId Project ID
         * @param {string} deploymentRuleId Deployment Rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectDeploymentRule: async (projectId: string, deploymentRuleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getProjectDeploymentRule', 'projectId', projectId)
            // verify required parameter 'deploymentRuleId' is not null or undefined
            assertParamExists('getProjectDeploymentRule', 'deploymentRuleId', deploymentRuleId)
            const localVarPath = `/project/{projectId}/deploymentRule/{deploymentRuleId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"deploymentRuleId"}}`, encodeURIComponent(String(deploymentRuleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List project deployment rules
         * @summary List project deployment rules
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectDeploymentRules: async (projectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('listProjectDeploymentRules', 'projectId', projectId)
            const localVarPath = `/project/{projectId}/deploymentRule`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update deployment rules priority order
         * @summary Update deployment rules priority order
         * @param {string} projectId Project ID
         * @param {ProjectDeploymentRulesPriorityOrderRequest} [projectDeploymentRulesPriorityOrderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeploymentRulesPriorityOrder: async (projectId: string, projectDeploymentRulesPriorityOrderRequest?: ProjectDeploymentRulesPriorityOrderRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateDeploymentRulesPriorityOrder', 'projectId', projectId)
            const localVarPath = `/project/{projectId}/deploymentRule/order`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectDeploymentRulesPriorityOrderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectDeploymentRuleApi - functional programming interface
 * @export
 */
export const ProjectDeploymentRuleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectDeploymentRuleApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a deployment rule
         * @summary Create a deployment rule
         * @param {string} projectId Project ID
         * @param {ProjectDeploymentRuleRequest} [projectDeploymentRuleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDeploymentRule(projectId: string, projectDeploymentRuleRequest?: ProjectDeploymentRuleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectDeploymentRule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDeploymentRule(projectId, projectDeploymentRuleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a project deployment rule
         * @summary Delete a project deployment rule
         * @param {string} projectId Project ID
         * @param {string} deploymentRuleId Deployment Rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProjectDeploymentRule(projectId: string, deploymentRuleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProjectDeploymentRule(projectId, deploymentRuleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Edit a project deployment rule
         * @summary Edit a project deployment rule
         * @param {string} projectId Project ID
         * @param {string} deploymentRuleId Deployment Rule ID
         * @param {ProjectDeploymentRuleRequest} [projectDeploymentRuleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editProjectDeployemtnRule(projectId: string, deploymentRuleId: string, projectDeploymentRuleRequest?: ProjectDeploymentRuleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectDeploymentRule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editProjectDeployemtnRule(projectId, deploymentRuleId, projectDeploymentRuleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a project deployment rule
         * @summary Get a project deployment rule
         * @param {string} projectId Project ID
         * @param {string} deploymentRuleId Deployment Rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjectDeploymentRule(projectId: string, deploymentRuleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectDeploymentRule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectDeploymentRule(projectId, deploymentRuleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List project deployment rules
         * @summary List project deployment rules
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProjectDeploymentRules(projectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectDeploymentRuleResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProjectDeploymentRules(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update deployment rules priority order
         * @summary Update deployment rules priority order
         * @param {string} projectId Project ID
         * @param {ProjectDeploymentRulesPriorityOrderRequest} [projectDeploymentRulesPriorityOrderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDeploymentRulesPriorityOrder(projectId: string, projectDeploymentRulesPriorityOrderRequest?: ProjectDeploymentRulesPriorityOrderRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDeploymentRulesPriorityOrder(projectId, projectDeploymentRulesPriorityOrderRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectDeploymentRuleApi - factory interface
 * @export
 */
export const ProjectDeploymentRuleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectDeploymentRuleApiFp(configuration)
    return {
        /**
         * Create a deployment rule
         * @summary Create a deployment rule
         * @param {string} projectId Project ID
         * @param {ProjectDeploymentRuleRequest} [projectDeploymentRuleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeploymentRule(projectId: string, projectDeploymentRuleRequest?: ProjectDeploymentRuleRequest, options?: any): AxiosPromise<ProjectDeploymentRule> {
            return localVarFp.createDeploymentRule(projectId, projectDeploymentRuleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a project deployment rule
         * @summary Delete a project deployment rule
         * @param {string} projectId Project ID
         * @param {string} deploymentRuleId Deployment Rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectDeploymentRule(projectId: string, deploymentRuleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteProjectDeploymentRule(projectId, deploymentRuleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit a project deployment rule
         * @summary Edit a project deployment rule
         * @param {string} projectId Project ID
         * @param {string} deploymentRuleId Deployment Rule ID
         * @param {ProjectDeploymentRuleRequest} [projectDeploymentRuleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editProjectDeployemtnRule(projectId: string, deploymentRuleId: string, projectDeploymentRuleRequest?: ProjectDeploymentRuleRequest, options?: any): AxiosPromise<ProjectDeploymentRule> {
            return localVarFp.editProjectDeployemtnRule(projectId, deploymentRuleId, projectDeploymentRuleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a project deployment rule
         * @summary Get a project deployment rule
         * @param {string} projectId Project ID
         * @param {string} deploymentRuleId Deployment Rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectDeploymentRule(projectId: string, deploymentRuleId: string, options?: any): AxiosPromise<ProjectDeploymentRule> {
            return localVarFp.getProjectDeploymentRule(projectId, deploymentRuleId, options).then((request) => request(axios, basePath));
        },
        /**
         * List project deployment rules
         * @summary List project deployment rules
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectDeploymentRules(projectId: string, options?: any): AxiosPromise<ProjectDeploymentRuleResponseList> {
            return localVarFp.listProjectDeploymentRules(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update deployment rules priority order
         * @summary Update deployment rules priority order
         * @param {string} projectId Project ID
         * @param {ProjectDeploymentRulesPriorityOrderRequest} [projectDeploymentRulesPriorityOrderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeploymentRulesPriorityOrder(projectId: string, projectDeploymentRulesPriorityOrderRequest?: ProjectDeploymentRulesPriorityOrderRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateDeploymentRulesPriorityOrder(projectId, projectDeploymentRulesPriorityOrderRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectDeploymentRuleApi - object-oriented interface
 * @export
 * @class ProjectDeploymentRuleApi
 * @extends {BaseAPI}
 */
export class ProjectDeploymentRuleApi extends BaseAPI {
    /**
     * Create a deployment rule
     * @summary Create a deployment rule
     * @param {string} projectId Project ID
     * @param {ProjectDeploymentRuleRequest} [projectDeploymentRuleRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDeploymentRuleApi
     */
    public createDeploymentRule(projectId: string, projectDeploymentRuleRequest?: ProjectDeploymentRuleRequest, options?: AxiosRequestConfig) {
        return ProjectDeploymentRuleApiFp(this.configuration).createDeploymentRule(projectId, projectDeploymentRuleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a project deployment rule
     * @summary Delete a project deployment rule
     * @param {string} projectId Project ID
     * @param {string} deploymentRuleId Deployment Rule ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDeploymentRuleApi
     */
    public deleteProjectDeploymentRule(projectId: string, deploymentRuleId: string, options?: AxiosRequestConfig) {
        return ProjectDeploymentRuleApiFp(this.configuration).deleteProjectDeploymentRule(projectId, deploymentRuleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit a project deployment rule
     * @summary Edit a project deployment rule
     * @param {string} projectId Project ID
     * @param {string} deploymentRuleId Deployment Rule ID
     * @param {ProjectDeploymentRuleRequest} [projectDeploymentRuleRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDeploymentRuleApi
     */
    public editProjectDeployemtnRule(projectId: string, deploymentRuleId: string, projectDeploymentRuleRequest?: ProjectDeploymentRuleRequest, options?: AxiosRequestConfig) {
        return ProjectDeploymentRuleApiFp(this.configuration).editProjectDeployemtnRule(projectId, deploymentRuleId, projectDeploymentRuleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a project deployment rule
     * @summary Get a project deployment rule
     * @param {string} projectId Project ID
     * @param {string} deploymentRuleId Deployment Rule ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDeploymentRuleApi
     */
    public getProjectDeploymentRule(projectId: string, deploymentRuleId: string, options?: AxiosRequestConfig) {
        return ProjectDeploymentRuleApiFp(this.configuration).getProjectDeploymentRule(projectId, deploymentRuleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List project deployment rules
     * @summary List project deployment rules
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDeploymentRuleApi
     */
    public listProjectDeploymentRules(projectId: string, options?: AxiosRequestConfig) {
        return ProjectDeploymentRuleApiFp(this.configuration).listProjectDeploymentRules(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update deployment rules priority order
     * @summary Update deployment rules priority order
     * @param {string} projectId Project ID
     * @param {ProjectDeploymentRulesPriorityOrderRequest} [projectDeploymentRulesPriorityOrderRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDeploymentRuleApi
     */
    public updateDeploymentRulesPriorityOrder(projectId: string, projectDeploymentRulesPriorityOrderRequest?: ProjectDeploymentRulesPriorityOrderRequest, options?: AxiosRequestConfig) {
        return ProjectDeploymentRuleApiFp(this.configuration).updateDeploymentRulesPriorityOrder(projectId, projectDeploymentRulesPriorityOrderRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProjectEnvironmentVariableApi - axios parameter creator
 * @export
 */
export const ProjectEnvironmentVariableApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * - Add an environment variable to the project.   - If the environment variable key already exists, then it will be replaced by the new one.   - If the environment variable value points toward an existing environment variable key, it will be considered as an alias. 
         * @summary Add an environment variable to the project
         * @param {string} projectId Project ID
         * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectEnvironmentVariable: async (projectId: string, environmentVariableRequest?: EnvironmentVariableRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createProjectEnvironmentVariable', 'projectId', projectId)
            const localVarPath = `/project/{projectId}/environmentVariable`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentVariableRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to add an alias at project level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at project level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - Only 1 alias level is allowed. You can\'t create an alias on an alias 
         * @summary Create an environment variable alias at the project level
         * @param {string} projectId Project ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectEnvironmentVariableAlias: async (projectId: string, environmentVariableId: string, key?: Key, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createProjectEnvironmentVariableAlias', 'projectId', projectId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('createProjectEnvironmentVariableAlias', 'environmentVariableId', environmentVariableId)
            const localVarPath = `/project/{projectId}/environmentVariable/{environmentVariableId}/alias`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(key, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to override at project level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at project level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
         * @summary Create an environment variable override at the project level
         * @param {string} projectId Project ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectEnvironmentVariableOverride: async (projectId: string, environmentVariableId: string, value?: Value, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createProjectEnvironmentVariableOverride', 'projectId', projectId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('createProjectEnvironmentVariableOverride', 'environmentVariableId', environmentVariableId)
            const localVarPath = `/project/{projectId}/environmentVariable/{environmentVariableId}/override`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(value, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - To delete an environment variable you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete an environment variable from a project
         * @param {string} projectId Project ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectEnvironmentVariable: async (projectId: string, environmentVariableId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteProjectEnvironmentVariable', 'projectId', projectId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('deleteProjectEnvironmentVariable', 'environmentVariableId', environmentVariableId)
            const localVarPath = `/project/{projectId}/environmentVariable/{environmentVariableId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit an environment variable belonging to the project
         * @param {string} projectId Project ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editProjectEnvironmentVariable: async (projectId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('editProjectEnvironmentVariable', 'projectId', projectId)
            // verify required parameter 'environmentVariableId' is not null or undefined
            assertParamExists('editProjectEnvironmentVariable', 'environmentVariableId', environmentVariableId)
            // verify required parameter 'environmentVariableEditRequest' is not null or undefined
            assertParamExists('editProjectEnvironmentVariable', 'environmentVariableEditRequest', environmentVariableEditRequest)
            const localVarPath = `/project/{projectId}/environmentVariable/{environmentVariableId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"environmentVariableId"}}`, encodeURIComponent(String(environmentVariableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentVariableEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List project environment variables
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectEnvironmentVariable: async (projectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('listProjectEnvironmentVariable', 'projectId', projectId)
            const localVarPath = `/project/{projectId}/environmentVariable`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectEnvironmentVariableApi - functional programming interface
 * @export
 */
export const ProjectEnvironmentVariableApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectEnvironmentVariableApiAxiosParamCreator(configuration)
    return {
        /**
         * - Add an environment variable to the project.   - If the environment variable key already exists, then it will be replaced by the new one.   - If the environment variable value points toward an existing environment variable key, it will be considered as an alias. 
         * @summary Add an environment variable to the project
         * @param {string} projectId Project ID
         * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProjectEnvironmentVariable(projectId: string, environmentVariableRequest?: EnvironmentVariableRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProjectEnvironmentVariable(projectId, environmentVariableRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - Allows you to add an alias at project level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at project level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - Only 1 alias level is allowed. You can\'t create an alias on an alias 
         * @summary Create an environment variable alias at the project level
         * @param {string} projectId Project ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProjectEnvironmentVariableAlias(projectId: string, environmentVariableId: string, key?: Key, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProjectEnvironmentVariableAlias(projectId, environmentVariableId, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - Allows you to override at project level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at project level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
         * @summary Create an environment variable override at the project level
         * @param {string} projectId Project ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProjectEnvironmentVariableOverride(projectId: string, environmentVariableId: string, value?: Value, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProjectEnvironmentVariableOverride(projectId, environmentVariableId, value, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - To delete an environment variable you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete an environment variable from a project
         * @param {string} projectId Project ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProjectEnvironmentVariable(projectId: string, environmentVariableId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProjectEnvironmentVariable(projectId, environmentVariableId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit an environment variable belonging to the project
         * @param {string} projectId Project ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editProjectEnvironmentVariable(projectId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editProjectEnvironmentVariable(projectId, environmentVariableId, environmentVariableEditRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List project environment variables
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProjectEnvironmentVariable(projectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVariableResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProjectEnvironmentVariable(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectEnvironmentVariableApi - factory interface
 * @export
 */
export const ProjectEnvironmentVariableApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectEnvironmentVariableApiFp(configuration)
    return {
        /**
         * - Add an environment variable to the project.   - If the environment variable key already exists, then it will be replaced by the new one.   - If the environment variable value points toward an existing environment variable key, it will be considered as an alias. 
         * @summary Add an environment variable to the project
         * @param {string} projectId Project ID
         * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectEnvironmentVariable(projectId: string, environmentVariableRequest?: EnvironmentVariableRequest, options?: any): AxiosPromise<EnvironmentVariable> {
            return localVarFp.createProjectEnvironmentVariable(projectId, environmentVariableRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to add an alias at project level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at project level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - Only 1 alias level is allowed. You can\'t create an alias on an alias 
         * @summary Create an environment variable alias at the project level
         * @param {string} projectId Project ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectEnvironmentVariableAlias(projectId: string, environmentVariableId: string, key?: Key, options?: any): AxiosPromise<EnvironmentVariable> {
            return localVarFp.createProjectEnvironmentVariableAlias(projectId, environmentVariableId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to override at project level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at project level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
         * @summary Create an environment variable override at the project level
         * @param {string} projectId Project ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectEnvironmentVariableOverride(projectId: string, environmentVariableId: string, value?: Value, options?: any): AxiosPromise<EnvironmentVariable> {
            return localVarFp.createProjectEnvironmentVariableOverride(projectId, environmentVariableId, value, options).then((request) => request(axios, basePath));
        },
        /**
         * - To delete an environment variable you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete an environment variable from a project
         * @param {string} projectId Project ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectEnvironmentVariable(projectId: string, environmentVariableId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteProjectEnvironmentVariable(projectId, environmentVariableId, options).then((request) => request(axios, basePath));
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit an environment variable belonging to the project
         * @param {string} projectId Project ID
         * @param {string} environmentVariableId Environment Variable ID
         * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editProjectEnvironmentVariable(projectId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options?: any): AxiosPromise<EnvironmentVariable> {
            return localVarFp.editProjectEnvironmentVariable(projectId, environmentVariableId, environmentVariableEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List project environment variables
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectEnvironmentVariable(projectId: string, options?: any): AxiosPromise<EnvironmentVariableResponseList> {
            return localVarFp.listProjectEnvironmentVariable(projectId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectEnvironmentVariableApi - object-oriented interface
 * @export
 * @class ProjectEnvironmentVariableApi
 * @extends {BaseAPI}
 */
export class ProjectEnvironmentVariableApi extends BaseAPI {
    /**
     * - Add an environment variable to the project.   - If the environment variable key already exists, then it will be replaced by the new one.   - If the environment variable value points toward an existing environment variable key, it will be considered as an alias. 
     * @summary Add an environment variable to the project
     * @param {string} projectId Project ID
     * @param {EnvironmentVariableRequest} [environmentVariableRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectEnvironmentVariableApi
     */
    public createProjectEnvironmentVariable(projectId: string, environmentVariableRequest?: EnvironmentVariableRequest, options?: AxiosRequestConfig) {
        return ProjectEnvironmentVariableApiFp(this.configuration).createProjectEnvironmentVariable(projectId, environmentVariableRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to add an alias at project level on an existing environment variable having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new environment variable at project level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" field of the newly created variable - Only 1 alias level is allowed. You can\'t create an alias on an alias 
     * @summary Create an environment variable alias at the project level
     * @param {string} projectId Project ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {Key} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectEnvironmentVariableApi
     */
    public createProjectEnvironmentVariableAlias(projectId: string, environmentVariableId: string, key?: Key, options?: AxiosRequestConfig) {
        return ProjectEnvironmentVariableApiFp(this.configuration).createProjectEnvironmentVariableAlias(projectId, environmentVariableId, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to override at project level an environment variable that has a higher scope. - You only have to specify a value in the request body - The system will create a new environment variable at project level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" field of the newly created variable 
     * @summary Create an environment variable override at the project level
     * @param {string} projectId Project ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {Value} [value] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectEnvironmentVariableApi
     */
    public createProjectEnvironmentVariableOverride(projectId: string, environmentVariableId: string, value?: Value, options?: AxiosRequestConfig) {
        return ProjectEnvironmentVariableApiFp(this.configuration).createProjectEnvironmentVariableOverride(projectId, environmentVariableId, value, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - To delete an environment variable you must have the project user permission - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
     * @summary Delete an environment variable from a project
     * @param {string} projectId Project ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectEnvironmentVariableApi
     */
    public deleteProjectEnvironmentVariable(projectId: string, environmentVariableId: string, options?: AxiosRequestConfig) {
        return ProjectEnvironmentVariableApiFp(this.configuration).deleteProjectEnvironmentVariable(projectId, environmentVariableId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the variable it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
     * @summary Edit an environment variable belonging to the project
     * @param {string} projectId Project ID
     * @param {string} environmentVariableId Environment Variable ID
     * @param {EnvironmentVariableEditRequest} environmentVariableEditRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectEnvironmentVariableApi
     */
    public editProjectEnvironmentVariable(projectId: string, environmentVariableId: string, environmentVariableEditRequest: EnvironmentVariableEditRequest, options?: AxiosRequestConfig) {
        return ProjectEnvironmentVariableApiFp(this.configuration).editProjectEnvironmentVariable(projectId, environmentVariableId, environmentVariableEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List project environment variables
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectEnvironmentVariableApi
     */
    public listProjectEnvironmentVariable(projectId: string, options?: AxiosRequestConfig) {
        return ProjectEnvironmentVariableApiFp(this.configuration).listProjectEnvironmentVariable(projectId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProjectMainCallsApi - axios parameter creator
 * @export
 */
export const ProjectMainCallsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * To delete a project you must have the admin permission
         * @summary Delete a project
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject: async (projectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteProject', 'projectId', projectId)
            const localVarPath = `/project/{projectId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To edit a project you must have the admin permission
         * @summary Edit a project
         * @param {string} projectId Project ID
         * @param {ProjectRequest} [projectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editProject: async (projectId: string, projectRequest?: ProjectRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('editProject', 'projectId', projectId)
            const localVarPath = `/project/{projectId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get project by ID
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject: async (projectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getProject', 'projectId', projectId)
            const localVarPath = `/project/{projectId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectMainCallsApi - functional programming interface
 * @export
 */
export const ProjectMainCallsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectMainCallsApiAxiosParamCreator(configuration)
    return {
        /**
         * To delete a project you must have the admin permission
         * @summary Delete a project
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProject(projectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProject(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * To edit a project you must have the admin permission
         * @summary Edit a project
         * @param {string} projectId Project ID
         * @param {ProjectRequest} [projectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editProject(projectId: string, projectRequest?: ProjectRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editProject(projectId, projectRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get project by ID
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProject(projectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProject(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectMainCallsApi - factory interface
 * @export
 */
export const ProjectMainCallsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectMainCallsApiFp(configuration)
    return {
        /**
         * To delete a project you must have the admin permission
         * @summary Delete a project
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject(projectId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteProject(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * To edit a project you must have the admin permission
         * @summary Edit a project
         * @param {string} projectId Project ID
         * @param {ProjectRequest} [projectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editProject(projectId: string, projectRequest?: ProjectRequest, options?: any): AxiosPromise<Project> {
            return localVarFp.editProject(projectId, projectRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get project by ID
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject(projectId: string, options?: any): AxiosPromise<Project> {
            return localVarFp.getProject(projectId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectMainCallsApi - object-oriented interface
 * @export
 * @class ProjectMainCallsApi
 * @extends {BaseAPI}
 */
export class ProjectMainCallsApi extends BaseAPI {
    /**
     * To delete a project you must have the admin permission
     * @summary Delete a project
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectMainCallsApi
     */
    public deleteProject(projectId: string, options?: AxiosRequestConfig) {
        return ProjectMainCallsApiFp(this.configuration).deleteProject(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To edit a project you must have the admin permission
     * @summary Edit a project
     * @param {string} projectId Project ID
     * @param {ProjectRequest} [projectRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectMainCallsApi
     */
    public editProject(projectId: string, projectRequest?: ProjectRequest, options?: AxiosRequestConfig) {
        return ProjectMainCallsApiFp(this.configuration).editProject(projectId, projectRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get project by ID
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectMainCallsApi
     */
    public getProject(projectId: string, options?: AxiosRequestConfig) {
        return ProjectMainCallsApiFp(this.configuration).getProject(projectId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProjectSecretApi - axios parameter creator
 * @export
 */
export const ProjectSecretApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * - Add a secret to the project.   - If the secret key already exists, then it will be replaced by the new one.   - If the secret value points toward an existing secret key, it will be considered as an alias. 
         * @summary Add a secret to the project
         * @param {string} projectId Project ID
         * @param {SecretRequest} [secretRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectSecret: async (projectId: string, secretRequest?: SecretRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createProjectSecret', 'projectId', projectId)
            const localVarPath = `/project/{projectId}/secret`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(secretRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to add an alias at project level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at project level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - Only 1 alias level is allowed. You can\'t create an alias on an alias 
         * @summary Create a secret alias at the project level
         * @param {string} projectId Project ID
         * @param {string} secretId Secret ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectSecretAlias: async (projectId: string, secretId: string, key?: Key, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createProjectSecretAlias', 'projectId', projectId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('createProjectSecretAlias', 'secretId', secretId)
            const localVarPath = `/project/{projectId}/secret/{secretId}/alias`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(key, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to override at project level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at project level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
         * @summary Create a secret override at the project level
         * @param {string} projectId Project ID
         * @param {string} secretId Secret ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectSecretOverride: async (projectId: string, secretId: string, value?: Value, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createProjectSecretOverride', 'projectId', projectId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('createProjectSecretOverride', 'secretId', secretId)
            const localVarPath = `/project/{projectId}/secret/{secretId}/override`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(value, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well  operationId: deleteProjectSecret 
         * @summary Delete a secret from a project
         * @param {string} projectId Project ID
         * @param {string} secretId Secret ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectSecret: async (projectId: string, secretId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteProjectSecret', 'projectId', projectId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('deleteProjectSecret', 'secretId', secretId)
            const localVarPath = `/project/{projectId}/secret/{secretId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit a secret belonging to the project
         * @param {string} projectId Project ID
         * @param {string} secretId Secret ID
         * @param {SecretEditRequest} secretEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editProjectSecret: async (projectId: string, secretId: string, secretEditRequest: SecretEditRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('editProjectSecret', 'projectId', projectId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('editProjectSecret', 'secretId', secretId)
            // verify required parameter 'secretEditRequest' is not null or undefined
            assertParamExists('editProjectSecret', 'secretEditRequest', secretEditRequest)
            const localVarPath = `/project/{projectId}/secret/{secretId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(secretEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List project secrets
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectSecrets: async (projectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('listProjectSecrets', 'projectId', projectId)
            const localVarPath = `/project/{projectId}/secret`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectSecretApi - functional programming interface
 * @export
 */
export const ProjectSecretApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectSecretApiAxiosParamCreator(configuration)
    return {
        /**
         * - Add a secret to the project.   - If the secret key already exists, then it will be replaced by the new one.   - If the secret value points toward an existing secret key, it will be considered as an alias. 
         * @summary Add a secret to the project
         * @param {string} projectId Project ID
         * @param {SecretRequest} [secretRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProjectSecret(projectId: string, secretRequest?: SecretRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProjectSecret(projectId, secretRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - Allows you to add an alias at project level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at project level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - Only 1 alias level is allowed. You can\'t create an alias on an alias 
         * @summary Create a secret alias at the project level
         * @param {string} projectId Project ID
         * @param {string} secretId Secret ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProjectSecretAlias(projectId: string, secretId: string, key?: Key, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProjectSecretAlias(projectId, secretId, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - Allows you to override at project level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at project level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
         * @summary Create a secret override at the project level
         * @param {string} projectId Project ID
         * @param {string} secretId Secret ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProjectSecretOverride(projectId: string, secretId: string, value?: Value, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProjectSecretOverride(projectId, secretId, value, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well  operationId: deleteProjectSecret 
         * @summary Delete a secret from a project
         * @param {string} projectId Project ID
         * @param {string} secretId Secret ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProjectSecret(projectId: string, secretId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProjectSecret(projectId, secretId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit a secret belonging to the project
         * @param {string} projectId Project ID
         * @param {string} secretId Secret ID
         * @param {SecretEditRequest} secretEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editProjectSecret(projectId: string, secretId: string, secretEditRequest: SecretEditRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editProjectSecret(projectId, secretId, secretEditRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List project secrets
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProjectSecrets(projectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecretResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProjectSecrets(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectSecretApi - factory interface
 * @export
 */
export const ProjectSecretApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectSecretApiFp(configuration)
    return {
        /**
         * - Add a secret to the project.   - If the secret key already exists, then it will be replaced by the new one.   - If the secret value points toward an existing secret key, it will be considered as an alias. 
         * @summary Add a secret to the project
         * @param {string} projectId Project ID
         * @param {SecretRequest} [secretRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectSecret(projectId: string, secretRequest?: SecretRequest, options?: any): AxiosPromise<Secret> {
            return localVarFp.createProjectSecret(projectId, secretRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to add an alias at project level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at project level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - Only 1 alias level is allowed. You can\'t create an alias on an alias 
         * @summary Create a secret alias at the project level
         * @param {string} projectId Project ID
         * @param {string} secretId Secret ID
         * @param {Key} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectSecretAlias(projectId: string, secretId: string, key?: Key, options?: any): AxiosPromise<Secret> {
            return localVarFp.createProjectSecretAlias(projectId, secretId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to override at project level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at project level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
         * @summary Create a secret override at the project level
         * @param {string} projectId Project ID
         * @param {string} secretId Secret ID
         * @param {Value} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectSecretOverride(projectId: string, secretId: string, value?: Value, options?: any): AxiosPromise<Secret> {
            return localVarFp.createProjectSecretOverride(projectId, secretId, value, options).then((request) => request(axios, basePath));
        },
        /**
         * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well  operationId: deleteProjectSecret 
         * @summary Delete a secret from a project
         * @param {string} projectId Project ID
         * @param {string} secretId Secret ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectSecret(projectId: string, secretId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteProjectSecret(projectId, secretId, options).then((request) => request(axios, basePath));
        },
        /**
         * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
         * @summary Edit a secret belonging to the project
         * @param {string} projectId Project ID
         * @param {string} secretId Secret ID
         * @param {SecretEditRequest} secretEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editProjectSecret(projectId: string, secretId: string, secretEditRequest: SecretEditRequest, options?: any): AxiosPromise<Secret> {
            return localVarFp.editProjectSecret(projectId, secretId, secretEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List project secrets
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectSecrets(projectId: string, options?: any): AxiosPromise<SecretResponseList> {
            return localVarFp.listProjectSecrets(projectId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectSecretApi - object-oriented interface
 * @export
 * @class ProjectSecretApi
 * @extends {BaseAPI}
 */
export class ProjectSecretApi extends BaseAPI {
    /**
     * - Add a secret to the project.   - If the secret key already exists, then it will be replaced by the new one.   - If the secret value points toward an existing secret key, it will be considered as an alias. 
     * @summary Add a secret to the project
     * @param {string} projectId Project ID
     * @param {SecretRequest} [secretRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSecretApi
     */
    public createProjectSecret(projectId: string, secretRequest?: SecretRequest, options?: AxiosRequestConfig) {
        return ProjectSecretApiFp(this.configuration).createProjectSecret(projectId, secretRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to add an alias at project level on an existing secret having higher scope, in order to customize its key. - You only have to specify a key in the request body - The system will create a new secret at project level with the same value as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the aliased_secret will be exposed in the \"aliased_secret\" field of the newly created secret - Only 1 alias level is allowed. You can\'t create an alias on an alias 
     * @summary Create a secret alias at the project level
     * @param {string} projectId Project ID
     * @param {string} secretId Secret ID
     * @param {Key} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSecretApi
     */
    public createProjectSecretAlias(projectId: string, secretId: string, key?: Key, options?: AxiosRequestConfig) {
        return ProjectSecretApiFp(this.configuration).createProjectSecretAlias(projectId, secretId, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to override at project level a secret that has a higher scope. - You only have to specify a value in the request body - The system will create a new secret at project level with the same key as the one corresponding to the secret id in the path - The response body will contain the newly created secret - Information regarding the overridden_secret will be exposed in the \"overridden_secret\" field of the newly created secret 
     * @summary Create a secret override at the project level
     * @param {string} projectId Project ID
     * @param {string} secretId Secret ID
     * @param {Value} [value] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSecretApi
     */
    public createProjectSecretOverride(projectId: string, secretId: string, value?: Value, options?: AxiosRequestConfig) {
        return ProjectSecretApiFp(this.configuration).createProjectSecretOverride(projectId, secretId, value, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - To delete a secret you must have the project user permission - You can\'t delete a BUILT_IN secret - If you delete a secret having override or alias, the associated override/alias will be deleted as well  operationId: deleteProjectSecret 
     * @summary Delete a secret from a project
     * @param {string} projectId Project ID
     * @param {string} secretId Secret ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSecretApi
     */
    public deleteProjectSecret(projectId: string, secretId: string, options?: AxiosRequestConfig) {
        return ProjectSecretApiFp(this.configuration).deleteProjectSecret(projectId, secretId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - You can\'t edit a BUILT_IN secret - For an override, you can\'t edit the key - For an alias, you can\'t edit the value - An override can only have a scope lower to the secret it is overriding (hierarchy is BUILT_IN > PROJECT > ENVIRONMENT > APPLICATION) 
     * @summary Edit a secret belonging to the project
     * @param {string} projectId Project ID
     * @param {string} secretId Secret ID
     * @param {SecretEditRequest} secretEditRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSecretApi
     */
    public editProjectSecret(projectId: string, secretId: string, secretEditRequest: SecretEditRequest, options?: AxiosRequestConfig) {
        return ProjectSecretApiFp(this.configuration).editProjectSecret(projectId, secretId, secretEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List project secrets
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSecretApi
     */
    public listProjectSecrets(projectId: string, options?: AxiosRequestConfig) {
        return ProjectSecretApiFp(this.configuration).listProjectSecrets(projectId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProjectsApi - axios parameter creator
 * @export
 */
export const ProjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a project
         * @param {string} organizationId Organization ID
         * @param {ProjectRequest} [projectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject: async (organizationId: string, projectRequest?: ProjectRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createProject', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/project`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of project ids, and for each its total numberof services and environments
         * @summary List total number of services and environments for each project of the organization
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationProjectStats: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationProjectStats', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/project/stats`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List projects
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProject: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listProject', 'organizationId', organizationId)
            const localVarPath = `/organization/{organizationId}/project`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsApi - functional programming interface
 * @export
 */
export const ProjectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a project
         * @param {string} organizationId Organization ID
         * @param {ProjectRequest} [projectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProject(organizationId: string, projectRequest?: ProjectRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProject(organizationId, projectRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of project ids, and for each its total numberof services and environments
         * @summary List total number of services and environments for each project of the organization
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationProjectStats(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectStatsResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationProjectStats(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List projects
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProject(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProject(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectsApi - factory interface
 * @export
 */
export const ProjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a project
         * @param {string} organizationId Organization ID
         * @param {ProjectRequest} [projectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject(organizationId: string, projectRequest?: ProjectRequest, options?: any): AxiosPromise<Project> {
            return localVarFp.createProject(organizationId, projectRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of project ids, and for each its total numberof services and environments
         * @summary List total number of services and environments for each project of the organization
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationProjectStats(organizationId: string, options?: any): AxiosPromise<ProjectStatsResponseList> {
            return localVarFp.getOrganizationProjectStats(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List projects
         * @param {string} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProject(organizationId: string, options?: any): AxiosPromise<ProjectResponseList> {
            return localVarFp.listProject(organizationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectsApi - object-oriented interface
 * @export
 * @class ProjectsApi
 * @extends {BaseAPI}
 */
export class ProjectsApi extends BaseAPI {
    /**
     * 
     * @summary Create a project
     * @param {string} organizationId Organization ID
     * @param {ProjectRequest} [projectRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public createProject(organizationId: string, projectRequest?: ProjectRequest, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).createProject(organizationId, projectRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of project ids, and for each its total numberof services and environments
     * @summary List total number of services and environments for each project of the organization
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getOrganizationProjectStats(organizationId: string, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).getOrganizationProjectStats(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List projects
     * @param {string} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public listProject(organizationId: string, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).listProject(organizationId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ReferralRewardsApi - axios parameter creator
 * @export
 */
export const ReferralRewardsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get your referral information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountReferral: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/referral`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A same code can be claimed only 3 times at max
         * @summary Claim a reward
         * @param {RewardClaim} [rewardClaim] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAccountRewardClaim: async (rewardClaim?: RewardClaim, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/rewardClaim`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rewardClaim, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReferralRewardsApi - functional programming interface
 * @export
 */
export const ReferralRewardsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReferralRewardsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get your referral information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountReferral(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Referral>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountReferral(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A same code can be claimed only 3 times at max
         * @summary Claim a reward
         * @param {RewardClaim} [rewardClaim] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAccountRewardClaim(rewardClaim?: RewardClaim, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postAccountRewardClaim(rewardClaim, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ReferralRewardsApi - factory interface
 * @export
 */
export const ReferralRewardsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReferralRewardsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get your referral information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountReferral(options?: any): AxiosPromise<Referral> {
            return localVarFp.getAccountReferral(options).then((request) => request(axios, basePath));
        },
        /**
         * A same code can be claimed only 3 times at max
         * @summary Claim a reward
         * @param {RewardClaim} [rewardClaim] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAccountRewardClaim(rewardClaim?: RewardClaim, options?: any): AxiosPromise<void> {
            return localVarFp.postAccountRewardClaim(rewardClaim, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReferralRewardsApi - object-oriented interface
 * @export
 * @class ReferralRewardsApi
 * @extends {BaseAPI}
 */
export class ReferralRewardsApi extends BaseAPI {
    /**
     * 
     * @summary Get your referral information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferralRewardsApi
     */
    public getAccountReferral(options?: AxiosRequestConfig) {
        return ReferralRewardsApiFp(this.configuration).getAccountReferral(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A same code can be claimed only 3 times at max
     * @summary Claim a reward
     * @param {RewardClaim} [rewardClaim] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferralRewardsApi
     */
    public postAccountRewardClaim(rewardClaim?: RewardClaim, options?: AxiosRequestConfig) {
        return ReferralRewardsApiFp(this.configuration).postAccountRewardClaim(rewardClaim, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserSignUpApi - axios parameter creator
 * @export
 */
export const UserSignUpApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Send a Sign Up request containing the user information
         * @summary Send Sign Up request
         * @param {SignUpRequest} [signUpRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserSignUp: async (signUpRequest?: SignUpRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/userSignUp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signUpRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the Sign Up information of the user
         * @summary Get Sign up information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSignUp: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/userSignUp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserSignUpApi - functional programming interface
 * @export
 */
export const UserSignUpApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserSignUpApiAxiosParamCreator(configuration)
    return {
        /**
         * Send a Sign Up request containing the user information
         * @summary Send Sign Up request
         * @param {SignUpRequest} [signUpRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserSignUp(signUpRequest?: SignUpRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserSignUp(signUpRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve the Sign Up information of the user
         * @summary Get Sign up information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserSignUp(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignUp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserSignUp(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserSignUpApi - factory interface
 * @export
 */
export const UserSignUpApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserSignUpApiFp(configuration)
    return {
        /**
         * Send a Sign Up request containing the user information
         * @summary Send Sign Up request
         * @param {SignUpRequest} [signUpRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserSignUp(signUpRequest?: SignUpRequest, options?: any): AxiosPromise<void> {
            return localVarFp.createUserSignUp(signUpRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the Sign Up information of the user
         * @summary Get Sign up information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSignUp(options?: any): AxiosPromise<SignUp> {
            return localVarFp.getUserSignUp(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserSignUpApi - object-oriented interface
 * @export
 * @class UserSignUpApi
 * @extends {BaseAPI}
 */
export class UserSignUpApi extends BaseAPI {
    /**
     * Send a Sign Up request containing the user information
     * @summary Send Sign Up request
     * @param {SignUpRequest} [signUpRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSignUpApi
     */
    public createUserSignUp(signUpRequest?: SignUpRequest, options?: AxiosRequestConfig) {
        return UserSignUpApiFp(this.configuration).createUserSignUp(signUpRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the Sign Up information of the user
     * @summary Get Sign up information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSignUpApi
     */
    public getUserSignUp(options?: AxiosRequestConfig) {
        return UserSignUpApiFp(this.configuration).getUserSignUp(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * VariableMainCallsApi - axios parameter creator
 * @export
 */
export const VariableMainCallsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * - Create a variable at the level defined in the request body. 
         * @summary Create a variable
         * @param {VariableRequest} [variableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVariable: async (variableRequest?: VariableRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/variable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(variableRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to add an alias at the level defined in the request body on an existing variable having a higher scope, in order to customize its key. - You have to specify a key in the request body and the scope and the parent id of the alias - The system will create a new variable at the requested level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" or in the \"aliased_secret\" field of the newly created variable - Only 1 alias level is allowed. You can\'t create an alias on an alias 
         * @summary Create a variable alias
         * @param {string} variableId Variable ID
         * @param {VariableAliasRequest} [variableAliasRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVariableAlias: async (variableId: string, variableAliasRequest?: VariableAliasRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'variableId' is not null or undefined
            assertParamExists('createVariableAlias', 'variableId', variableId)
            const localVarPath = `/variable/{variableId}/alias`
                .replace(`{${"variableId"}}`, encodeURIComponent(String(variableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(variableAliasRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Allows you to override a variable that has a higher scope. - You have to specify a value in the request body and the scope and the parent id of the variable to alias - The system will create a new environment variable at project level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" or in the \"overridden_secret\" field of the newly created variable 
         * @summary Create a variable override
         * @param {string} variableId Variable ID
         * @param {VariableOverrideRequest} [variableOverrideRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVariableOverride: async (variableId: string, variableOverrideRequest?: VariableOverrideRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'variableId' is not null or undefined
            assertParamExists('createVariableOverride', 'variableId', variableId)
            const localVarPath = `/variable/{variableId}/override`
                .replace(`{${"variableId"}}`, encodeURIComponent(String(variableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(variableOverrideRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - To delete a variable - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete a variable
         * @param {string} variableId Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVariable: async (variableId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'variableId' is not null or undefined
            assertParamExists('deleteVariable', 'variableId', variableId)
            const localVarPath = `/variable/{variableId}`
                .replace(`{${"variableId"}}`, encodeURIComponent(String(variableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value 
         * @summary Edit a variable
         * @param {string} variableId Variable ID
         * @param {VariableEditRequest} variableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editVariable: async (variableId: string, variableEditRequest: VariableEditRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'variableId' is not null or undefined
            assertParamExists('editVariable', 'variableId', variableId)
            // verify required parameter 'variableEditRequest' is not null or undefined
            assertParamExists('editVariable', 'variableEditRequest', variableEditRequest)
            const localVarPath = `/variable/{variableId}`
                .replace(`{${"variableId"}}`, encodeURIComponent(String(variableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(variableEditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of variables
         * @summary List variables
         * @param {string} [parentId] the id where the variable will be added
         * @param {APIVariableScopeEnum} [scope] the scope of the parent where the variable will be added
         * @param {boolean} [isSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVariables: async (parentId?: string, scope?: APIVariableScopeEnum, isSecret?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/variable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (parentId !== undefined) {
                localVarQueryParameter['parent_id'] = parentId;
            }

            if (scope !== undefined) {
                localVarQueryParameter['scope'] = scope;
            }

            if (isSecret !== undefined) {
                localVarQueryParameter['is_secret'] = isSecret;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VariableMainCallsApi - functional programming interface
 * @export
 */
export const VariableMainCallsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VariableMainCallsApiAxiosParamCreator(configuration)
    return {
        /**
         * - Create a variable at the level defined in the request body. 
         * @summary Create a variable
         * @param {VariableRequest} [variableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVariable(variableRequest?: VariableRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariableResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVariable(variableRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - Allows you to add an alias at the level defined in the request body on an existing variable having a higher scope, in order to customize its key. - You have to specify a key in the request body and the scope and the parent id of the alias - The system will create a new variable at the requested level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" or in the \"aliased_secret\" field of the newly created variable - Only 1 alias level is allowed. You can\'t create an alias on an alias 
         * @summary Create a variable alias
         * @param {string} variableId Variable ID
         * @param {VariableAliasRequest} [variableAliasRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVariableAlias(variableId: string, variableAliasRequest?: VariableAliasRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariableResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVariableAlias(variableId, variableAliasRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - Allows you to override a variable that has a higher scope. - You have to specify a value in the request body and the scope and the parent id of the variable to alias - The system will create a new environment variable at project level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" or in the \"overridden_secret\" field of the newly created variable 
         * @summary Create a variable override
         * @param {string} variableId Variable ID
         * @param {VariableOverrideRequest} [variableOverrideRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVariableOverride(variableId: string, variableOverrideRequest?: VariableOverrideRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariableResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVariableOverride(variableId, variableOverrideRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - To delete a variable - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete a variable
         * @param {string} variableId Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteVariable(variableId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteVariable(variableId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value 
         * @summary Edit a variable
         * @param {string} variableId Variable ID
         * @param {VariableEditRequest} variableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editVariable(variableId: string, variableEditRequest: VariableEditRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariableResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editVariable(variableId, variableEditRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of variables
         * @summary List variables
         * @param {string} [parentId] the id where the variable will be added
         * @param {APIVariableScopeEnum} [scope] the scope of the parent where the variable will be added
         * @param {boolean} [isSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listVariables(parentId?: string, scope?: APIVariableScopeEnum, isSecret?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariableResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listVariables(parentId, scope, isSecret, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * VariableMainCallsApi - factory interface
 * @export
 */
export const VariableMainCallsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VariableMainCallsApiFp(configuration)
    return {
        /**
         * - Create a variable at the level defined in the request body. 
         * @summary Create a variable
         * @param {VariableRequest} [variableRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVariable(variableRequest?: VariableRequest, options?: any): AxiosPromise<VariableResponse> {
            return localVarFp.createVariable(variableRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to add an alias at the level defined in the request body on an existing variable having a higher scope, in order to customize its key. - You have to specify a key in the request body and the scope and the parent id of the alias - The system will create a new variable at the requested level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" or in the \"aliased_secret\" field of the newly created variable - Only 1 alias level is allowed. You can\'t create an alias on an alias 
         * @summary Create a variable alias
         * @param {string} variableId Variable ID
         * @param {VariableAliasRequest} [variableAliasRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVariableAlias(variableId: string, variableAliasRequest?: VariableAliasRequest, options?: any): AxiosPromise<VariableResponse> {
            return localVarFp.createVariableAlias(variableId, variableAliasRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * - Allows you to override a variable that has a higher scope. - You have to specify a value in the request body and the scope and the parent id of the variable to alias - The system will create a new environment variable at project level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" or in the \"overridden_secret\" field of the newly created variable 
         * @summary Create a variable override
         * @param {string} variableId Variable ID
         * @param {VariableOverrideRequest} [variableOverrideRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVariableOverride(variableId: string, variableOverrideRequest?: VariableOverrideRequest, options?: any): AxiosPromise<VariableResponse> {
            return localVarFp.createVariableOverride(variableId, variableOverrideRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * - To delete a variable - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
         * @summary Delete a variable
         * @param {string} variableId Variable ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVariable(variableId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteVariable(variableId, options).then((request) => request(axios, basePath));
        },
        /**
         * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value 
         * @summary Edit a variable
         * @param {string} variableId Variable ID
         * @param {VariableEditRequest} variableEditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editVariable(variableId: string, variableEditRequest: VariableEditRequest, options?: any): AxiosPromise<VariableResponse> {
            return localVarFp.editVariable(variableId, variableEditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of variables
         * @summary List variables
         * @param {string} [parentId] the id where the variable will be added
         * @param {APIVariableScopeEnum} [scope] the scope of the parent where the variable will be added
         * @param {boolean} [isSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVariables(parentId?: string, scope?: APIVariableScopeEnum, isSecret?: boolean, options?: any): AxiosPromise<VariableResponseList> {
            return localVarFp.listVariables(parentId, scope, isSecret, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VariableMainCallsApi - object-oriented interface
 * @export
 * @class VariableMainCallsApi
 * @extends {BaseAPI}
 */
export class VariableMainCallsApi extends BaseAPI {
    /**
     * - Create a variable at the level defined in the request body. 
     * @summary Create a variable
     * @param {VariableRequest} [variableRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariableMainCallsApi
     */
    public createVariable(variableRequest?: VariableRequest, options?: AxiosRequestConfig) {
        return VariableMainCallsApiFp(this.configuration).createVariable(variableRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to add an alias at the level defined in the request body on an existing variable having a higher scope, in order to customize its key. - You have to specify a key in the request body and the scope and the parent id of the alias - The system will create a new variable at the requested level with the same value as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the aliased_variable will be exposed in the \"aliased_variable\" or in the \"aliased_secret\" field of the newly created variable - Only 1 alias level is allowed. You can\'t create an alias on an alias 
     * @summary Create a variable alias
     * @param {string} variableId Variable ID
     * @param {VariableAliasRequest} [variableAliasRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariableMainCallsApi
     */
    public createVariableAlias(variableId: string, variableAliasRequest?: VariableAliasRequest, options?: AxiosRequestConfig) {
        return VariableMainCallsApiFp(this.configuration).createVariableAlias(variableId, variableAliasRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Allows you to override a variable that has a higher scope. - You have to specify a value in the request body and the scope and the parent id of the variable to alias - The system will create a new environment variable at project level with the same key as the one corresponding to the variable id in the path - The response body will contain the newly created variable - Information regarding the overridden_variable will be exposed in the \"overridden_variable\" or in the \"overridden_secret\" field of the newly created variable 
     * @summary Create a variable override
     * @param {string} variableId Variable ID
     * @param {VariableOverrideRequest} [variableOverrideRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariableMainCallsApi
     */
    public createVariableOverride(variableId: string, variableOverrideRequest?: VariableOverrideRequest, options?: AxiosRequestConfig) {
        return VariableMainCallsApiFp(this.configuration).createVariableOverride(variableId, variableOverrideRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - To delete a variable - You can\'t delete a BUILT_IN variable - If you delete a variable having override or alias, the associated override/alias will be deleted as well 
     * @summary Delete a variable
     * @param {string} variableId Variable ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariableMainCallsApi
     */
    public deleteVariable(variableId: string, options?: AxiosRequestConfig) {
        return VariableMainCallsApiFp(this.configuration).deleteVariable(variableId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - You can\'t edit a BUILT_IN variable - For an override, you can\'t edit the key - For an alias, you can\'t edit the value 
     * @summary Edit a variable
     * @param {string} variableId Variable ID
     * @param {VariableEditRequest} variableEditRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariableMainCallsApi
     */
    public editVariable(variableId: string, variableEditRequest: VariableEditRequest, options?: AxiosRequestConfig) {
        return VariableMainCallsApiFp(this.configuration).editVariable(variableId, variableEditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of variables
     * @summary List variables
     * @param {string} [parentId] the id where the variable will be added
     * @param {APIVariableScopeEnum} [scope] the scope of the parent where the variable will be added
     * @param {boolean} [isSecret] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariableMainCallsApi
     */
    public listVariables(parentId?: string, scope?: APIVariableScopeEnum, isSecret?: boolean, options?: AxiosRequestConfig) {
        return VariableMainCallsApiFp(this.configuration).listVariables(parentId, scope, isSecret, options).then((request) => request(this.axios, this.basePath));
    }
}


